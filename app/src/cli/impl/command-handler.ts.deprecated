/**
 * CLI Command Handler Implementation
 * 
 * TODO: This file mixes CLI and agent concerns - should be refactored.
 * Design problem: CLI should only handle interface commands, not:
 * - Model management (agent responsibility)
 * - MCP server management (agent responsibility) 
 * - Memory/session management (agent responsibility)
 * 
 * Consider using simple-command-handler.ts instead for pure CLI functionality.
 */

import { exec, spawn } from 'node:child_process'
import { promisify } from 'node:util'

// TODO: Remove dependency on non-existent @qi/lib
// These types should be defined locally or imported from actual modules
interface ICommandHandler {
  // Implementation needed
}

interface CommandDefinition {
  name: string;
  description: string;
  usage: string;
  aliases?: string[];
  category: string;
  parameters: any[];
}

interface CommandResult {
  // Implementation needed
}

interface CommandRequest {
  // Implementation needed
}

interface CommandExecutor {
  // Implementation needed
}

interface IModelProvider {
  // Implementation needed  
}

interface IToolProvider {
  // Implementation needed
}

interface IMemoryProvider {
  // Implementation needed
}

const execAsync = promisify(exec)

// ============================================================================
// Built-in Command Definitions
// ============================================================================

const BUILT_IN_COMMANDS: CommandDefinition[] = [
  {
    name: 'help',
    description: 'Show available commands and their usage',
    usage: '/help [command_name]',
    aliases: ['h', '?'],
    category: 'system',
    parameters: []
  },
  {
    name: 'exit',
    description: 'Exit the CLI application',
    usage: '/exit',
    aliases: ['quit', 'q'],
    category: 'system',
    parameters: []
  },
  {
    name: 'status',
    description: 'Show current application status',
    usage: '/status',
    aliases: ['info'],
    category: 'system',
    parameters: []
  },
  {
    name: 'model',
    description: 'Show or change the current LLM model',
    usage: '/model [model_name]',
    category: 'llm',
    parameters: []
  },
  {
    name: 'mcp',
    description: 'MCP server management commands',
    usage: '/mcp <list|connect|disconnect> [server_name]',
    category: 'tools',
    parameters: []
  },
  {
    name: 'resume',
    description: 'Resume previous conversation or workflow',
    usage: '/resume [session_id]',
    category: 'session',
    parameters: []
  },
  {
    name: 'clear',
    description: 'Clear the screen',
    usage: '/clear',
    aliases: ['cls'],
    category: 'ui',
    parameters: []
  }
]

// Common shell commands that are safe to execute
const SAFE_SHELL_COMMANDS = new Set([
  'ls', 'dir', 'pwd', 'whoami', 'date', 'echo', 'cat', 'head', 'tail',
  'grep', 'find', 'which', 'man', 'history', 'ps', 'top', 'df', 'du',
  'git', 'npm', 'bun', 'node', 'python', 'pip'
])

// ============================================================================
// Command Handler Implementation
// ============================================================================

export interface CLICommandHandlerConfig {
  modelProvider?: IModelProvider
  toolProvider?: IToolProvider
  memoryProvider?: IMemoryProvider
  enableShellCommands?: boolean
}

export class CLICommandHandler implements ICommandHandler {
  private commandRegistry = new Map<string, CommandExecutor>()
  private commandDefinitions = new Map<string, CommandDefinition>()
  private aliasMap = new Map<string, string>()
  private shellCommandsEnabled = false
  private modelProvider?: IModelProvider
  private toolProvider?: IToolProvider
  private memoryProvider?: IMemoryProvider
  private currentModel?: string
  
  constructor(config: CLICommandHandlerConfig = {}) {
    this.modelProvider = config.modelProvider
    this.toolProvider = config.toolProvider
    this.memoryProvider = config.memoryProvider
    this.shellCommandsEnabled = config.enableShellCommands || false
    this.registerBuiltInCommands()
  }
  
  // ==========================================================================
  // ICommandHandler Implementation
  // ==========================================================================
  
  getAvailableCommands(): readonly CommandDefinition[] {
    return Array.from(this.commandDefinitions.values())
  }
  
  async executeCommand(request: CommandRequest): Promise<CommandResult> {
    const startTime = Date.now()
    
    try {
      // Resolve command name (handle aliases)
      const resolvedCommand = this.resolveCommandName(request.commandName)
      
      // Check if it's a registered command
      if (this.commandRegistry.has(resolvedCommand)) {
        const handler = this.commandRegistry.get(resolvedCommand)!
        const result = await handler(request)
        
        return {
          ...result,
          metadata: new Map([
            ...result.metadata,
            ['executionTime', Date.now() - startTime]
          ])
        }
      }
      
      // Try shell command execution if enabled
      if (this.shellCommandsEnabled && this.isSafeShellCommand(resolvedCommand)) {
        return await this.executeShellCommand(resolvedCommand, Array.from(request.parameters.values()) as string[])
      }
      
      // Command not found
      return {
        status: 'not_found',
        content: `Command not found: ${request.commandName}. Use /help to see available commands.`,
        success: false,
        output: '',
        commandName: request.commandName,
        metadata: new Map([['executionTime', Date.now() - startTime]])
      }
      
    } catch (error) {
      return {
        status: 'error',
        content: `Command execution failed: ${error instanceof Error ? error.message : String(error)}`,
        success: false,
        output: '',
        commandName: request.commandName,
        metadata: new Map([['executionTime', Date.now() - startTime]])
      }
    }
  }
  
  async validateCommand(commandName: string, parameters: ReadonlyMap<string, unknown>): Promise<boolean> {
    const resolvedCommand = this.resolveCommandName(commandName)
    return this.commandRegistry.has(resolvedCommand)
  }
  
  registerCommand(definition: CommandDefinition, handler: CommandExecutor): void {
    // Validate command name
    if (!definition.name || !/^[a-zA-Z][a-zA-Z0-9_-]*$/.test(definition.name)) {
      throw new Error(`Invalid command name: ${definition.name}`)
    }
    
    // Register the handler and definition
    this.commandRegistry.set(definition.name, handler)
    this.commandDefinitions.set(definition.name, definition)
    
    // Register aliases
    if (definition.aliases) {
      for (const alias of definition.aliases) {
        this.aliasMap.set(alias, definition.name)
      }
    }
  }
  
  unregisterCommand(commandName: string): void {
    this.commandRegistry.delete(commandName)
    const definition = this.commandDefinitions.get(commandName)
    this.commandDefinitions.delete(commandName)
    
    // Remove aliases
    if (definition?.aliases) {
      for (const alias of definition.aliases) {
        this.aliasMap.delete(alias)
      }
    }
  }
  
  // ==========================================================================
  // Legacy Support Methods
  // ==========================================================================
  
  register(name: string, handler: CommandExecutor, definition?: CommandDefinition): void {
    // Validate command name
    if (!name || !/^[a-zA-Z][a-zA-Z0-9_-]*$/.test(name)) {
      throw new Error(`Invalid command name: ${name}`)
    }
    
    // Register the handler
    this.commandRegistry.set(name, handler)
    
    // Register definition
    const commandDef: CommandDefinition = definition || {
      name,
      description: `Custom command: ${name}`,
      usage: `/${name}`,
      category: 'custom',
      parameters: []
    }
    
    this.commandDefinitions.set(name, commandDef)
    
    // Register aliases
    if (commandDef.aliases) {
      for (const alias of commandDef.aliases) {
        this.aliasMap.set(alias, name)
      }
    }
  }
  
  // ==========================================================================
  // Command Information
  // ==========================================================================
  
  hasCommand(name: string): boolean {
    const resolved = this.resolveCommandName(name)
    return this.commandRegistry.has(resolved)
  }
  
  getCommandHelp(name: string): string | null {
    const resolved = this.resolveCommandName(name)
    const definition = this.commandDefinitions.get(resolved)
    
    if (!definition) return null
    
    let help = `${definition.name}: ${definition.description}\n`
    help += `Usage: ${definition.usage}`
    
    if (definition.aliases?.length) {
      help += `\nAliases: ${definition.aliases.join(', ')}`
    }
    
    return help
  }
  
  // ==========================================================================
  // Shell Command Support
  // ==========================================================================
  
  supportsShellCommands(): boolean {
    return this.shellCommandsEnabled
  }
  
  setShellCommandsEnabled(enabled: boolean): void {
    this.shellCommandsEnabled = enabled
  }
  
  private isSafeShellCommand(command: string): boolean {
    return SAFE_SHELL_COMMANDS.has(command)
  }
  
  private async executeShellCommand(command: string, args: readonly string[]): Promise<CommandResult> {
    const startTime = Date.now()
    
    try {
      // Sanitize arguments
      const sanitizedArgs = args.map(arg => this.sanitizeShellArg(arg))
      const fullCommand = `${command} ${sanitizedArgs.join(' ')}`
      
      // Execute with timeout
      const { stdout, stderr } = await execAsync(fullCommand, {
        timeout: 30000, // 30 second timeout
        maxBuffer: 1024 * 1024 // 1MB buffer
      })
      
      return {
        status: 'success',
        content: stdout || stderr || 'Command executed successfully',
        output: stdout || stderr || 'Command executed successfully',
        commandName: command,
        success: true,
        metadata: new Map([
          ['executionTime', Date.now() - startTime]
        ])
      }
      
    } catch (error: any) {
      return {
        status: 'error',
        content: error.message || 'Shell command execution failed',
        output: error.message || 'Shell command execution failed',
        commandName: command,
        success: false,
        metadata: new Map([
          ['executionTime', Date.now() - startTime],
          ['exitCode', error.code]
        ])
      }
    }
  }
  
  private sanitizeShellArg(arg: string): string {
    // Basic sanitization - escape special characters
    return arg.replace(/[;&|`$(){}[\]]/g, '\\$&')
  }
  
  // ==========================================================================
  // Built-in Command Handlers
  // ==========================================================================
  
  private registerBuiltInCommands(): void {
    // Help command
    this.register('help', async (request: CommandRequest) => {
      const args = Array.from(request.parameters.values()) as string[]
      if (args.length > 0) {
        const help = this.getCommandHelp(args[0])
        return {
          status: 'success',
          content: help || `No help available for command: ${args[0]}`,
          output: help || `No help available for command: ${args[0]}`,
          commandName: 'help',
          success: true,
          metadata: new Map()
        }
      }
      
      const commands = this.getAvailableCommands()
      let output = 'Available commands:\n\n'
      
      for (const cmd of commands) {
        output += `/${cmd.name} - ${cmd.description}\n`
      }
      
      output += '\nUse /help <command> for detailed usage information.'
      
      if (this.shellCommandsEnabled) {
        output += '\n\nShell commands are enabled. Common commands like ls, git, npm are available.'
      }
      
      return { 
        status: 'success',
        content: output,
        output: output,
        commandName: 'help',
        success: true,
        metadata: new Map()
      }
    }, BUILT_IN_COMMANDS.find(c => c.name === 'help'))
    
    // Exit command
    this.register('exit', async (request: CommandRequest) => {
      // Signal the application to exit
      process.emit('SIGINT')
      return {
        status: 'success',
        content: 'Goodbye!',
        output: 'Goodbye!',
        commandName: 'exit',
        success: true,
        metadata: new Map()
      }
    }, BUILT_IN_COMMANDS.find(c => c.name === 'exit'))
    
    // Status command
    this.register('status', async (request: CommandRequest) => {
      const output = [
        `Commands Registered: ${this.commandRegistry.size}`,
        `Shell Commands: ${this.shellCommandsEnabled ? 'Enabled' : 'Disabled'}`
      ].join('\n')
      
      return { 
        status: 'success',
        content: output,
        output: output,
        commandName: 'status',
        success: true,
        metadata: new Map()
      }
    }, BUILT_IN_COMMANDS.find(c => c.name === 'status'))
    
    // Clear command
    this.register('clear', async (request: CommandRequest) => {
      // Clear screen using ANSI escape codes
      process.stdout.write('\x1b[2J\x1b[0f')
      return { 
        status: 'success',
        content: 'Screen cleared',
        output: '',
        commandName: 'clear',
        success: true,
        metadata: new Map()
      }
    }, BUILT_IN_COMMANDS.find(c => c.name === 'clear'))
    
    // Model command - show current model or switch models
    this.register('model', async (request: CommandRequest) => {
      const args = Array.from(request.parameters.values()) as string[]
      
      if (!this.modelProvider) {
        return {
          status: 'error',
          content: 'No model provider available. Initialize CLI with model provider.',
          output: 'No model provider available. Initialize CLI with model provider.',
          commandName: 'model',
          success: false,
          metadata: new Map()
        }
      }
      
      try {
        // Show current model
        if (args.length === 0) {
          const availableModels = await this.modelProvider.getAvailableModels()
          const currentModelInfo = this.currentModel 
            ? availableModels.find(m => m.id === this.currentModel || m.name === this.currentModel)
            : availableModels[0] // Default to first available model
          
          if (currentModelInfo) {
            const output = [
              `Current model: ${currentModelInfo.name} (${currentModelInfo.id})`,
              `Provider: ${currentModelInfo.providerId}`,
              `Parameters: temp=${currentModelInfo.parameters.temperature}, max_tokens=${currentModelInfo.parameters.maxTokens}`,
              `Capabilities: ${currentModelInfo.capabilities.supportsStreaming ? 'streaming' : 'no-streaming'}, ${currentModelInfo.capabilities.supportsToolCalling ? 'tools' : 'no-tools'}`
            ].join('\n')
            
            return {
              status: 'success',
              content: output,
              output: output,
              commandName: 'model',
              success: true,
              metadata: new Map([
                ['currentModel', currentModelInfo.id],
                ['providerId', currentModelInfo.providerId]
              ])
            }
          } else {
            return {
              status: 'error',
              content: 'No models available from model provider',
              output: 'No models available from model provider',
              commandName: 'model',
              success: false,
              metadata: new Map()
            }
          }
        }
        
        // Switch to specified model
        const targetModel = args[0]
        const availableModels = await this.modelProvider.getAvailableModels()
        const modelConfig = availableModels.find(m => 
          m.id === targetModel || 
          m.name === targetModel ||
          m.modelId === targetModel
        )
        
        if (!modelConfig) {
          const modelNames = availableModels.map(m => m.name).join(', ')
          return {
            status: 'error',
            content: `Model '${targetModel}' not found. Available models: ${modelNames}`,
            output: `Model '${targetModel}' not found. Available models: ${modelNames}`,
            commandName: 'model',
            success: false,
            metadata: new Map([['availableModels', modelNames]])
          }
        }
        
        // Validate the model configuration
        const isValid = await this.modelProvider.validateConfiguration(modelConfig)
        if (!isValid) {
          return {
            status: 'error',
            content: `Model '${targetModel}' configuration is invalid or model is not available`,
            output: `Model '${targetModel}' configuration is invalid or model is not available`,
            commandName: 'model',
            success: false,
            metadata: new Map()
          }
        }
        
        // Switch to the new model
        this.currentModel = modelConfig.id
        
        return {
          status: 'success',
          content: `Switched to model: ${modelConfig.name} (${modelConfig.id})`,
          output: `Switched to model: ${modelConfig.name} (${modelConfig.id})`,
          commandName: 'model',
          success: true,
          metadata: new Map([
            ['previousModel', this.currentModel],
            ['newModel', modelConfig.id],
            ['providerId', modelConfig.providerId]
          ])
        }
        
      } catch (error) {
        return {
          status: 'error',
          content: `Model command failed: ${error instanceof Error ? error.message : String(error)}`,
          output: `Model command failed: ${error instanceof Error ? error.message : String(error)}`,
          commandName: 'model',
          success: false,
          metadata: new Map()
        }
      }
    }, BUILT_IN_COMMANDS.find(c => c.name === 'model'))
    
    // MCP command - MCP server management
    this.register('mcp', async (request: CommandRequest) => {
      const args = Array.from(request.parameters.values()) as string[]
      
      if (!this.toolProvider) {
        return {
          status: 'error',
          content: 'No tool provider available. Initialize CLI with MCP tool provider.',
          output: 'No tool provider available. Initialize CLI with MCP tool provider.',
          commandName: 'mcp',
          success: false,
          metadata: new Map()
        }
      }

      try {
        const subCommand = args[0]
        
        if (!subCommand || subCommand === 'list') {
          // List available tools and server stats
          const availableTools = await this.toolProvider.getAvailableTools()
          
          // Try to get stats if available (cast to check if it's MCPToolProvider)
          let serverStats = ''
          if ('getToolProviderStats' in this.toolProvider) {
            const stats = (this.toolProvider as any).getToolProviderStats()
            serverStats = [
              `Active Servers: ${stats.activeClients}`,
              `Total Tools: ${stats.totalTools}`,
              `Cache Hit Rate: ${(stats.cacheHitRate * 100).toFixed(1)}%`,
              ''
            ].join('\n')
          }
          
          if (availableTools.length === 0) {
            return {
              status: 'success',
              content: serverStats + 'No MCP tools available. Check server connections.',
              output: serverStats + 'No MCP tools available. Check server connections.',
              commandName: 'mcp',
              success: true,
              metadata: new Map()
            }
          }
          
          const toolList = availableTools.map(tool => 
            `  ${tool.name} - ${tool.description} (${tool.category})`
          ).join('\n')
          
          const output = [
            serverStats,
            'Available MCP Tools:',
            toolList,
            '',
            'Use /mcp info <tool_name> for detailed tool information.'
          ].join('\n')
          
          return {
            status: 'success',
            content: output,
            output: output,
            commandName: 'mcp',
            success: true,
            metadata: new Map([
              ['toolCount', availableTools.length.toString()],
              ['serverStats', serverStats]
            ])
          }
        }
        
        if (subCommand === 'info' && args[1]) {
          // Show detailed information about a specific tool
          const toolName = args[1]
          const availableTools = await this.toolProvider.getAvailableTools()
          const tool = availableTools.find(t => t.name === toolName)
          
          if (!tool) {
            return {
              status: 'error',
              content: `Tool '${toolName}' not found. Use /mcp list to see available tools.`,
              output: `Tool '${toolName}' not found. Use /mcp list to see available tools.`,
              commandName: 'mcp',
              success: false,
              metadata: new Map()
            }
          }
          
          const requiredParams = tool.inputSchema.required.join(', ') || 'None'
          const properties = Array.from(tool.inputSchema.properties.entries())
            .map(([name, prop]) => `  ${name}: ${prop.type} - ${prop.description}`)
            .join('\n')
          
          const output = [
            `Tool: ${tool.name}`,
            `Description: ${tool.description}`,
            `Category: ${tool.category}`,
            `Required Parameters: ${requiredParams}`,
            '',
            'Parameters:',
            properties || '  None',
            '',
            `Capabilities:`,
            `  Async: ${tool.capabilities.isAsync}`,
            `  Streaming: ${tool.capabilities.supportsStreaming}`,
            `  Requires Confirmation: ${tool.capabilities.requiresConfirmation}`,
            `  Max Execution Time: ${tool.capabilities.maxExecutionTime}ms`
          ].join('\n')
          
          return {
            status: 'success',
            content: output,
            output: output,
            commandName: 'mcp',
            success: true,
            metadata: new Map([
              ['toolName', toolName],
              ['category', tool.category]
            ])
          }
        }
        
        if (subCommand === 'test' && args[1]) {
          // Test tool validation
          const toolName = args[1]
          const testParams = new Map<string, unknown>()
          
          // Parse additional arguments as key=value pairs
          for (let i = 2; i < args.length; i++) {
            const param = args[i]
            if (param.includes('=')) {
              const [key, value] = param.split('=', 2)
              testParams.set(key, value)
            }
          }
          
          const isValid = await this.toolProvider.validateTool(toolName, testParams)
          
          return {
            status: 'success',
            content: `Tool validation result: ${isValid ? 'VALID' : 'INVALID'}`,
            output: `Tool validation result: ${isValid ? 'VALID' : 'INVALID'}`,
            commandName: 'mcp',
            success: true,
            metadata: new Map([
              ['toolName', toolName],
              ['isValid', isValid.toString()]
            ])
          }
        }
        
        return {
          status: 'error',
          content: `Unknown MCP subcommand: ${subCommand}. Available: list, info <tool>, test <tool> [params]`,
          output: `Unknown MCP subcommand: ${subCommand}. Available: list, info <tool>, test <tool> [params]`,
          commandName: 'mcp',
          success: false,
          metadata: new Map()
        }
        
      } catch (error) {
        return {
          status: 'error',
          content: `MCP command failed: ${error instanceof Error ? error.message : String(error)}`,
          output: `MCP command failed: ${error instanceof Error ? error.message : String(error)}`,
          commandName: 'mcp',
          success: false,
          metadata: new Map()
        }
      }
    }, BUILT_IN_COMMANDS.find(c => c.name === 'mcp'))
    
    // Resume command - resume previous conversation or workflow
    this.register('resume', async (request: CommandRequest) => {
      const args = Array.from(request.parameters.values()) as string[]
      
      if (!this.memoryProvider) {
        return {
          status: 'error',
          content: 'No memory provider available. Initialize CLI with memory provider to use resume functionality.',
          output: 'No memory provider available. Initialize CLI with memory provider to use resume functionality.',
          commandName: 'resume',
          success: false,
          metadata: new Map()
        }
      }
      
      try {
        const sessionId = args[0]
        
        if (!sessionId) {
          // List available sessions if no session ID provided
          return {
            status: 'error',
            content: 'Please provide a session ID. Usage: /resume <session_id>',
            output: 'Please provide a session ID. Usage: /resume <session_id>',
            commandName: 'resume',
            success: false,
            metadata: new Map()
          }
        }
        
        // Try to get the session context
        const session = await this.memoryProvider.getSession(sessionId)
        if (!session) {
          return {
            status: 'error',
            content: `Session '${sessionId}' not found. Check your session ID.`,
            output: `Session '${sessionId}' not found. Check your session ID.`,
            commandName: 'resume',
            success: false,
            metadata: new Map()
          }
        }
        
        // Get conversation state
        const conversationState = await this.memoryProvider.getConversationState(sessionId)
        
        // Get processing history
        const processingHistory = await this.memoryProvider.getProcessingHistory(sessionId, 10)
        
        const output = [
          `Resuming session: ${sessionId}`,
          `Domain: ${session.domain}`,
          `Created: ${session.createdAt.toISOString()}`,
          `Last accessed: ${session.lastAccessedAt.toISOString()}`,
          '',
          `Messages in conversation: ${conversationState?.messages.length || 0}`,
          `Current pattern: ${conversationState?.currentPattern?.name || 'None'}`,
          `Processing history entries: ${processingHistory.length}`,
          '',
          'Recent activity:',
          processingHistory.slice(0, 5).map(event => 
            `  ${event.timestamp.toISOString()}: ${event.type} - ${event.eventId}`
          ).join('\n') || '  No recent activity',
          '',
          'Session resumed successfully. Previous context is now active.'
        ].join('\n')
        
        // Update session last accessed time
        await this.memoryProvider.updateSession(sessionId, new Map([
          ...session.metadata,
          ['lastResumed', new Date().toISOString()]
        ]))
        
        return {
          status: 'success',
          content: output,
          output: output,
          commandName: 'resume',
          success: true,
          metadata: new Map([
            ['sessionId', sessionId],
            ['domain', session.domain],
            ['messageCount', (conversationState?.messages.length || 0).toString()],
            ['historyCount', processingHistory.length.toString()],
            ['currentPattern', conversationState?.currentPattern?.name || 'none']
          ])
        }
        
      } catch (error) {
        return {
          status: 'error',
          content: `Resume command failed: ${error instanceof Error ? error.message : String(error)}`,
          output: `Resume command failed: ${error instanceof Error ? error.message : String(error)}`,
          commandName: 'resume',
          success: false,
          metadata: new Map()
        }
      }
    }, BUILT_IN_COMMANDS.find(c => c.name === 'resume'))
  }
  
  // ==========================================================================
  // Private Helper Methods
  // ==========================================================================
  
  private resolveCommandName(name: string): string {
    return this.aliasMap.get(name) || name
  }
  
  
  private formatUptime(startTime?: Date): string {
    if (!startTime) return 'unknown'
    
    const uptime = Date.now() - startTime.getTime()
    const seconds = Math.floor(uptime / 1000)
    const minutes = Math.floor(seconds / 60)
    const hours = Math.floor(minutes / 60)
    
    if (hours > 0) {
      return `${hours}h ${minutes % 60}m ${seconds % 60}s`
    } else if (minutes > 0) {
      return `${minutes}m ${seconds % 60}s`
    } else {
      return `${seconds}s`
    }
  }

  // ==========================================================================
  // CLI Framework Compatibility Methods
  // ==========================================================================

  async execute(commandName: string, args: string[] = []): Promise<CommandResult> {
    const parameters = new Map<string, unknown>()
    args.forEach((arg, index) => {
      parameters.set(index.toString(), arg)
    })
    
    const request: CommandRequest = {
      commandName,
      parameters,
      rawInput: `/${commandName} ${args.join(' ')}`.trim()
    }
    return this.executeCommand(request)
  }
}

// ============================================================================
// Factory Functions
// ============================================================================

/**
 * Create a command handler with default configuration
 */
export function createCommandHandler(): CLICommandHandler {
  return new CLICommandHandler()
}

/**
 * Create a command handler with shell commands enabled
 */
export function createCommandHandlerWithShell(): CLICommandHandler {
  const handler = new CLICommandHandler()
  handler.setShellCommandsEnabled(true)
  return handler
}