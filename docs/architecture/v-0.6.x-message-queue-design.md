# v-0.6.x Message Queue Architecture Design

## Overview

This document outlines the design for v-0.6.x message queue system inspired by Claude Code's h2A async messaging pattern, adapted for qi-v2-agent with QiCore functional programming principles.

## Analysis Summary

### Claude Code's h2A Pattern Key Insights

From the analysis of Claude Code's real-time steering mechanism:

1. **h2A AsyncIterator Class**: Provides non-blocking message queue with dual-buffer system
2. **Promise-based Flow Control**: Uses readResolve/readReject callbacks for async coordination
3. **Real-time Message Injection**: Supports enqueue() during active iteration
4. **State Management**: Complete lifecycle with started, isDone, hasError flags
5. **Stream Processing**: Integration with g2A parser for structured input processing
6. **Command Queue**: Separate command queuing system (kq5) for execution coordination

### Our Current State

**QiCoreEventManager Analysis**:
- ✅ Good: QiCore Result<T> patterns, proper error handling
- ✅ Good: Event history tracking and statistics
- ❌ Limitation: Basic EventEmitter wrapper, no async iteration
- ❌ Limitation: No stream processing or real-time steering
- ❌ Limitation: No message queue or command buffering

## v-0.6.x Architecture Design

### 1. QiAsyncMessageQueue (h2A-inspired)

```typescript
interface QiMessage<T = any> {
  id: string;
  type: string;
  payload: T;
  timestamp: Date;
  priority?: number;
}

interface QueueState {
  started: boolean;
  isDone: boolean;
  hasError: boolean;
  messageCount: number;
}

class QiAsyncMessageQueue<T = any> implements AsyncIterable<QiMessage<T>> {
  private queue: QiMessage<T>[] = [];
  private readResolve?: (value: IteratorResult<QiMessage<T>>) => void;
  private readReject?: (error: any) => void;
  private state: QueueState = {
    started: false,
    isDone: false,
    hasError: false,
    messageCount: 0
  };
  private cleanupFn?: () => void;

  // QiCore integration
  enqueue(message: QiMessage<T>): Result<void, QiError>
  done(): Result<void, QiError>
  error(error: QiError): Result<void, QiError>
  
  // AsyncIterable implementation
  [Symbol.asyncIterator](): AsyncIterator<QiMessage<T>>
  next(): Promise<IteratorResult<QiMessage<T>>>
}
```

### 2. QiStreamProcessor (g2A-inspired)

```typescript
interface StreamProcessorOptions {
  bufferSize?: number;
  parseMode?: 'line' | 'json' | 'custom';
  validator?: (data: any) => Result<boolean, QiError>;
}

class QiStreamProcessor<TInput, TOutput> {
  private inputStream: AsyncIterable<TInput>;
  private outputQueue: QiAsyncMessageQueue<TOutput>;
  
  constructor(
    input: AsyncIterable<TInput>,
    processor: (chunk: TInput) => Result<TOutput[], QiError>,
    options: StreamProcessorOptions = {}
  )
  
  async *process(): AsyncGenerator<TOutput, void, unknown>
  
  // QiCore integration
  private validateInput(data: TInput): Result<TInput, QiError>
  private handleProcessingError(error: QiError): Result<void, QiError>
}
```

### 3. QiCommandCoordinator (kq5-inspired)

```typescript
interface CommandContext {
  id: string;
  mode: 'prompt' | 'tool' | 'workflow';
  priority: number;
  abortController: AbortController;
}

interface CoordinatorState {
  isExecuting: boolean;
  isCompleted: boolean;
  queuedCommands: number;
  activeCommands: number;
}

class QiCommandCoordinator {
  private commandQueue: Array<{command: any, context: CommandContext}> = [];
  private messageHistory: any[] = [];
  private outputStream: QiAsyncMessageQueue;
  private state: CoordinatorState;

  // Core coordination methods
  enqueueCommand<T>(command: T, context: CommandContext): Result<void, QiError>
  executeCommands(): Promise<Result<void, QiError>>
  
  // State management
  getState(): CoordinatorState
  getQueuedCommands(): readonly CommandContext[]
  removeQueuedCommands(commandIds: string[]): Result<void, QiError>
  
  // Abort handling
  abortCommand(commandId: string): Result<void, QiError>
  abortAllCommands(): Result<void, QiError>
}
```

### 4. Enhanced QiCoreEventManager

```typescript
// Extend existing QiCoreEventManager with async capabilities
interface AsyncEventManager extends IEventManager {
  // Async event streaming
  createEventStream<T>(eventPattern: string): QiAsyncMessageQueue<T>
  
  // Message queue integration
  connectMessageQueue<T>(queue: QiAsyncMessageQueue<T>): Result<void, QiError>
  
  // Stream processing
  processEventStream<T, U>(
    inputStream: AsyncIterable<T>,
    processor: (event: T) => Result<U, QiError>
  ): AsyncIterable<U>
  
  // Real-time steering
  enableSteering(stdinMonitor: boolean): Result<void, QiError>
}

class EnhancedQiCoreEventManager extends QiCoreEventManager implements AsyncEventManager {
  private messageQueues: Map<string, QiAsyncMessageQueue> = new Map();
  private streamProcessors: Map<string, QiStreamProcessor> = new Map();
  private commandCoordinator?: QiCommandCoordinator;
  
  // Implementation of async methods...
}
```

## Key Design Principles

### 1. QiCore Integration
- All operations return `Result<T, QiError>`
- Use `match()` for error handling and flow control
- Maintain functional programming paradigms
- No throwing exceptions, use functional error handling

### 2. Non-blocking Architecture
- Promise-based async iteration following h2A pattern
- Dual-buffer system: direct resolution + queue buffering
- AbortController integration for graceful cancellation

### 3. Type Safety
- Full TypeScript generics support
- Strict message typing with QiMessage interface
- Command context typing with CommandContext

### 4. Real-time Capabilities
- stdin monitoring for real-time user input
- Message queue injection during active processing
- Command coordination with priority handling

### 5. Error Resilience
- Comprehensive error state management
- Graceful degradation on failures
- Error propagation through Result<T> patterns

## Integration with Existing Architecture

### Current v-0.5.x Components
- ✅ Keep: Hybrid CLI framework and navigation
- ✅ Keep: QiCore functional programming patterns
- ✅ Enhance: QiCoreEventManager → EnhancedQiCoreEventManager
- ✅ Add: QiAsyncMessageQueue, QiStreamProcessor, QiCommandCoordinator

### Migration Strategy
1. **Phase 1**: Implement core async message queue (QiAsyncMessageQueue)
2. **Phase 2**: Add stream processing capabilities (QiStreamProcessor)  
3. **Phase 3**: Implement command coordination (QiCommandCoordinator)
4. **Phase 4**: Enhance existing event manager (EnhancedQiCoreEventManager)
5. **Phase 5**: Integration testing and real-time steering validation

## Benefits over Current System

### Immediate Benefits
- **Non-blocking Processing**: Real-time message handling during agent execution
- **Stream Processing**: Handle large inputs efficiently with buffering
- **Command Coordination**: Proper queuing and execution management
- **Abort Handling**: Graceful cancellation with AbortController

### Foundation for Future Versions
- **v-0.7.x Tools**: Message queue supports concurrent tool execution
- **v-0.8.x Workflows**: Command coordination enables complex workflow orchestration
- **v-0.9.x Agent**: Full async architecture ready for agent loop implementation

## Implementation Priority

### High Priority (Core Functionality)
1. QiAsyncMessageQueue - Foundation for all async operations
2. QiCommandCoordinator - Essential for command queuing
3. EnhancedQiCoreEventManager - Integration with existing system

### Medium Priority (Enhanced Features)  
1. QiStreamProcessor - Important for large input handling
2. stdin monitoring - Real-time steering capabilities
3. AbortController integration - Graceful cancellation

### Low Priority (Polish & Optimization)
1. Priority-based queuing
2. Advanced error recovery
3. Performance optimizations
4. Comprehensive logging

This design provides a solid foundation for async messaging while maintaining our QiCore functional programming approach and preparing for the advanced features needed in future versions.