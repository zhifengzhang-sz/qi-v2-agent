# qi-prompt v-0.8.0 Workflow Design Guide

## Overview

The v-0.8.0 workflow system represents a complete architectural upgrade from template-based mock implementations to real LangGraph StateGraph-powered workflow orchestration. This guide covers the design principles, architecture, and implementation details of the new workflow system.

## Key Design Principles

### 1. **Real LangGraph Integration**
- **StateGraph Foundation**: All workflows are built on actual LangGraph StateGraph instances, not simplified mocks
- **True State Management**: Uses `Annotation.Root()` for proper state type definitions and flow control
- **Native Streaming**: Real-time execution streaming with LangGraph's built-in capabilities

### 2. **Research-Backed Patterns**
- **ReAct Pattern**: Think-Act-Observe-Adapt loops with interleaved reasoning and action execution
- **ReWOO Pattern**: Planner-Worker-Solver architecture with upfront planning and evidence collection
- **ADaPT Pattern**: Recursive task decomposition with And/Or logical operators

### 3. **Production-Ready Tool Integration**
- **6-Phase Pipeline**: Complete tool execution lifecycle with proper error handling
- **Result Transformation**: Seamless conversion between workflow and core tool system formats
- **Concurrent Execution**: Support for parallel tool invocation when dependencies allow

## Architecture Overview

### Core Components

```
┌─────────────────────────────────────────────────────────────┐
│                    qi-prompt v-0.8.0                        │
│                 Workflow Architecture                       │
└─────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────┐
│               LangGraph StateGraph Layer                    │
├─────────────────────┬───────────────────┬───────────────────┤
│   LangGraphWorkflow │   Research        │   Tool Integration │
│   Engine            │   Patterns        │   Bridge          │
│                     │                   │                   │
│   • StateGraph      │   • ReAct         │   • WorkflowTool  │
│   • Annotation.Root │   • ReWOO         │     Executor      │
│   • Real streaming  │   • ADaPT         │   • Result        │
│   • State mgmt      │                   │     Conversion    │
└─────────────────────┴───────────────────┴───────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────┐
│                    QiCore Integration                       │
├─────────────────────────────────────────────────────────────┤
│   • Result<T> patterns     • Structured logging with        │
│   • Error handling         • createQiLogger                 │
│   • Type safety           • Performance monitoring          │
└─────────────────────────────────────────────────────────────┘
```

### State Management Design

The workflow system uses LangGraph's `Annotation.Root()` for type-safe state management:

```typescript
const WorkflowStateAnnotation = Annotation.Root({
  // Core workflow data
  input: Annotation<string>,
  pattern: Annotation<string>,
  domain: Annotation<string>,
  
  // Execution tracking
  toolResults: Annotation<ToolResult[]>,
  reasoningOutput: Annotation<string>,
  output: Annotation<string>,
  
  // Graph-specific state
  currentNodeId: Annotation<string>,
  executionPath: Annotation<string[]>,
  isComplete: Annotation<boolean>,
  error: Annotation<string | null>,
})
```

## Research Pattern Implementations

### ReAct Pattern: Continuous Reasoning-Action Loops

**Architecture**: Think-Act-Observe-Decide cycle with conditional edges

```
Think → Act → Observe → Decide
  ↑                        ↓
  ←─────── Continue ────────┘
           or Finish
```

**Key Features**:
- Interleaved reasoning and action execution
- Dynamic completion criteria evaluation
- History tracking for thoughts and actions
- Tool integration with observation feedback

**State Flow**:
```typescript
interface ReActState {
  thought: string;           // Current reasoning
  action: string;           // Planned action
  actionInput: Record<string, unknown>; // Action parameters
  observation: string;      // Action results
  thoughtHistory: string[]; // Reasoning trail
  actionHistory: Array<{    // Action-result pairs
    action: string;
    input: Record<string, unknown>;
    observation: string;
  }>;
}
```

### ReWOO Pattern: Plan-Execute-Solve Architecture

**Architecture**: Complete upfront planning with evidence collection

```
Plan → Worker₁ → Worker₂ → ... → WorkerN → Solver
     ↓         ↓                  ↓        ↓
   Step₁     Step₂      ...     StepN   Solution
```

**Key Features**:
- Comprehensive upfront planning phase
- Parallel evidence collection by specialized workers
- Final synthesis by solver component
- Optimized for complex multi-step problems

### ADaPT Pattern: Recursive Task Decomposition

**Architecture**: As-needed decomposition with logical operators

```
Complex Task
    ↓ (decompose)
  And/Or Subtasks
    ↓ (execute/decompose)
  Simple Tasks → Results
    ↓ (combine)
  Final Output
```

**Key Features**:
- Recursive task breakdown when complexity exceeds threshold
- And/Or logical operators for task combination
- Adaptive decomposition based on execution capability
- Hierarchical result combination

## Tool Integration Architecture

### WorkflowToolExecutor Service

The `WorkflowToolExecutor` bridges the workflow system with the core tool infrastructure:

```typescript
class WorkflowToolExecutor {
  // Single tool execution
  async executeTool(request: WorkflowToolExecutionRequest): Promise<Result<WorkflowToolResult, QiError>>
  
  // Sequential execution
  async executeToolSequence(requests: WorkflowToolExecutionRequest[]): Promise<Result<WorkflowToolResult[], QiError>>
  
  // Concurrent batch execution
  async executeToolsBatch(requests: WorkflowToolExecutionRequest[]): Promise<Result<WorkflowToolResult[], QiError>>
}
```

### 6-Phase Tool Execution Pipeline

1. **Request Validation**: Input parameter validation and tool availability checks
2. **Permission Verification**: Security and access control validation
3. **Execution Preparation**: Context setup and resource allocation
4. **Tool Invocation**: Actual tool execution with timeout management
5. **Result Processing**: Output transformation and error handling
6. **Metadata Collection**: Performance metrics and execution tracking

## LLM-Based Workflow Planning

### Dynamic Workflow Generation

The system supports three workflow extraction methods:

1. **LLM-Based**: Dynamic generation using structured output with Zod schemas
2. **Template-Based**: Predefined patterns for common use cases
3. **Strategy-Based**: Hybrid approach combining templates with LLM enhancement

### LLM Integration Architecture

```typescript
class LLMWorkflowPlanner {
  async generateWorkflow(
    description: string,
    options: {
      provider: 'openai' | 'anthropic';
      model?: string;
      temperature?: number;
      maxTokens?: number;
    }
  ): Promise<Result<WorkflowPlan, QiError>>
}
```

**Structured Output Schema**:
```typescript
const WorkflowPlanSchema = z.object({
  name: z.string().describe('A descriptive name for the workflow'),
  description: z.string().describe('Brief explanation of what this workflow accomplishes'),
  nodes: z.array(z.object({
    id: z.string(),
    name: z.string(),
    type: z.enum(['input', 'processing', 'tool', 'reasoning', 'output', 'control']),
    description: z.string(),
    dependencies: z.array(z.string()).optional(),
    toolName: z.string().optional(),
    toolInput: z.record(z.unknown()).optional(),
  })).min(3),
  edges: z.array(z.object({
    from: z.string(),
    to: z.string(),
    condition: z.string().optional(),
  })),
  estimatedComplexity: z.enum(['simple', 'medium', 'complex']),
  suggestedPattern: z.enum(['react', 'rewoo', 'adapt']).optional(),
})
```

## Performance Characteristics

### Execution Metrics

- **Extraction Latency**: 100-500ms (LLM provider dependent)
- **StateGraph Overhead**: ~5ms per node + tool execution time
- **Memory Usage**: Linear with workflow complexity O(n)
- **Throughput**: Concurrent workflow support with resource limits

### Optimization Strategies

1. **Graph Precompilation**: Compile and cache frequently used patterns
2. **Tool Result Caching**: Cache tool results for repeated operations
3. **Streaming Execution**: Real-time progress updates during execution
4. **Resource Pooling**: Shared tool executor instances across workflows

## Error Handling Strategy

### Multi-Level Error Recovery

1. **Node Level**: Retry with exponential backoff
2. **Workflow Level**: Graceful degradation with partial results
3. **System Level**: Circuit breaker patterns for tool failures
4. **User Level**: Clear error messages with recovery suggestions

### QiCore Error Integration

All errors use QiCore's `Result<T>` pattern:

```typescript
type WorkflowResult = Result<{
  finalState: WorkflowState;
  executionPath: string[];
  performance: WorkflowPerformance;
}, QiError>
```

## Security Considerations

### Tool Access Control

- **Permission Validation**: Verify tool access permissions before execution
- **Input Sanitization**: Validate and sanitize all tool inputs
- **Resource Limits**: Enforce timeouts and resource consumption limits
- **Audit Logging**: Track all tool executions for security monitoring

### State Isolation

- **Workflow Sandboxing**: Isolate workflow execution contexts
- **Memory Protection**: Prevent cross-workflow state contamination
- **Secret Management**: Secure handling of sensitive configuration data

## Configuration and Customization

### Engine Configuration

```typescript
interface IWorkflowEngineConfig {
  defaultTimeoutMs?: number;
  maxConcurrentWorkflows?: number;
  enablePersistence?: boolean;
  enableMetrics?: boolean;
  loggingLevel?: 'debug' | 'info' | 'warn' | 'error';
}
```

### Pattern Customization

Each research pattern supports extensive configuration:

```typescript
interface ReActConfig {
  maxSteps: number;
  thinkingPrompt: string;
  actionPrompt: string;
  observationPrompt: string;
  completionCriteria: (state: ReActState) => boolean;
}
```

## Migration Guide

### From v-0.7.x Template System

1. **Replace QiWorkflowEngine**: Upgrade to `LangGraphWorkflowEngine`
2. **Update State Management**: Convert to LangGraph `Annotation.Root()` patterns
3. **Implement Real Tools**: Replace mock tool calls with `WorkflowToolExecutor`
4. **Add Logging**: Integrate `createQiLogger` throughout workflow components
5. **Test Patterns**: Validate ReAct/ReWOO/ADaPT pattern implementations

### Breaking Changes

- **State Structure**: New LangGraph-compatible state definitions required
- **Tool Interface**: Updated tool execution API with Result<T> patterns
- **Error Handling**: All errors now use QiCore error categories
- **Logging**: Console.log replaced with structured logging

## Next Steps

The v-0.8.0 workflow system provides a solid foundation for advanced workflow orchestration. Future enhancements may include:

1. **Persistence Layer**: Workflow state checkpointing and resume capabilities
2. **Visual Editor**: Graph-based workflow design interface
3. **Pattern Marketplace**: Community-contributed workflow patterns
4. **Performance Analytics**: Advanced metrics and optimization insights
5. **Multi-Agent Coordination**: Cross-workflow communication protocols

This design ensures scalability, maintainability, and extensibility for the evolving needs of the qi-prompt workflow system.