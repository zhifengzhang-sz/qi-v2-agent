# qi-prompt v-0.8.0 Implementation Guide

## Quick Start

This guide provides step-by-step instructions for implementing and using the v-0.8.0 workflow system with real LangGraph StateGraph integration.

## Prerequisites

### Dependencies

Ensure these packages are installed:

```bash
bun add @langchain/langgraph @langchain/core
bun add @qi/base @qi/core  # QiCore Result<T> patterns
```

### Environment Setup

```bash
# Optional: For LLM-based workflow planning
export OPENAI_API_KEY="your-api-key"
export ANTHROPIC_API_KEY="your-api-key"
```

## Basic Usage

### 1. Initialize the LangGraph Workflow Engine

```typescript
import { LangGraphWorkflowEngine } from '@qi/workflow/impl/LangGraphWorkflowEngine.js';
import { WorkflowToolExecutor } from '@qi/workflow/services/WorkflowToolExecutor.js';

// Create tool executor (optional but recommended)
const toolExecutor = new WorkflowToolExecutor();

// Initialize the engine
const engine = new LangGraphWorkflowEngine({
  defaultTimeoutMs: 30000,
  maxConcurrentWorkflows: 5,
  enableMetrics: true,
  loggingLevel: 'info'
}, toolExecutor);
```

### 2. Create and Execute a Basic Workflow

```typescript
// Create a workflow
const workflow = engine.createWorkflow('file-analysis');

// Define initial state
const initialState = {
  input: 'Analyze the structure of config.json file',
  pattern: 'file-analysis',
  domain: 'file-system',
  context: new Map([['sessionId', 'demo-session']]),
  toolResults: [],
  reasoningOutput: '',
  output: '',
  metadata: {
    startTime: Date.now(),
    currentStage: 'starting',
    processingSteps: [],
    performance: new Map(),
  }
};

// Execute the workflow
const result = await engine.execute(workflow, initialState);

if (result.finalState) {
  console.log('Workflow Output:', result.finalState.output);
  console.log('Execution Path:', result.executionPath);
  console.log('Performance:', result.performance);
}
```

### 3. Stream Workflow Execution

```typescript
// Stream execution for real-time updates
for await (const chunk of engine.stream(workflow, initialState)) {
  console.log(`Node: ${chunk.nodeId}`);
  console.log(`Stage: ${chunk.state.metadata.currentStage}`);
  console.log(`Complete: ${chunk.isComplete}`);
  
  if (chunk.isComplete) {
    console.log('Final Output:', chunk.state.output);
    break;
  }
}
```

## Research Pattern Implementation

### ReAct Pattern: Think-Act-Observe Loops

```typescript
import { ReActPattern } from '@qi/workflow/patterns/ReActPattern.js';

// Initialize ReAct pattern
const reactPattern = new ReActPattern(toolExecutor, {
  maxSteps: 8,
  thinkingPrompt: 'Think: What should I do next?',
  actionPrompt: 'Action: What action should I take?',
  observationPrompt: 'Observation: What did I learn?',
  completionCriteria: (state) => state.thought.includes('final answer')
});

// Execute ReAct workflow
const reactResult = await reactPattern.execute(
  'Find and analyze the main configuration file',
  'react-session-123'
);

console.log('ReAct Output:', reactResult.output);
console.log('Thought History:', reactResult.thoughtHistory);
console.log('Action History:', reactResult.actionHistory);
console.log('Tool Results:', reactResult.toolResults);
```

### ReWOO Pattern: Plan-Execute-Solve

```typescript
import { ReWOOPattern } from '@qi/workflow/patterns/ReWOOPattern.js';

// Initialize ReWOO pattern
const rewooPattern = new ReWOOPattern(toolExecutor, {
  maxPlanSteps: 5,
  maxWorkers: 3,
  evidenceThreshold: 0.8,
  timeoutMs: 60000
});

// Execute ReWOO workflow
const rewooResult = await rewooPattern.execute(
  'Research and document the project dependencies',
  'rewoo-session-456'
);

console.log('ReWOO Output:', rewooResult.output);
console.log('Plan Steps:', rewooResult.plan);
console.log('Evidence Collected:', rewooResult.evidence);
console.log('Solution:', rewooResult.solution);
```

### ADaPT Pattern: Recursive Task Decomposition

```typescript
import { ADaPTPattern } from '@qi/workflow/patterns/ADaPTPattern.js';

// Initialize ADaPT pattern
const adaptPattern = new ADaPTPattern(toolExecutor, {
  maxDecompositionLevel: 4,
  complexityThreshold: 'medium',
  enableAdaptiveDecomposition: true,
  maxRetries: 3,
  timeoutMs: 60000
});

// Execute ADaPT workflow
const adaptResult = await adaptPattern.execute(
  'Analyze project structure and create comprehensive documentation',
  'adapt-session-789'
);

console.log('ADaPT Output:', adaptResult.output);
console.log('Task Hierarchy:', adaptResult.tasks);
console.log('Completed Tasks:', adaptResult.completedTasks);
console.log('Performance:', adaptResult.performance);
```

## LLM-Based Workflow Planning

### Dynamic Workflow Generation

```typescript
import { LLMWorkflowPlanner } from '@qi/workflow/impl/LLMWorkflowPlanner.js';

// Initialize LLM planner
const planner = new LLMWorkflowPlanner({
  provider: 'openai',
  model: 'gpt-4',
  temperature: 0.1,
  maxTokens: 2000
});

// Generate workflow from natural language
const planResult = await planner.generateWorkflow(
  'Create a comprehensive code review workflow that analyzes TypeScript files for bugs, performance issues, and style violations'
);

if (planResult.tag === 'success') {
  const plan = planResult.value;
  console.log('Generated Workflow:', plan.name);
  console.log('Description:', plan.description);
  console.log('Nodes:', plan.nodes.length);
  console.log('Suggested Pattern:', plan.suggestedPattern);
  
  // Execute the generated workflow
  const generatedWorkflow = await planner.executeWorkflow(plan, {
    sessionId: 'llm-generated-session',
    input: 'src/main.ts',
    domain: 'code-review'
  });
  
  if (generatedWorkflow.tag === 'success') {
    console.log('LLM Workflow Result:', generatedWorkflow.value.output);
  }
}
```

### Fallback to Template-Based Planning

```typescript
// Automatic fallback when LLM is unavailable
const plannerWithFallback = new LLMWorkflowPlanner({
  provider: 'openai', // Will fallback to template if no API key
  fallbackToTemplate: true,
  templatePatterns: ['analysis', 'file-processing', 'code-review']
});

const fallbackResult = await plannerWithFallback.generateWorkflow(
  'Analyze and process configuration files'
);

// Always succeeds with either LLM or template result
console.log('Planning Method:', fallbackResult.value.metadata.planningMethod);
```

## Tool Integration

### Configure Tool Executor

```typescript
import { WorkflowToolExecutor } from '@qi/workflow/services/WorkflowToolExecutor.js';

// Initialize with specific tools
const toolExecutor = new WorkflowToolExecutor({
  timeoutMs: 10000,
  maxConcurrentTools: 3,
  enableRetry: true,
  retryAttempts: 2
});

// Check available tools
const availableTools = toolExecutor.getAvailableTools();
console.log('Available Tools:', availableTools);

// Manual tool execution
const toolResult = await toolExecutor.executeTool({
  toolName: 'Read',
  input: { file_path: '/path/to/file.txt' },
  nodeId: 'manual-execution',
  workflowId: 'manual-workflow',
  sessionId: 'manual-session'
});

if (toolResult.tag === 'success') {
  console.log('Tool Output:', toolResult.value.output);
  console.log('Execution Time:', toolResult.value.executionTime);
}
```

### Sequential Tool Execution

```typescript
// Execute multiple tools in sequence
const sequentialTools = [
  {
    toolName: 'Glob',
    input: { pattern: '**/*.ts' },
    nodeId: 'find-files',
    workflowId: 'analysis-workflow',
    sessionId: 'seq-session'
  },
  {
    toolName: 'Grep',
    input: { pattern: 'class.*extends', output_mode: 'content' },
    nodeId: 'find-classes',
    workflowId: 'analysis-workflow',
    sessionId: 'seq-session'
  }
];

const sequenceResult = await toolExecutor.executeToolSequence(sequentialTools);

if (sequenceResult.tag === 'success') {
  sequenceResult.value.forEach((result, index) => {
    console.log(`Tool ${index + 1} (${result.toolName}):`, result.output);
  });
}
```

### Concurrent Tool Execution

```typescript
// Execute multiple tools concurrently
const concurrentTools = [
  {
    toolName: 'Read',
    input: { file_path: 'package.json' },
    nodeId: 'read-pkg',
    workflowId: 'analysis-workflow',
    sessionId: 'concurrent-session'
  },
  {
    toolName: 'Read',
    input: { file_path: 'tsconfig.json' },
    nodeId: 'read-ts',
    workflowId: 'analysis-workflow',
    sessionId: 'concurrent-session'
  }
];

const batchResult = await toolExecutor.executeToolsBatch(concurrentTools);

if (batchResult.tag === 'success') {
  batchResult.value.forEach((result) => {
    console.log(`${result.toolName} completed in ${result.executionTime}ms`);
  });
}
```

## Advanced Features

### Workflow Streaming with Progress Tracking

```typescript
async function executeWithProgress(pattern: string, input: string) {
  const workflow = engine.createWorkflow(pattern);
  const initialState = createInitialState(input, pattern);
  
  let nodeCount = 0;
  const startTime = Date.now();
  
  for await (const chunk of engine.stream(workflow, initialState)) {
    nodeCount++;
    const elapsed = Date.now() - startTime;
    
    console.log(`[${elapsed}ms] Node ${nodeCount}: ${chunk.nodeId}`);
    
    if (chunk.state.metadata.processingSteps.length > 0) {
      const lastStep = chunk.state.metadata.processingSteps.slice(-1)[0];
      console.log(`  â””â”€ Step: ${lastStep}`);
    }
    
    if (chunk.state.toolResults.length > 0) {
      const lastTool = chunk.state.toolResults.slice(-1)[0];
      console.log(`  â””â”€ Tool: ${lastTool.toolName} (${lastTool.executionTime}ms)`);
    }
    
    if (chunk.isComplete) {
      console.log(`\nðŸŽ¯ Workflow completed in ${elapsed}ms`);
      console.log(`ðŸ“Š Total nodes executed: ${nodeCount}`);
      console.log(`ðŸ“‹ Final output: ${chunk.state.output.substring(0, 100)}...`);
      break;
    }
  }
}

// Usage
await executeWithProgress('comprehensive-analysis', 'Analyze this TypeScript project');
```

### Custom StateGraph Creation

```typescript
import { StateGraph, Annotation } from '@langchain/langgraph';

// Define custom state annotation
const CustomStateAnnotation = Annotation.Root({
  input: Annotation<string>,
  currentStep: Annotation<number>,
  customData: Annotation<Record<string, unknown>>,
  results: Annotation<string[]>,
  isComplete: Annotation<boolean>
});

// Create custom StateGraph
function createCustomWorkflow() {
  const graph = new StateGraph(CustomStateAnnotation);
  
  // Add custom nodes
  graph.addNode('initialize', async (state) => ({
    ...state,
    currentStep: 1,
    customData: { startTime: Date.now() },
    results: []
  }));
  
  graph.addNode('process', async (state) => ({
    ...state,
    currentStep: 2,
    results: [...state.results, `Processed: ${state.input}`]
  }));
  
  graph.addNode('finalize', async (state) => ({
    ...state,
    currentStep: 3,
    isComplete: true
  }));
  
  // Define edges
  graph.addEdge('__start__', 'initialize');
  graph.addEdge('initialize', 'process');
  graph.addEdge('process', 'finalize');
  graph.addEdge('finalize', '__end__');
  
  return graph.compile();
}

// Execute custom workflow
const customGraph = createCustomWorkflow();
const customResult = await customGraph.invoke({
  input: 'Custom workflow input',
  currentStep: 0,
  customData: {},
  results: [],
  isComplete: false
});

console.log('Custom Workflow Result:', customResult);
```

### Error Handling and Recovery

```typescript
import { isQiError } from '@qi/base';

async function robustWorkflowExecution(pattern: string, input: string) {
  try {
    const workflow = engine.createWorkflow(pattern);
    const initialState = createInitialState(input, pattern);
    
    const result = await engine.execute(workflow, initialState);
    
    if (result.finalState.output.includes('error') || result.executionPath.length === 0) {
      console.warn('Workflow completed with potential issues');
      console.log('Execution path:', result.executionPath);
      return result.finalState.output;
    }
    
    return result.finalState.output;
    
  } catch (error) {
    if (isQiError(error)) {
      console.error('QiCore Error:', error.message);
      console.error('Category:', error.category);
      console.error('Code:', error.code);
      
      // Attempt recovery with simpler pattern
      console.log('Attempting recovery with basic pattern...');
      return await executeBasicFallback(input);
    } else {
      console.error('Unexpected error:', error);
      throw error;
    }
  }
}

async function executeBasicFallback(input: string): Promise<string> {
  // Fallback to template-based workflow
  const simpleWorkflow = engine.createWorkflow('basic-processing');
  const fallbackState = createInitialState(input, 'basic-processing');
  
  const result = await engine.execute(simpleWorkflow, fallbackState);
  return result.finalState.output;
}
```

### Performance Monitoring

```typescript
class WorkflowPerformanceMonitor {
  private metrics = new Map<string, number[]>();
  
  async monitorExecution<T>(
    name: string, 
    execution: () => Promise<T>
  ): Promise<T> {
    const startTime = Date.now();
    
    try {
      const result = await execution();
      const duration = Date.now() - startTime;
      
      this.recordMetric(name, duration);
      console.log(`âœ… ${name} completed in ${duration}ms`);
      
      return result;
    } catch (error) {
      const duration = Date.now() - startTime;
      console.error(`âŒ ${name} failed after ${duration}ms`);
      throw error;
    }
  }
  
  private recordMetric(name: string, duration: number) {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }
    this.metrics.get(name)!.push(duration);
  }
  
  getStats(name: string) {
    const durations = this.metrics.get(name) || [];
    if (durations.length === 0) return null;
    
    const avg = durations.reduce((a, b) => a + b) / durations.length;
    const min = Math.min(...durations);
    const max = Math.max(...durations);
    
    return { avg, min, max, count: durations.length };
  }
  
  printAllStats() {
    console.log('\nðŸ“Š Workflow Performance Statistics:');
    for (const [name, durations] of this.metrics) {
      const stats = this.getStats(name);
      console.log(`  ${name}: avg=${stats!.avg.toFixed(1)}ms, min=${stats!.min}ms, max=${stats!.max}ms, count=${stats!.count}`);
    }
  }
}

// Usage
const monitor = new WorkflowPerformanceMonitor();

await monitor.monitorExecution('react-pattern', async () => {
  return await reactPattern.execute('Complex analysis task', 'perf-session');
});

await monitor.monitorExecution('rewoo-pattern', async () => {
  return await rewooPattern.execute('Research task', 'perf-session');
});

monitor.printAllStats();
```

## Testing Workflows

### Unit Testing Individual Patterns

```typescript
import { describe, it, expect } from 'vitest';

describe('ReAct Pattern', () => {
  it('should complete simple reasoning tasks', async () => {
    const pattern = new ReActPattern(mockToolExecutor);
    const result = await pattern.execute('What is 2+2?', 'test-session');
    
    expect(result.output).toContain('4');
    expect(result.thoughtHistory.length).toBeGreaterThan(0);
    expect(result.totalSteps).toBeGreaterThan(0);
  });
  
  it('should handle tool execution', async () => {
    const pattern = new ReActPattern(toolExecutor);
    const result = await pattern.execute('Read the package.json file', 'test-session');
    
    expect(result.toolResults.length).toBeGreaterThan(0);
    expect(result.toolResults[0].toolName).toBe('Read');
  });
});

describe('LangGraph Engine', () => {
  it('should execute basic workflow', async () => {
    const workflow = engine.createWorkflow('test-pattern');
    const state = createInitialState('test input', 'test-pattern');
    
    const result = await engine.execute(workflow, state);
    
    expect(result.finalState.output).toBeTruthy();
    expect(result.executionPath.length).toBeGreaterThan(0);
    expect(result.performance.totalTime).toBeGreaterThan(0);
  });
});
```

### Integration Testing

```typescript
describe('End-to-End Workflow', () => {
  it('should handle complete file analysis workflow', async () => {
    const input = 'Analyze the TypeScript configuration and dependencies';
    
    // Test LLM planning
    const planner = new LLMWorkflowPlanner({ provider: 'openai' });
    const plan = await planner.generateWorkflow(input);
    
    expect(plan.tag).toBe('success');
    if (plan.tag === 'success') {
      expect(plan.value.nodes.length).toBeGreaterThan(2);
      
      // Test workflow execution
      const result = await planner.executeWorkflow(plan.value, {
        sessionId: 'e2e-test',
        input,
        domain: 'file-analysis'
      });
      
      expect(result.tag).toBe('success');
      if (result.tag === 'success') {
        expect(result.value.output).toContain('TypeScript');
      }
    }
  });
});
```

## Common Patterns and Best Practices

### 1. Always Use Result<T> Pattern

```typescript
import { Result, success, failure } from '@qi/base';

async function safeWorkflowExecution(
  pattern: string, 
  input: string
): Promise<Result<string, string>> {
  try {
    const workflow = engine.createWorkflow(pattern);
    const state = createInitialState(input, pattern);
    const result = await engine.execute(workflow, state);
    
    return success(result.finalState.output);
  } catch (error) {
    return failure(error instanceof Error ? error.message : String(error));
  }
}
```

### 2. Implement Proper Logging

```typescript
import { createQiLogger } from '@qi/workflow/utils/QiCoreLogger.js';

const logger = createQiLogger({
  name: 'WorkflowApplication',
  level: 'info'
});

logger.info('Starting workflow execution', undefined, {
  component: 'WorkflowApp',
  workflowId: 'app-workflow-123',
  input: input.substring(0, 100)
});
```

### 3. Handle Resource Cleanup

```typescript
class WorkflowManager {
  private activeWorkflows = new Set<string>();
  
  async executeWorkflow(id: string, pattern: string, input: string) {
    this.activeWorkflows.add(id);
    
    try {
      const result = await engine.execute(
        engine.createWorkflow(pattern),
        createInitialState(input, pattern)
      );
      return result;
    } finally {
      this.activeWorkflows.delete(id);
    }
  }
  
  async shutdown() {
    // Wait for active workflows to complete
    while (this.activeWorkflows.size > 0) {
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    // Cleanup resources
    engine.cleanup?.();
  }
}
```

This implementation guide provides comprehensive coverage of the v-0.8.0 workflow system, from basic usage to advanced patterns and best practices. The examples demonstrate real LangGraph integration, proper error handling, and production-ready code patterns.