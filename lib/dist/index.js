var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a2, b2) => (typeof require !== "undefined" ? require : a2)[b2]
}) : x2)(function(x2) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x2 + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../node_modules/node-fetch/node_modules/whatwg-url/node_modules/webidl-conversions/lib/index.js
var require_lib = __commonJS({
  "../node_modules/node-fetch/node_modules/whatwg-url/node_modules/webidl-conversions/lib/index.js"(exports, module) {
    "use strict";
    var conversions = {};
    module.exports = conversions;
    function sign(x2) {
      return x2 < 0 ? -1 : 1;
    }
    function evenRound(x2) {
      if (x2 % 1 === 0.5 && (x2 & 1) === 0) {
        return Math.floor(x2);
      } else {
        return Math.round(x2);
      }
    }
    function createNumberConversion(bitLength, typeOpts) {
      if (!typeOpts.unsigned) {
        --bitLength;
      }
      const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
      const upperBound = Math.pow(2, bitLength) - 1;
      const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
      const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
      return function(V2, opts) {
        if (!opts) opts = {};
        let x2 = +V2;
        if (opts.enforceRange) {
          if (!Number.isFinite(x2)) {
            throw new TypeError("Argument is not a finite number");
          }
          x2 = sign(x2) * Math.floor(Math.abs(x2));
          if (x2 < lowerBound || x2 > upperBound) {
            throw new TypeError("Argument is not in byte range");
          }
          return x2;
        }
        if (!isNaN(x2) && opts.clamp) {
          x2 = evenRound(x2);
          if (x2 < lowerBound) x2 = lowerBound;
          if (x2 > upperBound) x2 = upperBound;
          return x2;
        }
        if (!Number.isFinite(x2) || x2 === 0) {
          return 0;
        }
        x2 = sign(x2) * Math.floor(Math.abs(x2));
        x2 = x2 % moduloVal;
        if (!typeOpts.unsigned && x2 >= moduloBound) {
          return x2 - moduloVal;
        } else if (typeOpts.unsigned) {
          if (x2 < 0) {
            x2 += moduloVal;
          } else if (x2 === -0) {
            return 0;
          }
        }
        return x2;
      };
    }
    conversions["void"] = function() {
      return void 0;
    };
    conversions["boolean"] = function(val) {
      return !!val;
    };
    conversions["byte"] = createNumberConversion(8, { unsigned: false });
    conversions["octet"] = createNumberConversion(8, { unsigned: true });
    conversions["short"] = createNumberConversion(16, { unsigned: false });
    conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
    conversions["long"] = createNumberConversion(32, { unsigned: false });
    conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
    conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
    conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
    conversions["double"] = function(V2) {
      const x2 = +V2;
      if (!Number.isFinite(x2)) {
        throw new TypeError("Argument is not a finite floating-point value");
      }
      return x2;
    };
    conversions["unrestricted double"] = function(V2) {
      const x2 = +V2;
      if (isNaN(x2)) {
        throw new TypeError("Argument is NaN");
      }
      return x2;
    };
    conversions["float"] = conversions["double"];
    conversions["unrestricted float"] = conversions["unrestricted double"];
    conversions["DOMString"] = function(V2, opts) {
      if (!opts) opts = {};
      if (opts.treatNullAsEmptyString && V2 === null) {
        return "";
      }
      return String(V2);
    };
    conversions["ByteString"] = function(V2, opts) {
      const x2 = String(V2);
      let c2 = void 0;
      for (let i2 = 0; (c2 = x2.codePointAt(i2)) !== void 0; ++i2) {
        if (c2 > 255) {
          throw new TypeError("Argument is not a valid bytestring");
        }
      }
      return x2;
    };
    conversions["USVString"] = function(V2) {
      const S2 = String(V2);
      const n2 = S2.length;
      const U2 = [];
      for (let i2 = 0; i2 < n2; ++i2) {
        const c2 = S2.charCodeAt(i2);
        if (c2 < 55296 || c2 > 57343) {
          U2.push(String.fromCodePoint(c2));
        } else if (56320 <= c2 && c2 <= 57343) {
          U2.push(String.fromCodePoint(65533));
        } else {
          if (i2 === n2 - 1) {
            U2.push(String.fromCodePoint(65533));
          } else {
            const d2 = S2.charCodeAt(i2 + 1);
            if (56320 <= d2 && d2 <= 57343) {
              const a2 = c2 & 1023;
              const b2 = d2 & 1023;
              U2.push(String.fromCodePoint((2 << 15) + (2 << 9) * a2 + b2));
              ++i2;
            } else {
              U2.push(String.fromCodePoint(65533));
            }
          }
        }
      }
      return U2.join("");
    };
    conversions["Date"] = function(V2, opts) {
      if (!(V2 instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
      }
      if (isNaN(V2)) {
        return void 0;
      }
      return V2;
    };
    conversions["RegExp"] = function(V2, opts) {
      if (!(V2 instanceof RegExp)) {
        V2 = new RegExp(V2);
      }
      return V2;
    };
  }
});

// ../node_modules/node-fetch/node_modules/whatwg-url/lib/utils.js
var require_utils = __commonJS({
  "../node_modules/node-fetch/node_modules/whatwg-url/lib/utils.js"(exports, module) {
    "use strict";
    module.exports.mixin = function mixin(target, source) {
      const keys = Object.getOwnPropertyNames(source);
      for (let i2 = 0; i2 < keys.length; ++i2) {
        Object.defineProperty(target, keys[i2], Object.getOwnPropertyDescriptor(source, keys[i2]));
      }
    };
    module.exports.wrapperSymbol = Symbol("wrapper");
    module.exports.implSymbol = Symbol("impl");
    module.exports.wrapperForImpl = function(impl) {
      return impl[module.exports.wrapperSymbol];
    };
    module.exports.implForWrapper = function(wrapper) {
      return wrapper[module.exports.implSymbol];
    };
  }
});

// ../node_modules/node-fetch/node_modules/whatwg-url/node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({
  "../node_modules/node-fetch/node_modules/whatwg-url/node_modules/tr46/lib/mappingTable.json"(exports, module) {
    module.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1e3, 1e3], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8e3]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9e3], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [3e4]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13e3, 13e3], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64e3, 64e3], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[12e4, 12e4], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128e3, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23e3]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149e3]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32e3]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195e3, 195e3], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [4e4]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
  }
});

// ../node_modules/node-fetch/node_modules/whatwg-url/node_modules/tr46/index.js
var require_tr46 = __commonJS({
  "../node_modules/node-fetch/node_modules/whatwg-url/node_modules/tr46/index.js"(exports, module) {
    "use strict";
    var punycode = __require("punycode");
    var mappingTable = require_mappingTable();
    var PROCESSING_OPTIONS = {
      TRANSITIONAL: 0,
      NONTRANSITIONAL: 1
    };
    function normalize(str) {
      return str.split("\0").map(function(s2) {
        return s2.normalize("NFC");
      }).join("\0");
    }
    function findStatus(val) {
      var start = 0;
      var end = mappingTable.length - 1;
      while (start <= end) {
        var mid = Math.floor((start + end) / 2);
        var target = mappingTable[mid];
        if (target[0][0] <= val && target[0][1] >= val) {
          return target;
        } else if (target[0][0] > val) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return null;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    function countSymbols(string) {
      return string.replace(regexAstralSymbols, "_").length;
    }
    function mapChars(domain_name, useSTD3, processing_option) {
      var hasError = false;
      var processed = "";
      var len = countSymbols(domain_name);
      for (var i2 = 0; i2 < len; ++i2) {
        var codePoint = domain_name.codePointAt(i2);
        var status = findStatus(codePoint);
        switch (status[1]) {
          case "disallowed":
            hasError = true;
            processed += String.fromCodePoint(codePoint);
            break;
          case "ignored":
            break;
          case "mapped":
            processed += String.fromCodePoint.apply(String, status[2]);
            break;
          case "deviation":
            if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
              processed += String.fromCodePoint.apply(String, status[2]);
            } else {
              processed += String.fromCodePoint(codePoint);
            }
            break;
          case "valid":
            processed += String.fromCodePoint(codePoint);
            break;
          case "disallowed_STD3_mapped":
            if (useSTD3) {
              hasError = true;
              processed += String.fromCodePoint(codePoint);
            } else {
              processed += String.fromCodePoint.apply(String, status[2]);
            }
            break;
          case "disallowed_STD3_valid":
            if (useSTD3) {
              hasError = true;
            }
            processed += String.fromCodePoint(codePoint);
            break;
        }
      }
      return {
        string: processed,
        error: hasError
      };
    }
    var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
    function validateLabel(label, processing_option) {
      if (label.substr(0, 4) === "xn--") {
        label = punycode.toUnicode(label);
        processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
      }
      var error = false;
      if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
        error = true;
      }
      var len = countSymbols(label);
      for (var i2 = 0; i2 < len; ++i2) {
        var status = findStatus(label.codePointAt(i2));
        if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
          error = true;
          break;
        }
      }
      return {
        label,
        error
      };
    }
    function processing(domain_name, useSTD3, processing_option) {
      var result = mapChars(domain_name, useSTD3, processing_option);
      result.string = normalize(result.string);
      var labels = result.string.split(".");
      for (var i2 = 0; i2 < labels.length; ++i2) {
        try {
          var validation = validateLabel(labels[i2]);
          labels[i2] = validation.label;
          result.error = result.error || validation.error;
        } catch (e2) {
          result.error = true;
        }
      }
      return {
        string: labels.join("."),
        error: result.error
      };
    }
    module.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
      var result = processing(domain_name, useSTD3, processing_option);
      var labels = result.string.split(".");
      labels = labels.map(function(l2) {
        try {
          return punycode.toASCII(l2);
        } catch (e2) {
          result.error = true;
          return l2;
        }
      });
      if (verifyDnsLength) {
        var total = labels.slice(0, labels.length - 1).join(".").length;
        if (total.length > 253 || total.length === 0) {
          result.error = true;
        }
        for (var i2 = 0; i2 < labels.length; ++i2) {
          if (labels.length > 63 || labels.length === 0) {
            result.error = true;
            break;
          }
        }
      }
      if (result.error) return null;
      return labels.join(".");
    };
    module.exports.toUnicode = function(domain_name, useSTD3) {
      var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
      return {
        domain: result.string,
        error: result.error
      };
    };
    module.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
  }
});

// ../node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({
  "../node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js"(exports, module) {
    "use strict";
    var punycode = __require("punycode");
    var tr46 = require_tr46();
    var specialSchemes = {
      ftp: 21,
      file: null,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var failure5 = Symbol("failure");
    function countSymbols(str) {
      return punycode.ucs2.decode(str).length;
    }
    function at2(input, idx) {
      const c2 = input[idx];
      return isNaN(c2) ? void 0 : String.fromCodePoint(c2);
    }
    function isASCIIDigit(c2) {
      return c2 >= 48 && c2 <= 57;
    }
    function isASCIIAlpha(c2) {
      return c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122;
    }
    function isASCIIAlphanumeric(c2) {
      return isASCIIAlpha(c2) || isASCIIDigit(c2);
    }
    function isASCIIHex(c2) {
      return isASCIIDigit(c2) || c2 >= 65 && c2 <= 70 || c2 >= 97 && c2 <= 102;
    }
    function isSingleDot(buffer) {
      return buffer === "." || buffer.toLowerCase() === "%2e";
    }
    function isDoubleDot(buffer) {
      buffer = buffer.toLowerCase();
      return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
    }
    function isWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
    }
    function isNormalizedWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
    }
    function containsForbiddenHostCodePoint(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function containsForbiddenHostCodePointExcludingPercent(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function isSpecialScheme(scheme) {
      return specialSchemes[scheme] !== void 0;
    }
    function isSpecial(url) {
      return isSpecialScheme(url.scheme);
    }
    function defaultPort(scheme) {
      return specialSchemes[scheme];
    }
    function percentEncode(c2) {
      let hex = c2.toString(16).toUpperCase();
      if (hex.length === 1) {
        hex = "0" + hex;
      }
      return "%" + hex;
    }
    function utf8PercentEncode(c2) {
      const buf = new Buffer(c2);
      let str = "";
      for (let i2 = 0; i2 < buf.length; ++i2) {
        str += percentEncode(buf[i2]);
      }
      return str;
    }
    function utf8PercentDecode(str) {
      const input = new Buffer(str);
      const output = [];
      for (let i2 = 0; i2 < input.length; ++i2) {
        if (input[i2] !== 37) {
          output.push(input[i2]);
        } else if (input[i2] === 37 && isASCIIHex(input[i2 + 1]) && isASCIIHex(input[i2 + 2])) {
          output.push(parseInt(input.slice(i2 + 1, i2 + 3).toString(), 16));
          i2 += 2;
        } else {
          output.push(input[i2]);
        }
      }
      return new Buffer(output).toString();
    }
    function isC0ControlPercentEncode(c2) {
      return c2 <= 31 || c2 > 126;
    }
    var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
    function isPathPercentEncode(c2) {
      return isC0ControlPercentEncode(c2) || extraPathPercentEncodeSet.has(c2);
    }
    var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
    function isUserinfoPercentEncode(c2) {
      return isPathPercentEncode(c2) || extraUserinfoPercentEncodeSet.has(c2);
    }
    function percentEncodeChar(c2, encodeSetPredicate) {
      const cStr = String.fromCodePoint(c2);
      if (encodeSetPredicate(c2)) {
        return utf8PercentEncode(cStr);
      }
      return cStr;
    }
    function parseIPv4Number(input) {
      let R2 = 10;
      if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R2 = 16;
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R2 = 8;
      }
      if (input === "") {
        return 0;
      }
      const regex = R2 === 10 ? /[^0-9]/ : R2 === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
      if (regex.test(input)) {
        return failure5;
      }
      return parseInt(input, R2);
    }
    function parseIPv4(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop();
        }
      }
      if (parts.length > 4) {
        return input;
      }
      const numbers = [];
      for (const part of parts) {
        if (part === "") {
          return input;
        }
        const n2 = parseIPv4Number(part);
        if (n2 === failure5) {
          return input;
        }
        numbers.push(n2);
      }
      for (let i2 = 0; i2 < numbers.length - 1; ++i2) {
        if (numbers[i2] > 255) {
          return failure5;
        }
      }
      if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        return failure5;
      }
      let ipv4 = numbers.pop();
      let counter = 0;
      for (const n2 of numbers) {
        ipv4 += n2 * Math.pow(256, 3 - counter);
        ++counter;
      }
      return ipv4;
    }
    function serializeIPv4(address) {
      let output = "";
      let n2 = address;
      for (let i2 = 1; i2 <= 4; ++i2) {
        output = String(n2 % 256) + output;
        if (i2 !== 4) {
          output = "." + output;
        }
        n2 = Math.floor(n2 / 256);
      }
      return output;
    }
    function parseIPv6(input) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0;
      let compress = null;
      let pointer = 0;
      input = punycode.ucs2.decode(input);
      if (input[pointer] === 58) {
        if (input[pointer + 1] !== 58) {
          return failure5;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) {
          return failure5;
        }
        if (input[pointer] === 58) {
          if (compress !== null) {
            return failure5;
          }
          ++pointer;
          ++pieceIndex;
          compress = pieceIndex;
          continue;
        }
        let value = 0;
        let length = 0;
        while (length < 4 && isASCIIHex(input[pointer])) {
          value = value * 16 + parseInt(at2(input, pointer), 16);
          ++pointer;
          ++length;
        }
        if (input[pointer] === 46) {
          if (length === 0) {
            return failure5;
          }
          pointer -= length;
          if (pieceIndex > 6) {
            return failure5;
          }
          let numbersSeen = 0;
          while (input[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (input[pointer] === 46 && numbersSeen < 4) {
                ++pointer;
              } else {
                return failure5;
              }
            }
            if (!isASCIIDigit(input[pointer])) {
              return failure5;
            }
            while (isASCIIDigit(input[pointer])) {
              const number = parseInt(at2(input, pointer));
              if (ipv4Piece === null) {
                ipv4Piece = number;
              } else if (ipv4Piece === 0) {
                return failure5;
              } else {
                ipv4Piece = ipv4Piece * 10 + number;
              }
              if (ipv4Piece > 255) {
                return failure5;
              }
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex;
            }
          }
          if (numbersSeen !== 4) {
            return failure5;
          }
          break;
        } else if (input[pointer] === 58) {
          ++pointer;
          if (input[pointer] === void 0) {
            return failure5;
          }
        } else if (input[pointer] !== void 0) {
          return failure5;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress === null && pieceIndex !== 8) {
        return failure5;
      }
      return address;
    }
    function serializeIPv6(address) {
      let output = "";
      const seqResult = findLongestZeroSequence(address);
      const compress = seqResult.idx;
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue;
        } else if (ignore0) {
          ignore0 = false;
        }
        if (compress === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":";
          output += separator;
          ignore0 = true;
          continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
          output += ":";
        }
      }
      return output;
    }
    function parseHost(input, isSpecialArg) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
          return failure5;
        }
        return parseIPv6(input.substring(1, input.length - 1));
      }
      if (!isSpecialArg) {
        return parseOpaqueHost(input);
      }
      const domain = utf8PercentDecode(input);
      const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
      if (asciiDomain === null) {
        return failure5;
      }
      if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure5;
      }
      const ipv4Host = parseIPv4(asciiDomain);
      if (typeof ipv4Host === "number" || ipv4Host === failure5) {
        return ipv4Host;
      }
      return asciiDomain;
    }
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePointExcludingPercent(input)) {
        return failure5;
      }
      let output = "";
      const decoded = punycode.ucs2.decode(input);
      for (let i2 = 0; i2 < decoded.length; ++i2) {
        output += percentEncodeChar(decoded[i2], isC0ControlPercentEncode);
      }
      return output;
    }
    function findLongestZeroSequence(arr) {
      let maxIdx = null;
      let maxLen = 1;
      let currStart = null;
      let currLen = 0;
      for (let i2 = 0; i2 < arr.length; ++i2) {
        if (arr[i2] !== 0) {
          if (currLen > maxLen) {
            maxIdx = currStart;
            maxLen = currLen;
          }
          currStart = null;
          currLen = 0;
        } else {
          if (currStart === null) {
            currStart = i2;
          }
          ++currLen;
        }
      }
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }
      return {
        idx: maxIdx,
        len: maxLen
      };
    }
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host);
      }
      if (host instanceof Array) {
        return "[" + serializeIPv6(host) + "]";
      }
      return host;
    }
    function trimControlChars(url) {
      return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
    }
    function trimTabAndNewline(url) {
      return url.replace(/\u0009|\u000A|\u000D/g, "");
    }
    function shortenPath(url) {
      const path2 = url.path;
      if (path2.length === 0) {
        return;
      }
      if (url.scheme === "file" && path2.length === 1 && isNormalizedWindowsDriveLetter(path2[0])) {
        return;
      }
      path2.pop();
    }
    function includesCredentials(url) {
      return url.username !== "" || url.password !== "";
    }
    function cannotHaveAUsernamePasswordPort(url) {
      return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
    }
    function isNormalizedWindowsDriveLetter(string) {
      return /^[A-Za-z]:$/.test(string);
    }
    function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
      this.pointer = 0;
      this.input = input;
      this.base = base || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null,
          cannotBeABaseURL: false
        };
        const res2 = trimControlChars(this.input);
        if (res2 !== this.input) {
          this.parseError = true;
        }
        this.input = res2;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) {
        this.parseError = true;
      }
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = punycode.ucs2.decode(this.input);
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c2 = this.input[this.pointer];
        const cStr = isNaN(c2) ? void 0 : String.fromCodePoint(c2);
        const ret = this["parse " + this.state](c2, cStr);
        if (!ret) {
          break;
        } else if (ret === failure5) {
          this.failure = true;
          break;
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c2, cStr) {
      if (isASCIIAlpha(c2)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure5;
      }
      return true;
    };
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c2, cStr) {
      if (isASCIIAlphanumeric(c2) || c2 === 43 || c2 === 45 || c2 === 46) {
        this.buffer += cStr.toLowerCase();
      } else if (c2 === 58) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
            return false;
          }
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
            return false;
          }
          if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
            return false;
          }
          if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
            return false;
          }
        }
        this.url.scheme = this.buffer;
        this.buffer = "";
        if (this.stateOverride) {
          return false;
        }
        if (this.url.scheme === "file") {
          if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
            this.parseError = true;
          }
          this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
          this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
          this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === 47) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.cannotBeABaseURL = true;
          this.url.path.push("");
          this.state = "cannot-be-a-base-URL path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure5;
      }
      return true;
    };
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c2) {
      if (this.base === null || this.base.cannotBeABaseURL && c2 !== 35) {
        return failure5;
      } else if (this.base.cannotBeABaseURL && c2 === 35) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.url.cannotBeABaseURL = true;
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c2) {
      if (c2 === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c2) {
      if (c2 === 47) {
        this.state = "authority";
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative"] = function parseRelative(c2) {
      this.url.scheme = this.base.scheme;
      if (isNaN(c2)) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c2 === 47) {
        this.state = "relative slash";
      } else if (c2 === 63) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c2 === 35) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (isSpecial(this.url) && c2 === 92) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice(0, this.base.path.length - 1);
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c2) {
      if (isSpecial(this.url) && (c2 === 47 || c2 === 92)) {
        if (c2 === 92) {
          this.parseError = true;
        }
        this.state = "special authority ignore slashes";
      } else if (c2 === 47) {
        this.state = "authority";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c2) {
      if (c2 === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c2) {
      if (c2 !== 47 && c2 !== 92) {
        this.state = "authority";
        --this.pointer;
      } else {
        this.parseError = true;
      }
      return true;
    };
    URLStateMachine.prototype["parse authority"] = function parseAuthority(c2, cStr) {
      if (c2 === 64) {
        this.parseError = true;
        if (this.atFlag) {
          this.buffer = "%40" + this.buffer;
        }
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === 58 && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints;
          } else {
            this.url.username += encodedCodePoints;
          }
        }
        this.buffer = "";
      } else if (isNaN(c2) || c2 === 47 || c2 === 63 || c2 === 35 || isSpecial(this.url) && c2 === 92) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure5;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c2, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c2 === 58 && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure5;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure5) {
          return failure5;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
        if (this.stateOverride === "hostname") {
          return false;
        }
      } else if (isNaN(c2) || c2 === 47 || c2 === 63 || c2 === 35 || isSpecial(this.url) && c2 === 92) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure5;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
          this.parseError = true;
          return false;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure5) {
          return failure5;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
          return false;
        }
      } else {
        if (c2 === 91) {
          this.arrFlag = true;
        } else if (c2 === 93) {
          this.arrFlag = false;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse port"] = function parsePort(c2, cStr) {
      if (isASCIIDigit(c2)) {
        this.buffer += cStr;
      } else if (isNaN(c2) || c2 === 47 || c2 === 63 || c2 === 35 || isSpecial(this.url) && c2 === 92 || this.stateOverride) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > Math.pow(2, 16) - 1) {
            this.parseError = true;
            return failure5;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure5;
      }
      return true;
    };
    var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([47, 92, 63, 35]);
    URLStateMachine.prototype["parse file"] = function parseFile(c2) {
      this.url.scheme = "file";
      if (c2 === 47 || c2 === 92) {
        if (c2 === 92) {
          this.parseError = true;
        }
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file") {
        if (isNaN(c2)) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
        } else if (c2 === 63) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = "";
          this.state = "query";
        } else if (c2 === 35) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
          !isWindowsDriveLetterCodePoints(c2, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
          !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            shortenPath(this.url);
          } else {
            this.parseError = true;
          }
          this.state = "path";
          --this.pointer;
        }
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c2) {
      if (c2 === 47 || c2 === 92) {
        if (c2 === 92) {
          this.parseError = true;
        }
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file") {
          if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0]);
          } else {
            this.url.host = this.base.host;
          }
        }
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file host"] = function parseFileHost(c2, cStr) {
      if (isNaN(c2) || c2 === 47 || c2 === 92 || c2 === 63 || c2 === 35) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
        } else {
          let host = parseHost(this.buffer, isSpecial(this.url));
          if (host === failure5) {
            return failure5;
          }
          if (host === "localhost") {
            host = "";
          }
          this.url.host = host;
          if (this.stateOverride) {
            return false;
          }
          this.buffer = "";
          this.state = "path start";
        }
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse path start"] = function parsePathStart(c2) {
      if (isSpecial(this.url)) {
        if (c2 === 92) {
          this.parseError = true;
        }
        this.state = "path";
        if (c2 !== 47 && c2 !== 92) {
          --this.pointer;
        }
      } else if (!this.stateOverride && c2 === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c2 === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c2 !== void 0) {
        this.state = "path";
        if (c2 !== 47) {
          --this.pointer;
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse path"] = function parsePath(c2) {
      if (isNaN(c2) || c2 === 47 || isSpecial(this.url) && c2 === 92 || !this.stateOverride && (c2 === 63 || c2 === 35)) {
        if (isSpecial(this.url) && c2 === 92) {
          this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c2 !== 47 && !(isSpecial(this.url) && c2 === 92)) {
            this.url.path.push("");
          }
        } else if (isSingleDot(this.buffer) && c2 !== 47 && !(isSpecial(this.url) && c2 === 92)) {
          this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
          if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
            if (this.url.host !== "" && this.url.host !== null) {
              this.parseError = true;
              this.url.host = "";
            }
            this.buffer = this.buffer[0] + ":";
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (this.url.scheme === "file" && (c2 === void 0 || c2 === 63 || c2 === 35)) {
          while (this.url.path.length > 1 && this.url.path[0] === "") {
            this.parseError = true;
            this.url.path.shift();
          }
        }
        if (c2 === 63) {
          this.url.query = "";
          this.state = "query";
        }
        if (c2 === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c2 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += percentEncodeChar(c2, isPathPercentEncode);
      }
      return true;
    };
    URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c2) {
      if (c2 === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (c2 === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (!isNaN(c2) && c2 !== 37) {
          this.parseError = true;
        }
        if (c2 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        if (!isNaN(c2)) {
          this.url.path[0] = this.url.path[0] + percentEncodeChar(c2, isC0ControlPercentEncode);
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse query"] = function parseQuery(c2, cStr) {
      if (isNaN(c2) || !this.stateOverride && c2 === 35) {
        if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
          this.encodingOverride = "utf-8";
        }
        const buffer = new Buffer(this.buffer);
        for (let i2 = 0; i2 < buffer.length; ++i2) {
          if (buffer[i2] < 33 || buffer[i2] > 126 || buffer[i2] === 34 || buffer[i2] === 35 || buffer[i2] === 60 || buffer[i2] === 62) {
            this.url.query += percentEncode(buffer[i2]);
          } else {
            this.url.query += String.fromCodePoint(buffer[i2]);
          }
        }
        this.buffer = "";
        if (c2 === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c2 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c2) {
      if (isNaN(c2)) {
      } else if (c2 === 0) {
        this.parseError = true;
      } else {
        if (c2 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.url.fragment += percentEncodeChar(c2, isC0ControlPercentEncode);
      }
      return true;
    };
    function serializeURL(url, excludeFragment) {
      let output = url.scheme + ":";
      if (url.host !== null) {
        output += "//";
        if (url.username !== "" || url.password !== "") {
          output += url.username;
          if (url.password !== "") {
            output += ":" + url.password;
          }
          output += "@";
        }
        output += serializeHost(url.host);
        if (url.port !== null) {
          output += ":" + url.port;
        }
      } else if (url.host === null && url.scheme === "file") {
        output += "//";
      }
      if (url.cannotBeABaseURL) {
        output += url.path[0];
      } else {
        for (const string of url.path) {
          output += "/" + string;
        }
      }
      if (url.query !== null) {
        output += "?" + url.query;
      }
      if (!excludeFragment && url.fragment !== null) {
        output += "#" + url.fragment;
      }
      return output;
    }
    function serializeOrigin(tuple) {
      let result = tuple.scheme + "://";
      result += serializeHost(tuple.host);
      if (tuple.port !== null) {
        result += ":" + tuple.port;
      }
      return result;
    }
    module.exports.serializeURL = serializeURL;
    module.exports.serializeURLOrigin = function(url) {
      switch (url.scheme) {
        case "blob":
          try {
            return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));
          } catch (e2) {
            return "null";
          }
        case "ftp":
        case "gopher":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url.scheme,
            host: url.host,
            port: url.port
          });
        case "file":
          return "file://";
        default:
          return "null";
      }
    };
    module.exports.basicURLParse = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
      if (usm.failure) {
        return "failure";
      }
      return usm.url;
    };
    module.exports.setTheUsername = function(url, username) {
      url.username = "";
      const decoded = punycode.ucs2.decode(username);
      for (let i2 = 0; i2 < decoded.length; ++i2) {
        url.username += percentEncodeChar(decoded[i2], isUserinfoPercentEncode);
      }
    };
    module.exports.setThePassword = function(url, password) {
      url.password = "";
      const decoded = punycode.ucs2.decode(password);
      for (let i2 = 0; i2 < decoded.length; ++i2) {
        url.password += percentEncodeChar(decoded[i2], isUserinfoPercentEncode);
      }
    };
    module.exports.serializeHost = serializeHost;
    module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
    module.exports.serializeInteger = function(integer) {
      return String(integer);
    };
    module.exports.parseURL = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      return module.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
    };
  }
});

// ../node_modules/node-fetch/node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({
  "../node_modules/node-fetch/node_modules/whatwg-url/lib/URL-impl.js"(exports) {
    "use strict";
    var usm = require_url_state_machine();
    exports.implementation = class URLImpl {
      constructor(constructorArgs) {
        const url = constructorArgs[0];
        const base = constructorArgs[1];
        let parsedBase = null;
        if (base !== void 0) {
          parsedBase = usm.basicURLParse(base);
          if (parsedBase === "failure") {
            throw new TypeError("Invalid base URL");
          }
        }
        const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get href() {
        return usm.serializeURL(this._url);
      }
      set href(v2) {
        const parsedURL = usm.basicURLParse(v2);
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get origin() {
        return usm.serializeURLOrigin(this._url);
      }
      get protocol() {
        return this._url.scheme + ":";
      }
      set protocol(v2) {
        usm.basicURLParse(v2 + ":", { url: this._url, stateOverride: "scheme start" });
      }
      get username() {
        return this._url.username;
      }
      set username(v2) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setTheUsername(this._url, v2);
      }
      get password() {
        return this._url.password;
      }
      set password(v2) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setThePassword(this._url, v2);
      }
      get host() {
        const url = this._url;
        if (url.host === null) {
          return "";
        }
        if (url.port === null) {
          return usm.serializeHost(url.host);
        }
        return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
      }
      set host(v2) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v2, { url: this._url, stateOverride: "host" });
      }
      get hostname() {
        if (this._url.host === null) {
          return "";
        }
        return usm.serializeHost(this._url.host);
      }
      set hostname(v2) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v2, { url: this._url, stateOverride: "hostname" });
      }
      get port() {
        if (this._url.port === null) {
          return "";
        }
        return usm.serializeInteger(this._url.port);
      }
      set port(v2) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        if (v2 === "") {
          this._url.port = null;
        } else {
          usm.basicURLParse(v2, { url: this._url, stateOverride: "port" });
        }
      }
      get pathname() {
        if (this._url.cannotBeABaseURL) {
          return this._url.path[0];
        }
        if (this._url.path.length === 0) {
          return "";
        }
        return "/" + this._url.path.join("/");
      }
      set pathname(v2) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        this._url.path = [];
        usm.basicURLParse(v2, { url: this._url, stateOverride: "path start" });
      }
      get search() {
        if (this._url.query === null || this._url.query === "") {
          return "";
        }
        return "?" + this._url.query;
      }
      set search(v2) {
        const url = this._url;
        if (v2 === "") {
          url.query = null;
          return;
        }
        const input = v2[0] === "?" ? v2.substring(1) : v2;
        url.query = "";
        usm.basicURLParse(input, { url, stateOverride: "query" });
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
          return "";
        }
        return "#" + this._url.fragment;
      }
      set hash(v2) {
        if (v2 === "") {
          this._url.fragment = null;
          return;
        }
        const input = v2[0] === "#" ? v2.substring(1) : v2;
        this._url.fragment = "";
        usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
      }
      toJSON() {
        return this.href;
      }
    };
  }
});

// ../node_modules/node-fetch/node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({
  "../node_modules/node-fetch/node_modules/whatwg-url/lib/URL.js"(exports, module) {
    "use strict";
    var conversions = require_lib();
    var utils = require_utils();
    var Impl = require_URL_impl();
    var impl = utils.implSymbol;
    function URL4(url) {
      if (!this || this[impl] || !(this instanceof URL4)) {
        throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
      }
      if (arguments.length < 1) {
        throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
      }
      const args = [];
      for (let i2 = 0; i2 < arguments.length && i2 < 2; ++i2) {
        args[i2] = arguments[i2];
      }
      args[0] = conversions["USVString"](args[0]);
      if (args[1] !== void 0) {
        args[1] = conversions["USVString"](args[1]);
      }
      module.exports.setup(this, args);
    }
    URL4.prototype.toJSON = function toJSON() {
      if (!this || !module.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      const args = [];
      for (let i2 = 0; i2 < arguments.length && i2 < 0; ++i2) {
        args[i2] = arguments[i2];
      }
      return this[impl].toJSON.apply(this[impl], args);
    };
    Object.defineProperty(URL4.prototype, "href", {
      get() {
        return this[impl].href;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].href = V2;
      },
      enumerable: true,
      configurable: true
    });
    URL4.prototype.toString = function() {
      if (!this || !module.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      return this.href;
    };
    Object.defineProperty(URL4.prototype, "origin", {
      get() {
        return this[impl].origin;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL4.prototype, "protocol", {
      get() {
        return this[impl].protocol;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].protocol = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL4.prototype, "username", {
      get() {
        return this[impl].username;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].username = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL4.prototype, "password", {
      get() {
        return this[impl].password;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].password = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL4.prototype, "host", {
      get() {
        return this[impl].host;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].host = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL4.prototype, "hostname", {
      get() {
        return this[impl].hostname;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].hostname = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL4.prototype, "port", {
      get() {
        return this[impl].port;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].port = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL4.prototype, "pathname", {
      get() {
        return this[impl].pathname;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].pathname = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL4.prototype, "search", {
      get() {
        return this[impl].search;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].search = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL4.prototype, "hash", {
      get() {
        return this[impl].hash;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].hash = V2;
      },
      enumerable: true,
      configurable: true
    });
    module.exports = {
      is(obj) {
        return !!obj && obj[impl] instanceof Impl.implementation;
      },
      create(constructorArgs, privateData) {
        let obj = Object.create(URL4.prototype);
        this.setup(obj, constructorArgs, privateData);
        return obj;
      },
      setup(obj, constructorArgs, privateData) {
        if (!privateData) privateData = {};
        privateData.wrapper = obj;
        obj[impl] = new Impl.implementation(constructorArgs, privateData);
        obj[impl][utils.wrapperSymbol] = obj;
      },
      interface: URL4,
      expose: {
        Window: { URL: URL4 },
        Worker: { URL: URL4 }
      }
    };
  }
});

// ../node_modules/node-fetch/node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS({
  "../node_modules/node-fetch/node_modules/whatwg-url/lib/public-api.js"(exports) {
    "use strict";
    exports.URL = require_URL().interface;
    exports.serializeURL = require_url_state_machine().serializeURL;
    exports.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
    exports.basicURLParse = require_url_state_machine().basicURLParse;
    exports.setTheUsername = require_url_state_machine().setTheUsername;
    exports.setThePassword = require_url_state_machine().setThePassword;
    exports.serializeHost = require_url_state_machine().serializeHost;
    exports.serializeInteger = require_url_state_machine().serializeInteger;
    exports.parseURL = require_url_state_machine().parseURL;
  }
});

// ../node_modules/node-fetch/lib/index.mjs
var lib_exports = {};
__export(lib_exports, {
  AbortError: () => AbortError,
  FetchError: () => FetchError,
  Headers: () => Headers3,
  Request: () => Request3,
  Response: () => Response3,
  default: () => lib_default
});
import Stream from "stream";
import http from "http";
import Url from "url";
import https from "https";
import zlib from "zlib";
function FetchError(message, type, systemError) {
  Error.call(this, message);
  this.message = message;
  this.type = type;
  if (systemError) {
    this.code = this.errno = systemError.code;
  }
  Error.captureStackTrace(this, this.constructor);
}
function Body(body) {
  var _this = this;
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
  let size = _ref$size === void 0 ? 0 : _ref$size;
  var _ref$timeout = _ref.timeout;
  let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
  if (body == null) {
    body = null;
  } else if (isURLSearchParams(body)) {
    body = Buffer.from(body.toString());
  } else if (isBlob(body)) ;
  else if (Buffer.isBuffer(body)) ;
  else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
    body = Buffer.from(body);
  } else if (ArrayBuffer.isView(body)) {
    body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
  } else if (body instanceof Stream) ;
  else {
    body = Buffer.from(String(body));
  }
  this[INTERNALS] = {
    body,
    disturbed: false,
    error: null
  };
  this.size = size;
  this.timeout = timeout;
  if (body instanceof Stream) {
    body.on("error", function(err) {
      const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
      _this[INTERNALS].error = error;
    });
  }
}
function consumeBody() {
  var _this4 = this;
  if (this[INTERNALS].disturbed) {
    return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
  }
  this[INTERNALS].disturbed = true;
  if (this[INTERNALS].error) {
    return Body.Promise.reject(this[INTERNALS].error);
  }
  let body = this.body;
  if (body === null) {
    return Body.Promise.resolve(Buffer.alloc(0));
  }
  if (isBlob(body)) {
    body = body.stream();
  }
  if (Buffer.isBuffer(body)) {
    return Body.Promise.resolve(body);
  }
  if (!(body instanceof Stream)) {
    return Body.Promise.resolve(Buffer.alloc(0));
  }
  let accum = [];
  let accumBytes = 0;
  let abort = false;
  return new Body.Promise(function(resolve, reject) {
    let resTimeout;
    if (_this4.timeout) {
      resTimeout = setTimeout(function() {
        abort = true;
        reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
      }, _this4.timeout);
    }
    body.on("error", function(err) {
      if (err.name === "AbortError") {
        abort = true;
        reject(err);
      } else {
        reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
      }
    });
    body.on("data", function(chunk) {
      if (abort || chunk === null) {
        return;
      }
      if (_this4.size && accumBytes + chunk.length > _this4.size) {
        abort = true;
        reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
        return;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    });
    body.on("end", function() {
      if (abort) {
        return;
      }
      clearTimeout(resTimeout);
      try {
        resolve(Buffer.concat(accum, accumBytes));
      } catch (err) {
        reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
      }
    });
  });
}
function convertBody(buffer, headers) {
  if (typeof convert !== "function") {
    throw new Error("The package `encoding` must be installed to use the textConverted() function");
  }
  const ct2 = headers.get("content-type");
  let charset = "utf-8";
  let res, str;
  if (ct2) {
    res = /charset=([^;]*)/i.exec(ct2);
  }
  str = buffer.slice(0, 1024).toString();
  if (!res && str) {
    res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
  }
  if (!res && str) {
    res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
    if (!res) {
      res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
      if (res) {
        res.pop();
      }
    }
    if (res) {
      res = /charset=(.*)/i.exec(res.pop());
    }
  }
  if (!res && str) {
    res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
  }
  if (res) {
    charset = res.pop();
    if (charset === "gb2312" || charset === "gbk") {
      charset = "gb18030";
    }
  }
  return convert(buffer, "UTF-8", charset).toString();
}
function isURLSearchParams(obj) {
  if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
    return false;
  }
  return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
}
function isBlob(obj) {
  return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
}
function clone(instance) {
  let p1, p2;
  let body = instance.body;
  if (instance.bodyUsed) {
    throw new Error("cannot clone body after it is used");
  }
  if (body instanceof Stream && typeof body.getBoundary !== "function") {
    p1 = new PassThrough();
    p2 = new PassThrough();
    body.pipe(p1);
    body.pipe(p2);
    instance[INTERNALS].body = p1;
    body = p2;
  }
  return body;
}
function extractContentType(body) {
  if (body === null) {
    return null;
  } else if (typeof body === "string") {
    return "text/plain;charset=UTF-8";
  } else if (isURLSearchParams(body)) {
    return "application/x-www-form-urlencoded;charset=UTF-8";
  } else if (isBlob(body)) {
    return body.type || null;
  } else if (Buffer.isBuffer(body)) {
    return null;
  } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
    return null;
  } else if (ArrayBuffer.isView(body)) {
    return null;
  } else if (typeof body.getBoundary === "function") {
    return `multipart/form-data;boundary=${body.getBoundary()}`;
  } else if (body instanceof Stream) {
    return null;
  } else {
    return "text/plain;charset=UTF-8";
  }
}
function getTotalBytes(instance) {
  const body = instance.body;
  if (body === null) {
    return 0;
  } else if (isBlob(body)) {
    return body.size;
  } else if (Buffer.isBuffer(body)) {
    return body.length;
  } else if (body && typeof body.getLengthSync === "function") {
    if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
    body.hasKnownLength && body.hasKnownLength()) {
      return body.getLengthSync();
    }
    return null;
  } else {
    return null;
  }
}
function writeToStream(dest, instance) {
  const body = instance.body;
  if (body === null) {
    dest.end();
  } else if (isBlob(body)) {
    body.stream().pipe(dest);
  } else if (Buffer.isBuffer(body)) {
    dest.write(body);
    dest.end();
  } else {
    body.pipe(dest);
  }
}
function validateName(name) {
  name = `${name}`;
  if (invalidTokenRegex.test(name) || name === "") {
    throw new TypeError(`${name} is not a legal HTTP header name`);
  }
}
function validateValue(value) {
  value = `${value}`;
  if (invalidHeaderCharRegex.test(value)) {
    throw new TypeError(`${value} is not a legal HTTP header value`);
  }
}
function find(map, name) {
  name = name.toLowerCase();
  for (const key in map) {
    if (key.toLowerCase() === name) {
      return key;
    }
  }
  return void 0;
}
function getHeaders(headers) {
  let kind3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
  const keys = Object.keys(headers[MAP]).sort();
  return keys.map(kind3 === "key" ? function(k2) {
    return k2.toLowerCase();
  } : kind3 === "value" ? function(k2) {
    return headers[MAP][k2].join(", ");
  } : function(k2) {
    return [k2.toLowerCase(), headers[MAP][k2].join(", ")];
  });
}
function createHeadersIterator(target, kind3) {
  const iterator = Object.create(HeadersIteratorPrototype);
  iterator[INTERNAL] = {
    target,
    kind: kind3,
    index: 0
  };
  return iterator;
}
function exportNodeCompatibleHeaders(headers) {
  const obj = Object.assign({ __proto__: null }, headers[MAP]);
  const hostHeaderKey = find(headers[MAP], "Host");
  if (hostHeaderKey !== void 0) {
    obj[hostHeaderKey] = obj[hostHeaderKey][0];
  }
  return obj;
}
function createHeadersLenient(obj) {
  const headers = new Headers3();
  for (const name of Object.keys(obj)) {
    if (invalidTokenRegex.test(name)) {
      continue;
    }
    if (Array.isArray(obj[name])) {
      for (const val of obj[name]) {
        if (invalidHeaderCharRegex.test(val)) {
          continue;
        }
        if (headers[MAP][name] === void 0) {
          headers[MAP][name] = [val];
        } else {
          headers[MAP][name].push(val);
        }
      }
    } else if (!invalidHeaderCharRegex.test(obj[name])) {
      headers[MAP][name] = [obj[name]];
    }
  }
  return headers;
}
function parseURL(urlStr) {
  if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
    urlStr = new URL2(urlStr).toString();
  }
  return parse_url(urlStr);
}
function isRequest(input) {
  return typeof input === "object" && typeof input[INTERNALS$2] === "object";
}
function isAbortSignal(signal) {
  const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
  return !!(proto && proto.constructor.name === "AbortSignal");
}
function getNodeRequestOptions(request) {
  const parsedURL = request[INTERNALS$2].parsedURL;
  const headers = new Headers3(request[INTERNALS$2].headers);
  if (!headers.has("Accept")) {
    headers.set("Accept", "*/*");
  }
  if (!parsedURL.protocol || !parsedURL.hostname) {
    throw new TypeError("Only absolute URLs are supported");
  }
  if (!/^https?:$/.test(parsedURL.protocol)) {
    throw new TypeError("Only HTTP(S) protocols are supported");
  }
  if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
    throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
  }
  let contentLengthValue = null;
  if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
    contentLengthValue = "0";
  }
  if (request.body != null) {
    const totalBytes = getTotalBytes(request);
    if (typeof totalBytes === "number") {
      contentLengthValue = String(totalBytes);
    }
  }
  if (contentLengthValue) {
    headers.set("Content-Length", contentLengthValue);
  }
  if (!headers.has("User-Agent")) {
    headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
  }
  if (request.compress && !headers.has("Accept-Encoding")) {
    headers.set("Accept-Encoding", "gzip,deflate");
  }
  let agent = request.agent;
  if (typeof agent === "function") {
    agent = agent(parsedURL);
  }
  return Object.assign({}, parsedURL, {
    method: request.method,
    headers: exportNodeCompatibleHeaders(headers),
    agent
  });
}
function AbortError(message) {
  Error.call(this, message);
  this.type = "aborted";
  this.message = message;
  Error.captureStackTrace(this, this.constructor);
}
function fetch3(url, opts) {
  if (!fetch3.Promise) {
    throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
  }
  Body.Promise = fetch3.Promise;
  return new fetch3.Promise(function(resolve, reject) {
    const request = new Request3(url, opts);
    const options = getNodeRequestOptions(request);
    const send = (options.protocol === "https:" ? https : http).request;
    const signal = request.signal;
    let response = null;
    const abort = function abort2() {
      let error = new AbortError("The user aborted a request.");
      reject(error);
      if (request.body && request.body instanceof Stream.Readable) {
        destroyStream(request.body, error);
      }
      if (!response || !response.body) return;
      response.body.emit("error", error);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = function abortAndFinalize2() {
      abort();
      finalize();
    };
    const req = send(options);
    let reqTimeout;
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    function finalize() {
      req.abort();
      if (signal) signal.removeEventListener("abort", abortAndFinalize);
      clearTimeout(reqTimeout);
    }
    if (request.timeout) {
      req.once("socket", function(socket) {
        reqTimeout = setTimeout(function() {
          reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
          finalize();
        }, request.timeout);
      });
    }
    req.on("error", function(err) {
      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
      if (response && response.body) {
        destroyStream(response.body, err);
      }
      finalize();
    });
    fixResponseChunkedTransferBadEnding(req, function(err) {
      if (signal && signal.aborted) {
        return;
      }
      if (response && response.body) {
        destroyStream(response.body, err);
      }
    });
    if (parseInt(process.version.substring(1)) < 14) {
      req.on("socket", function(s2) {
        s2.addListener("close", function(hadError) {
          const hasDataListener = s2.listenerCount("data") > 0;
          if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
            const err = new Error("Premature close");
            err.code = "ERR_STREAM_PREMATURE_CLOSE";
            response.body.emit("error", err);
          }
        });
      });
    }
    req.on("response", function(res) {
      clearTimeout(reqTimeout);
      const headers = createHeadersLenient(res.headers);
      if (fetch3.isRedirect(res.statusCode)) {
        const location = headers.get("Location");
        let locationURL = null;
        try {
          locationURL = location === null ? null : new URL$1(location, request.url).toString();
        } catch (err) {
          if (request.redirect !== "manual") {
            reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
            finalize();
            return;
          }
        }
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              try {
                headers.set("Location", locationURL);
              } catch (err) {
                reject(err);
              }
            }
            break;
          case "follow":
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOpts = {
              headers: new Headers3(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: request.body,
              signal: request.signal,
              timeout: request.timeout,
              size: request.size
            };
            if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
              for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                requestOpts.headers.delete(name);
              }
            }
            if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
              requestOpts.method = "GET";
              requestOpts.body = void 0;
              requestOpts.headers.delete("content-length");
            }
            resolve(fetch3(new Request3(locationURL, requestOpts)));
            finalize();
            return;
        }
      }
      res.once("end", function() {
        if (signal) signal.removeEventListener("abort", abortAndFinalize);
      });
      let body = res.pipe(new PassThrough$1());
      const response_options = {
        url: request.url,
        status: res.statusCode,
        statusText: res.statusMessage,
        headers,
        size: request.size,
        timeout: request.timeout,
        counter: request.counter
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
        response = new Response3(body, response_options);
        resolve(response);
        return;
      }
      const zlibOptions = {
        flush: zlib.Z_SYNC_FLUSH,
        finishFlush: zlib.Z_SYNC_FLUSH
      };
      if (codings == "gzip" || codings == "x-gzip") {
        body = body.pipe(zlib.createGunzip(zlibOptions));
        response = new Response3(body, response_options);
        resolve(response);
        return;
      }
      if (codings == "deflate" || codings == "x-deflate") {
        const raw = res.pipe(new PassThrough$1());
        raw.once("data", function(chunk) {
          if ((chunk[0] & 15) === 8) {
            body = body.pipe(zlib.createInflate());
          } else {
            body = body.pipe(zlib.createInflateRaw());
          }
          response = new Response3(body, response_options);
          resolve(response);
        });
        raw.on("end", function() {
          if (!response) {
            response = new Response3(body, response_options);
            resolve(response);
          }
        });
        return;
      }
      if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
        body = body.pipe(zlib.createBrotliDecompress());
        response = new Response3(body, response_options);
        resolve(response);
        return;
      }
      response = new Response3(body, response_options);
      resolve(response);
    });
    writeToStream(req, request);
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  let socket;
  request.on("socket", function(s2) {
    socket = s2;
  });
  request.on("response", function(response) {
    const headers = response.headers;
    if (headers["transfer-encoding"] === "chunked" && !headers["content-length"]) {
      response.once("close", function(hadError) {
        const hasDataListener = socket && socket.listenerCount("data") > 0;
        if (hasDataListener && !hadError) {
          const err = new Error("Premature close");
          err.code = "ERR_STREAM_PREMATURE_CLOSE";
          errorCallback(err);
        }
      });
    }
  });
}
function destroyStream(stream, err) {
  if (stream.destroy) {
    stream.destroy(err);
  } else {
    stream.emit("error", err);
    stream.end();
  }
}
var import_whatwg_url, Readable, BUFFER, TYPE, Blob3, convert, INTERNALS, PassThrough, invalidTokenRegex, invalidHeaderCharRegex, MAP, Headers3, INTERNAL, HeadersIteratorPrototype, INTERNALS$1, STATUS_CODES, Response3, INTERNALS$2, URL2, parse_url, format_url, streamDestructionSupported, Request3, URL$1, PassThrough$1, isDomainOrSubdomain, isSameProtocol, lib_default;
var init_lib = __esm({
  "../node_modules/node-fetch/lib/index.mjs"() {
    "use strict";
    import_whatwg_url = __toESM(require_public_api(), 1);
    Readable = Stream.Readable;
    BUFFER = Symbol("buffer");
    TYPE = Symbol("type");
    Blob3 = class _Blob {
      constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
          const a2 = blobParts;
          const length = Number(a2.length);
          for (let i2 = 0; i2 < length; i2++) {
            const element = a2[i2];
            let buffer;
            if (element instanceof Buffer) {
              buffer = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
            } else if (element instanceof ArrayBuffer) {
              buffer = Buffer.from(element);
            } else if (element instanceof _Blob) {
              buffer = element[BUFFER];
            } else {
              buffer = Buffer.from(typeof element === "string" ? element : String(element));
            }
            size += buffer.length;
            buffers.push(buffer);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options && options.type !== void 0 && String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
          this[TYPE] = type;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE];
      }
      text() {
        return Promise.resolve(this[BUFFER].toString());
      }
      arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab);
      }
      stream() {
        const readable = new Readable();
        readable._read = function() {
        };
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
      }
      toString() {
        return "[object Blob]";
      }
      slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === void 0) {
          relativeStart = 0;
        } else if (start < 0) {
          relativeStart = Math.max(size + start, 0);
        } else {
          relativeStart = Math.min(start, size);
        }
        if (end === void 0) {
          relativeEnd = size;
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0);
        } else {
          relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new _Blob([], { type: arguments[2] });
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob3.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Object.defineProperty(Blob3.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    });
    FetchError.prototype = Object.create(Error.prototype);
    FetchError.prototype.constructor = FetchError;
    FetchError.prototype.name = "FetchError";
    try {
      convert = __require("encoding").convert;
    } catch (e2) {
    }
    INTERNALS = Symbol("Body internals");
    PassThrough = Stream.PassThrough;
    Body.prototype = {
      get body() {
        return this[INTERNALS].body;
      },
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      },
      /**
       * Decode response as ArrayBuffer
       *
       * @return  Promise
       */
      arrayBuffer() {
        return consumeBody.call(this).then(function(buf) {
          return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
      },
      /**
       * Return raw response as Blob
       *
       * @return Promise
       */
      blob() {
        let ct2 = this.headers && this.headers.get("content-type") || "";
        return consumeBody.call(this).then(function(buf) {
          return Object.assign(
            // Prevent copying
            new Blob3([], {
              type: ct2.toLowerCase()
            }),
            {
              [BUFFER]: buf
            }
          );
        });
      },
      /**
       * Decode response as json
       *
       * @return  Promise
       */
      json() {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer) {
          try {
            return JSON.parse(buffer.toString());
          } catch (err) {
            return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
          }
        });
      },
      /**
       * Decode response as text
       *
       * @return  Promise
       */
      text() {
        return consumeBody.call(this).then(function(buffer) {
          return buffer.toString();
        });
      },
      /**
       * Decode response as buffer (non-spec api)
       *
       * @return  Promise
       */
      buffer() {
        return consumeBody.call(this);
      },
      /**
       * Decode response as text, while automatically detecting the encoding and
       * trying to decode to UTF-8 (non-spec api)
       *
       * @return  Promise
       */
      textConverted() {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer) {
          return convertBody(buffer, _this3.headers);
        });
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    Body.mixIn = function(proto) {
      for (const name of Object.getOwnPropertyNames(Body.prototype)) {
        if (!(name in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
          Object.defineProperty(proto, name, desc);
        }
      }
    };
    Body.Promise = global.Promise;
    invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    MAP = Symbol("map");
    Headers3 = class _Headers {
      /**
       * Headers class
       *
       * @param   Object  headers  Response headers
       * @return  Void
       */
      constructor() {
        let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        this[MAP] = /* @__PURE__ */ Object.create(null);
        if (init instanceof _Headers) {
          const rawHeaders = init.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value);
            }
          }
          return;
        }
        if (init == null) ;
        else if (typeof init === "object") {
          const method = init[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair of init) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs.push(Array.from(pair));
            }
            for (const pair of pairs) {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key of Object.keys(init)) {
              const value = init[key];
              this.append(key, value);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      /**
       * Return combined header value given name
       *
       * @param   String  name  Header name
       * @return  Mixed
       */
      get(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key === void 0) {
          return null;
        }
        return this[MAP][key].join(", ");
      }
      /**
       * Iterate over all headers
       *
       * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
       * @param   Boolean   thisArg   `this` context for callback function
       * @return  Void
       */
      forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        let pairs = getHeaders(this);
        let i2 = 0;
        while (i2 < pairs.length) {
          var _pairs$i = pairs[i2];
          const name = _pairs$i[0], value = _pairs$i[1];
          callback.call(thisArg, value, name, this);
          pairs = getHeaders(this);
          i2++;
        }
      }
      /**
       * Overwrite header values given name
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      set(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        this[MAP][key !== void 0 ? key : name] = [value];
      }
      /**
       * Append a value onto existing header
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      append(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          this[MAP][key].push(value);
        } else {
          this[MAP][name] = [value];
        }
      }
      /**
       * Check for header name existence
       *
       * @param   String   name  Header name
       * @return  Boolean
       */
      has(name) {
        name = `${name}`;
        validateName(name);
        return find(this[MAP], name) !== void 0;
      }
      /**
       * Delete all header values given name
       *
       * @param   String  name  Header name
       * @return  Void
       */
      delete(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          delete this[MAP][key];
        }
      }
      /**
       * Return raw headers (non-spec api)
       *
       * @return  Object
       */
      raw() {
        return this[MAP];
      }
      /**
       * Get an iterator on keys.
       *
       * @return  Iterator
       */
      keys() {
        return createHeadersIterator(this, "key");
      }
      /**
       * Get an iterator on values.
       *
       * @return  Iterator
       */
      values() {
        return createHeadersIterator(this, "value");
      }
      /**
       * Get an iterator on entries.
       *
       * This is the default iterator of the Headers object.
       *
       * @return  Iterator
       */
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers3.prototype.entries = Headers3.prototype[Symbol.iterator];
    Object.defineProperty(Headers3.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Headers3.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true }
    });
    INTERNAL = Symbol("internal");
    HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind3 = _INTERNAL.kind, index = _INTERNAL.index;
        const values = getHeaders(target, kind3);
        const len = values.length;
        if (index >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index = index + 1;
        return {
          value: values[index],
          done: false
        };
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    });
    INTERNALS$1 = Symbol("Response internals");
    STATUS_CODES = http.STATUS_CODES;
    Response3 = class _Response {
      constructor() {
        let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers3(opts.headers);
        if (body != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: opts.url,
          status,
          statusText: opts.statusText || STATUS_CODES[status],
          headers,
          counter: opts.counter
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      /**
       * Convenience property representing if the request ended normally
       */
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      /**
       * Clone this response
       *
       * @return  Response
       */
      clone() {
        return new _Response(clone(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected
        });
      }
    };
    Body.mixIn(Response3.prototype);
    Object.defineProperties(Response3.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    Object.defineProperty(Response3.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    });
    INTERNALS$2 = Symbol("Request internals");
    URL2 = Url.URL || import_whatwg_url.default.URL;
    parse_url = Url.parse;
    format_url = Url.format;
    streamDestructionSupported = "destroy" in Stream.Readable.prototype;
    Request3 = class _Request {
      constructor(input) {
        let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest(input)) {
          if (input && input.href) {
            parsedURL = parseURL(input.href);
          } else {
            parsedURL = parseURL(`${input}`);
          }
          input = {};
        } else {
          parsedURL = parseURL(input.url);
        }
        let method = init.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
        Body.call(this, inputBody, {
          timeout: init.timeout || input.timeout || 0,
          size: init.size || input.size || 0
        });
        const headers = new Headers3(init.headers || input.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init) signal = init.signal;
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS$2] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
        this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$2].method;
      }
      get url() {
        return format_url(this[INTERNALS$2].parsedURL);
      }
      get headers() {
        return this[INTERNALS$2].headers;
      }
      get redirect() {
        return this[INTERNALS$2].redirect;
      }
      get signal() {
        return this[INTERNALS$2].signal;
      }
      /**
       * Clone this request
       *
       * @return  Request
       */
      clone() {
        return new _Request(this);
      }
    };
    Body.mixIn(Request3.prototype);
    Object.defineProperty(Request3.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Request3.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    AbortError.prototype = Object.create(Error.prototype);
    AbortError.prototype.constructor = AbortError;
    AbortError.prototype.name = "AbortError";
    URL$1 = Url.URL || import_whatwg_url.default.URL;
    PassThrough$1 = Stream.PassThrough;
    isDomainOrSubdomain = function isDomainOrSubdomain2(destination, original) {
      const orig = new URL$1(original).hostname;
      const dest = new URL$1(destination).hostname;
      return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
    };
    isSameProtocol = function isSameProtocol2(destination, original) {
      const orig = new URL$1(original).protocol;
      const dest = new URL$1(destination).protocol;
      return orig === dest;
    };
    fetch3.isRedirect = function(code) {
      return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
    };
    fetch3.Promise = global.Promise;
    lib_default = fetch3;
  }
});

// ../node_modules/formdata-node/node_modules/web-streams-polyfill/dist/ponyfill.mjs
function t() {
}
function r(e2) {
  return "object" == typeof e2 && null !== e2 || "function" == typeof e2;
}
function n(e2, t2) {
  try {
    Object.defineProperty(e2, "name", { value: t2, configurable: true });
  } catch (e3) {
  }
}
function u(e2) {
  return new a(e2);
}
function c(e2) {
  return l(e2);
}
function d(e2) {
  return s(e2);
}
function f(e2, t2, r2) {
  return i.call(e2, t2, r2);
}
function b(e2, t2, r2) {
  f(f(e2, t2, r2), void 0, o);
}
function h(e2, t2) {
  b(e2, t2);
}
function _(e2, t2) {
  b(e2, void 0, t2);
}
function p(e2, t2, r2) {
  return f(e2, t2, r2);
}
function m(e2) {
  f(e2, void 0, o);
}
function g(e2, t2, r2) {
  if ("function" != typeof e2) throw new TypeError("Argument is not a function");
  return Function.prototype.apply.call(e2, t2, r2);
}
function w(e2, t2, r2) {
  try {
    return c(g(e2, t2, r2));
  } catch (e3) {
    return d(e3);
  }
}
function E(e2, t2) {
  e2._ownerReadableStream = t2, t2._reader = e2, "readable" === t2._state ? O(e2) : "closed" === t2._state ? function(e3) {
    O(e3), j(e3);
  }(e2) : B(e2, t2._storedError);
}
function P(e2, t2) {
  return Gt(e2._ownerReadableStream, t2);
}
function W(e2) {
  const t2 = e2._ownerReadableStream;
  "readable" === t2._state ? A(e2, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")) : function(e3, t3) {
    B(e3, t3);
  }(e2, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")), t2._readableStreamController[C](), t2._reader = void 0, e2._ownerReadableStream = void 0;
}
function k(e2) {
  return new TypeError("Cannot " + e2 + " a stream using a released reader");
}
function O(e2) {
  e2._closedPromise = u((t2, r2) => {
    e2._closedPromise_resolve = t2, e2._closedPromise_reject = r2;
  });
}
function B(e2, t2) {
  O(e2), A(e2, t2);
}
function A(e2, t2) {
  void 0 !== e2._closedPromise_reject && (m(e2._closedPromise), e2._closedPromise_reject(t2), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0);
}
function j(e2) {
  void 0 !== e2._closedPromise_resolve && (e2._closedPromise_resolve(void 0), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0);
}
function F(e2, t2) {
  if (void 0 !== e2 && ("object" != typeof (r2 = e2) && "function" != typeof r2)) throw new TypeError(`${t2} is not an object.`);
  var r2;
}
function I(e2, t2) {
  if ("function" != typeof e2) throw new TypeError(`${t2} is not a function.`);
}
function D(e2, t2) {
  if (!/* @__PURE__ */ function(e3) {
    return "object" == typeof e3 && null !== e3 || "function" == typeof e3;
  }(e2)) throw new TypeError(`${t2} is not an object.`);
}
function $(e2, t2, r2) {
  if (void 0 === e2) throw new TypeError(`Parameter ${t2} is required in '${r2}'.`);
}
function M(e2, t2, r2) {
  if (void 0 === e2) throw new TypeError(`${t2} is required in '${r2}'.`);
}
function Y(e2) {
  return Number(e2);
}
function Q(e2) {
  return 0 === e2 ? 0 : e2;
}
function N(e2, t2) {
  const r2 = Number.MAX_SAFE_INTEGER;
  let o2 = Number(e2);
  if (o2 = Q(o2), !z3(o2)) throw new TypeError(`${t2} is not a finite number`);
  if (o2 = function(e3) {
    return Q(L(e3));
  }(o2), o2 < 0 || o2 > r2) throw new TypeError(`${t2} is outside the accepted range of 0 to ${r2}, inclusive`);
  return z3(o2) && 0 !== o2 ? o2 : 0;
}
function H(e2) {
  if (!r(e2)) return false;
  if ("function" != typeof e2.getReader) return false;
  try {
    return "boolean" == typeof e2.locked;
  } catch (e3) {
    return false;
  }
}
function x(e2) {
  if (!r(e2)) return false;
  if ("function" != typeof e2.getWriter) return false;
  try {
    return "boolean" == typeof e2.locked;
  } catch (e3) {
    return false;
  }
}
function V(e2, t2) {
  if (!Vt(e2)) throw new TypeError(`${t2} is not a ReadableStream.`);
}
function U(e2, t2) {
  e2._reader._readRequests.push(t2);
}
function G(e2, t2, r2) {
  const o2 = e2._reader._readRequests.shift();
  r2 ? o2._closeSteps() : o2._chunkSteps(t2);
}
function X(e2) {
  return e2._reader._readRequests.length;
}
function J(e2) {
  const t2 = e2._reader;
  return void 0 !== t2 && !!K(t2);
}
function K(e2) {
  return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_readRequests") && e2 instanceof ReadableStreamDefaultReader);
}
function Z(e2, t2) {
  const r2 = e2._readRequests;
  e2._readRequests = new S(), r2.forEach((e3) => {
    e3._errorSteps(t2);
  });
}
function ee(e2) {
  return new TypeError(`ReadableStreamDefaultReader.prototype.${e2} can only be used on a ReadableStreamDefaultReader`);
}
function oe(e2) {
  if (!r(e2)) return false;
  if (!Object.prototype.hasOwnProperty.call(e2, "_asyncIteratorImpl")) return false;
  try {
    return e2._asyncIteratorImpl instanceof te;
  } catch (e3) {
    return false;
  }
}
function ne(e2) {
  return new TypeError(`ReadableStreamAsyncIterator.${e2} can only be used on a ReadableSteamAsyncIterator`);
}
function ie(e2, t2, r2, o2, n2) {
  new Uint8Array(e2).set(new Uint8Array(r2, o2, n2), t2);
}
function le(e2) {
  const t2 = function(e3, t3, r2) {
    if (e3.slice) return e3.slice(t3, r2);
    const o2 = r2 - t3, n2 = new ArrayBuffer(o2);
    return ie(n2, 0, e3, t3, o2), n2;
  }(e2.buffer, e2.byteOffset, e2.byteOffset + e2.byteLength);
  return new Uint8Array(t2);
}
function se(e2) {
  const t2 = e2._queue.shift();
  return e2._queueTotalSize -= t2.size, e2._queueTotalSize < 0 && (e2._queueTotalSize = 0), t2.value;
}
function ue(e2, t2, r2) {
  if ("number" != typeof (o2 = r2) || ae(o2) || o2 < 0 || r2 === 1 / 0) throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
  var o2;
  e2._queue.push({ value: t2, size: r2 }), e2._queueTotalSize += r2;
}
function ce(e2) {
  e2._queue = new S(), e2._queueTotalSize = 0;
}
function de(e2) {
  return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_controlledReadableByteStream") && e2 instanceof ReadableByteStreamController);
}
function fe(e2) {
  return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_associatedReadableByteStreamController") && e2 instanceof ReadableStreamBYOBRequest);
}
function be(e2) {
  const t2 = function(e3) {
    const t3 = e3._controlledReadableByteStream;
    if ("readable" !== t3._state) return false;
    if (e3._closeRequested) return false;
    if (!e3._started) return false;
    if (J(t3) && X(t3) > 0) return true;
    if (Le(t3) && ze(t3) > 0) return true;
    if (ke(e3) > 0) return true;
    return false;
  }(e2);
  if (!t2) return;
  if (e2._pulling) return void (e2._pullAgain = true);
  e2._pulling = true;
  b(e2._pullAlgorithm(), () => (e2._pulling = false, e2._pullAgain && (e2._pullAgain = false, be(e2)), null), (t3) => (Pe(e2, t3), null));
}
function he(e2) {
  Re(e2), e2._pendingPullIntos = new S();
}
function _e(e2, t2) {
  let r2 = false;
  "closed" === e2._state && (r2 = true);
  const o2 = pe(t2);
  "default" === t2.readerType ? G(e2, o2, r2) : function(e3, t3, r3) {
    const o3 = e3._reader._readIntoRequests.shift();
    r3 ? o3._closeSteps(t3) : o3._chunkSteps(t3);
  }(e2, o2, r2);
}
function pe(e2) {
  const t2 = e2.bytesFilled, r2 = e2.elementSize;
  return new e2.viewConstructor(e2.buffer, e2.byteOffset, t2 / r2);
}
function me(e2, t2, r2, o2) {
  e2._queue.push({ buffer: t2, byteOffset: r2, byteLength: o2 }), e2._queueTotalSize += o2;
}
function ye(e2, t2, r2, o2) {
  let n2;
  try {
    n2 = t2.slice(r2, r2 + o2);
  } catch (t3) {
    throw Pe(e2, t3), t3;
  }
  me(e2, n2, 0, o2);
}
function ge(e2, t2) {
  t2.bytesFilled > 0 && ye(e2, t2.buffer, t2.byteOffset, t2.bytesFilled), Ce(e2);
}
function we(e2, t2) {
  const r2 = t2.elementSize, o2 = t2.bytesFilled - t2.bytesFilled % r2, n2 = Math.min(e2._queueTotalSize, t2.byteLength - t2.bytesFilled), a2 = t2.bytesFilled + n2, i2 = a2 - a2 % r2;
  let l2 = n2, s2 = false;
  i2 > o2 && (l2 = i2 - t2.bytesFilled, s2 = true);
  const u2 = e2._queue;
  for (; l2 > 0; ) {
    const r3 = u2.peek(), o3 = Math.min(l2, r3.byteLength), n3 = t2.byteOffset + t2.bytesFilled;
    ie(t2.buffer, n3, r3.buffer, r3.byteOffset, o3), r3.byteLength === o3 ? u2.shift() : (r3.byteOffset += o3, r3.byteLength -= o3), e2._queueTotalSize -= o3, Se(e2, o3, t2), l2 -= o3;
  }
  return s2;
}
function Se(e2, t2, r2) {
  r2.bytesFilled += t2;
}
function ve(e2) {
  0 === e2._queueTotalSize && e2._closeRequested ? (Ee(e2), Xt(e2._controlledReadableByteStream)) : be(e2);
}
function Re(e2) {
  null !== e2._byobRequest && (e2._byobRequest._associatedReadableByteStreamController = void 0, e2._byobRequest._view = null, e2._byobRequest = null);
}
function Te(e2) {
  for (; e2._pendingPullIntos.length > 0; ) {
    if (0 === e2._queueTotalSize) return;
    const t2 = e2._pendingPullIntos.peek();
    we(e2, t2) && (Ce(e2), _e(e2._controlledReadableByteStream, t2));
  }
}
function qe(e2, t2) {
  const r2 = e2._pendingPullIntos.peek();
  Re(e2);
  "closed" === e2._controlledReadableByteStream._state ? function(e3, t3) {
    "none" === t3.readerType && Ce(e3);
    const r3 = e3._controlledReadableByteStream;
    if (Le(r3)) for (; ze(r3) > 0; ) _e(r3, Ce(e3));
  }(e2, r2) : function(e3, t3, r3) {
    if (Se(0, t3, r3), "none" === r3.readerType) return ge(e3, r3), void Te(e3);
    if (r3.bytesFilled < r3.elementSize) return;
    Ce(e3);
    const o2 = r3.bytesFilled % r3.elementSize;
    if (o2 > 0) {
      const t4 = r3.byteOffset + r3.bytesFilled;
      ye(e3, r3.buffer, t4 - o2, o2);
    }
    r3.bytesFilled -= o2, _e(e3._controlledReadableByteStream, r3), Te(e3);
  }(e2, t2, r2), be(e2);
}
function Ce(e2) {
  return e2._pendingPullIntos.shift();
}
function Ee(e2) {
  e2._pullAlgorithm = void 0, e2._cancelAlgorithm = void 0;
}
function Pe(e2, t2) {
  const r2 = e2._controlledReadableByteStream;
  "readable" === r2._state && (he(e2), ce(e2), Ee(e2), Jt(r2, t2));
}
function We(e2, t2) {
  const r2 = e2._queue.shift();
  e2._queueTotalSize -= r2.byteLength, ve(e2);
  const o2 = new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength);
  t2._chunkSteps(o2);
}
function ke(e2) {
  const t2 = e2._controlledReadableByteStream._state;
  return "errored" === t2 ? null : "closed" === t2 ? 0 : e2._strategyHWM - e2._queueTotalSize;
}
function Oe(e2, t2, r2) {
  const o2 = Object.create(ReadableByteStreamController.prototype);
  let n2, a2, i2;
  n2 = void 0 !== t2.start ? () => t2.start(o2) : () => {
  }, a2 = void 0 !== t2.pull ? () => t2.pull(o2) : () => c(void 0), i2 = void 0 !== t2.cancel ? (e3) => t2.cancel(e3) : () => c(void 0);
  const l2 = t2.autoAllocateChunkSize;
  if (0 === l2) throw new TypeError("autoAllocateChunkSize must be greater than 0");
  !function(e3, t3, r3, o3, n3, a3, i3) {
    t3._controlledReadableByteStream = e3, t3._pullAgain = false, t3._pulling = false, t3._byobRequest = null, t3._queue = t3._queueTotalSize = void 0, ce(t3), t3._closeRequested = false, t3._started = false, t3._strategyHWM = a3, t3._pullAlgorithm = o3, t3._cancelAlgorithm = n3, t3._autoAllocateChunkSize = i3, t3._pendingPullIntos = new S(), e3._readableStreamController = t3, b(c(r3()), () => (t3._started = true, be(t3), null), (e4) => (Pe(t3, e4), null));
  }(e2, o2, n2, a2, i2, r2, l2);
}
function Be(e2) {
  return new TypeError(`ReadableStreamBYOBRequest.prototype.${e2} can only be used on a ReadableStreamBYOBRequest`);
}
function Ae(e2) {
  return new TypeError(`ReadableByteStreamController.prototype.${e2} can only be used on a ReadableByteStreamController`);
}
function je(e2, t2) {
  e2._reader._readIntoRequests.push(t2);
}
function ze(e2) {
  return e2._reader._readIntoRequests.length;
}
function Le(e2) {
  const t2 = e2._reader;
  return void 0 !== t2 && !!Fe(t2);
}
function Fe(e2) {
  return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_readIntoRequests") && e2 instanceof ReadableStreamBYOBReader);
}
function Ie(e2, t2) {
  const r2 = e2._readIntoRequests;
  e2._readIntoRequests = new S(), r2.forEach((e3) => {
    e3._errorSteps(t2);
  });
}
function De(e2) {
  return new TypeError(`ReadableStreamBYOBReader.prototype.${e2} can only be used on a ReadableStreamBYOBReader`);
}
function $e(e2, t2) {
  const { highWaterMark: r2 } = e2;
  if (void 0 === r2) return t2;
  if (ae(r2) || r2 < 0) throw new RangeError("Invalid highWaterMark");
  return r2;
}
function Me(e2) {
  const { size: t2 } = e2;
  return t2 || (() => 1);
}
function Ye(e2, t2) {
  F(e2, t2);
  const r2 = null == e2 ? void 0 : e2.highWaterMark, o2 = null == e2 ? void 0 : e2.size;
  return { highWaterMark: void 0 === r2 ? void 0 : Y(r2), size: void 0 === o2 ? void 0 : Qe(o2, `${t2} has member 'size' that`) };
}
function Qe(e2, t2) {
  return I(e2, t2), (t3) => Y(e2(t3));
}
function Ne(e2, t2, r2) {
  return I(e2, r2), (r3) => w(e2, t2, [r3]);
}
function He(e2, t2, r2) {
  return I(e2, r2), () => w(e2, t2, []);
}
function xe(e2, t2, r2) {
  return I(e2, r2), (r3) => g(e2, t2, [r3]);
}
function Ve(e2, t2, r2) {
  return I(e2, r2), (r3, o2) => w(e2, t2, [r3, o2]);
}
function Ge(e2) {
  return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_writableStreamController") && e2 instanceof WritableStream);
}
function Xe(e2) {
  return void 0 !== e2._writer;
}
function Je(e2, t2) {
  var r2;
  if ("closed" === e2._state || "errored" === e2._state) return c(void 0);
  e2._writableStreamController._abortReason = t2, null === (r2 = e2._writableStreamController._abortController) || void 0 === r2 || r2.abort(t2);
  const o2 = e2._state;
  if ("closed" === o2 || "errored" === o2) return c(void 0);
  if (void 0 !== e2._pendingAbortRequest) return e2._pendingAbortRequest._promise;
  let n2 = false;
  "erroring" === o2 && (n2 = true, t2 = void 0);
  const a2 = u((r3, o3) => {
    e2._pendingAbortRequest = { _promise: void 0, _resolve: r3, _reject: o3, _reason: t2, _wasAlreadyErroring: n2 };
  });
  return e2._pendingAbortRequest._promise = a2, n2 || et(e2, t2), a2;
}
function Ke(e2) {
  const t2 = e2._state;
  if ("closed" === t2 || "errored" === t2) return d(new TypeError(`The stream (in ${t2} state) is not in the writable state and cannot be closed`));
  const r2 = u((t3, r3) => {
    const o3 = { _resolve: t3, _reject: r3 };
    e2._closeRequest = o3;
  }), o2 = e2._writer;
  var n2;
  return void 0 !== o2 && e2._backpressure && "writable" === t2 && Et(o2), ue(n2 = e2._writableStreamController, lt, 0), dt(n2), r2;
}
function Ze(e2, t2) {
  "writable" !== e2._state ? tt(e2) : et(e2, t2);
}
function et(e2, t2) {
  const r2 = e2._writableStreamController;
  e2._state = "erroring", e2._storedError = t2;
  const o2 = e2._writer;
  void 0 !== o2 && it(o2, t2), !function(e3) {
    if (void 0 === e3._inFlightWriteRequest && void 0 === e3._inFlightCloseRequest) return false;
    return true;
  }(e2) && r2._started && tt(e2);
}
function tt(e2) {
  e2._state = "errored", e2._writableStreamController[R]();
  const t2 = e2._storedError;
  if (e2._writeRequests.forEach((e3) => {
    e3._reject(t2);
  }), e2._writeRequests = new S(), void 0 === e2._pendingAbortRequest) return void ot(e2);
  const r2 = e2._pendingAbortRequest;
  if (e2._pendingAbortRequest = void 0, r2._wasAlreadyErroring) return r2._reject(t2), void ot(e2);
  b(e2._writableStreamController[v](r2._reason), () => (r2._resolve(), ot(e2), null), (t3) => (r2._reject(t3), ot(e2), null));
}
function rt(e2) {
  return void 0 !== e2._closeRequest || void 0 !== e2._inFlightCloseRequest;
}
function ot(e2) {
  void 0 !== e2._closeRequest && (e2._closeRequest._reject(e2._storedError), e2._closeRequest = void 0);
  const t2 = e2._writer;
  void 0 !== t2 && St(t2, e2._storedError);
}
function nt(e2, t2) {
  const r2 = e2._writer;
  void 0 !== r2 && t2 !== e2._backpressure && (t2 ? function(e3) {
    Rt(e3);
  }(r2) : Et(r2)), e2._backpressure = t2;
}
function at(e2) {
  return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_ownerWritableStream") && e2 instanceof WritableStreamDefaultWriter);
}
function it(e2, t2) {
  "pending" === e2._readyPromiseState ? Ct(e2, t2) : function(e3, t3) {
    Tt(e3, t3);
  }(e2, t2);
}
function st(e2) {
  return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_controlledWritableStream") && e2 instanceof WritableStreamDefaultController);
}
function ut(e2) {
  e2._writeAlgorithm = void 0, e2._closeAlgorithm = void 0, e2._abortAlgorithm = void 0, e2._strategySizeAlgorithm = void 0;
}
function ct(e2) {
  return e2._strategyHWM - e2._queueTotalSize;
}
function dt(e2) {
  const t2 = e2._controlledWritableStream;
  if (!e2._started) return;
  if (void 0 !== t2._inFlightWriteRequest) return;
  if ("erroring" === t2._state) return void tt(t2);
  if (0 === e2._queue.length) return;
  const r2 = e2._queue.peek().value;
  r2 === lt ? function(e3) {
    const t3 = e3._controlledWritableStream;
    (function(e4) {
      e4._inFlightCloseRequest = e4._closeRequest, e4._closeRequest = void 0;
    })(t3), se(e3);
    const r3 = e3._closeAlgorithm();
    ut(e3), b(r3, () => (function(e4) {
      e4._inFlightCloseRequest._resolve(void 0), e4._inFlightCloseRequest = void 0, "erroring" === e4._state && (e4._storedError = void 0, void 0 !== e4._pendingAbortRequest && (e4._pendingAbortRequest._resolve(), e4._pendingAbortRequest = void 0)), e4._state = "closed";
      const t4 = e4._writer;
      void 0 !== t4 && vt(t4);
    }(t3), null), (e4) => (function(e5, t4) {
      e5._inFlightCloseRequest._reject(t4), e5._inFlightCloseRequest = void 0, void 0 !== e5._pendingAbortRequest && (e5._pendingAbortRequest._reject(t4), e5._pendingAbortRequest = void 0), Ze(e5, t4);
    }(t3, e4), null));
  }(e2) : function(e3, t3) {
    const r3 = e3._controlledWritableStream;
    !function(e4) {
      e4._inFlightWriteRequest = e4._writeRequests.shift();
    }(r3);
    b(e3._writeAlgorithm(t3), () => {
      !function(e4) {
        e4._inFlightWriteRequest._resolve(void 0), e4._inFlightWriteRequest = void 0;
      }(r3);
      const t4 = r3._state;
      if (se(e3), !rt(r3) && "writable" === t4) {
        const t5 = bt(e3);
        nt(r3, t5);
      }
      return dt(e3), null;
    }, (t4) => ("writable" === r3._state && ut(e3), function(e4, t5) {
      e4._inFlightWriteRequest._reject(t5), e4._inFlightWriteRequest = void 0, Ze(e4, t5);
    }(r3, t4), null));
  }(e2, r2);
}
function ft(e2, t2) {
  "writable" === e2._controlledWritableStream._state && ht(e2, t2);
}
function bt(e2) {
  return ct(e2) <= 0;
}
function ht(e2, t2) {
  const r2 = e2._controlledWritableStream;
  ut(e2), et(r2, t2);
}
function _t(e2) {
  return new TypeError(`WritableStream.prototype.${e2} can only be used on a WritableStream`);
}
function pt(e2) {
  return new TypeError(`WritableStreamDefaultController.prototype.${e2} can only be used on a WritableStreamDefaultController`);
}
function mt(e2) {
  return new TypeError(`WritableStreamDefaultWriter.prototype.${e2} can only be used on a WritableStreamDefaultWriter`);
}
function yt(e2) {
  return new TypeError("Cannot " + e2 + " a stream using a released writer");
}
function gt(e2) {
  e2._closedPromise = u((t2, r2) => {
    e2._closedPromise_resolve = t2, e2._closedPromise_reject = r2, e2._closedPromiseState = "pending";
  });
}
function wt(e2, t2) {
  gt(e2), St(e2, t2);
}
function St(e2, t2) {
  void 0 !== e2._closedPromise_reject && (m(e2._closedPromise), e2._closedPromise_reject(t2), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0, e2._closedPromiseState = "rejected");
}
function vt(e2) {
  void 0 !== e2._closedPromise_resolve && (e2._closedPromise_resolve(void 0), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0, e2._closedPromiseState = "resolved");
}
function Rt(e2) {
  e2._readyPromise = u((t2, r2) => {
    e2._readyPromise_resolve = t2, e2._readyPromise_reject = r2;
  }), e2._readyPromiseState = "pending";
}
function Tt(e2, t2) {
  Rt(e2), Ct(e2, t2);
}
function qt(e2) {
  Rt(e2), Et(e2);
}
function Ct(e2, t2) {
  void 0 !== e2._readyPromise_reject && (m(e2._readyPromise), e2._readyPromise_reject(t2), e2._readyPromise_resolve = void 0, e2._readyPromise_reject = void 0, e2._readyPromiseState = "rejected");
}
function Et(e2) {
  void 0 !== e2._readyPromise_resolve && (e2._readyPromise_resolve(void 0), e2._readyPromise_resolve = void 0, e2._readyPromise_reject = void 0, e2._readyPromiseState = "fulfilled");
}
function kt(e2, t2, r2, o2, n2, a2) {
  const i2 = e2.getReader(), l2 = t2.getWriter();
  Vt(e2) && (e2._disturbed = true);
  let s2, _2, g2, w2 = false, S2 = false, v2 = "readable", R2 = "writable", T2 = false, q2 = false;
  const C2 = u((e3) => {
    g2 = e3;
  });
  let E2 = Promise.resolve(void 0);
  return u((P2, W2) => {
    let k2;
    function O2() {
      if (w2) return;
      const e3 = u((e4, t3) => {
        !function r3(o3) {
          o3 ? e4() : f(function() {
            if (w2) return c(true);
            return f(l2.ready, () => f(i2.read(), (e5) => !!e5.done || (E2 = l2.write(e5.value), m(E2), false)));
          }(), r3, t3);
        }(false);
      });
      m(e3);
    }
    function B2() {
      return v2 = "closed", r2 ? L2() : z4(() => (Ge(t2) && (T2 = rt(t2), R2 = t2._state), T2 || "closed" === R2 ? c(void 0) : "erroring" === R2 || "errored" === R2 ? d(_2) : (T2 = true, l2.close())), false, void 0), null;
    }
    function A2(e3) {
      return w2 || (v2 = "errored", s2 = e3, o2 ? L2(true, e3) : z4(() => l2.abort(e3), true, e3)), null;
    }
    function j2(e3) {
      return S2 || (R2 = "errored", _2 = e3, n2 ? L2(true, e3) : z4(() => i2.cancel(e3), true, e3)), null;
    }
    if (void 0 !== a2 && (k2 = () => {
      const e3 = void 0 !== a2.reason ? a2.reason : new Wt("Aborted", "AbortError"), t3 = [];
      o2 || t3.push(() => "writable" === R2 ? l2.abort(e3) : c(void 0)), n2 || t3.push(() => "readable" === v2 ? i2.cancel(e3) : c(void 0)), z4(() => Promise.all(t3.map((e4) => e4())), true, e3);
    }, a2.aborted ? k2() : a2.addEventListener("abort", k2)), Vt(e2) && (v2 = e2._state, s2 = e2._storedError), Ge(t2) && (R2 = t2._state, _2 = t2._storedError, T2 = rt(t2)), Vt(e2) && Ge(t2) && (q2 = true, g2()), "errored" === v2) A2(s2);
    else if ("erroring" === R2 || "errored" === R2) j2(_2);
    else if ("closed" === v2) B2();
    else if (T2 || "closed" === R2) {
      const e3 = new TypeError("the destination writable stream closed before all data could be piped to it");
      n2 ? L2(true, e3) : z4(() => i2.cancel(e3), true, e3);
    }
    function z4(e3, t3, r3) {
      function o3() {
        return "writable" !== R2 || T2 ? n3() : h(function() {
          let e4;
          return c(function t4() {
            if (e4 !== E2) return e4 = E2, p(E2, t4, t4);
          }());
        }(), n3), null;
      }
      function n3() {
        return e3 ? b(e3(), () => F2(t3, r3), (e4) => F2(true, e4)) : F2(t3, r3), null;
      }
      w2 || (w2 = true, q2 ? o3() : h(C2, o3));
    }
    function L2(e3, t3) {
      z4(void 0, e3, t3);
    }
    function F2(e3, t3) {
      return S2 = true, l2.releaseLock(), i2.releaseLock(), void 0 !== a2 && a2.removeEventListener("abort", k2), e3 ? W2(t3) : P2(void 0), null;
    }
    w2 || (b(i2.closed, B2, A2), b(l2.closed, function() {
      return S2 || (R2 = "closed"), null;
    }, j2)), q2 ? O2() : y(() => {
      q2 = true, g2(), O2();
    });
  });
}
function Ot(e2, t2) {
  return function(e3) {
    try {
      return e3.getReader({ mode: "byob" }).releaseLock(), true;
    } catch (e4) {
      return false;
    }
  }(e2) ? function(e3) {
    let t3, r2, o2, n2, a2, i2 = e3.getReader(), l2 = false, s2 = false, d2 = false, f2 = false, h2 = false, p2 = false;
    const m2 = u((e4) => {
      a2 = e4;
    });
    function y2(e4) {
      _(e4.closed, (t4) => (e4 !== i2 || (o2.error(t4), n2.error(t4), h2 && p2 || a2(void 0)), null));
    }
    function g2() {
      l2 && (i2.releaseLock(), i2 = e3.getReader(), y2(i2), l2 = false), b(i2.read(), (e4) => {
        var t4, r3;
        if (d2 = false, f2 = false, e4.done) return h2 || o2.close(), p2 || n2.close(), null === (t4 = o2.byobRequest) || void 0 === t4 || t4.respond(0), null === (r3 = n2.byobRequest) || void 0 === r3 || r3.respond(0), h2 && p2 || a2(void 0), null;
        const l3 = e4.value, u2 = l3;
        let c2 = l3;
        if (!h2 && !p2) try {
          c2 = le(l3);
        } catch (e5) {
          return o2.error(e5), n2.error(e5), a2(i2.cancel(e5)), null;
        }
        return h2 || o2.enqueue(u2), p2 || n2.enqueue(c2), s2 = false, d2 ? S2() : f2 && v2(), null;
      }, () => (s2 = false, null));
    }
    function w2(t4, r3) {
      l2 || (i2.releaseLock(), i2 = e3.getReader({ mode: "byob" }), y2(i2), l2 = true);
      const u2 = r3 ? n2 : o2, c2 = r3 ? o2 : n2;
      b(i2.read(t4), (e4) => {
        var t5;
        d2 = false, f2 = false;
        const o3 = r3 ? p2 : h2, n3 = r3 ? h2 : p2;
        if (e4.done) {
          o3 || u2.close(), n3 || c2.close();
          const r4 = e4.value;
          return void 0 !== r4 && (o3 || u2.byobRequest.respondWithNewView(r4), n3 || null === (t5 = c2.byobRequest) || void 0 === t5 || t5.respond(0)), o3 && n3 || a2(void 0), null;
        }
        const l3 = e4.value;
        if (n3) o3 || u2.byobRequest.respondWithNewView(l3);
        else {
          let e5;
          try {
            e5 = le(l3);
          } catch (e6) {
            return u2.error(e6), c2.error(e6), a2(i2.cancel(e6)), null;
          }
          o3 || u2.byobRequest.respondWithNewView(l3), c2.enqueue(e5);
        }
        return s2 = false, d2 ? S2() : f2 && v2(), null;
      }, () => (s2 = false, null));
    }
    function S2() {
      if (s2) return d2 = true, c(void 0);
      s2 = true;
      const e4 = o2.byobRequest;
      return null === e4 ? g2() : w2(e4.view, false), c(void 0);
    }
    function v2() {
      if (s2) return f2 = true, c(void 0);
      s2 = true;
      const e4 = n2.byobRequest;
      return null === e4 ? g2() : w2(e4.view, true), c(void 0);
    }
    function R2(e4) {
      if (h2 = true, t3 = e4, p2) {
        const e5 = [t3, r2], o3 = i2.cancel(e5);
        a2(o3);
      }
      return m2;
    }
    function T2(e4) {
      if (p2 = true, r2 = e4, h2) {
        const e5 = [t3, r2], o3 = i2.cancel(e5);
        a2(o3);
      }
      return m2;
    }
    const q2 = new ReadableStream3({ type: "bytes", start(e4) {
      o2 = e4;
    }, pull: S2, cancel: R2 }), C2 = new ReadableStream3({ type: "bytes", start(e4) {
      n2 = e4;
    }, pull: v2, cancel: T2 });
    return y2(i2), [q2, C2];
  }(e2) : function(e3, t3) {
    const r2 = e3.getReader();
    let o2, n2, a2, i2, l2, s2 = false, d2 = false, f2 = false, h2 = false;
    const p2 = u((e4) => {
      l2 = e4;
    });
    function m2() {
      return s2 ? (d2 = true, c(void 0)) : (s2 = true, b(r2.read(), (e4) => {
        if (d2 = false, e4.done) return f2 || a2.close(), h2 || i2.close(), f2 && h2 || l2(void 0), null;
        const t4 = e4.value, r3 = t4, o3 = t4;
        return f2 || a2.enqueue(r3), h2 || i2.enqueue(o3), s2 = false, d2 && m2(), null;
      }, () => (s2 = false, null)), c(void 0));
    }
    function y2(e4) {
      if (f2 = true, o2 = e4, h2) {
        const e5 = [o2, n2], t4 = r2.cancel(e5);
        l2(t4);
      }
      return p2;
    }
    function g2(e4) {
      if (h2 = true, n2 = e4, f2) {
        const e5 = [o2, n2], t4 = r2.cancel(e5);
        l2(t4);
      }
      return p2;
    }
    const w2 = new ReadableStream3({ start(e4) {
      a2 = e4;
    }, pull: m2, cancel: y2 }), S2 = new ReadableStream3({ start(e4) {
      i2 = e4;
    }, pull: m2, cancel: g2 });
    return _(r2.closed, (e4) => (a2.error(e4), i2.error(e4), f2 && h2 || l2(void 0), null)), [w2, S2];
  }(e2);
}
function Bt(e2) {
  return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_controlledReadableStream") && e2 instanceof ReadableStreamDefaultController);
}
function At(e2) {
  const t2 = function(e3) {
    const t3 = e3._controlledReadableStream;
    if (!Ft(e3)) return false;
    if (!e3._started) return false;
    if (Ut(t3) && X(t3) > 0) return true;
    if (Lt(e3) > 0) return true;
    return false;
  }(e2);
  if (!t2) return;
  if (e2._pulling) return void (e2._pullAgain = true);
  e2._pulling = true;
  b(e2._pullAlgorithm(), () => (e2._pulling = false, e2._pullAgain && (e2._pullAgain = false, At(e2)), null), (t3) => (zt(e2, t3), null));
}
function jt(e2) {
  e2._pullAlgorithm = void 0, e2._cancelAlgorithm = void 0, e2._strategySizeAlgorithm = void 0;
}
function zt(e2, t2) {
  const r2 = e2._controlledReadableStream;
  "readable" === r2._state && (ce(e2), jt(e2), Jt(r2, t2));
}
function Lt(e2) {
  const t2 = e2._controlledReadableStream._state;
  return "errored" === t2 ? null : "closed" === t2 ? 0 : e2._strategyHWM - e2._queueTotalSize;
}
function Ft(e2) {
  return !e2._closeRequested && "readable" === e2._controlledReadableStream._state;
}
function It(e2, t2, r2, o2) {
  const n2 = Object.create(ReadableStreamDefaultController.prototype);
  let a2, i2, l2;
  a2 = void 0 !== t2.start ? () => t2.start(n2) : () => {
  }, i2 = void 0 !== t2.pull ? () => t2.pull(n2) : () => c(void 0), l2 = void 0 !== t2.cancel ? (e3) => t2.cancel(e3) : () => c(void 0), function(e3, t3, r3, o3, n3, a3, i3) {
    t3._controlledReadableStream = e3, t3._queue = void 0, t3._queueTotalSize = void 0, ce(t3), t3._started = false, t3._closeRequested = false, t3._pullAgain = false, t3._pulling = false, t3._strategySizeAlgorithm = i3, t3._strategyHWM = a3, t3._pullAlgorithm = o3, t3._cancelAlgorithm = n3, e3._readableStreamController = t3, b(c(r3()), () => (t3._started = true, At(t3), null), (e4) => (zt(t3, e4), null));
  }(e2, n2, a2, i2, l2, r2, o2);
}
function Dt(e2) {
  return new TypeError(`ReadableStreamDefaultController.prototype.${e2} can only be used on a ReadableStreamDefaultController`);
}
function $t(e2, t2, r2) {
  return I(e2, r2), (r3) => w(e2, t2, [r3]);
}
function Mt(e2, t2, r2) {
  return I(e2, r2), (r3) => w(e2, t2, [r3]);
}
function Yt(e2, t2, r2) {
  return I(e2, r2), (r3) => g(e2, t2, [r3]);
}
function Qt(e2, t2) {
  if ("bytes" !== (e2 = `${e2}`)) throw new TypeError(`${t2} '${e2}' is not a valid enumeration value for ReadableStreamType`);
  return e2;
}
function Nt(e2, t2) {
  if ("byob" !== (e2 = `${e2}`)) throw new TypeError(`${t2} '${e2}' is not a valid enumeration value for ReadableStreamReaderMode`);
  return e2;
}
function Ht(e2, t2) {
  F(e2, t2);
  const r2 = null == e2 ? void 0 : e2.preventAbort, o2 = null == e2 ? void 0 : e2.preventCancel, n2 = null == e2 ? void 0 : e2.preventClose, a2 = null == e2 ? void 0 : e2.signal;
  return void 0 !== a2 && function(e3, t3) {
    if (!function(e4) {
      if ("object" != typeof e4 || null === e4) return false;
      try {
        return "boolean" == typeof e4.aborted;
      } catch (e5) {
        return false;
      }
    }(e3)) throw new TypeError(`${t3} is not an AbortSignal.`);
  }(a2, `${t2} has member 'signal' that`), { preventAbort: Boolean(r2), preventCancel: Boolean(o2), preventClose: Boolean(n2), signal: a2 };
}
function xt(e2, t2) {
  F(e2, t2);
  const r2 = null == e2 ? void 0 : e2.readable;
  M(r2, "readable", "ReadableWritablePair"), function(e3, t3) {
    if (!H(e3)) throw new TypeError(`${t3} is not a ReadableStream.`);
  }(r2, `${t2} has member 'readable' that`);
  const o2 = null == e2 ? void 0 : e2.writable;
  return M(o2, "writable", "ReadableWritablePair"), function(e3, t3) {
    if (!x(e3)) throw new TypeError(`${t3} is not a WritableStream.`);
  }(o2, `${t2} has member 'writable' that`), { readable: r2, writable: o2 };
}
function Vt(e2) {
  return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_readableStreamController") && e2 instanceof ReadableStream3);
}
function Ut(e2) {
  return void 0 !== e2._reader;
}
function Gt(e2, r2) {
  if (e2._disturbed = true, "closed" === e2._state) return c(void 0);
  if ("errored" === e2._state) return d(e2._storedError);
  Xt(e2);
  const o2 = e2._reader;
  if (void 0 !== o2 && Fe(o2)) {
    const e3 = o2._readIntoRequests;
    o2._readIntoRequests = new S(), e3.forEach((e4) => {
      e4._closeSteps(void 0);
    });
  }
  return p(e2._readableStreamController[T](r2), t);
}
function Xt(e2) {
  e2._state = "closed";
  const t2 = e2._reader;
  if (void 0 !== t2 && (j(t2), K(t2))) {
    const e3 = t2._readRequests;
    t2._readRequests = new S(), e3.forEach((e4) => {
      e4._closeSteps();
    });
  }
}
function Jt(e2, t2) {
  e2._state = "errored", e2._storedError = t2;
  const r2 = e2._reader;
  void 0 !== r2 && (A(r2, t2), K(r2) ? Z(r2, t2) : Ie(r2, t2));
}
function Kt(e2) {
  return new TypeError(`ReadableStream.prototype.${e2} can only be used on a ReadableStream`);
}
function Zt(e2, t2) {
  F(e2, t2);
  const r2 = null == e2 ? void 0 : e2.highWaterMark;
  return M(r2, "highWaterMark", "QueuingStrategyInit"), { highWaterMark: Y(r2) };
}
function tr(e2) {
  return new TypeError(`ByteLengthQueuingStrategy.prototype.${e2} can only be used on a ByteLengthQueuingStrategy`);
}
function rr(e2) {
  return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_byteLengthQueuingStrategyHighWaterMark") && e2 instanceof ByteLengthQueuingStrategy);
}
function nr(e2) {
  return new TypeError(`CountQueuingStrategy.prototype.${e2} can only be used on a CountQueuingStrategy`);
}
function ar(e2) {
  return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_countQueuingStrategyHighWaterMark") && e2 instanceof CountQueuingStrategy);
}
function ir(e2, t2, r2) {
  return I(e2, r2), (r3) => w(e2, t2, [r3]);
}
function lr(e2, t2, r2) {
  return I(e2, r2), (r3) => g(e2, t2, [r3]);
}
function sr(e2, t2, r2) {
  return I(e2, r2), (r3, o2) => w(e2, t2, [r3, o2]);
}
function ur(e2) {
  return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_transformStreamController") && e2 instanceof TransformStream);
}
function cr(e2, t2) {
  Sr(e2, t2), dr(e2, t2);
}
function dr(e2, t2) {
  hr(e2._transformStreamController), function(e3, t3) {
    e3._writableController.error(t3);
    "writable" === e3._writableState && Tr(e3, t3);
  }(e2, t2), e2._backpressure && fr(e2, false);
}
function fr(e2, t2) {
  void 0 !== e2._backpressureChangePromise && e2._backpressureChangePromise_resolve(), e2._backpressureChangePromise = u((t3) => {
    e2._backpressureChangePromise_resolve = t3;
  }), e2._backpressure = t2;
}
function br(e2) {
  return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_controlledTransformStream") && e2 instanceof TransformStreamDefaultController);
}
function hr(e2) {
  e2._transformAlgorithm = void 0, e2._flushAlgorithm = void 0;
}
function _r(e2, t2) {
  const r2 = e2._controlledTransformStream;
  if (!gr(r2)) throw new TypeError("Readable side is not in a state that permits enqueue");
  try {
    !function(e3, t3) {
      e3._readablePulling = false;
      try {
        e3._readableController.enqueue(t3);
      } catch (t4) {
        throw Sr(e3, t4), t4;
      }
    }(r2, t2);
  } catch (e3) {
    throw dr(r2, e3), r2._readableStoredError;
  }
  const o2 = function(e3) {
    return !function(e4) {
      if (!gr(e4)) return false;
      if (e4._readablePulling) return true;
      if (vr(e4) > 0) return true;
      return false;
    }(e3);
  }(r2);
  o2 !== r2._backpressure && fr(r2, true);
}
function pr(e2, t2) {
  return p(e2._transformAlgorithm(t2), void 0, (t3) => {
    throw cr(e2._controlledTransformStream, t3), t3;
  });
}
function mr(e2) {
  return new TypeError(`TransformStreamDefaultController.prototype.${e2} can only be used on a TransformStreamDefaultController`);
}
function yr(e2) {
  return new TypeError(`TransformStream.prototype.${e2} can only be used on a TransformStream`);
}
function gr(e2) {
  return !e2._readableCloseRequested && "readable" === e2._readableState;
}
function wr(e2) {
  e2._readableState = "closed", e2._readableCloseRequested = true, e2._readableController.close();
}
function Sr(e2, t2) {
  "readable" === e2._readableState && (e2._readableState = "errored", e2._readableStoredError = t2), e2._readableController.error(t2);
}
function vr(e2) {
  return e2._readableController.desiredSize;
}
function Rr(e2, t2) {
  "writable" !== e2._writableState ? qr(e2) : Tr(e2, t2);
}
function Tr(e2, t2) {
  e2._writableState = "erroring", e2._writableStoredError = t2, !function(e3) {
    return e3._writableHasInFlightOperation;
  }(e2) && e2._writableStarted && qr(e2);
}
function qr(e2) {
  e2._writableState = "errored";
}
function Cr(e2) {
  "erroring" === e2._writableState && qr(e2);
}
var e, o, a, i, l, s, y, S, v, R, T, q, C, z3, L, ReadableStreamDefaultReader, te, re, ae, ReadableStreamBYOBRequest, ReadableByteStreamController, ReadableStreamBYOBReader, Ue, WritableStream, WritableStreamDefaultWriter, lt, WritableStreamDefaultController, Pt, Wt, ReadableStreamDefaultController, ReadableStream3, er, ByteLengthQueuingStrategy, or, CountQueuingStrategy, TransformStream, TransformStreamDefaultController;
var init_ponyfill = __esm({
  "../node_modules/formdata-node/node_modules/web-streams-polyfill/dist/ponyfill.mjs"() {
    "use strict";
    e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? Symbol : (e2) => `Symbol(${e2})`;
    o = t;
    a = Promise;
    i = Promise.prototype.then;
    l = Promise.resolve.bind(a);
    s = Promise.reject.bind(a);
    y = (e2) => {
      if ("function" == typeof queueMicrotask) y = queueMicrotask;
      else {
        const e3 = c(void 0);
        y = (t2) => f(e3, t2);
      }
      return y(e2);
    };
    S = class {
      constructor() {
        this._cursor = 0, this._size = 0, this._front = { _elements: [], _next: void 0 }, this._back = this._front, this._cursor = 0, this._size = 0;
      }
      get length() {
        return this._size;
      }
      push(e2) {
        const t2 = this._back;
        let r2 = t2;
        16383 === t2._elements.length && (r2 = { _elements: [], _next: void 0 }), t2._elements.push(e2), r2 !== t2 && (this._back = r2, t2._next = r2), ++this._size;
      }
      shift() {
        const e2 = this._front;
        let t2 = e2;
        const r2 = this._cursor;
        let o2 = r2 + 1;
        const n2 = e2._elements, a2 = n2[r2];
        return 16384 === o2 && (t2 = e2._next, o2 = 0), --this._size, this._cursor = o2, e2 !== t2 && (this._front = t2), n2[r2] = void 0, a2;
      }
      forEach(e2) {
        let t2 = this._cursor, r2 = this._front, o2 = r2._elements;
        for (; !(t2 === o2.length && void 0 === r2._next || t2 === o2.length && (r2 = r2._next, o2 = r2._elements, t2 = 0, 0 === o2.length)); ) e2(o2[t2]), ++t2;
      }
      peek() {
        const e2 = this._front, t2 = this._cursor;
        return e2._elements[t2];
      }
    };
    v = e("[[AbortSteps]]");
    R = e("[[ErrorSteps]]");
    T = e("[[CancelSteps]]");
    q = e("[[PullSteps]]");
    C = e("[[ReleaseSteps]]");
    z3 = Number.isFinite || function(e2) {
      return "number" == typeof e2 && isFinite(e2);
    };
    L = Math.trunc || function(e2) {
      return e2 < 0 ? Math.ceil(e2) : Math.floor(e2);
    };
    ReadableStreamDefaultReader = class {
      constructor(e2) {
        if ($(e2, 1, "ReadableStreamDefaultReader"), V(e2, "First parameter"), Ut(e2)) throw new TypeError("This stream has already been locked for exclusive reading by another reader");
        E(this, e2), this._readRequests = new S();
      }
      get closed() {
        return K(this) ? this._closedPromise : d(ee("closed"));
      }
      cancel(e2) {
        return K(this) ? void 0 === this._ownerReadableStream ? d(k("cancel")) : P(this, e2) : d(ee("cancel"));
      }
      read() {
        if (!K(this)) return d(ee("read"));
        if (void 0 === this._ownerReadableStream) return d(k("read from"));
        let e2, t2;
        const r2 = u((r3, o2) => {
          e2 = r3, t2 = o2;
        });
        return function(e3, t3) {
          const r3 = e3._ownerReadableStream;
          r3._disturbed = true, "closed" === r3._state ? t3._closeSteps() : "errored" === r3._state ? t3._errorSteps(r3._storedError) : r3._readableStreamController[q](t3);
        }(this, { _chunkSteps: (t3) => e2({ value: t3, done: false }), _closeSteps: () => e2({ value: void 0, done: true }), _errorSteps: (e3) => t2(e3) }), r2;
      }
      releaseLock() {
        if (!K(this)) throw ee("releaseLock");
        void 0 !== this._ownerReadableStream && function(e2) {
          W(e2);
          const t2 = new TypeError("Reader was released");
          Z(e2, t2);
        }(this);
      }
    };
    Object.defineProperties(ReadableStreamDefaultReader.prototype, { cancel: { enumerable: true }, read: { enumerable: true }, releaseLock: { enumerable: true }, closed: { enumerable: true } }), n(ReadableStreamDefaultReader.prototype.cancel, "cancel"), n(ReadableStreamDefaultReader.prototype.read, "read"), n(ReadableStreamDefaultReader.prototype.releaseLock, "releaseLock"), "symbol" == typeof e.toStringTag && Object.defineProperty(ReadableStreamDefaultReader.prototype, e.toStringTag, { value: "ReadableStreamDefaultReader", configurable: true });
    te = class {
      constructor(e2, t2) {
        this._ongoingPromise = void 0, this._isFinished = false, this._reader = e2, this._preventCancel = t2;
      }
      next() {
        const e2 = () => this._nextSteps();
        return this._ongoingPromise = this._ongoingPromise ? p(this._ongoingPromise, e2, e2) : e2(), this._ongoingPromise;
      }
      return(e2) {
        const t2 = () => this._returnSteps(e2);
        return this._ongoingPromise ? p(this._ongoingPromise, t2, t2) : t2();
      }
      _nextSteps() {
        if (this._isFinished) return Promise.resolve({ value: void 0, done: true });
        const e2 = this._reader;
        return void 0 === e2 ? d(k("iterate")) : f(e2.read(), (e3) => {
          var t2;
          return this._ongoingPromise = void 0, e3.done && (this._isFinished = true, null === (t2 = this._reader) || void 0 === t2 || t2.releaseLock(), this._reader = void 0), e3;
        }, (e3) => {
          var t2;
          throw this._ongoingPromise = void 0, this._isFinished = true, null === (t2 = this._reader) || void 0 === t2 || t2.releaseLock(), this._reader = void 0, e3;
        });
      }
      _returnSteps(e2) {
        if (this._isFinished) return Promise.resolve({ value: e2, done: true });
        this._isFinished = true;
        const t2 = this._reader;
        if (void 0 === t2) return d(k("finish iterating"));
        if (this._reader = void 0, !this._preventCancel) {
          const r2 = t2.cancel(e2);
          return t2.releaseLock(), p(r2, () => ({ value: e2, done: true }));
        }
        return t2.releaseLock(), c({ value: e2, done: true });
      }
    };
    re = { next() {
      return oe(this) ? this._asyncIteratorImpl.next() : d(ne("next"));
    }, return(e2) {
      return oe(this) ? this._asyncIteratorImpl.return(e2) : d(ne("return"));
    } };
    "symbol" == typeof e.asyncIterator && Object.defineProperty(re, e.asyncIterator, { value() {
      return this;
    }, writable: true, configurable: true });
    ae = Number.isNaN || function(e2) {
      return e2 != e2;
    };
    ReadableStreamBYOBRequest = class {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get view() {
        if (!fe(this)) throw Be("view");
        return this._view;
      }
      respond(e2) {
        if (!fe(this)) throw Be("respond");
        if ($(e2, 1, "respond"), e2 = N(e2, "First parameter"), void 0 === this._associatedReadableByteStreamController) throw new TypeError("This BYOB request has been invalidated");
        this._view.buffer, function(e3, t2) {
          const r2 = e3._pendingPullIntos.peek();
          if ("closed" === e3._controlledReadableByteStream._state) {
            if (0 !== t2) throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
          } else {
            if (0 === t2) throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
            if (r2.bytesFilled + t2 > r2.byteLength) throw new RangeError("bytesWritten out of range");
          }
          r2.buffer = r2.buffer, qe(e3, t2);
        }(this._associatedReadableByteStreamController, e2);
      }
      respondWithNewView(e2) {
        if (!fe(this)) throw Be("respondWithNewView");
        if ($(e2, 1, "respondWithNewView"), !ArrayBuffer.isView(e2)) throw new TypeError("You can only respond with array buffer views");
        if (void 0 === this._associatedReadableByteStreamController) throw new TypeError("This BYOB request has been invalidated");
        e2.buffer, function(e3, t2) {
          const r2 = e3._pendingPullIntos.peek();
          if ("closed" === e3._controlledReadableByteStream._state) {
            if (0 !== t2.byteLength) throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
          } else if (0 === t2.byteLength) throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
          if (r2.byteOffset + r2.bytesFilled !== t2.byteOffset) throw new RangeError("The region specified by view does not match byobRequest");
          if (r2.bufferByteLength !== t2.buffer.byteLength) throw new RangeError("The buffer of view has different capacity than byobRequest");
          if (r2.bytesFilled + t2.byteLength > r2.byteLength) throw new RangeError("The region specified by view is larger than byobRequest");
          const o2 = t2.byteLength;
          r2.buffer = t2.buffer, qe(e3, o2);
        }(this._associatedReadableByteStreamController, e2);
      }
    };
    Object.defineProperties(ReadableStreamBYOBRequest.prototype, { respond: { enumerable: true }, respondWithNewView: { enumerable: true }, view: { enumerable: true } }), n(ReadableStreamBYOBRequest.prototype.respond, "respond"), n(ReadableStreamBYOBRequest.prototype.respondWithNewView, "respondWithNewView"), "symbol" == typeof e.toStringTag && Object.defineProperty(ReadableStreamBYOBRequest.prototype, e.toStringTag, { value: "ReadableStreamBYOBRequest", configurable: true });
    ReadableByteStreamController = class {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get byobRequest() {
        if (!de(this)) throw Ae("byobRequest");
        return function(e2) {
          if (null === e2._byobRequest && e2._pendingPullIntos.length > 0) {
            const t2 = e2._pendingPullIntos.peek(), r2 = new Uint8Array(t2.buffer, t2.byteOffset + t2.bytesFilled, t2.byteLength - t2.bytesFilled), o2 = Object.create(ReadableStreamBYOBRequest.prototype);
            !function(e3, t3, r3) {
              e3._associatedReadableByteStreamController = t3, e3._view = r3;
            }(o2, e2, r2), e2._byobRequest = o2;
          }
          return e2._byobRequest;
        }(this);
      }
      get desiredSize() {
        if (!de(this)) throw Ae("desiredSize");
        return ke(this);
      }
      close() {
        if (!de(this)) throw Ae("close");
        if (this._closeRequested) throw new TypeError("The stream has already been closed; do not close it again!");
        const e2 = this._controlledReadableByteStream._state;
        if ("readable" !== e2) throw new TypeError(`The stream (in ${e2} state) is not in the readable state and cannot be closed`);
        !function(e3) {
          const t2 = e3._controlledReadableByteStream;
          if (e3._closeRequested || "readable" !== t2._state) return;
          if (e3._queueTotalSize > 0) return void (e3._closeRequested = true);
          if (e3._pendingPullIntos.length > 0) {
            if (e3._pendingPullIntos.peek().bytesFilled > 0) {
              const t3 = new TypeError("Insufficient bytes to fill elements in the given buffer");
              throw Pe(e3, t3), t3;
            }
          }
          Ee(e3), Xt(t2);
        }(this);
      }
      enqueue(e2) {
        if (!de(this)) throw Ae("enqueue");
        if ($(e2, 1, "enqueue"), !ArrayBuffer.isView(e2)) throw new TypeError("chunk must be an array buffer view");
        if (0 === e2.byteLength) throw new TypeError("chunk must have non-zero byteLength");
        if (0 === e2.buffer.byteLength) throw new TypeError("chunk's buffer must have non-zero byteLength");
        if (this._closeRequested) throw new TypeError("stream is closed or draining");
        const t2 = this._controlledReadableByteStream._state;
        if ("readable" !== t2) throw new TypeError(`The stream (in ${t2} state) is not in the readable state and cannot be enqueued to`);
        !function(e3, t3) {
          const r2 = e3._controlledReadableByteStream;
          if (e3._closeRequested || "readable" !== r2._state) return;
          const o2 = t3.buffer, n2 = t3.byteOffset, a2 = t3.byteLength, i2 = o2;
          if (e3._pendingPullIntos.length > 0) {
            const t4 = e3._pendingPullIntos.peek();
            t4.buffer, 0, Re(e3), t4.buffer = t4.buffer, "none" === t4.readerType && ge(e3, t4);
          }
          if (J(r2)) if (function(e4) {
            const t4 = e4._controlledReadableByteStream._reader;
            for (; t4._readRequests.length > 0; ) {
              if (0 === e4._queueTotalSize) return;
              We(e4, t4._readRequests.shift());
            }
          }(e3), 0 === X(r2)) me(e3, i2, n2, a2);
          else {
            e3._pendingPullIntos.length > 0 && Ce(e3);
            G(r2, new Uint8Array(i2, n2, a2), false);
          }
          else Le(r2) ? (me(e3, i2, n2, a2), Te(e3)) : me(e3, i2, n2, a2);
          be(e3);
        }(this, e2);
      }
      error(e2) {
        if (!de(this)) throw Ae("error");
        Pe(this, e2);
      }
      [T](e2) {
        he(this), ce(this);
        const t2 = this._cancelAlgorithm(e2);
        return Ee(this), t2;
      }
      [q](e2) {
        const t2 = this._controlledReadableByteStream;
        if (this._queueTotalSize > 0) return void We(this, e2);
        const r2 = this._autoAllocateChunkSize;
        if (void 0 !== r2) {
          let t3;
          try {
            t3 = new ArrayBuffer(r2);
          } catch (t4) {
            return void e2._errorSteps(t4);
          }
          const o2 = { buffer: t3, bufferByteLength: r2, byteOffset: 0, byteLength: r2, bytesFilled: 0, elementSize: 1, viewConstructor: Uint8Array, readerType: "default" };
          this._pendingPullIntos.push(o2);
        }
        U(t2, e2), be(this);
      }
      [C]() {
        if (this._pendingPullIntos.length > 0) {
          const e2 = this._pendingPullIntos.peek();
          e2.readerType = "none", this._pendingPullIntos = new S(), this._pendingPullIntos.push(e2);
        }
      }
    };
    Object.defineProperties(ReadableByteStreamController.prototype, { close: { enumerable: true }, enqueue: { enumerable: true }, error: { enumerable: true }, byobRequest: { enumerable: true }, desiredSize: { enumerable: true } }), n(ReadableByteStreamController.prototype.close, "close"), n(ReadableByteStreamController.prototype.enqueue, "enqueue"), n(ReadableByteStreamController.prototype.error, "error"), "symbol" == typeof e.toStringTag && Object.defineProperty(ReadableByteStreamController.prototype, e.toStringTag, { value: "ReadableByteStreamController", configurable: true });
    ReadableStreamBYOBReader = class {
      constructor(e2) {
        if ($(e2, 1, "ReadableStreamBYOBReader"), V(e2, "First parameter"), Ut(e2)) throw new TypeError("This stream has already been locked for exclusive reading by another reader");
        if (!de(e2._readableStreamController)) throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
        E(this, e2), this._readIntoRequests = new S();
      }
      get closed() {
        return Fe(this) ? this._closedPromise : d(De("closed"));
      }
      cancel(e2) {
        return Fe(this) ? void 0 === this._ownerReadableStream ? d(k("cancel")) : P(this, e2) : d(De("cancel"));
      }
      read(e2) {
        if (!Fe(this)) return d(De("read"));
        if (!ArrayBuffer.isView(e2)) return d(new TypeError("view must be an array buffer view"));
        if (0 === e2.byteLength) return d(new TypeError("view must have non-zero byteLength"));
        if (0 === e2.buffer.byteLength) return d(new TypeError("view's buffer must have non-zero byteLength"));
        if (e2.buffer, void 0 === this._ownerReadableStream) return d(k("read from"));
        let t2, r2;
        const o2 = u((e3, o3) => {
          t2 = e3, r2 = o3;
        });
        return function(e3, t3, r3) {
          const o3 = e3._ownerReadableStream;
          o3._disturbed = true, "errored" === o3._state ? r3._errorSteps(o3._storedError) : function(e4, t4, r4) {
            const o4 = e4._controlledReadableByteStream;
            let n2 = 1;
            t4.constructor !== DataView && (n2 = t4.constructor.BYTES_PER_ELEMENT);
            const a2 = t4.constructor, i2 = t4.buffer, l2 = { buffer: i2, bufferByteLength: i2.byteLength, byteOffset: t4.byteOffset, byteLength: t4.byteLength, bytesFilled: 0, elementSize: n2, viewConstructor: a2, readerType: "byob" };
            if (e4._pendingPullIntos.length > 0) return e4._pendingPullIntos.push(l2), void je(o4, r4);
            if ("closed" !== o4._state) {
              if (e4._queueTotalSize > 0) {
                if (we(e4, l2)) {
                  const t5 = pe(l2);
                  return ve(e4), void r4._chunkSteps(t5);
                }
                if (e4._closeRequested) {
                  const t5 = new TypeError("Insufficient bytes to fill elements in the given buffer");
                  return Pe(e4, t5), void r4._errorSteps(t5);
                }
              }
              e4._pendingPullIntos.push(l2), je(o4, r4), be(e4);
            } else {
              const e5 = new a2(l2.buffer, l2.byteOffset, 0);
              r4._closeSteps(e5);
            }
          }(o3._readableStreamController, t3, r3);
        }(this, e2, { _chunkSteps: (e3) => t2({ value: e3, done: false }), _closeSteps: (e3) => t2({ value: e3, done: true }), _errorSteps: (e3) => r2(e3) }), o2;
      }
      releaseLock() {
        if (!Fe(this)) throw De("releaseLock");
        void 0 !== this._ownerReadableStream && function(e2) {
          W(e2);
          const t2 = new TypeError("Reader was released");
          Ie(e2, t2);
        }(this);
      }
    };
    Object.defineProperties(ReadableStreamBYOBReader.prototype, { cancel: { enumerable: true }, read: { enumerable: true }, releaseLock: { enumerable: true }, closed: { enumerable: true } }), n(ReadableStreamBYOBReader.prototype.cancel, "cancel"), n(ReadableStreamBYOBReader.prototype.read, "read"), n(ReadableStreamBYOBReader.prototype.releaseLock, "releaseLock"), "symbol" == typeof e.toStringTag && Object.defineProperty(ReadableStreamBYOBReader.prototype, e.toStringTag, { value: "ReadableStreamBYOBReader", configurable: true });
    Ue = "function" == typeof AbortController;
    WritableStream = class {
      constructor(e2 = {}, t2 = {}) {
        void 0 === e2 ? e2 = null : D(e2, "First parameter");
        const r2 = Ye(t2, "Second parameter"), o2 = function(e3, t3) {
          F(e3, t3);
          const r3 = null == e3 ? void 0 : e3.abort, o3 = null == e3 ? void 0 : e3.close, n3 = null == e3 ? void 0 : e3.start, a3 = null == e3 ? void 0 : e3.type, i2 = null == e3 ? void 0 : e3.write;
          return { abort: void 0 === r3 ? void 0 : Ne(r3, e3, `${t3} has member 'abort' that`), close: void 0 === o3 ? void 0 : He(o3, e3, `${t3} has member 'close' that`), start: void 0 === n3 ? void 0 : xe(n3, e3, `${t3} has member 'start' that`), write: void 0 === i2 ? void 0 : Ve(i2, e3, `${t3} has member 'write' that`), type: a3 };
        }(e2, "First parameter");
        var n2;
        (n2 = this)._state = "writable", n2._storedError = void 0, n2._writer = void 0, n2._writableStreamController = void 0, n2._writeRequests = new S(), n2._inFlightWriteRequest = void 0, n2._closeRequest = void 0, n2._inFlightCloseRequest = void 0, n2._pendingAbortRequest = void 0, n2._backpressure = false;
        if (void 0 !== o2.type) throw new RangeError("Invalid type is specified");
        const a2 = Me(r2);
        !function(e3, t3, r3, o3) {
          const n3 = Object.create(WritableStreamDefaultController.prototype);
          let a3, i2, l2, s2;
          a3 = void 0 !== t3.start ? () => t3.start(n3) : () => {
          };
          i2 = void 0 !== t3.write ? (e4) => t3.write(e4, n3) : () => c(void 0);
          l2 = void 0 !== t3.close ? () => t3.close() : () => c(void 0);
          s2 = void 0 !== t3.abort ? (e4) => t3.abort(e4) : () => c(void 0);
          !function(e4, t4, r4, o4, n4, a4, i3, l3) {
            t4._controlledWritableStream = e4, e4._writableStreamController = t4, t4._queue = void 0, t4._queueTotalSize = void 0, ce(t4), t4._abortReason = void 0, t4._abortController = function() {
              if (Ue) return new AbortController();
            }(), t4._started = false, t4._strategySizeAlgorithm = l3, t4._strategyHWM = i3, t4._writeAlgorithm = o4, t4._closeAlgorithm = n4, t4._abortAlgorithm = a4;
            const s3 = bt(t4);
            nt(e4, s3);
            const u2 = r4();
            b(c(u2), () => (t4._started = true, dt(t4), null), (r5) => (t4._started = true, Ze(e4, r5), null));
          }(e3, n3, a3, i2, l2, s2, r3, o3);
        }(this, o2, $e(r2, 1), a2);
      }
      get locked() {
        if (!Ge(this)) throw _t("locked");
        return Xe(this);
      }
      abort(e2) {
        return Ge(this) ? Xe(this) ? d(new TypeError("Cannot abort a stream that already has a writer")) : Je(this, e2) : d(_t("abort"));
      }
      close() {
        return Ge(this) ? Xe(this) ? d(new TypeError("Cannot close a stream that already has a writer")) : rt(this) ? d(new TypeError("Cannot close an already-closing stream")) : Ke(this) : d(_t("close"));
      }
      getWriter() {
        if (!Ge(this)) throw _t("getWriter");
        return new WritableStreamDefaultWriter(this);
      }
    };
    Object.defineProperties(WritableStream.prototype, { abort: { enumerable: true }, close: { enumerable: true }, getWriter: { enumerable: true }, locked: { enumerable: true } }), n(WritableStream.prototype.abort, "abort"), n(WritableStream.prototype.close, "close"), n(WritableStream.prototype.getWriter, "getWriter"), "symbol" == typeof e.toStringTag && Object.defineProperty(WritableStream.prototype, e.toStringTag, { value: "WritableStream", configurable: true });
    WritableStreamDefaultWriter = class {
      constructor(e2) {
        if ($(e2, 1, "WritableStreamDefaultWriter"), function(e3, t3) {
          if (!Ge(e3)) throw new TypeError(`${t3} is not a WritableStream.`);
        }(e2, "First parameter"), Xe(e2)) throw new TypeError("This stream has already been locked for exclusive writing by another writer");
        this._ownerWritableStream = e2, e2._writer = this;
        const t2 = e2._state;
        if ("writable" === t2) !rt(e2) && e2._backpressure ? Rt(this) : qt(this), gt(this);
        else if ("erroring" === t2) Tt(this, e2._storedError), gt(this);
        else if ("closed" === t2) qt(this), gt(r2 = this), vt(r2);
        else {
          const t3 = e2._storedError;
          Tt(this, t3), wt(this, t3);
        }
        var r2;
      }
      get closed() {
        return at(this) ? this._closedPromise : d(mt("closed"));
      }
      get desiredSize() {
        if (!at(this)) throw mt("desiredSize");
        if (void 0 === this._ownerWritableStream) throw yt("desiredSize");
        return function(e2) {
          const t2 = e2._ownerWritableStream, r2 = t2._state;
          if ("errored" === r2 || "erroring" === r2) return null;
          if ("closed" === r2) return 0;
          return ct(t2._writableStreamController);
        }(this);
      }
      get ready() {
        return at(this) ? this._readyPromise : d(mt("ready"));
      }
      abort(e2) {
        return at(this) ? void 0 === this._ownerWritableStream ? d(yt("abort")) : function(e3, t2) {
          return Je(e3._ownerWritableStream, t2);
        }(this, e2) : d(mt("abort"));
      }
      close() {
        if (!at(this)) return d(mt("close"));
        const e2 = this._ownerWritableStream;
        return void 0 === e2 ? d(yt("close")) : rt(e2) ? d(new TypeError("Cannot close an already-closing stream")) : Ke(this._ownerWritableStream);
      }
      releaseLock() {
        if (!at(this)) throw mt("releaseLock");
        void 0 !== this._ownerWritableStream && function(e2) {
          const t2 = e2._ownerWritableStream, r2 = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
          it(e2, r2), function(e3, t3) {
            "pending" === e3._closedPromiseState ? St(e3, t3) : function(e4, t4) {
              wt(e4, t4);
            }(e3, t3);
          }(e2, r2), t2._writer = void 0, e2._ownerWritableStream = void 0;
        }(this);
      }
      write(e2) {
        return at(this) ? void 0 === this._ownerWritableStream ? d(yt("write to")) : function(e3, t2) {
          const r2 = e3._ownerWritableStream, o2 = r2._writableStreamController, n2 = function(e4, t3) {
            try {
              return e4._strategySizeAlgorithm(t3);
            } catch (t4) {
              return ft(e4, t4), 1;
            }
          }(o2, t2);
          if (r2 !== e3._ownerWritableStream) return d(yt("write to"));
          const a2 = r2._state;
          if ("errored" === a2) return d(r2._storedError);
          if (rt(r2) || "closed" === a2) return d(new TypeError("The stream is closing or closed and cannot be written to"));
          if ("erroring" === a2) return d(r2._storedError);
          const i2 = function(e4) {
            return u((t3, r3) => {
              const o3 = { _resolve: t3, _reject: r3 };
              e4._writeRequests.push(o3);
            });
          }(r2);
          return function(e4, t3, r3) {
            try {
              ue(e4, t3, r3);
            } catch (t4) {
              return void ft(e4, t4);
            }
            const o3 = e4._controlledWritableStream;
            if (!rt(o3) && "writable" === o3._state) {
              nt(o3, bt(e4));
            }
            dt(e4);
          }(o2, t2, n2), i2;
        }(this, e2) : d(mt("write"));
      }
    };
    Object.defineProperties(WritableStreamDefaultWriter.prototype, { abort: { enumerable: true }, close: { enumerable: true }, releaseLock: { enumerable: true }, write: { enumerable: true }, closed: { enumerable: true }, desiredSize: { enumerable: true }, ready: { enumerable: true } }), n(WritableStreamDefaultWriter.prototype.abort, "abort"), n(WritableStreamDefaultWriter.prototype.close, "close"), n(WritableStreamDefaultWriter.prototype.releaseLock, "releaseLock"), n(WritableStreamDefaultWriter.prototype.write, "write"), "symbol" == typeof e.toStringTag && Object.defineProperty(WritableStreamDefaultWriter.prototype, e.toStringTag, { value: "WritableStreamDefaultWriter", configurable: true });
    lt = {};
    WritableStreamDefaultController = class {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get abortReason() {
        if (!st(this)) throw pt("abortReason");
        return this._abortReason;
      }
      get signal() {
        if (!st(this)) throw pt("signal");
        if (void 0 === this._abortController) throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
        return this._abortController.signal;
      }
      error(e2) {
        if (!st(this)) throw pt("error");
        "writable" === this._controlledWritableStream._state && ht(this, e2);
      }
      [v](e2) {
        const t2 = this._abortAlgorithm(e2);
        return ut(this), t2;
      }
      [R]() {
        ce(this);
      }
    };
    Object.defineProperties(WritableStreamDefaultController.prototype, { abortReason: { enumerable: true }, signal: { enumerable: true }, error: { enumerable: true } }), "symbol" == typeof e.toStringTag && Object.defineProperty(WritableStreamDefaultController.prototype, e.toStringTag, { value: "WritableStreamDefaultController", configurable: true });
    Pt = "undefined" != typeof DOMException ? DOMException : void 0;
    Wt = function(e2) {
      if ("function" != typeof e2 && "object" != typeof e2) return false;
      try {
        return new e2(), true;
      } catch (e3) {
        return false;
      }
    }(Pt) ? Pt : function() {
      const e2 = function(e3, t2) {
        this.message = e3 || "", this.name = t2 || "Error", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
      };
      return e2.prototype = Object.create(Error.prototype), Object.defineProperty(e2.prototype, "constructor", { value: e2, writable: true, configurable: true }), e2;
    }();
    ReadableStreamDefaultController = class {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get desiredSize() {
        if (!Bt(this)) throw Dt("desiredSize");
        return Lt(this);
      }
      close() {
        if (!Bt(this)) throw Dt("close");
        if (!Ft(this)) throw new TypeError("The stream is not in a state that permits close");
        !function(e2) {
          if (!Ft(e2)) return;
          const t2 = e2._controlledReadableStream;
          e2._closeRequested = true, 0 === e2._queue.length && (jt(e2), Xt(t2));
        }(this);
      }
      enqueue(e2) {
        if (!Bt(this)) throw Dt("enqueue");
        if (!Ft(this)) throw new TypeError("The stream is not in a state that permits enqueue");
        return function(e3, t2) {
          if (!Ft(e3)) return;
          const r2 = e3._controlledReadableStream;
          if (Ut(r2) && X(r2) > 0) G(r2, t2, false);
          else {
            let r3;
            try {
              r3 = e3._strategySizeAlgorithm(t2);
            } catch (t3) {
              throw zt(e3, t3), t3;
            }
            try {
              ue(e3, t2, r3);
            } catch (t3) {
              throw zt(e3, t3), t3;
            }
          }
          At(e3);
        }(this, e2);
      }
      error(e2) {
        if (!Bt(this)) throw Dt("error");
        zt(this, e2);
      }
      [T](e2) {
        ce(this);
        const t2 = this._cancelAlgorithm(e2);
        return jt(this), t2;
      }
      [q](e2) {
        const t2 = this._controlledReadableStream;
        if (this._queue.length > 0) {
          const r2 = se(this);
          this._closeRequested && 0 === this._queue.length ? (jt(this), Xt(t2)) : At(this), e2._chunkSteps(r2);
        } else U(t2, e2), At(this);
      }
      [C]() {
      }
    };
    Object.defineProperties(ReadableStreamDefaultController.prototype, { close: { enumerable: true }, enqueue: { enumerable: true }, error: { enumerable: true }, desiredSize: { enumerable: true } }), n(ReadableStreamDefaultController.prototype.close, "close"), n(ReadableStreamDefaultController.prototype.enqueue, "enqueue"), n(ReadableStreamDefaultController.prototype.error, "error"), "symbol" == typeof e.toStringTag && Object.defineProperty(ReadableStreamDefaultController.prototype, e.toStringTag, { value: "ReadableStreamDefaultController", configurable: true });
    ReadableStream3 = class {
      constructor(e2 = {}, t2 = {}) {
        void 0 === e2 ? e2 = null : D(e2, "First parameter");
        const r2 = Ye(t2, "Second parameter"), o2 = function(e3, t3) {
          F(e3, t3);
          const r3 = e3, o3 = null == r3 ? void 0 : r3.autoAllocateChunkSize, n3 = null == r3 ? void 0 : r3.cancel, a2 = null == r3 ? void 0 : r3.pull, i2 = null == r3 ? void 0 : r3.start, l2 = null == r3 ? void 0 : r3.type;
          return { autoAllocateChunkSize: void 0 === o3 ? void 0 : N(o3, `${t3} has member 'autoAllocateChunkSize' that`), cancel: void 0 === n3 ? void 0 : $t(n3, r3, `${t3} has member 'cancel' that`), pull: void 0 === a2 ? void 0 : Mt(a2, r3, `${t3} has member 'pull' that`), start: void 0 === i2 ? void 0 : Yt(i2, r3, `${t3} has member 'start' that`), type: void 0 === l2 ? void 0 : Qt(l2, `${t3} has member 'type' that`) };
        }(e2, "First parameter");
        var n2;
        if ((n2 = this)._state = "readable", n2._reader = void 0, n2._storedError = void 0, n2._disturbed = false, "bytes" === o2.type) {
          if (void 0 !== r2.size) throw new RangeError("The strategy for a byte stream cannot have a size function");
          Oe(this, o2, $e(r2, 0));
        } else {
          const e3 = Me(r2);
          It(this, o2, $e(r2, 1), e3);
        }
      }
      get locked() {
        if (!Vt(this)) throw Kt("locked");
        return Ut(this);
      }
      cancel(e2) {
        return Vt(this) ? Ut(this) ? d(new TypeError("Cannot cancel a stream that already has a reader")) : Gt(this, e2) : d(Kt("cancel"));
      }
      getReader(e2) {
        if (!Vt(this)) throw Kt("getReader");
        return void 0 === function(e3, t2) {
          F(e3, t2);
          const r2 = null == e3 ? void 0 : e3.mode;
          return { mode: void 0 === r2 ? void 0 : Nt(r2, `${t2} has member 'mode' that`) };
        }(e2, "First parameter").mode ? new ReadableStreamDefaultReader(this) : function(e3) {
          return new ReadableStreamBYOBReader(e3);
        }(this);
      }
      pipeThrough(e2, t2 = {}) {
        if (!H(this)) throw Kt("pipeThrough");
        $(e2, 1, "pipeThrough");
        const r2 = xt(e2, "First parameter"), o2 = Ht(t2, "Second parameter");
        if (this.locked) throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
        if (r2.writable.locked) throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
        return m(kt(this, r2.writable, o2.preventClose, o2.preventAbort, o2.preventCancel, o2.signal)), r2.readable;
      }
      pipeTo(e2, t2 = {}) {
        if (!H(this)) return d(Kt("pipeTo"));
        if (void 0 === e2) return d("Parameter 1 is required in 'pipeTo'.");
        if (!x(e2)) return d(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
        let r2;
        try {
          r2 = Ht(t2, "Second parameter");
        } catch (e3) {
          return d(e3);
        }
        return this.locked ? d(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")) : e2.locked ? d(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")) : kt(this, e2, r2.preventClose, r2.preventAbort, r2.preventCancel, r2.signal);
      }
      tee() {
        if (!H(this)) throw Kt("tee");
        if (this.locked) throw new TypeError("Cannot tee a stream that already has a reader");
        return Ot(this);
      }
      values(e2) {
        if (!H(this)) throw Kt("values");
        return function(e3, t2) {
          const r2 = e3.getReader(), o2 = new te(r2, t2), n2 = Object.create(re);
          return n2._asyncIteratorImpl = o2, n2;
        }(this, function(e3, t2) {
          F(e3, t2);
          const r2 = null == e3 ? void 0 : e3.preventCancel;
          return { preventCancel: Boolean(r2) };
        }(e2, "First parameter").preventCancel);
      }
    };
    Object.defineProperties(ReadableStream3.prototype, { cancel: { enumerable: true }, getReader: { enumerable: true }, pipeThrough: { enumerable: true }, pipeTo: { enumerable: true }, tee: { enumerable: true }, values: { enumerable: true }, locked: { enumerable: true } }), n(ReadableStream3.prototype.cancel, "cancel"), n(ReadableStream3.prototype.getReader, "getReader"), n(ReadableStream3.prototype.pipeThrough, "pipeThrough"), n(ReadableStream3.prototype.pipeTo, "pipeTo"), n(ReadableStream3.prototype.tee, "tee"), n(ReadableStream3.prototype.values, "values"), "symbol" == typeof e.toStringTag && Object.defineProperty(ReadableStream3.prototype, e.toStringTag, { value: "ReadableStream", configurable: true }), "symbol" == typeof e.asyncIterator && Object.defineProperty(ReadableStream3.prototype, e.asyncIterator, { value: ReadableStream3.prototype.values, writable: true, configurable: true });
    er = (e2) => e2.byteLength;
    n(er, "size");
    ByteLengthQueuingStrategy = class {
      constructor(e2) {
        $(e2, 1, "ByteLengthQueuingStrategy"), e2 = Zt(e2, "First parameter"), this._byteLengthQueuingStrategyHighWaterMark = e2.highWaterMark;
      }
      get highWaterMark() {
        if (!rr(this)) throw tr("highWaterMark");
        return this._byteLengthQueuingStrategyHighWaterMark;
      }
      get size() {
        if (!rr(this)) throw tr("size");
        return er;
      }
    };
    Object.defineProperties(ByteLengthQueuingStrategy.prototype, { highWaterMark: { enumerable: true }, size: { enumerable: true } }), "symbol" == typeof e.toStringTag && Object.defineProperty(ByteLengthQueuingStrategy.prototype, e.toStringTag, { value: "ByteLengthQueuingStrategy", configurable: true });
    or = () => 1;
    n(or, "size");
    CountQueuingStrategy = class {
      constructor(e2) {
        $(e2, 1, "CountQueuingStrategy"), e2 = Zt(e2, "First parameter"), this._countQueuingStrategyHighWaterMark = e2.highWaterMark;
      }
      get highWaterMark() {
        if (!ar(this)) throw nr("highWaterMark");
        return this._countQueuingStrategyHighWaterMark;
      }
      get size() {
        if (!ar(this)) throw nr("size");
        return or;
      }
    };
    Object.defineProperties(CountQueuingStrategy.prototype, { highWaterMark: { enumerable: true }, size: { enumerable: true } }), "symbol" == typeof e.toStringTag && Object.defineProperty(CountQueuingStrategy.prototype, e.toStringTag, { value: "CountQueuingStrategy", configurable: true });
    TransformStream = class {
      constructor(e2 = {}, t2 = {}, r2 = {}) {
        void 0 === e2 && (e2 = null);
        const o2 = Ye(t2, "Second parameter"), n2 = Ye(r2, "Third parameter"), a2 = function(e3, t3) {
          F(e3, t3);
          const r3 = null == e3 ? void 0 : e3.flush, o3 = null == e3 ? void 0 : e3.readableType, n3 = null == e3 ? void 0 : e3.start, a3 = null == e3 ? void 0 : e3.transform, i3 = null == e3 ? void 0 : e3.writableType;
          return { flush: void 0 === r3 ? void 0 : ir(r3, e3, `${t3} has member 'flush' that`), readableType: o3, start: void 0 === n3 ? void 0 : lr(n3, e3, `${t3} has member 'start' that`), transform: void 0 === a3 ? void 0 : sr(a3, e3, `${t3} has member 'transform' that`), writableType: i3 };
        }(e2, "First parameter");
        if (void 0 !== a2.readableType) throw new RangeError("Invalid readableType specified");
        if (void 0 !== a2.writableType) throw new RangeError("Invalid writableType specified");
        const i2 = $e(n2, 0), l2 = Me(n2), s2 = $e(o2, 1), f2 = Me(o2);
        let b2;
        !function(e3, t3, r3, o3, n3, a3) {
          function i3() {
            return t3;
          }
          function l3(t4) {
            return function(e4, t5) {
              const r4 = e4._transformStreamController;
              if (e4._backpressure) {
                return p(e4._backpressureChangePromise, () => {
                  if ("erroring" === (Ge(e4._writable) ? e4._writable._state : e4._writableState)) throw Ge(e4._writable) ? e4._writable._storedError : e4._writableStoredError;
                  return pr(r4, t5);
                });
              }
              return pr(r4, t5);
            }(e3, t4);
          }
          function s3(t4) {
            return function(e4, t5) {
              return cr(e4, t5), c(void 0);
            }(e3, t4);
          }
          function u2() {
            return function(e4) {
              const t4 = e4._transformStreamController, r4 = t4._flushAlgorithm();
              return hr(t4), p(r4, () => {
                if ("errored" === e4._readableState) throw e4._readableStoredError;
                gr(e4) && wr(e4);
              }, (t5) => {
                throw cr(e4, t5), e4._readableStoredError;
              });
            }(e3);
          }
          function d2() {
            return function(e4) {
              return fr(e4, false), e4._backpressureChangePromise;
            }(e3);
          }
          function f3(t4) {
            return dr(e3, t4), c(void 0);
          }
          e3._writableState = "writable", e3._writableStoredError = void 0, e3._writableHasInFlightOperation = false, e3._writableStarted = false, e3._writable = function(e4, t4, r4, o4, n4, a4, i4) {
            return new WritableStream({ start(r5) {
              e4._writableController = r5;
              try {
                const t5 = r5.signal;
                void 0 !== t5 && t5.addEventListener("abort", () => {
                  "writable" === e4._writableState && (e4._writableState = "erroring", t5.reason && (e4._writableStoredError = t5.reason));
                });
              } catch (e5) {
              }
              return p(t4(), () => (e4._writableStarted = true, Cr(e4), null), (t5) => {
                throw e4._writableStarted = true, Rr(e4, t5), t5;
              });
            }, write: (t5) => (function(e5) {
              e5._writableHasInFlightOperation = true;
            }(e4), p(r4(t5), () => (function(e5) {
              e5._writableHasInFlightOperation = false;
            }(e4), Cr(e4), null), (t6) => {
              throw function(e5, t7) {
                e5._writableHasInFlightOperation = false, Rr(e5, t7);
              }(e4, t6), t6;
            })), close: () => (function(e5) {
              e5._writableHasInFlightOperation = true;
            }(e4), p(o4(), () => (function(e5) {
              e5._writableHasInFlightOperation = false;
              "erroring" === e5._writableState && (e5._writableStoredError = void 0);
              e5._writableState = "closed";
            }(e4), null), (t5) => {
              throw function(e5, t6) {
                e5._writableHasInFlightOperation = false, e5._writableState, Rr(e5, t6);
              }(e4, t5), t5;
            })), abort: (t5) => (e4._writableState = "errored", e4._writableStoredError = t5, n4(t5)) }, { highWaterMark: a4, size: i4 });
          }(e3, i3, l3, u2, s3, r3, o3), e3._readableState = "readable", e3._readableStoredError = void 0, e3._readableCloseRequested = false, e3._readablePulling = false, e3._readable = function(e4, t4, r4, o4, n4, a4) {
            return new ReadableStream3({ start: (r5) => (e4._readableController = r5, t4().catch((t5) => {
              Sr(e4, t5);
            })), pull: () => (e4._readablePulling = true, r4().catch((t5) => {
              Sr(e4, t5);
            })), cancel: (t5) => (e4._readableState = "closed", o4(t5)) }, { highWaterMark: n4, size: a4 });
          }(e3, i3, d2, f3, n3, a3), e3._backpressure = void 0, e3._backpressureChangePromise = void 0, e3._backpressureChangePromise_resolve = void 0, fr(e3, true), e3._transformStreamController = void 0;
        }(this, u((e3) => {
          b2 = e3;
        }), s2, f2, i2, l2), function(e3, t3) {
          const r3 = Object.create(TransformStreamDefaultController.prototype);
          let o3, n3;
          o3 = void 0 !== t3.transform ? (e4) => t3.transform(e4, r3) : (e4) => {
            try {
              return _r(r3, e4), c(void 0);
            } catch (e5) {
              return d(e5);
            }
          };
          n3 = void 0 !== t3.flush ? () => t3.flush(r3) : () => c(void 0);
          !function(e4, t4, r4, o4) {
            t4._controlledTransformStream = e4, e4._transformStreamController = t4, t4._transformAlgorithm = r4, t4._flushAlgorithm = o4;
          }(e3, r3, o3, n3);
        }(this, a2), void 0 !== a2.start ? b2(a2.start(this._transformStreamController)) : b2(void 0);
      }
      get readable() {
        if (!ur(this)) throw yr("readable");
        return this._readable;
      }
      get writable() {
        if (!ur(this)) throw yr("writable");
        return this._writable;
      }
    };
    Object.defineProperties(TransformStream.prototype, { readable: { enumerable: true }, writable: { enumerable: true } }), "symbol" == typeof e.toStringTag && Object.defineProperty(TransformStream.prototype, e.toStringTag, { value: "TransformStream", configurable: true });
    TransformStreamDefaultController = class {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get desiredSize() {
        if (!br(this)) throw mr("desiredSize");
        return vr(this._controlledTransformStream);
      }
      enqueue(e2) {
        if (!br(this)) throw mr("enqueue");
        _r(this, e2);
      }
      error(e2) {
        if (!br(this)) throw mr("error");
        var t2;
        t2 = e2, cr(this._controlledTransformStream, t2);
      }
      terminate() {
        if (!br(this)) throw mr("terminate");
        !function(e2) {
          const t2 = e2._controlledTransformStream;
          gr(t2) && wr(t2);
          const r2 = new TypeError("TransformStream terminated");
          dr(t2, r2);
        }(this);
      }
    };
    Object.defineProperties(TransformStreamDefaultController.prototype, { enqueue: { enumerable: true }, error: { enumerable: true }, terminate: { enumerable: true }, desiredSize: { enumerable: true } }), n(TransformStreamDefaultController.prototype.enqueue, "enqueue"), n(TransformStreamDefaultController.prototype.error, "error"), n(TransformStreamDefaultController.prototype.terminate, "terminate"), "symbol" == typeof e.toStringTag && Object.defineProperty(TransformStreamDefaultController.prototype, e.toStringTag, { value: "TransformStreamDefaultController", configurable: true });
  }
});

// ../node_modules/formdata-node/lib/esm/isFunction.js
var isFunction;
var init_isFunction = __esm({
  "../node_modules/formdata-node/lib/esm/isFunction.js"() {
    "use strict";
    isFunction = (value) => typeof value === "function";
  }
});

// ../node_modules/formdata-node/lib/esm/blobHelpers.js
async function* clonePart(part) {
  const end = part.byteOffset + part.byteLength;
  let position = part.byteOffset;
  while (position !== end) {
    const size = Math.min(end - position, CHUNK_SIZE);
    const chunk = part.buffer.slice(position, position + size);
    position += chunk.byteLength;
    yield new Uint8Array(chunk);
  }
}
async function* consumeNodeBlob(blob) {
  let position = 0;
  while (position !== blob.size) {
    const chunk = blob.slice(position, Math.min(blob.size, position + CHUNK_SIZE));
    const buffer = await chunk.arrayBuffer();
    position += buffer.byteLength;
    yield new Uint8Array(buffer);
  }
}
async function* consumeBlobParts(parts, clone2 = false) {
  for (const part of parts) {
    if (ArrayBuffer.isView(part)) {
      if (clone2) {
        yield* clonePart(part);
      } else {
        yield part;
      }
    } else if (isFunction(part.stream)) {
      yield* part.stream();
    } else {
      yield* consumeNodeBlob(part);
    }
  }
}
function* sliceBlob(blobParts, blobSize, start = 0, end) {
  end !== null && end !== void 0 ? end : end = blobSize;
  let relativeStart = start < 0 ? Math.max(blobSize + start, 0) : Math.min(start, blobSize);
  let relativeEnd = end < 0 ? Math.max(blobSize + end, 0) : Math.min(end, blobSize);
  const span = Math.max(relativeEnd - relativeStart, 0);
  let added = 0;
  for (const part of blobParts) {
    if (added >= span) {
      break;
    }
    const partSize = ArrayBuffer.isView(part) ? part.byteLength : part.size;
    if (relativeStart && partSize <= relativeStart) {
      relativeStart -= partSize;
      relativeEnd -= partSize;
    } else {
      let chunk;
      if (ArrayBuffer.isView(part)) {
        chunk = part.subarray(relativeStart, Math.min(partSize, relativeEnd));
        added += chunk.byteLength;
      } else {
        chunk = part.slice(relativeStart, Math.min(partSize, relativeEnd));
        added += chunk.size;
      }
      relativeEnd -= partSize;
      relativeStart = 0;
      yield chunk;
    }
  }
}
var CHUNK_SIZE;
var init_blobHelpers = __esm({
  "../node_modules/formdata-node/lib/esm/blobHelpers.js"() {
    "use strict";
    init_isFunction();
    CHUNK_SIZE = 65536;
  }
});

// ../node_modules/formdata-node/lib/esm/Blob.js
var __classPrivateFieldGet, __classPrivateFieldSet, _Blob_parts, _Blob_type, _Blob_size, Blob4;
var init_Blob = __esm({
  "../node_modules/formdata-node/lib/esm/Blob.js"() {
    "use strict";
    init_ponyfill();
    init_isFunction();
    init_blobHelpers();
    __classPrivateFieldGet = function(receiver, state, kind3, f2) {
      if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind3 === "m" ? f2 : kind3 === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind3, f2) {
      if (kind3 === "m") throw new TypeError("Private method is not writable");
      if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind3 === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
    };
    Blob4 = class _Blob {
      constructor(blobParts = [], options = {}) {
        _Blob_parts.set(this, []);
        _Blob_type.set(this, "");
        _Blob_size.set(this, 0);
        options !== null && options !== void 0 ? options : options = {};
        if (typeof blobParts !== "object" || blobParts === null) {
          throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
        }
        if (!isFunction(blobParts[Symbol.iterator])) {
          throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
        }
        if (typeof options !== "object" && !isFunction(options)) {
          throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
        }
        const encoder = new TextEncoder();
        for (const raw of blobParts) {
          let part;
          if (ArrayBuffer.isView(raw)) {
            part = new Uint8Array(raw.buffer.slice(raw.byteOffset, raw.byteOffset + raw.byteLength));
          } else if (raw instanceof ArrayBuffer) {
            part = new Uint8Array(raw.slice(0));
          } else if (raw instanceof _Blob) {
            part = raw;
          } else {
            part = encoder.encode(String(raw));
          }
          __classPrivateFieldSet(this, _Blob_size, __classPrivateFieldGet(this, _Blob_size, "f") + (ArrayBuffer.isView(part) ? part.byteLength : part.size), "f");
          __classPrivateFieldGet(this, _Blob_parts, "f").push(part);
        }
        const type = options.type === void 0 ? "" : String(options.type);
        __classPrivateFieldSet(this, _Blob_type, /^[\x20-\x7E]*$/.test(type) ? type : "", "f");
      }
      static [(_Blob_parts = /* @__PURE__ */ new WeakMap(), _Blob_type = /* @__PURE__ */ new WeakMap(), _Blob_size = /* @__PURE__ */ new WeakMap(), Symbol.hasInstance)](value) {
        return Boolean(value && typeof value === "object" && isFunction(value.constructor) && (isFunction(value.stream) || isFunction(value.arrayBuffer)) && /^(Blob|File)$/.test(value[Symbol.toStringTag]));
      }
      get type() {
        return __classPrivateFieldGet(this, _Blob_type, "f");
      }
      get size() {
        return __classPrivateFieldGet(this, _Blob_size, "f");
      }
      slice(start, end, contentType) {
        return new _Blob(sliceBlob(__classPrivateFieldGet(this, _Blob_parts, "f"), this.size, start, end), {
          type: contentType
        });
      }
      async text() {
        const decoder = new TextDecoder();
        let result = "";
        for await (const chunk of consumeBlobParts(__classPrivateFieldGet(this, _Blob_parts, "f"))) {
          result += decoder.decode(chunk, { stream: true });
        }
        result += decoder.decode();
        return result;
      }
      async arrayBuffer() {
        const view = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of consumeBlobParts(__classPrivateFieldGet(this, _Blob_parts, "f"))) {
          view.set(chunk, offset);
          offset += chunk.length;
        }
        return view.buffer;
      }
      stream() {
        const iterator = consumeBlobParts(__classPrivateFieldGet(this, _Blob_parts, "f"), true);
        return new ReadableStream3({
          async pull(controller) {
            const { value, done } = await iterator.next();
            if (done) {
              return queueMicrotask(() => controller.close());
            }
            controller.enqueue(value);
          },
          async cancel() {
            await iterator.return();
          }
        });
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
    };
    Object.defineProperties(Blob4.prototype, {
      type: { enumerable: true },
      size: { enumerable: true },
      slice: { enumerable: true },
      stream: { enumerable: true },
      text: { enumerable: true },
      arrayBuffer: { enumerable: true }
    });
  }
});

// ../node_modules/formdata-node/lib/esm/File.js
var __classPrivateFieldSet2, __classPrivateFieldGet2, _File_name, _File_lastModified, File2;
var init_File = __esm({
  "../node_modules/formdata-node/lib/esm/File.js"() {
    "use strict";
    init_Blob();
    __classPrivateFieldSet2 = function(receiver, state, value, kind3, f2) {
      if (kind3 === "m") throw new TypeError("Private method is not writable");
      if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind3 === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldGet2 = function(receiver, state, kind3, f2) {
      if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind3 === "m" ? f2 : kind3 === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
    };
    File2 = class extends Blob4 {
      constructor(fileBits, name, options = {}) {
        super(fileBits, options);
        _File_name.set(this, void 0);
        _File_lastModified.set(this, 0);
        if (arguments.length < 2) {
          throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
        }
        __classPrivateFieldSet2(this, _File_name, String(name), "f");
        const lastModified = options.lastModified === void 0 ? Date.now() : Number(options.lastModified);
        if (!Number.isNaN(lastModified)) {
          __classPrivateFieldSet2(this, _File_lastModified, lastModified, "f");
        }
      }
      static [(_File_name = /* @__PURE__ */ new WeakMap(), _File_lastModified = /* @__PURE__ */ new WeakMap(), Symbol.hasInstance)](value) {
        return value instanceof Blob4 && value[Symbol.toStringTag] === "File" && typeof value.name === "string";
      }
      get name() {
        return __classPrivateFieldGet2(this, _File_name, "f");
      }
      get lastModified() {
        return __classPrivateFieldGet2(this, _File_lastModified, "f");
      }
      get webkitRelativePath() {
        return "";
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    };
  }
});

// ../node_modules/formdata-node/lib/esm/isFile.js
var isFile;
var init_isFile = __esm({
  "../node_modules/formdata-node/lib/esm/isFile.js"() {
    "use strict";
    init_File();
    isFile = (value) => value instanceof File2;
  }
});

// ../node_modules/ms/index.js
var require_ms = __commonJS({
  "../node_modules/ms/index.js"(exports, module) {
    "use strict";
    var s2 = 1e3;
    var m2 = s2 * 60;
    var h2 = m2 * 60;
    var d2 = h2 * 24;
    var w2 = d2 * 7;
    var y2 = d2 * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match7 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match7) {
        return;
      }
      var n2 = parseFloat(match7[1]);
      var type = (match7[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n2 * y2;
        case "weeks":
        case "week":
        case "w":
          return n2 * w2;
        case "days":
        case "day":
        case "d":
          return n2 * d2;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n2 * h2;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n2 * m2;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n2 * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n2;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d2) {
        return Math.round(ms / d2) + "d";
      }
      if (msAbs >= h2) {
        return Math.round(ms / h2) + "h";
      }
      if (msAbs >= m2) {
        return Math.round(ms / m2) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms / s2) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d2) {
        return plural(ms, msAbs, d2, "day");
      }
      if (msAbs >= h2) {
        return plural(ms, msAbs, h2, "hour");
      }
      if (msAbs >= m2) {
        return plural(ms, msAbs, m2, "minute");
      }
      if (msAbs >= s2) {
        return plural(ms, msAbs, s2, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n2, name) {
      var isPlural = msAbs >= n2 * 1.5;
      return Math.round(ms / n2) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../node_modules/humanize-ms/index.js
var require_humanize_ms = __commonJS({
  "../node_modules/humanize-ms/index.js"(exports, module) {
    "use strict";
    var util = __require("util");
    var ms = require_ms();
    module.exports = function(t2) {
      if (typeof t2 === "number") return t2;
      var r2 = ms(t2);
      if (r2 === void 0) {
        var err = new Error(util.format("humanize-ms(%j) result undefined", t2));
        console.warn(err.stack);
      }
      return r2;
    };
  }
});

// ../node_modules/agentkeepalive/lib/constants.js
var require_constants = __commonJS({
  "../node_modules/agentkeepalive/lib/constants.js"(exports, module) {
    "use strict";
    module.exports = {
      // agent
      CURRENT_ID: Symbol("agentkeepalive#currentId"),
      CREATE_ID: Symbol("agentkeepalive#createId"),
      INIT_SOCKET: Symbol("agentkeepalive#initSocket"),
      CREATE_HTTPS_CONNECTION: Symbol("agentkeepalive#createHttpsConnection"),
      // socket
      SOCKET_CREATED_TIME: Symbol("agentkeepalive#socketCreatedTime"),
      SOCKET_NAME: Symbol("agentkeepalive#socketName"),
      SOCKET_REQUEST_COUNT: Symbol("agentkeepalive#socketRequestCount"),
      SOCKET_REQUEST_FINISHED_COUNT: Symbol("agentkeepalive#socketRequestFinishedCount")
    };
  }
});

// ../node_modules/agentkeepalive/lib/agent.js
var require_agent = __commonJS({
  "../node_modules/agentkeepalive/lib/agent.js"(exports, module) {
    "use strict";
    var OriginalAgent = __require("http").Agent;
    var ms = require_humanize_ms();
    var debug3 = __require("util").debuglog("agentkeepalive");
    var {
      INIT_SOCKET,
      CURRENT_ID,
      CREATE_ID,
      SOCKET_CREATED_TIME,
      SOCKET_NAME,
      SOCKET_REQUEST_COUNT,
      SOCKET_REQUEST_FINISHED_COUNT
    } = require_constants();
    var defaultTimeoutListenerCount = 1;
    var majorVersion = parseInt(process.version.split(".", 1)[0].substring(1));
    if (majorVersion >= 11 && majorVersion <= 12) {
      defaultTimeoutListenerCount = 2;
    } else if (majorVersion >= 13) {
      defaultTimeoutListenerCount = 3;
    }
    function deprecate2(message) {
      console.log("[agentkeepalive:deprecated] %s", message);
    }
    var Agent = class extends OriginalAgent {
      constructor(options) {
        options = options || {};
        options.keepAlive = options.keepAlive !== false;
        if (options.freeSocketTimeout === void 0) {
          options.freeSocketTimeout = 4e3;
        }
        if (options.keepAliveTimeout) {
          deprecate2("options.keepAliveTimeout is deprecated, please use options.freeSocketTimeout instead");
          options.freeSocketTimeout = options.keepAliveTimeout;
          delete options.keepAliveTimeout;
        }
        if (options.freeSocketKeepAliveTimeout) {
          deprecate2("options.freeSocketKeepAliveTimeout is deprecated, please use options.freeSocketTimeout instead");
          options.freeSocketTimeout = options.freeSocketKeepAliveTimeout;
          delete options.freeSocketKeepAliveTimeout;
        }
        if (options.timeout === void 0) {
          options.timeout = Math.max(options.freeSocketTimeout * 2, 8e3);
        }
        options.timeout = ms(options.timeout);
        options.freeSocketTimeout = ms(options.freeSocketTimeout);
        options.socketActiveTTL = options.socketActiveTTL ? ms(options.socketActiveTTL) : 0;
        super(options);
        this[CURRENT_ID] = 0;
        this.createSocketCount = 0;
        this.createSocketCountLastCheck = 0;
        this.createSocketErrorCount = 0;
        this.createSocketErrorCountLastCheck = 0;
        this.closeSocketCount = 0;
        this.closeSocketCountLastCheck = 0;
        this.errorSocketCount = 0;
        this.errorSocketCountLastCheck = 0;
        this.requestCount = 0;
        this.requestCountLastCheck = 0;
        this.timeoutSocketCount = 0;
        this.timeoutSocketCountLastCheck = 0;
        this.on("free", (socket) => {
          const timeout = this.calcSocketTimeout(socket);
          if (timeout > 0 && socket.timeout !== timeout) {
            socket.setTimeout(timeout);
          }
        });
      }
      get freeSocketKeepAliveTimeout() {
        deprecate2("agent.freeSocketKeepAliveTimeout is deprecated, please use agent.options.freeSocketTimeout instead");
        return this.options.freeSocketTimeout;
      }
      get timeout() {
        deprecate2("agent.timeout is deprecated, please use agent.options.timeout instead");
        return this.options.timeout;
      }
      get socketActiveTTL() {
        deprecate2("agent.socketActiveTTL is deprecated, please use agent.options.socketActiveTTL instead");
        return this.options.socketActiveTTL;
      }
      calcSocketTimeout(socket) {
        let freeSocketTimeout = this.options.freeSocketTimeout;
        const socketActiveTTL = this.options.socketActiveTTL;
        if (socketActiveTTL) {
          const aliveTime = Date.now() - socket[SOCKET_CREATED_TIME];
          const diff = socketActiveTTL - aliveTime;
          if (diff <= 0) {
            return diff;
          }
          if (freeSocketTimeout && diff < freeSocketTimeout) {
            freeSocketTimeout = diff;
          }
        }
        if (freeSocketTimeout) {
          const customFreeSocketTimeout = socket.freeSocketTimeout || socket.freeSocketKeepAliveTimeout;
          return customFreeSocketTimeout || freeSocketTimeout;
        }
      }
      keepSocketAlive(socket) {
        const result = super.keepSocketAlive(socket);
        if (!result) return result;
        const customTimeout = this.calcSocketTimeout(socket);
        if (typeof customTimeout === "undefined") {
          return true;
        }
        if (customTimeout <= 0) {
          debug3(
            "%s(requests: %s, finished: %s) free but need to destroy by TTL, request count %s, diff is %s",
            socket[SOCKET_NAME],
            socket[SOCKET_REQUEST_COUNT],
            socket[SOCKET_REQUEST_FINISHED_COUNT],
            customTimeout
          );
          return false;
        }
        if (socket.timeout !== customTimeout) {
          socket.setTimeout(customTimeout);
        }
        return true;
      }
      // only call on addRequest
      reuseSocket(...args) {
        super.reuseSocket(...args);
        const socket = args[0];
        const req = args[1];
        req.reusedSocket = true;
        const agentTimeout = this.options.timeout;
        if (getSocketTimeout(socket) !== agentTimeout) {
          socket.setTimeout(agentTimeout);
          debug3("%s reset timeout to %sms", socket[SOCKET_NAME], agentTimeout);
        }
        socket[SOCKET_REQUEST_COUNT]++;
        debug3(
          "%s(requests: %s, finished: %s) reuse on addRequest, timeout %sms",
          socket[SOCKET_NAME],
          socket[SOCKET_REQUEST_COUNT],
          socket[SOCKET_REQUEST_FINISHED_COUNT],
          getSocketTimeout(socket)
        );
      }
      [CREATE_ID]() {
        const id = this[CURRENT_ID]++;
        if (this[CURRENT_ID] === Number.MAX_SAFE_INTEGER) this[CURRENT_ID] = 0;
        return id;
      }
      [INIT_SOCKET](socket, options) {
        if (options.timeout) {
          const timeout = getSocketTimeout(socket);
          if (!timeout) {
            socket.setTimeout(options.timeout);
          }
        }
        if (this.options.keepAlive) {
          socket.setNoDelay(true);
        }
        this.createSocketCount++;
        if (this.options.socketActiveTTL) {
          socket[SOCKET_CREATED_TIME] = Date.now();
        }
        socket[SOCKET_NAME] = `sock[${this[CREATE_ID]()}#${options._agentKey}]`.split("-----BEGIN", 1)[0];
        socket[SOCKET_REQUEST_COUNT] = 1;
        socket[SOCKET_REQUEST_FINISHED_COUNT] = 0;
        installListeners(this, socket, options);
      }
      createConnection(options, oncreate) {
        let called = false;
        const onNewCreate = (err, socket) => {
          if (called) return;
          called = true;
          if (err) {
            this.createSocketErrorCount++;
            return oncreate(err);
          }
          this[INIT_SOCKET](socket, options);
          oncreate(err, socket);
        };
        const newSocket = super.createConnection(options, onNewCreate);
        if (newSocket) onNewCreate(null, newSocket);
        return newSocket;
      }
      get statusChanged() {
        const changed = this.createSocketCount !== this.createSocketCountLastCheck || this.createSocketErrorCount !== this.createSocketErrorCountLastCheck || this.closeSocketCount !== this.closeSocketCountLastCheck || this.errorSocketCount !== this.errorSocketCountLastCheck || this.timeoutSocketCount !== this.timeoutSocketCountLastCheck || this.requestCount !== this.requestCountLastCheck;
        if (changed) {
          this.createSocketCountLastCheck = this.createSocketCount;
          this.createSocketErrorCountLastCheck = this.createSocketErrorCount;
          this.closeSocketCountLastCheck = this.closeSocketCount;
          this.errorSocketCountLastCheck = this.errorSocketCount;
          this.timeoutSocketCountLastCheck = this.timeoutSocketCount;
          this.requestCountLastCheck = this.requestCount;
        }
        return changed;
      }
      getCurrentStatus() {
        return {
          createSocketCount: this.createSocketCount,
          createSocketErrorCount: this.createSocketErrorCount,
          closeSocketCount: this.closeSocketCount,
          errorSocketCount: this.errorSocketCount,
          timeoutSocketCount: this.timeoutSocketCount,
          requestCount: this.requestCount,
          freeSockets: inspect2(this.freeSockets),
          sockets: inspect2(this.sockets),
          requests: inspect2(this.requests)
        };
      }
    };
    function getSocketTimeout(socket) {
      return socket.timeout || socket._idleTimeout;
    }
    function installListeners(agent, socket, options) {
      debug3("%s create, timeout %sms", socket[SOCKET_NAME], getSocketTimeout(socket));
      function onFree() {
        if (!socket._httpMessage && socket[SOCKET_REQUEST_COUNT] === 1) return;
        socket[SOCKET_REQUEST_FINISHED_COUNT]++;
        agent.requestCount++;
        debug3(
          "%s(requests: %s, finished: %s) free",
          socket[SOCKET_NAME],
          socket[SOCKET_REQUEST_COUNT],
          socket[SOCKET_REQUEST_FINISHED_COUNT]
        );
        const name = agent.getName(options);
        if (socket.writable && agent.requests[name] && agent.requests[name].length) {
          socket[SOCKET_REQUEST_COUNT]++;
          debug3(
            "%s(requests: %s, finished: %s) will be reuse on agent free event",
            socket[SOCKET_NAME],
            socket[SOCKET_REQUEST_COUNT],
            socket[SOCKET_REQUEST_FINISHED_COUNT]
          );
        }
      }
      socket.on("free", onFree);
      function onClose(isError) {
        debug3(
          "%s(requests: %s, finished: %s) close, isError: %s",
          socket[SOCKET_NAME],
          socket[SOCKET_REQUEST_COUNT],
          socket[SOCKET_REQUEST_FINISHED_COUNT],
          isError
        );
        agent.closeSocketCount++;
      }
      socket.on("close", onClose);
      function onTimeout() {
        const listenerCount = socket.listeners("timeout").length;
        const timeout = getSocketTimeout(socket);
        const req = socket._httpMessage;
        const reqTimeoutListenerCount = req && req.listeners("timeout").length || 0;
        debug3(
          "%s(requests: %s, finished: %s) timeout after %sms, listeners %s, defaultTimeoutListenerCount %s, hasHttpRequest %s, HttpRequest timeoutListenerCount %s",
          socket[SOCKET_NAME],
          socket[SOCKET_REQUEST_COUNT],
          socket[SOCKET_REQUEST_FINISHED_COUNT],
          timeout,
          listenerCount,
          defaultTimeoutListenerCount,
          !!req,
          reqTimeoutListenerCount
        );
        if (debug3.enabled) {
          debug3("timeout listeners: %s", socket.listeners("timeout").map((f2) => f2.name).join(", "));
        }
        agent.timeoutSocketCount++;
        const name = agent.getName(options);
        if (agent.freeSockets[name] && agent.freeSockets[name].indexOf(socket) !== -1) {
          socket.destroy();
          agent.removeSocket(socket, options);
          debug3("%s is free, destroy quietly", socket[SOCKET_NAME]);
        } else {
          if (reqTimeoutListenerCount === 0) {
            const error = new Error("Socket timeout");
            error.code = "ERR_SOCKET_TIMEOUT";
            error.timeout = timeout;
            socket.destroy(error);
            agent.removeSocket(socket, options);
            debug3("%s destroy with timeout error", socket[SOCKET_NAME]);
          }
        }
      }
      socket.on("timeout", onTimeout);
      function onError(err) {
        const listenerCount = socket.listeners("error").length;
        debug3(
          "%s(requests: %s, finished: %s) error: %s, listenerCount: %s",
          socket[SOCKET_NAME],
          socket[SOCKET_REQUEST_COUNT],
          socket[SOCKET_REQUEST_FINISHED_COUNT],
          err,
          listenerCount
        );
        agent.errorSocketCount++;
        if (listenerCount === 1) {
          debug3("%s emit uncaught error event", socket[SOCKET_NAME]);
          socket.removeListener("error", onError);
          socket.emit("error", err);
        }
      }
      socket.on("error", onError);
      function onRemove() {
        debug3(
          "%s(requests: %s, finished: %s) agentRemove",
          socket[SOCKET_NAME],
          socket[SOCKET_REQUEST_COUNT],
          socket[SOCKET_REQUEST_FINISHED_COUNT]
        );
        socket.removeListener("close", onClose);
        socket.removeListener("error", onError);
        socket.removeListener("free", onFree);
        socket.removeListener("timeout", onTimeout);
        socket.removeListener("agentRemove", onRemove);
      }
      socket.on("agentRemove", onRemove);
    }
    module.exports = Agent;
    function inspect2(obj) {
      const res = {};
      for (const key in obj) {
        res[key] = obj[key].length;
      }
      return res;
    }
  }
});

// ../node_modules/agentkeepalive/lib/https_agent.js
var require_https_agent = __commonJS({
  "../node_modules/agentkeepalive/lib/https_agent.js"(exports, module) {
    "use strict";
    var OriginalHttpsAgent = __require("https").Agent;
    var HttpAgent = require_agent();
    var {
      INIT_SOCKET,
      CREATE_HTTPS_CONNECTION
    } = require_constants();
    var HttpsAgent = class extends HttpAgent {
      constructor(options) {
        super(options);
        this.defaultPort = 443;
        this.protocol = "https:";
        this.maxCachedSessions = this.options.maxCachedSessions;
        if (this.maxCachedSessions === void 0) {
          this.maxCachedSessions = 100;
        }
        this._sessionCache = {
          map: {},
          list: []
        };
      }
      createConnection(options, oncreate) {
        const socket = this[CREATE_HTTPS_CONNECTION](options, oncreate);
        this[INIT_SOCKET](socket, options);
        return socket;
      }
    };
    HttpsAgent.prototype[CREATE_HTTPS_CONNECTION] = OriginalHttpsAgent.prototype.createConnection;
    [
      "getName",
      "_getSession",
      "_cacheSession",
      // https://github.com/nodejs/node/pull/4982
      "_evictSession"
    ].forEach(function(method) {
      if (typeof OriginalHttpsAgent.prototype[method] === "function") {
        HttpsAgent.prototype[method] = OriginalHttpsAgent.prototype[method];
      }
    });
    module.exports = HttpsAgent;
  }
});

// ../node_modules/agentkeepalive/index.js
var require_agentkeepalive = __commonJS({
  "../node_modules/agentkeepalive/index.js"(exports, module) {
    "use strict";
    var HttpAgent = require_agent();
    module.exports = HttpAgent;
    module.exports.HttpAgent = HttpAgent;
    module.exports.HttpsAgent = require_https_agent();
    module.exports.constants = require_constants();
  }
});

// ../node_modules/event-target-shim/dist/event-target-shim.js
var require_event_target_shim = __commonJS({
  "../node_modules/event-target-shim/dist/event-target-shim.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var privateData = /* @__PURE__ */ new WeakMap();
    var wrappers = /* @__PURE__ */ new WeakMap();
    function pd(event) {
      const retv = privateData.get(event);
      console.assert(
        retv != null,
        "'this' is expected an Event object, but got",
        event
      );
      return retv;
    }
    function setCancelFlag(data) {
      if (data.passiveListener != null) {
        if (typeof console !== "undefined" && typeof console.error === "function") {
          console.error(
            "Unable to preventDefault inside passive event listener invocation.",
            data.passiveListener
          );
        }
        return;
      }
      if (!data.event.cancelable) {
        return;
      }
      data.canceled = true;
      if (typeof data.event.preventDefault === "function") {
        data.event.preventDefault();
      }
    }
    function Event(eventTarget, event) {
      privateData.set(this, {
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: false,
        stopped: false,
        immediateStopped: false,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now()
      });
      Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
      const keys = Object.keys(event);
      for (let i2 = 0; i2 < keys.length; ++i2) {
        const key = keys[i2];
        if (!(key in this)) {
          Object.defineProperty(this, key, defineRedirectDescriptor(key));
        }
      }
    }
    Event.prototype = {
      /**
       * The type of this event.
       * @type {string}
       */
      get type() {
        return pd(this).event.type;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       */
      get target() {
        return pd(this).eventTarget;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       */
      get currentTarget() {
        return pd(this).currentTarget;
      },
      /**
       * @returns {EventTarget[]} The composed path of this event.
       */
      composedPath() {
        const currentTarget = pd(this).currentTarget;
        if (currentTarget == null) {
          return [];
        }
        return [currentTarget];
      },
      /**
       * Constant of NONE.
       * @type {number}
       */
      get NONE() {
        return 0;
      },
      /**
       * Constant of CAPTURING_PHASE.
       * @type {number}
       */
      get CAPTURING_PHASE() {
        return 1;
      },
      /**
       * Constant of AT_TARGET.
       * @type {number}
       */
      get AT_TARGET() {
        return 2;
      },
      /**
       * Constant of BUBBLING_PHASE.
       * @type {number}
       */
      get BUBBLING_PHASE() {
        return 3;
      },
      /**
       * The target of this event.
       * @type {number}
       */
      get eventPhase() {
        return pd(this).eventPhase;
      },
      /**
       * Stop event bubbling.
       * @returns {void}
       */
      stopPropagation() {
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.stopPropagation === "function") {
          data.event.stopPropagation();
        }
      },
      /**
       * Stop event bubbling.
       * @returns {void}
       */
      stopImmediatePropagation() {
        const data = pd(this);
        data.stopped = true;
        data.immediateStopped = true;
        if (typeof data.event.stopImmediatePropagation === "function") {
          data.event.stopImmediatePropagation();
        }
      },
      /**
       * The flag to be bubbling.
       * @type {boolean}
       */
      get bubbles() {
        return Boolean(pd(this).event.bubbles);
      },
      /**
       * The flag to be cancelable.
       * @type {boolean}
       */
      get cancelable() {
        return Boolean(pd(this).event.cancelable);
      },
      /**
       * Cancel this event.
       * @returns {void}
       */
      preventDefault() {
        setCancelFlag(pd(this));
      },
      /**
       * The flag to indicate cancellation state.
       * @type {boolean}
       */
      get defaultPrevented() {
        return pd(this).canceled;
      },
      /**
       * The flag to be composed.
       * @type {boolean}
       */
      get composed() {
        return Boolean(pd(this).event.composed);
      },
      /**
       * The unix time of this event.
       * @type {number}
       */
      get timeStamp() {
        return pd(this).timeStamp;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       * @deprecated
       */
      get srcElement() {
        return pd(this).eventTarget;
      },
      /**
       * The flag to stop event bubbling.
       * @type {boolean}
       * @deprecated
       */
      get cancelBubble() {
        return pd(this).stopped;
      },
      set cancelBubble(value) {
        if (!value) {
          return;
        }
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.cancelBubble === "boolean") {
          data.event.cancelBubble = true;
        }
      },
      /**
       * The flag to indicate cancellation state.
       * @type {boolean}
       * @deprecated
       */
      get returnValue() {
        return !pd(this).canceled;
      },
      set returnValue(value) {
        if (!value) {
          setCancelFlag(pd(this));
        }
      },
      /**
       * Initialize this event object. But do nothing under event dispatching.
       * @param {string} type The event type.
       * @param {boolean} [bubbles=false] The flag to be possible to bubble up.
       * @param {boolean} [cancelable=false] The flag to be possible to cancel.
       * @deprecated
       */
      initEvent() {
      }
    };
    Object.defineProperty(Event.prototype, "constructor", {
      value: Event,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
      Object.setPrototypeOf(Event.prototype, window.Event.prototype);
      wrappers.set(window.Event.prototype, Event);
    }
    function defineRedirectDescriptor(key) {
      return {
        get() {
          return pd(this).event[key];
        },
        set(value) {
          pd(this).event[key] = value;
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineCallDescriptor(key) {
      return {
        value() {
          const event = pd(this).event;
          return event[key].apply(event, arguments);
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineWrapper(BaseEvent, proto) {
      const keys = Object.keys(proto);
      if (keys.length === 0) {
        return BaseEvent;
      }
      function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
      }
      CustomEvent.prototype = Object.create(BaseEvent.prototype, {
        constructor: { value: CustomEvent, configurable: true, writable: true }
      });
      for (let i2 = 0; i2 < keys.length; ++i2) {
        const key = keys[i2];
        if (!(key in BaseEvent.prototype)) {
          const descriptor = Object.getOwnPropertyDescriptor(proto, key);
          const isFunc = typeof descriptor.value === "function";
          Object.defineProperty(
            CustomEvent.prototype,
            key,
            isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key)
          );
        }
      }
      return CustomEvent;
    }
    function getWrapper(proto) {
      if (proto == null || proto === Object.prototype) {
        return Event;
      }
      let wrapper = wrappers.get(proto);
      if (wrapper == null) {
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
        wrappers.set(proto, wrapper);
      }
      return wrapper;
    }
    function wrapEvent(eventTarget, event) {
      const Wrapper = getWrapper(Object.getPrototypeOf(event));
      return new Wrapper(eventTarget, event);
    }
    function isStopped(event) {
      return pd(event).immediateStopped;
    }
    function setEventPhase(event, eventPhase) {
      pd(event).eventPhase = eventPhase;
    }
    function setCurrentTarget(event, currentTarget) {
      pd(event).currentTarget = currentTarget;
    }
    function setPassiveListener(event, passiveListener) {
      pd(event).passiveListener = passiveListener;
    }
    var listenersMap = /* @__PURE__ */ new WeakMap();
    var CAPTURE = 1;
    var BUBBLE = 2;
    var ATTRIBUTE = 3;
    function isObject(x2) {
      return x2 !== null && typeof x2 === "object";
    }
    function getListeners(eventTarget) {
      const listeners = listenersMap.get(eventTarget);
      if (listeners == null) {
        throw new TypeError(
          "'this' is expected an EventTarget object, but got another value."
        );
      }
      return listeners;
    }
    function defineEventAttributeDescriptor(eventName) {
      return {
        get() {
          const listeners = getListeners(this);
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              return node.listener;
            }
            node = node.next;
          }
          return null;
        },
        set(listener) {
          if (typeof listener !== "function" && !isObject(listener)) {
            listener = null;
          }
          const listeners = getListeners(this);
          let prev = null;
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              if (prev !== null) {
                prev.next = node.next;
              } else if (node.next !== null) {
                listeners.set(eventName, node.next);
              } else {
                listeners.delete(eventName);
              }
            } else {
              prev = node;
            }
            node = node.next;
          }
          if (listener !== null) {
            const newNode = {
              listener,
              listenerType: ATTRIBUTE,
              passive: false,
              once: false,
              next: null
            };
            if (prev === null) {
              listeners.set(eventName, newNode);
            } else {
              prev.next = newNode;
            }
          }
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineEventAttribute(eventTargetPrototype, eventName) {
      Object.defineProperty(
        eventTargetPrototype,
        `on${eventName}`,
        defineEventAttributeDescriptor(eventName)
      );
    }
    function defineCustomEventTarget(eventNames) {
      function CustomEventTarget() {
        EventTarget.call(this);
      }
      CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
        constructor: {
          value: CustomEventTarget,
          configurable: true,
          writable: true
        }
      });
      for (let i2 = 0; i2 < eventNames.length; ++i2) {
        defineEventAttribute(CustomEventTarget.prototype, eventNames[i2]);
      }
      return CustomEventTarget;
    }
    function EventTarget() {
      if (this instanceof EventTarget) {
        listenersMap.set(this, /* @__PURE__ */ new Map());
        return;
      }
      if (arguments.length === 1 && Array.isArray(arguments[0])) {
        return defineCustomEventTarget(arguments[0]);
      }
      if (arguments.length > 0) {
        const types2 = new Array(arguments.length);
        for (let i2 = 0; i2 < arguments.length; ++i2) {
          types2[i2] = arguments[i2];
        }
        return defineCustomEventTarget(types2);
      }
      throw new TypeError("Cannot call a class as a function");
    }
    EventTarget.prototype = {
      /**
       * Add a given listener to this event target.
       * @param {string} eventName The event name to add.
       * @param {Function} listener The listener to add.
       * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
       * @returns {void}
       */
      addEventListener(eventName, listener, options) {
        if (listener == null) {
          return;
        }
        if (typeof listener !== "function" && !isObject(listener)) {
          throw new TypeError("'listener' should be a function or an object.");
        }
        const listeners = getListeners(this);
        const optionsIsObj = isObject(options);
        const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        const newNode = {
          listener,
          listenerType,
          passive: optionsIsObj && Boolean(options.passive),
          once: optionsIsObj && Boolean(options.once),
          next: null
        };
        let node = listeners.get(eventName);
        if (node === void 0) {
          listeners.set(eventName, newNode);
          return;
        }
        let prev = null;
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            return;
          }
          prev = node;
          node = node.next;
        }
        prev.next = newNode;
      },
      /**
       * Remove a given listener from this event target.
       * @param {string} eventName The event name to remove.
       * @param {Function} listener The listener to remove.
       * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
       * @returns {void}
       */
      removeEventListener(eventName, listener, options) {
        if (listener == null) {
          return;
        }
        const listeners = getListeners(this);
        const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        let prev = null;
        let node = listeners.get(eventName);
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
            return;
          }
          prev = node;
          node = node.next;
        }
      },
      /**
       * Dispatch a given event.
       * @param {Event|{type:string}} event The event to dispatch.
       * @returns {boolean} `false` if canceled.
       */
      dispatchEvent(event) {
        if (event == null || typeof event.type !== "string") {
          throw new TypeError('"event.type" should be a string.');
        }
        const listeners = getListeners(this);
        const eventName = event.type;
        let node = listeners.get(eventName);
        if (node == null) {
          return true;
        }
        const wrappedEvent = wrapEvent(this, event);
        let prev = null;
        while (node != null) {
          if (node.once) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
          } else {
            prev = node;
          }
          setPassiveListener(
            wrappedEvent,
            node.passive ? node.listener : null
          );
          if (typeof node.listener === "function") {
            try {
              node.listener.call(this, wrappedEvent);
            } catch (err) {
              if (typeof console !== "undefined" && typeof console.error === "function") {
                console.error(err);
              }
            }
          } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
            node.listener.handleEvent(wrappedEvent);
          }
          if (isStopped(wrappedEvent)) {
            break;
          }
          node = node.next;
        }
        setPassiveListener(wrappedEvent, null);
        setEventPhase(wrappedEvent, 0);
        setCurrentTarget(wrappedEvent, null);
        return !wrappedEvent.defaultPrevented;
      }
    };
    Object.defineProperty(EventTarget.prototype, "constructor", {
      value: EventTarget,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
      Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
    }
    exports.defineEventAttribute = defineEventAttribute;
    exports.EventTarget = EventTarget;
    exports.default = EventTarget;
    module.exports = EventTarget;
    module.exports.EventTarget = module.exports["default"] = EventTarget;
    module.exports.defineEventAttribute = defineEventAttribute;
  }
});

// ../node_modules/abort-controller/dist/abort-controller.js
var require_abort_controller = __commonJS({
  "../node_modules/abort-controller/dist/abort-controller.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var eventTargetShim = require_event_target_shim();
    var AbortSignal2 = class extends eventTargetShim.EventTarget {
      /**
       * AbortSignal cannot be constructed directly.
       */
      constructor() {
        super();
        throw new TypeError("AbortSignal cannot be constructed directly");
      }
      /**
       * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.
       */
      get aborted() {
        const aborted = abortedFlags.get(this);
        if (typeof aborted !== "boolean") {
          throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        }
        return aborted;
      }
    };
    eventTargetShim.defineEventAttribute(AbortSignal2.prototype, "abort");
    function createAbortSignal() {
      const signal = Object.create(AbortSignal2.prototype);
      eventTargetShim.EventTarget.call(signal);
      abortedFlags.set(signal, false);
      return signal;
    }
    function abortSignal(signal) {
      if (abortedFlags.get(signal) !== false) {
        return;
      }
      abortedFlags.set(signal, true);
      signal.dispatchEvent({ type: "abort" });
    }
    var abortedFlags = /* @__PURE__ */ new WeakMap();
    Object.defineProperties(AbortSignal2.prototype, {
      aborted: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortSignal2.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortSignal"
      });
    }
    var AbortController2 = class {
      /**
       * Initialize this controller.
       */
      constructor() {
        signals.set(this, createAbortSignal());
      }
      /**
       * Returns the `AbortSignal` object associated with this object.
       */
      get signal() {
        return getSignal(this);
      }
      /**
       * Abort and signal to any observers that the associated activity is to be aborted.
       */
      abort() {
        abortSignal(getSignal(this));
      }
    };
    var signals = /* @__PURE__ */ new WeakMap();
    function getSignal(controller) {
      const signal = signals.get(controller);
      if (signal == null) {
        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
      }
      return signal;
    }
    Object.defineProperties(AbortController2.prototype, {
      signal: { enumerable: true },
      abort: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortController2.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortController"
      });
    }
    exports.AbortController = AbortController2;
    exports.AbortSignal = AbortSignal2;
    exports.default = AbortController2;
    module.exports = AbortController2;
    module.exports.AbortController = module.exports["default"] = AbortController2;
    module.exports.AbortSignal = AbortSignal2;
  }
});

// ../node_modules/node-domexception/index.js
var require_node_domexception = __commonJS({
  "../node_modules/node-domexception/index.js"(exports, module) {
    "use strict";
    if (!globalThis.DOMException) {
      try {
        const { MessageChannel } = __require("worker_threads"), port = new MessageChannel().port1, ab = new ArrayBuffer();
        port.postMessage(ab, [ab, ab]);
      } catch (err) {
        err.constructor.name === "DOMException" && (globalThis.DOMException = err.constructor);
      }
    }
    module.exports = globalThis.DOMException;
  }
});

// ../node_modules/formdata-node/lib/esm/isPlainObject.js
function isPlainObject2(value) {
  if (getType2(value) !== "object") {
    return false;
  }
  const pp = Object.getPrototypeOf(value);
  if (pp === null || pp === void 0) {
    return true;
  }
  const Ctor = pp.constructor && pp.constructor.toString();
  return Ctor === Object.toString();
}
var getType2, isPlainObject_default2;
var init_isPlainObject = __esm({
  "../node_modules/formdata-node/lib/esm/isPlainObject.js"() {
    "use strict";
    getType2 = (value) => Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
    isPlainObject_default2 = isPlainObject2;
  }
});

// ../node_modules/formdata-node/lib/esm/fileFromPath.js
var fileFromPath_exports = {};
__export(fileFromPath_exports, {
  fileFromPath: () => fileFromPath2,
  fileFromPathSync: () => fileFromPathSync,
  isFile: () => isFile
});
import { statSync, createReadStream, promises as fs } from "fs";
import { basename } from "path";
function createFileFromPath(path2, { mtimeMs, size }, filenameOrOptions, options = {}) {
  let filename;
  if (isPlainObject_default2(filenameOrOptions)) {
    [options, filename] = [filenameOrOptions, void 0];
  } else {
    filename = filenameOrOptions;
  }
  const file = new FileFromPath({ path: path2, size, lastModified: mtimeMs });
  if (!filename) {
    filename = file.name;
  }
  return new File2([file], filename, {
    ...options,
    lastModified: file.lastModified
  });
}
function fileFromPathSync(path2, filenameOrOptions, options = {}) {
  const stats = statSync(path2);
  return createFileFromPath(path2, stats, filenameOrOptions, options);
}
async function fileFromPath2(path2, filenameOrOptions, options) {
  const stats = await fs.stat(path2);
  return createFileFromPath(path2, stats, filenameOrOptions, options);
}
var import_node_domexception, __classPrivateFieldSet4, __classPrivateFieldGet5, _FileFromPath_path, _FileFromPath_start, MESSAGE, FileFromPath;
var init_fileFromPath = __esm({
  "../node_modules/formdata-node/lib/esm/fileFromPath.js"() {
    "use strict";
    import_node_domexception = __toESM(require_node_domexception(), 1);
    init_File();
    init_isPlainObject();
    init_isFile();
    __classPrivateFieldSet4 = function(receiver, state, value, kind3, f2) {
      if (kind3 === "m") throw new TypeError("Private method is not writable");
      if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind3 === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldGet5 = function(receiver, state, kind3, f2) {
      if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind3 === "m" ? f2 : kind3 === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
    };
    MESSAGE = "The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.";
    FileFromPath = class _FileFromPath {
      constructor(input) {
        _FileFromPath_path.set(this, void 0);
        _FileFromPath_start.set(this, void 0);
        __classPrivateFieldSet4(this, _FileFromPath_path, input.path, "f");
        __classPrivateFieldSet4(this, _FileFromPath_start, input.start || 0, "f");
        this.name = basename(__classPrivateFieldGet5(this, _FileFromPath_path, "f"));
        this.size = input.size;
        this.lastModified = input.lastModified;
      }
      slice(start, end) {
        return new _FileFromPath({
          path: __classPrivateFieldGet5(this, _FileFromPath_path, "f"),
          lastModified: this.lastModified,
          size: end - start,
          start
        });
      }
      async *stream() {
        const { mtimeMs } = await fs.stat(__classPrivateFieldGet5(this, _FileFromPath_path, "f"));
        if (mtimeMs > this.lastModified) {
          throw new import_node_domexception.default(MESSAGE, "NotReadableError");
        }
        if (this.size) {
          yield* createReadStream(__classPrivateFieldGet5(this, _FileFromPath_path, "f"), {
            start: __classPrivateFieldGet5(this, _FileFromPath_start, "f"),
            end: __classPrivateFieldGet5(this, _FileFromPath_start, "f") + this.size - 1
          });
        }
      }
      get [(_FileFromPath_path = /* @__PURE__ */ new WeakMap(), _FileFromPath_start = /* @__PURE__ */ new WeakMap(), Symbol.toStringTag)]() {
        return "File";
      }
    };
  }
});

// ../node_modules/extend/index.js
var require_extend = __commonJS({
  "../node_modules/extend/index.js"(exports, module) {
    "use strict";
    var hasOwn3 = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray = function isArray2(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject3 = function isPlainObject4(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn3.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn3.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn3.call(obj, key);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty && options.name === "__proto__") {
        defineProperty(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name) {
      if (name === "__proto__") {
        if (!hasOwn3.call(obj, name)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name).value;
        }
      }
      return obj[name];
    };
    module.exports = function extend() {
      var options, name, src, copy, copyIsArray, clone2;
      var target = arguments[0];
      var i2 = 1;
      var length = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i2 = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i2 < length; ++i2) {
        options = arguments[i2];
        if (options != null) {
          for (name in options) {
            src = getProperty(target, name);
            copy = getProperty(options, name);
            if (target !== copy) {
              if (deep && copy && (isPlainObject3(copy) || (copyIsArray = isArray(copy)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone2 = src && isArray(src) ? src : [];
                } else {
                  clone2 = src && isPlainObject3(src) ? src : {};
                }
                setProperty(target, { name, newValue: extend(deep, clone2, copy) });
              } else if (typeof copy !== "undefined") {
                setProperty(target, { name, newValue: copy });
              }
            }
          }
        }
      }
      return target;
    };
  }
});

// ../node_modules/gaxios/node_modules/is-stream/index.js
var require_is_stream = __commonJS({
  "../node_modules/gaxios/node_modules/is-stream/index.js"(exports, module) {
    "use strict";
    var isStream = (stream) => stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
    isStream.writable = (stream) => isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
    isStream.readable = (stream) => isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
    isStream.duplex = (stream) => isStream.writable(stream) && isStream.readable(stream);
    isStream.transform = (stream) => isStream.duplex(stream) && typeof stream._transform === "function";
    module.exports = isStream;
  }
});

// ../node_modules/gaxios/package.json
var require_package = __commonJS({
  "../node_modules/gaxios/package.json"(exports, module) {
    module.exports = {
      name: "gaxios",
      version: "6.7.1",
      description: "A simple common HTTP client specifically for Google APIs and services.",
      main: "build/src/index.js",
      types: "build/src/index.d.ts",
      files: [
        "build/src"
      ],
      scripts: {
        lint: "gts check",
        test: "c8 mocha build/test",
        "presystem-test": "npm run compile",
        "system-test": "mocha build/system-test --timeout 80000",
        compile: "tsc -p .",
        fix: "gts fix",
        prepare: "npm run compile",
        pretest: "npm run compile",
        webpack: "webpack",
        "prebrowser-test": "npm run compile",
        "browser-test": "node build/browser-test/browser-test-runner.js",
        docs: "compodoc src/",
        "docs-test": "linkinator docs",
        "predocs-test": "npm run docs",
        "samples-test": "cd samples/ && npm link ../ && npm test && cd ../",
        prelint: "cd samples; npm link ../; npm install",
        clean: "gts clean",
        precompile: "gts clean"
      },
      repository: "googleapis/gaxios",
      keywords: [
        "google"
      ],
      engines: {
        node: ">=14"
      },
      author: "Google, LLC",
      license: "Apache-2.0",
      devDependencies: {
        "@babel/plugin-proposal-private-methods": "^7.18.6",
        "@compodoc/compodoc": "1.1.19",
        "@types/cors": "^2.8.6",
        "@types/express": "^4.16.1",
        "@types/extend": "^3.0.1",
        "@types/mocha": "^9.0.0",
        "@types/multiparty": "0.0.36",
        "@types/mv": "^2.1.0",
        "@types/ncp": "^2.0.1",
        "@types/node": "^20.0.0",
        "@types/node-fetch": "^2.5.7",
        "@types/sinon": "^17.0.0",
        "@types/tmp": "0.2.6",
        "@types/uuid": "^10.0.0",
        "abort-controller": "^3.0.0",
        assert: "^2.0.0",
        browserify: "^17.0.0",
        c8: "^8.0.0",
        cheerio: "1.0.0-rc.10",
        cors: "^2.8.5",
        execa: "^5.0.0",
        express: "^4.16.4",
        "form-data": "^4.0.0",
        gts: "^5.0.0",
        "is-docker": "^2.0.0",
        karma: "^6.0.0",
        "karma-chrome-launcher": "^3.0.0",
        "karma-coverage": "^2.0.0",
        "karma-firefox-launcher": "^2.0.0",
        "karma-mocha": "^2.0.0",
        "karma-remap-coverage": "^0.1.5",
        "karma-sourcemap-loader": "^0.4.0",
        "karma-webpack": "5.0.0",
        linkinator: "^3.0.0",
        mocha: "^8.0.0",
        multiparty: "^4.2.1",
        mv: "^2.1.1",
        ncp: "^2.0.0",
        nock: "^13.0.0",
        "null-loader": "^4.0.0",
        puppeteer: "^19.0.0",
        sinon: "^18.0.0",
        "stream-browserify": "^3.0.0",
        tmp: "0.2.3",
        "ts-loader": "^8.0.0",
        typescript: "^5.1.6",
        webpack: "^5.35.0",
        "webpack-cli": "^4.0.0"
      },
      dependencies: {
        extend: "^3.0.2",
        "https-proxy-agent": "^7.0.1",
        "is-stream": "^2.0.0",
        "node-fetch": "^2.6.9",
        uuid: "^9.0.1"
      }
    };
  }
});

// ../node_modules/gaxios/build/src/util.js
var require_util = __commonJS({
  "../node_modules/gaxios/build/src/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pkg = void 0;
    exports.pkg = require_package();
  }
});

// ../node_modules/gaxios/build/src/common.js
var require_common = __commonJS({
  "../node_modules/gaxios/build/src/common.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _a3;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GaxiosError = exports.GAXIOS_ERROR_SYMBOL = void 0;
    exports.defaultErrorRedactor = defaultErrorRedactor;
    var url_1 = __require("url");
    var util_1 = require_util();
    var extend_1 = __importDefault(require_extend());
    exports.GAXIOS_ERROR_SYMBOL = Symbol.for(`${util_1.pkg.name}-gaxios-error`);
    var GaxiosError = class _GaxiosError extends Error {
      /**
       * Support `instanceof` operator for `GaxiosError` across builds/duplicated files.
       *
       * @see {@link GAXIOS_ERROR_SYMBOL}
       * @see {@link GaxiosError[GAXIOS_ERROR_SYMBOL]}
       */
      static [(_a3 = exports.GAXIOS_ERROR_SYMBOL, Symbol.hasInstance)](instance) {
        if (instance && typeof instance === "object" && exports.GAXIOS_ERROR_SYMBOL in instance && instance[exports.GAXIOS_ERROR_SYMBOL] === util_1.pkg.version) {
          return true;
        }
        return Function.prototype[Symbol.hasInstance].call(_GaxiosError, instance);
      }
      constructor(message, config, response, error) {
        var _b;
        super(message);
        this.config = config;
        this.response = response;
        this.error = error;
        this[_a3] = util_1.pkg.version;
        this.config = (0, extend_1.default)(true, {}, config);
        if (this.response) {
          this.response.config = (0, extend_1.default)(true, {}, this.response.config);
        }
        if (this.response) {
          try {
            this.response.data = translateData(this.config.responseType, (_b = this.response) === null || _b === void 0 ? void 0 : _b.data);
          } catch (_c) {
          }
          this.status = this.response.status;
        }
        if (error && "code" in error && error.code) {
          this.code = error.code;
        }
        if (config.errorRedactor) {
          config.errorRedactor({
            config: this.config,
            response: this.response
          });
        }
      }
    };
    exports.GaxiosError = GaxiosError;
    function translateData(responseType, data) {
      switch (responseType) {
        case "stream":
          return data;
        case "json":
          return JSON.parse(JSON.stringify(data));
        case "arraybuffer":
          return JSON.parse(Buffer.from(data).toString("utf8"));
        case "blob":
          return JSON.parse(data.text());
        default:
          return data;
      }
    }
    function defaultErrorRedactor(data) {
      const REDACT = "<<REDACTED> - See `errorRedactor` option in `gaxios` for configuration>.";
      function redactHeaders(headers) {
        if (!headers)
          return;
        for (const key of Object.keys(headers)) {
          if (/^authentication$/i.test(key)) {
            headers[key] = REDACT;
          }
          if (/^authorization$/i.test(key)) {
            headers[key] = REDACT;
          }
          if (/secret/i.test(key)) {
            headers[key] = REDACT;
          }
        }
      }
      function redactString(obj, key) {
        if (typeof obj === "object" && obj !== null && typeof obj[key] === "string") {
          const text = obj[key];
          if (/grant_type=/i.test(text) || /assertion=/i.test(text) || /secret/i.test(text)) {
            obj[key] = REDACT;
          }
        }
      }
      function redactObject(obj) {
        if (typeof obj === "object" && obj !== null) {
          if ("grant_type" in obj) {
            obj["grant_type"] = REDACT;
          }
          if ("assertion" in obj) {
            obj["assertion"] = REDACT;
          }
          if ("client_secret" in obj) {
            obj["client_secret"] = REDACT;
          }
        }
      }
      if (data.config) {
        redactHeaders(data.config.headers);
        redactString(data.config, "data");
        redactObject(data.config.data);
        redactString(data.config, "body");
        redactObject(data.config.body);
        try {
          const url = new url_1.URL("", data.config.url);
          if (url.searchParams.has("token")) {
            url.searchParams.set("token", REDACT);
          }
          if (url.searchParams.has("client_secret")) {
            url.searchParams.set("client_secret", REDACT);
          }
          data.config.url = url.toString();
        } catch (_b) {
        }
      }
      if (data.response) {
        defaultErrorRedactor({ config: data.response.config });
        redactHeaders(data.response.headers);
        redactString(data.response, "data");
        redactObject(data.response.data);
      }
      return data;
    }
  }
});

// ../node_modules/gaxios/build/src/retry.js
var require_retry = __commonJS({
  "../node_modules/gaxios/build/src/retry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRetryConfig = getRetryConfig;
    async function getRetryConfig(err) {
      let config = getConfig(err);
      if (!err || !err.config || !config && !err.config.retry) {
        return { shouldRetry: false };
      }
      config = config || {};
      config.currentRetryAttempt = config.currentRetryAttempt || 0;
      config.retry = config.retry === void 0 || config.retry === null ? 3 : config.retry;
      config.httpMethodsToRetry = config.httpMethodsToRetry || [
        "GET",
        "HEAD",
        "PUT",
        "OPTIONS",
        "DELETE"
      ];
      config.noResponseRetries = config.noResponseRetries === void 0 || config.noResponseRetries === null ? 2 : config.noResponseRetries;
      config.retryDelayMultiplier = config.retryDelayMultiplier ? config.retryDelayMultiplier : 2;
      config.timeOfFirstRequest = config.timeOfFirstRequest ? config.timeOfFirstRequest : Date.now();
      config.totalTimeout = config.totalTimeout ? config.totalTimeout : Number.MAX_SAFE_INTEGER;
      config.maxRetryDelay = config.maxRetryDelay ? config.maxRetryDelay : Number.MAX_SAFE_INTEGER;
      const retryRanges = [
        // https://en.wikipedia.org/wiki/List_of_HTTP_status_codes
        // 1xx - Retry (Informational, request still processing)
        // 2xx - Do not retry (Success)
        // 3xx - Do not retry (Redirect)
        // 4xx - Do not retry (Client errors)
        // 408 - Retry ("Request Timeout")
        // 429 - Retry ("Too Many Requests")
        // 5xx - Retry (Server errors)
        [100, 199],
        [408, 408],
        [429, 429],
        [500, 599]
      ];
      config.statusCodesToRetry = config.statusCodesToRetry || retryRanges;
      err.config.retryConfig = config;
      const shouldRetryFn = config.shouldRetry || shouldRetryRequest;
      if (!await shouldRetryFn(err)) {
        return { shouldRetry: false, config: err.config };
      }
      const delay = getNextRetryDelay(config);
      err.config.retryConfig.currentRetryAttempt += 1;
      const backoff = config.retryBackoff ? config.retryBackoff(err, delay) : new Promise((resolve) => {
        setTimeout(resolve, delay);
      });
      if (config.onRetryAttempt) {
        config.onRetryAttempt(err);
      }
      await backoff;
      return { shouldRetry: true, config: err.config };
    }
    function shouldRetryRequest(err) {
      var _a3;
      const config = getConfig(err);
      if (err.name === "AbortError" || ((_a3 = err.error) === null || _a3 === void 0 ? void 0 : _a3.name) === "AbortError") {
        return false;
      }
      if (!config || config.retry === 0) {
        return false;
      }
      if (!err.response && (config.currentRetryAttempt || 0) >= config.noResponseRetries) {
        return false;
      }
      if (!err.config.method || config.httpMethodsToRetry.indexOf(err.config.method.toUpperCase()) < 0) {
        return false;
      }
      if (err.response && err.response.status) {
        let isInRange = false;
        for (const [min, max] of config.statusCodesToRetry) {
          const status = err.response.status;
          if (status >= min && status <= max) {
            isInRange = true;
            break;
          }
        }
        if (!isInRange) {
          return false;
        }
      }
      config.currentRetryAttempt = config.currentRetryAttempt || 0;
      if (config.currentRetryAttempt >= config.retry) {
        return false;
      }
      return true;
    }
    function getConfig(err) {
      if (err && err.config && err.config.retryConfig) {
        return err.config.retryConfig;
      }
      return;
    }
    function getNextRetryDelay(config) {
      var _a3;
      const retryDelay = config.currentRetryAttempt ? 0 : (_a3 = config.retryDelay) !== null && _a3 !== void 0 ? _a3 : 100;
      const calculatedDelay = retryDelay + (Math.pow(config.retryDelayMultiplier, config.currentRetryAttempt) - 1) / 2 * 1e3;
      const maxAllowableDelay = config.totalTimeout - (Date.now() - config.timeOfFirstRequest);
      return Math.min(calculatedDelay, maxAllowableDelay, config.maxRetryDelay);
    }
  }
});

// ../node_modules/gaxios/node_modules/uuid/dist/esm-node/rng.js
import crypto2 from "crypto";
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    crypto2.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
var rnds8Pool, poolPtr;
var init_rng = __esm({
  "../node_modules/gaxios/node_modules/uuid/dist/esm-node/rng.js"() {
    "use strict";
    rnds8Pool = new Uint8Array(256);
    poolPtr = rnds8Pool.length;
  }
});

// ../node_modules/gaxios/node_modules/uuid/dist/esm-node/regex.js
var regex_default;
var init_regex = __esm({
  "../node_modules/gaxios/node_modules/uuid/dist/esm-node/regex.js"() {
    "use strict";
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  }
});

// ../node_modules/gaxios/node_modules/uuid/dist/esm-node/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate = __esm({
  "../node_modules/gaxios/node_modules/uuid/dist/esm-node/validate.js"() {
    "use strict";
    init_regex();
    validate_default = validate;
  }
});

// ../node_modules/gaxios/node_modules/uuid/dist/esm-node/stringify.js
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
function stringify(arr, offset = 0) {
  const uuid = unsafeStringify(arr, offset);
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex, stringify_default;
var init_stringify = __esm({
  "../node_modules/gaxios/node_modules/uuid/dist/esm-node/stringify.js"() {
    "use strict";
    init_validate();
    byteToHex = [];
    for (let i2 = 0; i2 < 256; ++i2) {
      byteToHex.push((i2 + 256).toString(16).slice(1));
    }
    stringify_default = stringify;
  }
});

// ../node_modules/gaxios/node_modules/uuid/dist/esm-node/v1.js
function v1(options, buf, offset) {
  let i2 = buf && offset || 0;
  const b2 = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  const dt2 = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt2 < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt2 < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b2[i2++] = tl >>> 24 & 255;
  b2[i2++] = tl >>> 16 & 255;
  b2[i2++] = tl >>> 8 & 255;
  b2[i2++] = tl & 255;
  const tmh = msecs / 4294967296 * 1e4 & 268435455;
  b2[i2++] = tmh >>> 8 & 255;
  b2[i2++] = tmh & 255;
  b2[i2++] = tmh >>> 24 & 15 | 16;
  b2[i2++] = tmh >>> 16 & 255;
  b2[i2++] = clockseq >>> 8 | 128;
  b2[i2++] = clockseq & 255;
  for (let n2 = 0; n2 < 6; ++n2) {
    b2[i2 + n2] = node[n2];
  }
  return buf || unsafeStringify(b2);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "../node_modules/gaxios/node_modules/uuid/dist/esm-node/v1.js"() {
    "use strict";
    init_rng();
    init_stringify();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  }
});

// ../node_modules/gaxios/node_modules/uuid/dist/esm-node/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v2;
  const arr = new Uint8Array(16);
  arr[0] = (v2 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v2 >>> 16 & 255;
  arr[2] = v2 >>> 8 & 255;
  arr[3] = v2 & 255;
  arr[4] = (v2 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v2 & 255;
  arr[6] = (v2 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v2 & 255;
  arr[8] = (v2 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v2 & 255;
  arr[10] = (v2 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v2 / 4294967296 & 255;
  arr[12] = v2 >>> 24 & 255;
  arr[13] = v2 >>> 16 & 255;
  arr[14] = v2 >>> 8 & 255;
  arr[15] = v2 & 255;
  return arr;
}
var parse_default;
var init_parse = __esm({
  "../node_modules/gaxios/node_modules/uuid/dist/esm-node/parse.js"() {
    "use strict";
    init_validate();
    parse_default = parse;
  }
});

// ../node_modules/gaxios/node_modules/uuid/dist/esm-node/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i2 = 0; i2 < str.length; ++i2) {
    bytes.push(str.charCodeAt(i2));
  }
  return bytes;
}
function v35(name, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i2 = 0; i2 < 16; ++i2) {
        buf[offset + i2] = bytes[i2];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL3;
  return generateUUID;
}
var DNS, URL3;
var init_v35 = __esm({
  "../node_modules/gaxios/node_modules/uuid/dist/esm-node/v35.js"() {
    "use strict";
    init_stringify();
    init_parse();
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL3 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// ../node_modules/gaxios/node_modules/uuid/dist/esm-node/md5.js
import crypto3 from "crypto";
function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return crypto3.createHash("md5").update(bytes).digest();
}
var md5_default;
var init_md5 = __esm({
  "../node_modules/gaxios/node_modules/uuid/dist/esm-node/md5.js"() {
    "use strict";
    md5_default = md5;
  }
});

// ../node_modules/gaxios/node_modules/uuid/dist/esm-node/v3.js
var v3, v3_default;
var init_v3 = __esm({
  "../node_modules/gaxios/node_modules/uuid/dist/esm-node/v3.js"() {
    "use strict";
    init_v35();
    init_md5();
    v3 = v35("v3", 48, md5_default);
    v3_default = v3;
  }
});

// ../node_modules/gaxios/node_modules/uuid/dist/esm-node/native.js
import crypto4 from "crypto";
var native_default;
var init_native = __esm({
  "../node_modules/gaxios/node_modules/uuid/dist/esm-node/native.js"() {
    "use strict";
    native_default = {
      randomUUID: crypto4.randomUUID
    };
  }
});

// ../node_modules/gaxios/node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i2 = 0; i2 < 16; ++i2) {
      buf[offset + i2] = rnds[i2];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default;
var init_v4 = __esm({
  "../node_modules/gaxios/node_modules/uuid/dist/esm-node/v4.js"() {
    "use strict";
    init_native();
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// ../node_modules/gaxios/node_modules/uuid/dist/esm-node/sha1.js
import crypto5 from "crypto";
function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return crypto5.createHash("sha1").update(bytes).digest();
}
var sha1_default;
var init_sha1 = __esm({
  "../node_modules/gaxios/node_modules/uuid/dist/esm-node/sha1.js"() {
    "use strict";
    sha1_default = sha1;
  }
});

// ../node_modules/gaxios/node_modules/uuid/dist/esm-node/v5.js
var v5, v5_default;
var init_v5 = __esm({
  "../node_modules/gaxios/node_modules/uuid/dist/esm-node/v5.js"() {
    "use strict";
    init_v35();
    init_sha1();
    v5 = v35("v5", 80, sha1_default);
    v5_default = v5;
  }
});

// ../node_modules/gaxios/node_modules/uuid/dist/esm-node/nil.js
var nil_default;
var init_nil = __esm({
  "../node_modules/gaxios/node_modules/uuid/dist/esm-node/nil.js"() {
    "use strict";
    nil_default = "00000000-0000-0000-0000-000000000000";
  }
});

// ../node_modules/gaxios/node_modules/uuid/dist/esm-node/version.js
function version(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.slice(14, 15), 16);
}
var version_default;
var init_version = __esm({
  "../node_modules/gaxios/node_modules/uuid/dist/esm-node/version.js"() {
    "use strict";
    init_validate();
    version_default = version;
  }
});

// ../node_modules/gaxios/node_modules/uuid/dist/esm-node/index.js
var esm_node_exports = {};
__export(esm_node_exports, {
  NIL: () => nil_default,
  parse: () => parse_default,
  stringify: () => stringify_default,
  v1: () => v1_default,
  v3: () => v3_default,
  v4: () => v4_default,
  v5: () => v5_default,
  validate: () => validate_default,
  version: () => version_default
});
var init_esm_node = __esm({
  "../node_modules/gaxios/node_modules/uuid/dist/esm-node/index.js"() {
    "use strict";
    init_v1();
    init_v3();
    init_v4();
    init_v5();
    init_nil();
    init_version();
    init_validate();
    init_stringify();
    init_parse();
  }
});

// ../node_modules/gaxios/build/src/interceptor.js
var require_interceptor = __commonJS({
  "../node_modules/gaxios/build/src/interceptor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GaxiosInterceptorManager = void 0;
    var GaxiosInterceptorManager = class extends Set {
    };
    exports.GaxiosInterceptorManager = GaxiosInterceptorManager;
  }
});

// ../node_modules/debug/src/common.js
var require_common2 = __commonJS({
  "../node_modules/debug/src/common.js"(exports, module) {
    "use strict";
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i2 = 0; i2 < namespace.length; i2++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i2);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug3(...args) {
          if (!debug3.enabled) {
            return;
          }
          const self2 = debug3;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match7, format) => {
            if (match7 === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match7 = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match7;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug3.namespace = namespace;
        debug3.useColors = createDebug.useColors();
        debug3.color = createDebug.selectColor(namespace);
        debug3.extend = extend;
        debug3.destroy = createDebug.destroy;
        Object.defineProperty(debug3, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v2) => {
            enableOverride = v2;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug3);
        }
        return debug3;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// ../node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../node_modules/debug/src/browser.js"(exports, module) {
    "use strict";
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m2;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m2[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match7) => {
        if (match7 === "%%") {
          return;
        }
        index++;
        if (match7 === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c2);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r2;
      try {
        r2 = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r2 && typeof process !== "undefined" && "env" in process) {
        r2 = process.env.DEBUG;
      }
      return r2;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common2()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v2) {
      try {
        return JSON.stringify(v2);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// ../node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "../node_modules/has-flag/index.js"(exports, module) {
    "use strict";
    module.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// ../node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "../node_modules/supports-color/index.js"(exports, module) {
    "use strict";
    var os = __require("os");
    var tty = __require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var flagForceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      flagForceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      flagForceColor = 1;
    }
    function envForceColor() {
      if ("FORCE_COLOR" in env) {
        if (env.FORCE_COLOR === "true") {
          return 1;
        }
        if (env.FORCE_COLOR === "false") {
          return 0;
        }
        return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
      const noFlagForceColor = envForceColor();
      if (noFlagForceColor !== void 0) {
        flagForceColor = noFlagForceColor;
      }
      const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
      if (forceColor === 0) {
        return 0;
      }
      if (sniffFlags) {
        if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
          return 3;
        }
        if (hasFlag("color=256")) {
          return 2;
        }
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE", "DRONE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version2 = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream, options = {}) {
      const level = supportsColor(stream, {
        streamIsTTY: stream && stream.isTTY,
        ...options
      });
      return translateLevel(level);
    }
    module.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel({ isTTY: tty.isatty(1) }),
      stderr: getSupportLevel({ isTTY: tty.isatty(2) })
    };
  }
});

// ../node_modules/debug/src/node.js
var require_node = __commonJS({
  "../node_modules/debug/src/node.js"(exports, module) {
    "use strict";
    var tty = __require("tty");
    var util = __require("util");
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k2) => {
        return k2.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c2 = this.color;
        const colorCode = "\x1B[3" + (c2 < 8 ? c2 : "8;5;" + c2);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug3) {
      debug3.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i2 = 0; i2 < keys.length; i2++) {
        debug3.inspectOpts[keys[i2]] = exports.inspectOpts[keys[i2]];
      }
    }
    module.exports = require_common2()(exports);
    var { formatters } = module.exports;
    formatters.o = function(v2) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v2, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v2) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v2, this.inspectOpts);
    };
  }
});

// ../node_modules/debug/src/index.js
var require_src = __commonJS({
  "../node_modules/debug/src/index.js"(exports, module) {
    "use strict";
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module.exports = require_browser();
    } else {
      module.exports = require_node();
    }
  }
});

// ../node_modules/agent-base/dist/helpers.js
var require_helpers = __commonJS({
  "../node_modules/agent-base/dist/helpers.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.req = exports.json = exports.toBuffer = void 0;
    var http2 = __importStar(__require("http"));
    var https2 = __importStar(__require("https"));
    async function toBuffer(stream) {
      let length = 0;
      const chunks = [];
      for await (const chunk of stream) {
        length += chunk.length;
        chunks.push(chunk);
      }
      return Buffer.concat(chunks, length);
    }
    exports.toBuffer = toBuffer;
    async function json(stream) {
      const buf = await toBuffer(stream);
      const str = buf.toString("utf8");
      try {
        return JSON.parse(str);
      } catch (_err) {
        const err = _err;
        err.message += ` (input: ${str})`;
        throw err;
      }
    }
    exports.json = json;
    function req(url, opts = {}) {
      const href = typeof url === "string" ? url : url.href;
      const req2 = (href.startsWith("https:") ? https2 : http2).request(url, opts);
      const promise = new Promise((resolve, reject) => {
        req2.once("response", resolve).once("error", reject).end();
      });
      req2.then = promise.then.bind(promise);
      return req2;
    }
    exports.req = req;
  }
});

// ../node_modules/agent-base/dist/index.js
var require_dist = __commonJS({
  "../node_modules/agent-base/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Agent = void 0;
    var net = __importStar(__require("net"));
    var http2 = __importStar(__require("http"));
    var https_1 = __require("https");
    __exportStar(require_helpers(), exports);
    var INTERNAL2 = Symbol("AgentBaseInternalState");
    var Agent = class extends http2.Agent {
      constructor(opts) {
        super(opts);
        this[INTERNAL2] = {};
      }
      /**
       * Determine whether this is an `http` or `https` request.
       */
      isSecureEndpoint(options) {
        if (options) {
          if (typeof options.secureEndpoint === "boolean") {
            return options.secureEndpoint;
          }
          if (typeof options.protocol === "string") {
            return options.protocol === "https:";
          }
        }
        const { stack } = new Error();
        if (typeof stack !== "string")
          return false;
        return stack.split("\n").some((l2) => l2.indexOf("(https.js:") !== -1 || l2.indexOf("node:https:") !== -1);
      }
      // In order to support async signatures in `connect()` and Node's native
      // connection pooling in `http.Agent`, the array of sockets for each origin
      // has to be updated synchronously. This is so the length of the array is
      // accurate when `addRequest()` is next called. We achieve this by creating a
      // fake socket and adding it to `sockets[origin]` and incrementing
      // `totalSocketCount`.
      incrementSockets(name) {
        if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {
          return null;
        }
        if (!this.sockets[name]) {
          this.sockets[name] = [];
        }
        const fakeSocket = new net.Socket({ writable: false });
        this.sockets[name].push(fakeSocket);
        this.totalSocketCount++;
        return fakeSocket;
      }
      decrementSockets(name, socket) {
        if (!this.sockets[name] || socket === null) {
          return;
        }
        const sockets = this.sockets[name];
        const index = sockets.indexOf(socket);
        if (index !== -1) {
          sockets.splice(index, 1);
          this.totalSocketCount--;
          if (sockets.length === 0) {
            delete this.sockets[name];
          }
        }
      }
      // In order to properly update the socket pool, we need to call `getName()` on
      // the core `https.Agent` if it is a secureEndpoint.
      getName(options) {
        const secureEndpoint = this.isSecureEndpoint(options);
        if (secureEndpoint) {
          return https_1.Agent.prototype.getName.call(this, options);
        }
        return super.getName(options);
      }
      createSocket(req, options, cb) {
        const connectOpts = {
          ...options,
          secureEndpoint: this.isSecureEndpoint(options)
        };
        const name = this.getName(connectOpts);
        const fakeSocket = this.incrementSockets(name);
        Promise.resolve().then(() => this.connect(req, connectOpts)).then((socket) => {
          this.decrementSockets(name, fakeSocket);
          if (socket instanceof http2.Agent) {
            try {
              return socket.addRequest(req, connectOpts);
            } catch (err) {
              return cb(err);
            }
          }
          this[INTERNAL2].currentSocket = socket;
          super.createSocket(req, options, cb);
        }, (err) => {
          this.decrementSockets(name, fakeSocket);
          cb(err);
        });
      }
      createConnection() {
        const socket = this[INTERNAL2].currentSocket;
        this[INTERNAL2].currentSocket = void 0;
        if (!socket) {
          throw new Error("No socket was returned in the `connect()` function");
        }
        return socket;
      }
      get defaultPort() {
        return this[INTERNAL2].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
      }
      set defaultPort(v2) {
        if (this[INTERNAL2]) {
          this[INTERNAL2].defaultPort = v2;
        }
      }
      get protocol() {
        return this[INTERNAL2].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
      }
      set protocol(v2) {
        if (this[INTERNAL2]) {
          this[INTERNAL2].protocol = v2;
        }
      }
    };
    exports.Agent = Agent;
  }
});

// ../node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS({
  "../node_modules/https-proxy-agent/dist/parse-proxy-response.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseProxyResponse = void 0;
    var debug_1 = __importDefault(require_src());
    var debug3 = (0, debug_1.default)("https-proxy-agent:parse-proxy-response");
    function parseProxyResponse(socket) {
      return new Promise((resolve, reject) => {
        let buffersLength = 0;
        const buffers = [];
        function read() {
          const b2 = socket.read();
          if (b2)
            ondata(b2);
          else
            socket.once("readable", read);
        }
        function cleanup() {
          socket.removeListener("end", onend);
          socket.removeListener("error", onerror);
          socket.removeListener("readable", read);
        }
        function onend() {
          cleanup();
          debug3("onend");
          reject(new Error("Proxy connection ended before receiving CONNECT response"));
        }
        function onerror(err) {
          cleanup();
          debug3("onerror %o", err);
          reject(err);
        }
        function ondata(b2) {
          buffers.push(b2);
          buffersLength += b2.length;
          const buffered = Buffer.concat(buffers, buffersLength);
          const endOfHeaders = buffered.indexOf("\r\n\r\n");
          if (endOfHeaders === -1) {
            debug3("have not received end of HTTP headers yet...");
            read();
            return;
          }
          const headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split("\r\n");
          const firstLine = headerParts.shift();
          if (!firstLine) {
            socket.destroy();
            return reject(new Error("No header received from proxy CONNECT response"));
          }
          const firstLineParts = firstLine.split(" ");
          const statusCode = +firstLineParts[1];
          const statusText = firstLineParts.slice(2).join(" ");
          const headers = {};
          for (const header of headerParts) {
            if (!header)
              continue;
            const firstColon = header.indexOf(":");
            if (firstColon === -1) {
              socket.destroy();
              return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
            }
            const key = header.slice(0, firstColon).toLowerCase();
            const value = header.slice(firstColon + 1).trimStart();
            const current = headers[key];
            if (typeof current === "string") {
              headers[key] = [current, value];
            } else if (Array.isArray(current)) {
              current.push(value);
            } else {
              headers[key] = value;
            }
          }
          debug3("got proxy server response: %o %o", firstLine, headers);
          cleanup();
          resolve({
            connect: {
              statusCode,
              statusText,
              headers
            },
            buffered
          });
        }
        socket.on("error", onerror);
        socket.on("end", onend);
        read();
      });
    }
    exports.parseProxyResponse = parseProxyResponse;
  }
});

// ../node_modules/https-proxy-agent/dist/index.js
var require_dist2 = __commonJS({
  "../node_modules/https-proxy-agent/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpsProxyAgent = void 0;
    var net = __importStar(__require("net"));
    var tls = __importStar(__require("tls"));
    var assert_1 = __importDefault(__require("assert"));
    var debug_1 = __importDefault(require_src());
    var agent_base_1 = require_dist();
    var url_1 = __require("url");
    var parse_proxy_response_1 = require_parse_proxy_response();
    var debug3 = (0, debug_1.default)("https-proxy-agent");
    var setServernameFromNonIpHost = (options) => {
      if (options.servername === void 0 && options.host && !net.isIP(options.host)) {
        return {
          ...options,
          servername: options.host
        };
      }
      return options;
    };
    var HttpsProxyAgent = class extends agent_base_1.Agent {
      constructor(proxy, opts) {
        super(opts);
        this.options = { path: void 0 };
        this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
        this.proxyHeaders = opts?.headers ?? {};
        debug3("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
        const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
        const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
        this.connectOpts = {
          // Attempt to negotiate http/1.1 for proxy servers that support http/2
          ALPNProtocols: ["http/1.1"],
          ...opts ? omit(opts, "headers") : null,
          host,
          port
        };
      }
      /**
       * Called when the node-core HTTP client library is creating a
       * new HTTP request.
       */
      async connect(req, opts) {
        const { proxy } = this;
        if (!opts.host) {
          throw new TypeError('No "host" provided');
        }
        let socket;
        if (proxy.protocol === "https:") {
          debug3("Creating `tls.Socket`: %o", this.connectOpts);
          socket = tls.connect(setServernameFromNonIpHost(this.connectOpts));
        } else {
          debug3("Creating `net.Socket`: %o", this.connectOpts);
          socket = net.connect(this.connectOpts);
        }
        const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
        const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
        let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r
`;
        if (proxy.username || proxy.password) {
          const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
          headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
        }
        headers.Host = `${host}:${opts.port}`;
        if (!headers["Proxy-Connection"]) {
          headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
        }
        for (const name of Object.keys(headers)) {
          payload += `${name}: ${headers[name]}\r
`;
        }
        const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);
        socket.write(`${payload}\r
`);
        const { connect, buffered } = await proxyResponsePromise;
        req.emit("proxyConnect", connect);
        this.emit("proxyConnect", connect, req);
        if (connect.statusCode === 200) {
          req.once("socket", resume);
          if (opts.secureEndpoint) {
            debug3("Upgrading socket connection to TLS");
            return tls.connect({
              ...omit(setServernameFromNonIpHost(opts), "host", "path", "port"),
              socket
            });
          }
          return socket;
        }
        socket.destroy();
        const fakeSocket = new net.Socket({ writable: false });
        fakeSocket.readable = true;
        req.once("socket", (s2) => {
          debug3("Replaying proxy buffer for failed request");
          (0, assert_1.default)(s2.listenerCount("data") > 0);
          s2.push(buffered);
          s2.push(null);
        });
        return fakeSocket;
      }
    };
    HttpsProxyAgent.protocols = ["http", "https"];
    exports.HttpsProxyAgent = HttpsProxyAgent;
    function resume(socket) {
      socket.resume();
    }
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// ../node_modules/gaxios/build/src/gaxios.js
var require_gaxios = __commonJS({
  "../node_modules/gaxios/build/src/gaxios.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __classPrivateFieldGet11 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind3, f2) {
      if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind3 === "m" ? f2 : kind3 === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
    };
    var __classPrivateFieldSet10 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind3, f2) {
      if (kind3 === "m") throw new TypeError("Private method is not writable");
      if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind3 === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _Gaxios_instances;
    var _a3;
    var _Gaxios_urlMayUseProxy;
    var _Gaxios_applyRequestInterceptors;
    var _Gaxios_applyResponseInterceptors;
    var _Gaxios_prepareRequest;
    var _Gaxios_proxyAgent;
    var _Gaxios_getProxyAgent;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Gaxios = void 0;
    var extend_1 = __importDefault(require_extend());
    var https_1 = __require("https");
    var node_fetch_1 = __importDefault((init_lib(), __toCommonJS(lib_exports)));
    var querystring_1 = __importDefault(__require("querystring"));
    var is_stream_1 = __importDefault(require_is_stream());
    var url_1 = __require("url");
    var common_1 = require_common();
    var retry_1 = require_retry();
    var stream_1 = __require("stream");
    var uuid_1 = (init_esm_node(), __toCommonJS(esm_node_exports));
    var interceptor_1 = require_interceptor();
    var fetch5 = hasFetch() ? window.fetch : node_fetch_1.default;
    function hasWindow() {
      return typeof window !== "undefined" && !!window;
    }
    function hasFetch() {
      return hasWindow() && !!window.fetch;
    }
    function hasBuffer() {
      return typeof Buffer !== "undefined";
    }
    function hasHeader(options, header) {
      return !!getHeader3(options, header);
    }
    function getHeader3(options, header) {
      header = header.toLowerCase();
      for (const key of Object.keys((options === null || options === void 0 ? void 0 : options.headers) || {})) {
        if (header === key.toLowerCase()) {
          return options.headers[key];
        }
      }
      return void 0;
    }
    var Gaxios = class {
      /**
       * The Gaxios class is responsible for making HTTP requests.
       * @param defaults The default set of options to be used for this instance.
       */
      constructor(defaults2) {
        _Gaxios_instances.add(this);
        this.agentCache = /* @__PURE__ */ new Map();
        this.defaults = defaults2 || {};
        this.interceptors = {
          request: new interceptor_1.GaxiosInterceptorManager(),
          response: new interceptor_1.GaxiosInterceptorManager()
        };
      }
      /**
       * Perform an HTTP request with the given options.
       * @param opts Set of HTTP options that will be used for this HTTP request.
       */
      async request(opts = {}) {
        opts = await __classPrivateFieldGet11(this, _Gaxios_instances, "m", _Gaxios_prepareRequest).call(this, opts);
        opts = await __classPrivateFieldGet11(this, _Gaxios_instances, "m", _Gaxios_applyRequestInterceptors).call(this, opts);
        return __classPrivateFieldGet11(this, _Gaxios_instances, "m", _Gaxios_applyResponseInterceptors).call(this, this._request(opts));
      }
      async _defaultAdapter(opts) {
        const fetchImpl = opts.fetchImplementation || fetch5;
        const res = await fetchImpl(opts.url, opts);
        const data = await this.getResponseData(opts, res);
        return this.translateResponse(opts, res, data);
      }
      /**
       * Internal, retryable version of the `request` method.
       * @param opts Set of HTTP options that will be used for this HTTP request.
       */
      async _request(opts = {}) {
        var _b;
        try {
          let translatedResponse;
          if (opts.adapter) {
            translatedResponse = await opts.adapter(opts, this._defaultAdapter.bind(this));
          } else {
            translatedResponse = await this._defaultAdapter(opts);
          }
          if (!opts.validateStatus(translatedResponse.status)) {
            if (opts.responseType === "stream") {
              let response = "";
              await new Promise((resolve) => {
                (translatedResponse === null || translatedResponse === void 0 ? void 0 : translatedResponse.data).on("data", (chunk) => {
                  response += chunk;
                });
                (translatedResponse === null || translatedResponse === void 0 ? void 0 : translatedResponse.data).on("end", resolve);
              });
              translatedResponse.data = response;
            }
            throw new common_1.GaxiosError(`Request failed with status code ${translatedResponse.status}`, opts, translatedResponse);
          }
          return translatedResponse;
        } catch (e2) {
          const err = e2 instanceof common_1.GaxiosError ? e2 : new common_1.GaxiosError(e2.message, opts, void 0, e2);
          const { shouldRetry, config } = await (0, retry_1.getRetryConfig)(err);
          if (shouldRetry && config) {
            err.config.retryConfig.currentRetryAttempt = config.retryConfig.currentRetryAttempt;
            opts.retryConfig = (_b = err.config) === null || _b === void 0 ? void 0 : _b.retryConfig;
            return this._request(opts);
          }
          throw err;
        }
      }
      async getResponseData(opts, res) {
        switch (opts.responseType) {
          case "stream":
            return res.body;
          case "json": {
            let data = await res.text();
            try {
              data = JSON.parse(data);
            } catch (_b) {
            }
            return data;
          }
          case "arraybuffer":
            return res.arrayBuffer();
          case "blob":
            return res.blob();
          case "text":
            return res.text();
          default:
            return this.getResponseDataFromContentType(res);
        }
      }
      /**
       * By default, throw for any non-2xx status code
       * @param status status code from the HTTP response
       */
      validateStatus(status) {
        return status >= 200 && status < 300;
      }
      /**
       * Encode a set of key/value pars into a querystring format (?foo=bar&baz=boo)
       * @param params key value pars to encode
       */
      paramsSerializer(params) {
        return querystring_1.default.stringify(params);
      }
      translateResponse(opts, res, data) {
        const headers = {};
        res.headers.forEach((value, key) => {
          headers[key] = value;
        });
        return {
          config: opts,
          data,
          headers,
          status: res.status,
          statusText: res.statusText,
          // XMLHttpRequestLike
          request: {
            responseURL: res.url
          }
        };
      }
      /**
       * Attempts to parse a response by looking at the Content-Type header.
       * @param {FetchResponse} response the HTTP response.
       * @returns {Promise<any>} a promise that resolves to the response data.
       */
      async getResponseDataFromContentType(response) {
        let contentType = response.headers.get("Content-Type");
        if (contentType === null) {
          return response.text();
        }
        contentType = contentType.toLowerCase();
        if (contentType.includes("application/json")) {
          let data = await response.text();
          try {
            data = JSON.parse(data);
          } catch (_b) {
          }
          return data;
        } else if (contentType.match(/^text\//)) {
          return response.text();
        } else {
          return response.blob();
        }
      }
      /**
       * Creates an async generator that yields the pieces of a multipart/related request body.
       * This implementation follows the spec: https://www.ietf.org/rfc/rfc2387.txt. However, recursive
       * multipart/related requests are not currently supported.
       *
       * @param {GaxioMultipartOptions[]} multipartOptions the pieces to turn into a multipart/related body.
       * @param {string} boundary the boundary string to be placed between each part.
       */
      async *getMultipartRequest(multipartOptions, boundary) {
        const finale = `--${boundary}--`;
        for (const currentPart of multipartOptions) {
          const partContentType = currentPart.headers["Content-Type"] || "application/octet-stream";
          const preamble = `--${boundary}\r
Content-Type: ${partContentType}\r
\r
`;
          yield preamble;
          if (typeof currentPart.content === "string") {
            yield currentPart.content;
          } else {
            yield* currentPart.content;
          }
          yield "\r\n";
        }
        yield finale;
      }
    };
    exports.Gaxios = Gaxios;
    _a3 = Gaxios, _Gaxios_instances = /* @__PURE__ */ new WeakSet(), _Gaxios_urlMayUseProxy = function _Gaxios_urlMayUseProxy2(url, noProxy = []) {
      var _b, _c;
      const candidate = new url_1.URL(url);
      const noProxyList = [...noProxy];
      const noProxyEnvList = ((_c = (_b = process.env.NO_PROXY) !== null && _b !== void 0 ? _b : process.env.no_proxy) === null || _c === void 0 ? void 0 : _c.split(",")) || [];
      for (const rule of noProxyEnvList) {
        noProxyList.push(rule.trim());
      }
      for (const rule of noProxyList) {
        if (rule instanceof RegExp) {
          if (rule.test(candidate.toString())) {
            return false;
          }
        } else if (rule instanceof url_1.URL) {
          if (rule.origin === candidate.origin) {
            return false;
          }
        } else if (rule.startsWith("*.") || rule.startsWith(".")) {
          const cleanedRule = rule.replace(/^\*\./, ".");
          if (candidate.hostname.endsWith(cleanedRule)) {
            return false;
          }
        } else if (rule === candidate.origin || rule === candidate.hostname || rule === candidate.href) {
          return false;
        }
      }
      return true;
    }, _Gaxios_applyRequestInterceptors = /**
     * Applies the request interceptors. The request interceptors are applied after the
     * call to prepareRequest is completed.
     *
     * @param {GaxiosOptions} options The current set of options.
     *
     * @returns {Promise<GaxiosOptions>} Promise that resolves to the set of options or response after interceptors are applied.
     */
    async function _Gaxios_applyRequestInterceptors2(options) {
      let promiseChain = Promise.resolve(options);
      for (const interceptor of this.interceptors.request.values()) {
        if (interceptor) {
          promiseChain = promiseChain.then(interceptor.resolved, interceptor.rejected);
        }
      }
      return promiseChain;
    }, _Gaxios_applyResponseInterceptors = /**
     * Applies the response interceptors. The response interceptors are applied after the
     * call to request is made.
     *
     * @param {GaxiosOptions} options The current set of options.
     *
     * @returns {Promise<GaxiosOptions>} Promise that resolves to the set of options or response after interceptors are applied.
     */
    async function _Gaxios_applyResponseInterceptors2(response) {
      let promiseChain = Promise.resolve(response);
      for (const interceptor of this.interceptors.response.values()) {
        if (interceptor) {
          promiseChain = promiseChain.then(interceptor.resolved, interceptor.rejected);
        }
      }
      return promiseChain;
    }, _Gaxios_prepareRequest = /**
     * Validates the options, merges them with defaults, and prepare request.
     *
     * @param options The original options passed from the client.
     * @returns Prepared options, ready to make a request
     */
    async function _Gaxios_prepareRequest2(options) {
      var _b, _c, _d, _e2;
      const opts = (0, extend_1.default)(true, {}, this.defaults, options);
      if (!opts.url) {
        throw new Error("URL is required.");
      }
      const baseUrl = opts.baseUrl || opts.baseURL;
      if (baseUrl) {
        opts.url = baseUrl.toString() + opts.url;
      }
      opts.paramsSerializer = opts.paramsSerializer || this.paramsSerializer;
      if (opts.params && Object.keys(opts.params).length > 0) {
        let additionalQueryParams = opts.paramsSerializer(opts.params);
        if (additionalQueryParams.startsWith("?")) {
          additionalQueryParams = additionalQueryParams.slice(1);
        }
        const prefix = opts.url.toString().includes("?") ? "&" : "?";
        opts.url = opts.url + prefix + additionalQueryParams;
      }
      if (typeof options.maxContentLength === "number") {
        opts.size = options.maxContentLength;
      }
      if (typeof options.maxRedirects === "number") {
        opts.follow = options.maxRedirects;
      }
      opts.headers = opts.headers || {};
      if (opts.multipart === void 0 && opts.data) {
        const isFormData2 = typeof FormData === "undefined" ? false : (opts === null || opts === void 0 ? void 0 : opts.data) instanceof FormData;
        if (is_stream_1.default.readable(opts.data)) {
          opts.body = opts.data;
        } else if (hasBuffer() && Buffer.isBuffer(opts.data)) {
          opts.body = opts.data;
          if (!hasHeader(opts, "Content-Type")) {
            opts.headers["Content-Type"] = "application/json";
          }
        } else if (typeof opts.data === "object") {
          if (!isFormData2) {
            if (getHeader3(opts, "content-type") === "application/x-www-form-urlencoded") {
              opts.body = opts.paramsSerializer(opts.data);
            } else {
              if (!hasHeader(opts, "Content-Type")) {
                opts.headers["Content-Type"] = "application/json";
              }
              opts.body = JSON.stringify(opts.data);
            }
          }
        } else {
          opts.body = opts.data;
        }
      } else if (opts.multipart && opts.multipart.length > 0) {
        const boundary = (0, uuid_1.v4)();
        opts.headers["Content-Type"] = `multipart/related; boundary=${boundary}`;
        const bodyStream = new stream_1.PassThrough();
        opts.body = bodyStream;
        (0, stream_1.pipeline)(this.getMultipartRequest(opts.multipart, boundary), bodyStream, () => {
        });
      }
      opts.validateStatus = opts.validateStatus || this.validateStatus;
      opts.responseType = opts.responseType || "unknown";
      if (!opts.headers["Accept"] && opts.responseType === "json") {
        opts.headers["Accept"] = "application/json";
      }
      opts.method = opts.method || "GET";
      const proxy = opts.proxy || ((_b = process === null || process === void 0 ? void 0 : process.env) === null || _b === void 0 ? void 0 : _b.HTTPS_PROXY) || ((_c = process === null || process === void 0 ? void 0 : process.env) === null || _c === void 0 ? void 0 : _c.https_proxy) || ((_d = process === null || process === void 0 ? void 0 : process.env) === null || _d === void 0 ? void 0 : _d.HTTP_PROXY) || ((_e2 = process === null || process === void 0 ? void 0 : process.env) === null || _e2 === void 0 ? void 0 : _e2.http_proxy);
      const urlMayUseProxy = __classPrivateFieldGet11(this, _Gaxios_instances, "m", _Gaxios_urlMayUseProxy).call(this, opts.url, opts.noProxy);
      if (opts.agent) {
      } else if (proxy && urlMayUseProxy) {
        const HttpsProxyAgent = await __classPrivateFieldGet11(_a3, _a3, "m", _Gaxios_getProxyAgent).call(_a3);
        if (this.agentCache.has(proxy)) {
          opts.agent = this.agentCache.get(proxy);
        } else {
          opts.agent = new HttpsProxyAgent(proxy, {
            cert: opts.cert,
            key: opts.key
          });
          this.agentCache.set(proxy, opts.agent);
        }
      } else if (opts.cert && opts.key) {
        if (this.agentCache.has(opts.key)) {
          opts.agent = this.agentCache.get(opts.key);
        } else {
          opts.agent = new https_1.Agent({
            cert: opts.cert,
            key: opts.key
          });
          this.agentCache.set(opts.key, opts.agent);
        }
      }
      if (typeof opts.errorRedactor !== "function" && opts.errorRedactor !== false) {
        opts.errorRedactor = common_1.defaultErrorRedactor;
      }
      return opts;
    }, _Gaxios_getProxyAgent = async function _Gaxios_getProxyAgent2() {
      __classPrivateFieldSet10(this, _a3, __classPrivateFieldGet11(this, _a3, "f", _Gaxios_proxyAgent) || (await Promise.resolve().then(() => __importStar(require_dist2()))).HttpsProxyAgent, "f", _Gaxios_proxyAgent);
      return __classPrivateFieldGet11(this, _a3, "f", _Gaxios_proxyAgent);
    };
    _Gaxios_proxyAgent = { value: void 0 };
  }
});

// ../node_modules/gaxios/build/src/index.js
var require_src2 = __commonJS({
  "../node_modules/gaxios/build/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.instance = exports.Gaxios = exports.GaxiosError = void 0;
    exports.request = request;
    var gaxios_1 = require_gaxios();
    Object.defineProperty(exports, "Gaxios", { enumerable: true, get: function() {
      return gaxios_1.Gaxios;
    } });
    var common_1 = require_common();
    Object.defineProperty(exports, "GaxiosError", { enumerable: true, get: function() {
      return common_1.GaxiosError;
    } });
    __exportStar(require_interceptor(), exports);
    exports.instance = new gaxios_1.Gaxios();
    async function request(opts) {
      return exports.instance.request(opts);
    }
  }
});

// ../node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "../node_modules/bignumber.js/bignumber.js"(exports, module) {
    "use strict";
    (function(globalObject) {
      "use strict";
      var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone2(configObject) {
        var div, convertBase, parseNumeric, P2 = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: "\xA0",
          // non-breaking space
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber2(v2, b2) {
          var alphabet2, c2, caseChanged, e2, i2, isNum, len, str, x2 = this;
          if (!(x2 instanceof BigNumber2)) return new BigNumber2(v2, b2);
          if (b2 == null) {
            if (v2 && v2._isBigNumber === true) {
              x2.s = v2.s;
              if (!v2.c || v2.e > MAX_EXP) {
                x2.c = x2.e = null;
              } else if (v2.e < MIN_EXP) {
                x2.c = [x2.e = 0];
              } else {
                x2.e = v2.e;
                x2.c = v2.c.slice();
              }
              return;
            }
            if ((isNum = typeof v2 == "number") && v2 * 0 == 0) {
              x2.s = 1 / v2 < 0 ? (v2 = -v2, -1) : 1;
              if (v2 === ~~v2) {
                for (e2 = 0, i2 = v2; i2 >= 10; i2 /= 10, e2++) ;
                if (e2 > MAX_EXP) {
                  x2.c = x2.e = null;
                } else {
                  x2.e = e2;
                  x2.c = [v2];
                }
                return;
              }
              str = String(v2);
            } else {
              if (!isNumeric.test(str = String(v2))) return parseNumeric(x2, str, isNum);
              x2.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e2 = str.indexOf(".")) > -1) str = str.replace(".", "");
            if ((i2 = str.search(/e/i)) > 0) {
              if (e2 < 0) e2 = i2;
              e2 += +str.slice(i2 + 1);
              str = str.substring(0, i2);
            } else if (e2 < 0) {
              e2 = str.length;
            }
          } else {
            intCheck(b2, 2, ALPHABET.length, "Base");
            if (b2 == 10 && alphabetHasNormalDecimalDigits) {
              x2 = new BigNumber2(v2);
              return round(x2, DECIMAL_PLACES + x2.e + 1, ROUNDING_MODE);
            }
            str = String(v2);
            if (isNum = typeof v2 == "number") {
              if (v2 * 0 != 0) return parseNumeric(x2, str, isNum, b2);
              x2.s = 1 / v2 < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v2);
              }
            } else {
              x2.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet2 = ALPHABET.slice(0, b2);
            e2 = i2 = 0;
            for (len = str.length; i2 < len; i2++) {
              if (alphabet2.indexOf(c2 = str.charAt(i2)) < 0) {
                if (c2 == ".") {
                  if (i2 > e2) {
                    e2 = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i2 = -1;
                    e2 = 0;
                    continue;
                  }
                }
                return parseNumeric(x2, String(v2), isNum, b2);
              }
            }
            isNum = false;
            str = convertBase(str, b2, 10, x2.s);
            if ((e2 = str.indexOf(".")) > -1) str = str.replace(".", "");
            else e2 = str.length;
          }
          for (i2 = 0; str.charCodeAt(i2) === 48; i2++) ;
          for (len = str.length; str.charCodeAt(--len) === 48; ) ;
          if (str = str.slice(i2, ++len)) {
            len -= i2;
            if (isNum && BigNumber2.DEBUG && len > 15 && (v2 > MAX_SAFE_INTEGER || v2 !== mathfloor(v2))) {
              throw Error(tooManyDigits + x2.s * v2);
            }
            if ((e2 = e2 - i2 - 1) > MAX_EXP) {
              x2.c = x2.e = null;
            } else if (e2 < MIN_EXP) {
              x2.c = [x2.e = 0];
            } else {
              x2.e = e2;
              x2.c = [];
              i2 = (e2 + 1) % LOG_BASE;
              if (e2 < 0) i2 += LOG_BASE;
              if (i2 < len) {
                if (i2) x2.c.push(+str.slice(0, i2));
                for (len -= LOG_BASE; i2 < len; ) {
                  x2.c.push(+str.slice(i2, i2 += LOG_BASE));
                }
                i2 = LOG_BASE - (str = str.slice(i2)).length;
              } else {
                i2 -= len;
              }
              for (; i2--; str += "0") ;
              x2.c.push(+str);
            }
          } else {
            x2.c = [x2.e = 0];
          }
        }
        BigNumber2.clone = clone2;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function(obj) {
          var p2, v2;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p2 = "DECIMAL_PLACES")) {
                v2 = obj[p2];
                intCheck(v2, 0, MAX, p2);
                DECIMAL_PLACES = v2;
              }
              if (obj.hasOwnProperty(p2 = "ROUNDING_MODE")) {
                v2 = obj[p2];
                intCheck(v2, 0, 8, p2);
                ROUNDING_MODE = v2;
              }
              if (obj.hasOwnProperty(p2 = "EXPONENTIAL_AT")) {
                v2 = obj[p2];
                if (v2 && v2.pop) {
                  intCheck(v2[0], -MAX, 0, p2);
                  intCheck(v2[1], 0, MAX, p2);
                  TO_EXP_NEG = v2[0];
                  TO_EXP_POS = v2[1];
                } else {
                  intCheck(v2, -MAX, MAX, p2);
                  TO_EXP_NEG = -(TO_EXP_POS = v2 < 0 ? -v2 : v2);
                }
              }
              if (obj.hasOwnProperty(p2 = "RANGE")) {
                v2 = obj[p2];
                if (v2 && v2.pop) {
                  intCheck(v2[0], -MAX, -1, p2);
                  intCheck(v2[1], 1, MAX, p2);
                  MIN_EXP = v2[0];
                  MAX_EXP = v2[1];
                } else {
                  intCheck(v2, -MAX, MAX, p2);
                  if (v2) {
                    MIN_EXP = -(MAX_EXP = v2 < 0 ? -v2 : v2);
                  } else {
                    throw Error(bignumberError + p2 + " cannot be zero: " + v2);
                  }
                }
              }
              if (obj.hasOwnProperty(p2 = "CRYPTO")) {
                v2 = obj[p2];
                if (v2 === !!v2) {
                  if (v2) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v2;
                    } else {
                      CRYPTO = !v2;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v2;
                  }
                } else {
                  throw Error(bignumberError + p2 + " not true or false: " + v2);
                }
              }
              if (obj.hasOwnProperty(p2 = "MODULO_MODE")) {
                v2 = obj[p2];
                intCheck(v2, 0, 9, p2);
                MODULO_MODE = v2;
              }
              if (obj.hasOwnProperty(p2 = "POW_PRECISION")) {
                v2 = obj[p2];
                intCheck(v2, 0, MAX, p2);
                POW_PRECISION = v2;
              }
              if (obj.hasOwnProperty(p2 = "FORMAT")) {
                v2 = obj[p2];
                if (typeof v2 == "object") FORMAT = v2;
                else throw Error(bignumberError + p2 + " not an object: " + v2);
              }
              if (obj.hasOwnProperty(p2 = "ALPHABET")) {
                v2 = obj[p2];
                if (typeof v2 == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v2)) {
                  alphabetHasNormalDecimalDigits = v2.slice(0, 10) == "0123456789";
                  ALPHABET = v2;
                } else {
                  throw Error(bignumberError + p2 + " invalid: " + v2);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber2.isBigNumber = function(v2) {
          if (!v2 || v2._isBigNumber !== true) return false;
          if (!BigNumber2.DEBUG) return true;
          var i2, n2, c2 = v2.c, e2 = v2.e, s2 = v2.s;
          out: if ({}.toString.call(c2) == "[object Array]") {
            if ((s2 === 1 || s2 === -1) && e2 >= -MAX && e2 <= MAX && e2 === mathfloor(e2)) {
              if (c2[0] === 0) {
                if (e2 === 0 && c2.length === 1) return true;
                break out;
              }
              i2 = (e2 + 1) % LOG_BASE;
              if (i2 < 1) i2 += LOG_BASE;
              if (String(c2[0]).length == i2) {
                for (i2 = 0; i2 < c2.length; i2++) {
                  n2 = c2[i2];
                  if (n2 < 0 || n2 >= BASE || n2 !== mathfloor(n2)) break out;
                }
                if (n2 !== 0) return true;
              }
            }
          } else if (c2 === null && e2 === null && (s2 === null || s2 === 1 || s2 === -1)) {
            return true;
          }
          throw Error(bignumberError + "Invalid BigNumber: " + v2);
        };
        BigNumber2.maximum = BigNumber2.max = function() {
          return maxOrMin(arguments, -1);
        };
        BigNumber2.minimum = BigNumber2.min = function() {
          return maxOrMin(arguments, 1);
        };
        BigNumber2.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a2, b2, e2, k2, v2, i2 = 0, c2 = [], rand = new BigNumber2(ONE);
            if (dp == null) dp = DECIMAL_PLACES;
            else intCheck(dp, 0, MAX);
            k2 = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a2 = crypto.getRandomValues(new Uint32Array(k2 *= 2));
                for (; i2 < k2; ) {
                  v2 = a2[i2] * 131072 + (a2[i2 + 1] >>> 11);
                  if (v2 >= 9e15) {
                    b2 = crypto.getRandomValues(new Uint32Array(2));
                    a2[i2] = b2[0];
                    a2[i2 + 1] = b2[1];
                  } else {
                    c2.push(v2 % 1e14);
                    i2 += 2;
                  }
                }
                i2 = k2 / 2;
              } else if (crypto.randomBytes) {
                a2 = crypto.randomBytes(k2 *= 7);
                for (; i2 < k2; ) {
                  v2 = (a2[i2] & 31) * 281474976710656 + a2[i2 + 1] * 1099511627776 + a2[i2 + 2] * 4294967296 + a2[i2 + 3] * 16777216 + (a2[i2 + 4] << 16) + (a2[i2 + 5] << 8) + a2[i2 + 6];
                  if (v2 >= 9e15) {
                    crypto.randomBytes(7).copy(a2, i2);
                  } else {
                    c2.push(v2 % 1e14);
                    i2 += 7;
                  }
                }
                i2 = k2 / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i2 < k2; ) {
                v2 = random53bitInt();
                if (v2 < 9e15) c2[i2++] = v2 % 1e14;
              }
            }
            k2 = c2[--i2];
            dp %= LOG_BASE;
            if (k2 && dp) {
              v2 = POWS_TEN[LOG_BASE - dp];
              c2[i2] = mathfloor(k2 / v2) * v2;
            }
            for (; c2[i2] === 0; c2.pop(), i2--) ;
            if (i2 < 0) {
              c2 = [e2 = 0];
            } else {
              for (e2 = -1; c2[0] === 0; c2.splice(0, 1), e2 -= LOG_BASE) ;
              for (i2 = 1, v2 = c2[0]; v2 >= 10; v2 /= 10, i2++) ;
              if (i2 < LOG_BASE) e2 -= LOG_BASE - i2;
            }
            rand.e = e2;
            rand.c = c2;
            return rand;
          };
        }();
        BigNumber2.sum = function() {
          var i2 = 1, args = arguments, sum = new BigNumber2(args[0]);
          for (; i2 < args.length; ) sum = sum.plus(args[i2++]);
          return sum;
        };
        convertBase = /* @__PURE__ */ function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet2) {
            var j2, arr = [0], arrL, i2 = 0, len = str.length;
            for (; i2 < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
              arr[0] += alphabet2.indexOf(str.charAt(i2++));
              for (j2 = 0; j2 < arr.length; j2++) {
                if (arr[j2] > baseOut - 1) {
                  if (arr[j2 + 1] == null) arr[j2 + 1] = 0;
                  arr[j2 + 1] += arr[j2] / baseOut | 0;
                  arr[j2] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign, callerIsToString) {
            var alphabet2, d2, e2, k2, r2, x2, xc, y2, i2 = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i2 >= 0) {
              k2 = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y2 = new BigNumber2(baseIn);
              x2 = y2.pow(str.length - i2);
              POW_PRECISION = k2;
              y2.c = toBaseOut(
                toFixedPoint(coeffToString(x2.c), x2.e, "0"),
                10,
                baseOut,
                decimal
              );
              y2.e = y2.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet2 = ALPHABET, decimal) : (alphabet2 = decimal, ALPHABET));
            e2 = k2 = xc.length;
            for (; xc[--k2] == 0; xc.pop()) ;
            if (!xc[0]) return alphabet2.charAt(0);
            if (i2 < 0) {
              --e2;
            } else {
              x2.c = xc;
              x2.e = e2;
              x2.s = sign;
              x2 = div(x2, y2, dp, rm, baseOut);
              xc = x2.c;
              r2 = x2.r;
              e2 = x2.e;
            }
            d2 = e2 + dp + 1;
            i2 = xc[d2];
            k2 = baseOut / 2;
            r2 = r2 || d2 < 0 || xc[d2 + 1] != null;
            r2 = rm < 4 ? (i2 != null || r2) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : i2 > k2 || i2 == k2 && (rm == 4 || r2 || rm == 6 && xc[d2 - 1] & 1 || rm == (x2.s < 0 ? 8 : 7));
            if (d2 < 1 || !xc[0]) {
              str = r2 ? toFixedPoint(alphabet2.charAt(1), -dp, alphabet2.charAt(0)) : alphabet2.charAt(0);
            } else {
              xc.length = d2;
              if (r2) {
                for (--baseOut; ++xc[--d2] > baseOut; ) {
                  xc[d2] = 0;
                  if (!d2) {
                    ++e2;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k2 = xc.length; !xc[--k2]; ) ;
              for (i2 = 0, str = ""; i2 <= k2; str += alphabet2.charAt(xc[i2++])) ;
              str = toFixedPoint(str, e2, alphabet2.charAt(0));
            }
            return str;
          };
        }();
        div = /* @__PURE__ */ function() {
          function multiply(x2, k2, base) {
            var m2, temp, xlo, xhi, carry = 0, i2 = x2.length, klo = k2 % SQRT_BASE, khi = k2 / SQRT_BASE | 0;
            for (x2 = x2.slice(); i2--; ) {
              xlo = x2[i2] % SQRT_BASE;
              xhi = x2[i2] / SQRT_BASE | 0;
              m2 = khi * xlo + xhi * klo;
              temp = klo * xlo + m2 % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base | 0) + (m2 / SQRT_BASE | 0) + khi * xhi;
              x2[i2] = temp % base;
            }
            if (carry) x2 = [carry].concat(x2);
            return x2;
          }
          function compare2(a2, b2, aL, bL) {
            var i2, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i2 = cmp = 0; i2 < aL; i2++) {
                if (a2[i2] != b2[i2]) {
                  cmp = a2[i2] > b2[i2] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a2, b2, aL, base) {
            var i2 = 0;
            for (; aL--; ) {
              a2[aL] -= i2;
              i2 = a2[aL] < b2[aL] ? 1 : 0;
              a2[aL] = i2 * base + a2[aL] - b2[aL];
            }
            for (; !a2[0] && a2.length > 1; a2.splice(0, 1)) ;
          }
          return function(x2, y2, dp, rm, base) {
            var cmp, e2, i2, more, n2, prod, prodL, q2, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s2 = x2.s == y2.s ? 1 : -1, xc = x2.c, yc = y2.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(
                // Return NaN if either NaN, or both Infinity or 0.
                !x2.s || !y2.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                  // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                  xc && xc[0] == 0 || !yc ? s2 * 0 : s2 / 0
                )
              );
            }
            q2 = new BigNumber2(s2);
            qc = q2.c = [];
            e2 = x2.e - y2.e;
            s2 = dp + e2 + 1;
            if (!base) {
              base = BASE;
              e2 = bitFloor(x2.e / LOG_BASE) - bitFloor(y2.e / LOG_BASE);
              s2 = s2 / LOG_BASE | 0;
            }
            for (i2 = 0; yc[i2] == (xc[i2] || 0); i2++) ;
            if (yc[i2] > (xc[i2] || 0)) e2--;
            if (s2 < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i2 = 0;
              s2 += 2;
              n2 = mathfloor(base / (yc[0] + 1));
              if (n2 > 1) {
                yc = multiply(yc, n2, base);
                xc = multiply(xc, n2, base);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0) ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2) yc0++;
              do {
                n2 = 0;
                cmp = compare2(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                  n2 = mathfloor(rem0 / yc0);
                  if (n2 > 1) {
                    if (n2 >= base) n2 = base - 1;
                    prod = multiply(yc, n2, base);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n2--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n2 == 0) {
                      cmp = n2 = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL) prod = [0].concat(prod);
                  subtract(rem, prod, remL, base);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare2(yc, rem, yL, remL) < 1) {
                      n2++;
                      subtract(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n2++;
                  rem = [0];
                }
                qc[i2++] = n2;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s2--);
              more = rem[0] != null;
              if (!qc[0]) qc.splice(0, 1);
            }
            if (base == BASE) {
              for (i2 = 1, s2 = qc[0]; s2 >= 10; s2 /= 10, i2++) ;
              round(q2, dp + (q2.e = i2 + e2 * LOG_BASE - 1) + 1, rm, more);
            } else {
              q2.e = e2;
              q2.r = +more;
            }
            return q2;
          };
        }();
        function format(n2, i2, rm, id) {
          var c0, e2, ne2, len, str;
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          if (!n2.c) return n2.toString();
          c0 = n2.c[0];
          ne2 = n2.e;
          if (i2 == null) {
            str = coeffToString(n2.c);
            str = id == 1 || id == 2 && (ne2 <= TO_EXP_NEG || ne2 >= TO_EXP_POS) ? toExponential(str, ne2) : toFixedPoint(str, ne2, "0");
          } else {
            n2 = round(new BigNumber2(n2), i2, rm);
            e2 = n2.e;
            str = coeffToString(n2.c);
            len = str.length;
            if (id == 1 || id == 2 && (i2 <= e2 || e2 <= TO_EXP_NEG)) {
              for (; len < i2; str += "0", len++) ;
              str = toExponential(str, e2);
            } else {
              i2 -= ne2 + (id === 2 && e2 > ne2);
              str = toFixedPoint(str, e2, "0");
              if (e2 + 1 > len) {
                if (--i2 > 0) for (str += "."; i2--; str += "0") ;
              } else {
                i2 += e2 - len;
                if (i2 > 0) {
                  if (e2 + 1 == len) str += ".";
                  for (; i2--; str += "0") ;
                }
              }
            }
          }
          return n2.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, n2) {
          var k2, y2, i2 = 1, x2 = new BigNumber2(args[0]);
          for (; i2 < args.length; i2++) {
            y2 = new BigNumber2(args[i2]);
            if (!y2.s || (k2 = compare(x2, y2)) === n2 || k2 === 0 && x2.s === n2) {
              x2 = y2;
            }
          }
          return x2;
        }
        function normalise(n2, c2, e2) {
          var i2 = 1, j2 = c2.length;
          for (; !c2[--j2]; c2.pop()) ;
          for (j2 = c2[0]; j2 >= 10; j2 /= 10, i2++) ;
          if ((e2 = i2 + e2 * LOG_BASE - 1) > MAX_EXP) {
            n2.c = n2.e = null;
          } else if (e2 < MIN_EXP) {
            n2.c = [n2.e = 0];
          } else {
            n2.e = e2;
            n2.c = c2;
          }
          return n2;
        }
        parseNumeric = /* @__PURE__ */ function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x2, str, isNum, b2) {
            var base, s2 = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s2)) {
              x2.s = isNaN(s2) ? null : s2 < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s2 = s2.replace(basePrefix, function(m2, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b2 || b2 == base ? p1 : m2;
                });
                if (b2) {
                  base = b2;
                  s2 = s2.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s2) return new BigNumber2(s2, base);
              }
              if (BigNumber2.DEBUG) {
                throw Error(bignumberError + "Not a" + (b2 ? " base " + b2 : "") + " number: " + str);
              }
              x2.s = null;
            }
            x2.c = x2.e = null;
          };
        }();
        function round(x2, sd, rm, r2) {
          var d2, i2, j2, k2, n2, ni, rd, xc = x2.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d2 = 1, k2 = xc[0]; k2 >= 10; k2 /= 10, d2++) ;
              i2 = sd - d2;
              if (i2 < 0) {
                i2 += LOG_BASE;
                j2 = sd;
                n2 = xc[ni = 0];
                rd = mathfloor(n2 / pows10[d2 - j2 - 1] % 10);
              } else {
                ni = mathceil((i2 + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r2) {
                    for (; xc.length <= ni; xc.push(0)) ;
                    n2 = rd = 0;
                    d2 = 1;
                    i2 %= LOG_BASE;
                    j2 = i2 - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n2 = k2 = xc[ni];
                  for (d2 = 1; k2 >= 10; k2 /= 10, d2++) ;
                  i2 %= LOG_BASE;
                  j2 = i2 - LOG_BASE + d2;
                  rd = j2 < 0 ? 0 : mathfloor(n2 / pows10[d2 - j2 - 1] % 10);
                }
              }
              r2 = r2 || sd < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc[ni + 1] != null || (j2 < 0 ? n2 : n2 % pows10[d2 - j2 - 1]);
              r2 = rm < 4 ? (rd || r2) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r2 || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i2 > 0 ? j2 > 0 ? n2 / pows10[d2 - j2] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r2) {
                  sd -= x2.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x2.e = -sd || 0;
                } else {
                  xc[0] = x2.e = 0;
                }
                return x2;
              }
              if (i2 == 0) {
                xc.length = ni;
                k2 = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k2 = pows10[LOG_BASE - i2];
                xc[ni] = j2 > 0 ? mathfloor(n2 / pows10[d2 - j2] % pows10[j2]) * k2 : 0;
              }
              if (r2) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i2 = 1, j2 = xc[0]; j2 >= 10; j2 /= 10, i2++) ;
                    j2 = xc[0] += k2;
                    for (k2 = 1; j2 >= 10; j2 /= 10, k2++) ;
                    if (i2 != k2) {
                      x2.e++;
                      if (xc[0] == BASE) xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k2;
                    if (xc[ni] != BASE) break;
                    xc[ni--] = 0;
                    k2 = 1;
                  }
                }
              }
              for (i2 = xc.length; xc[--i2] === 0; xc.pop()) ;
            }
            if (x2.e > MAX_EXP) {
              x2.c = x2.e = null;
            } else if (x2.e < MIN_EXP) {
              x2.c = [x2.e = 0];
            }
          }
          return x2;
        }
        function valueOf(n2) {
          var str, e2 = n2.e;
          if (e2 === null) return n2.toString();
          str = coeffToString(n2.c);
          str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(str, e2) : toFixedPoint(str, e2, "0");
          return n2.s < 0 ? "-" + str : str;
        }
        P2.absoluteValue = P2.abs = function() {
          var x2 = new BigNumber2(this);
          if (x2.s < 0) x2.s = 1;
          return x2;
        };
        P2.comparedTo = function(y2, b2) {
          return compare(this, new BigNumber2(y2, b2));
        };
        P2.decimalPlaces = P2.dp = function(dp, rm) {
          var c2, n2, v2, x2 = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x2), dp + x2.e + 1, rm);
          }
          if (!(c2 = x2.c)) return null;
          n2 = ((v2 = c2.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v2 = c2[v2]) for (; v2 % 10 == 0; v2 /= 10, n2--) ;
          if (n2 < 0) n2 = 0;
          return n2;
        };
        P2.dividedBy = P2.div = function(y2, b2) {
          return div(this, new BigNumber2(y2, b2), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P2.dividedToIntegerBy = P2.idiv = function(y2, b2) {
          return div(this, new BigNumber2(y2, b2), 0, 1);
        };
        P2.exponentiatedBy = P2.pow = function(n2, m2) {
          var half, isModExp, i2, k2, more, nIsBig, nIsNeg, nIsOdd, y2, x2 = this;
          n2 = new BigNumber2(n2);
          if (n2.c && !n2.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n2));
          }
          if (m2 != null) m2 = new BigNumber2(m2);
          nIsBig = n2.e > 14;
          if (!x2.c || !x2.c[0] || x2.c[0] == 1 && !x2.e && x2.c.length == 1 || !n2.c || !n2.c[0]) {
            y2 = new BigNumber2(Math.pow(+valueOf(x2), nIsBig ? n2.s * (2 - isOdd(n2)) : +valueOf(n2)));
            return m2 ? y2.mod(m2) : y2;
          }
          nIsNeg = n2.s < 0;
          if (m2) {
            if (m2.c ? !m2.c[0] : !m2.s) return new BigNumber2(NaN);
            isModExp = !nIsNeg && x2.isInteger() && m2.isInteger();
            if (isModExp) x2 = x2.mod(m2);
          } else if (n2.e > 9 && (x2.e > 0 || x2.e < -1 || (x2.e == 0 ? x2.c[0] > 1 || nIsBig && x2.c[1] >= 24e7 : x2.c[0] < 8e13 || nIsBig && x2.c[0] <= 9999975e7))) {
            k2 = x2.s < 0 && isOdd(n2) ? -0 : 0;
            if (x2.e > -1) k2 = 1 / k2;
            return new BigNumber2(nIsNeg ? 1 / k2 : k2);
          } else if (POW_PRECISION) {
            k2 = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg) n2.s = 1;
            nIsOdd = isOdd(n2);
          } else {
            i2 = Math.abs(+valueOf(n2));
            nIsOdd = i2 % 2;
          }
          y2 = new BigNumber2(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y2 = y2.times(x2);
              if (!y2.c) break;
              if (k2) {
                if (y2.c.length > k2) y2.c.length = k2;
              } else if (isModExp) {
                y2 = y2.mod(m2);
              }
            }
            if (i2) {
              i2 = mathfloor(i2 / 2);
              if (i2 === 0) break;
              nIsOdd = i2 % 2;
            } else {
              n2 = n2.times(half);
              round(n2, n2.e + 1, 1);
              if (n2.e > 14) {
                nIsOdd = isOdd(n2);
              } else {
                i2 = +valueOf(n2);
                if (i2 === 0) break;
                nIsOdd = i2 % 2;
              }
            }
            x2 = x2.times(x2);
            if (k2) {
              if (x2.c && x2.c.length > k2) x2.c.length = k2;
            } else if (isModExp) {
              x2 = x2.mod(m2);
            }
          }
          if (isModExp) return y2;
          if (nIsNeg) y2 = ONE.div(y2);
          return m2 ? y2.mod(m2) : k2 ? round(y2, POW_PRECISION, ROUNDING_MODE, more) : y2;
        };
        P2.integerValue = function(rm) {
          var n2 = new BigNumber2(this);
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          return round(n2, n2.e + 1, rm);
        };
        P2.isEqualTo = P2.eq = function(y2, b2) {
          return compare(this, new BigNumber2(y2, b2)) === 0;
        };
        P2.isFinite = function() {
          return !!this.c;
        };
        P2.isGreaterThan = P2.gt = function(y2, b2) {
          return compare(this, new BigNumber2(y2, b2)) > 0;
        };
        P2.isGreaterThanOrEqualTo = P2.gte = function(y2, b2) {
          return (b2 = compare(this, new BigNumber2(y2, b2))) === 1 || b2 === 0;
        };
        P2.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P2.isLessThan = P2.lt = function(y2, b2) {
          return compare(this, new BigNumber2(y2, b2)) < 0;
        };
        P2.isLessThanOrEqualTo = P2.lte = function(y2, b2) {
          return (b2 = compare(this, new BigNumber2(y2, b2))) === -1 || b2 === 0;
        };
        P2.isNaN = function() {
          return !this.s;
        };
        P2.isNegative = function() {
          return this.s < 0;
        };
        P2.isPositive = function() {
          return this.s > 0;
        };
        P2.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P2.minus = function(y2, b2) {
          var i2, j2, t2, xLTy, x2 = this, a2 = x2.s;
          y2 = new BigNumber2(y2, b2);
          b2 = y2.s;
          if (!a2 || !b2) return new BigNumber2(NaN);
          if (a2 != b2) {
            y2.s = -b2;
            return x2.plus(y2);
          }
          var xe2 = x2.e / LOG_BASE, ye2 = y2.e / LOG_BASE, xc = x2.c, yc = y2.c;
          if (!xe2 || !ye2) {
            if (!xc || !yc) return xc ? (y2.s = -b2, y2) : new BigNumber2(yc ? x2 : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y2.s = -b2, y2) : new BigNumber2(xc[0] ? x2 : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe2 = bitFloor(xe2);
          ye2 = bitFloor(ye2);
          xc = xc.slice();
          if (a2 = xe2 - ye2) {
            if (xLTy = a2 < 0) {
              a2 = -a2;
              t2 = xc;
            } else {
              ye2 = xe2;
              t2 = yc;
            }
            t2.reverse();
            for (b2 = a2; b2--; t2.push(0)) ;
            t2.reverse();
          } else {
            j2 = (xLTy = (a2 = xc.length) < (b2 = yc.length)) ? a2 : b2;
            for (a2 = b2 = 0; b2 < j2; b2++) {
              if (xc[b2] != yc[b2]) {
                xLTy = xc[b2] < yc[b2];
                break;
              }
            }
          }
          if (xLTy) {
            t2 = xc;
            xc = yc;
            yc = t2;
            y2.s = -y2.s;
          }
          b2 = (j2 = yc.length) - (i2 = xc.length);
          if (b2 > 0) for (; b2--; xc[i2++] = 0) ;
          b2 = BASE - 1;
          for (; j2 > a2; ) {
            if (xc[--j2] < yc[j2]) {
              for (i2 = j2; i2 && !xc[--i2]; xc[i2] = b2) ;
              --xc[i2];
              xc[j2] += BASE;
            }
            xc[j2] -= yc[j2];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye2) ;
          if (!xc[0]) {
            y2.s = ROUNDING_MODE == 3 ? -1 : 1;
            y2.c = [y2.e = 0];
            return y2;
          }
          return normalise(y2, xc, ye2);
        };
        P2.modulo = P2.mod = function(y2, b2) {
          var q2, s2, x2 = this;
          y2 = new BigNumber2(y2, b2);
          if (!x2.c || !y2.s || y2.c && !y2.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y2.c || x2.c && !x2.c[0]) {
            return new BigNumber2(x2);
          }
          if (MODULO_MODE == 9) {
            s2 = y2.s;
            y2.s = 1;
            q2 = div(x2, y2, 0, 3);
            y2.s = s2;
            q2.s *= s2;
          } else {
            q2 = div(x2, y2, 0, MODULO_MODE);
          }
          y2 = x2.minus(q2.times(y2));
          if (!y2.c[0] && MODULO_MODE == 1) y2.s = x2.s;
          return y2;
        };
        P2.multipliedBy = P2.times = function(y2, b2) {
          var c2, e2, i2, j2, k2, m2, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x2 = this, xc = x2.c, yc = (y2 = new BigNumber2(y2, b2)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x2.s || !y2.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y2.c = y2.e = y2.s = null;
            } else {
              y2.s *= x2.s;
              if (!xc || !yc) {
                y2.c = y2.e = null;
              } else {
                y2.c = [0];
                y2.e = 0;
              }
            }
            return y2;
          }
          e2 = bitFloor(x2.e / LOG_BASE) + bitFloor(y2.e / LOG_BASE);
          y2.s *= x2.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i2 = xcL;
            xcL = ycL;
            ycL = i2;
          }
          for (i2 = xcL + ycL, zc = []; i2--; zc.push(0)) ;
          base = BASE;
          sqrtBase = SQRT_BASE;
          for (i2 = ycL; --i2 >= 0; ) {
            c2 = 0;
            ylo = yc[i2] % sqrtBase;
            yhi = yc[i2] / sqrtBase | 0;
            for (k2 = xcL, j2 = i2 + k2; j2 > i2; ) {
              xlo = xc[--k2] % sqrtBase;
              xhi = xc[k2] / sqrtBase | 0;
              m2 = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m2 % sqrtBase * sqrtBase + zc[j2] + c2;
              c2 = (xlo / base | 0) + (m2 / sqrtBase | 0) + yhi * xhi;
              zc[j2--] = xlo % base;
            }
            zc[j2] = c2;
          }
          if (c2) {
            ++e2;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y2, zc, e2);
        };
        P2.negated = function() {
          var x2 = new BigNumber2(this);
          x2.s = -x2.s || null;
          return x2;
        };
        P2.plus = function(y2, b2) {
          var t2, x2 = this, a2 = x2.s;
          y2 = new BigNumber2(y2, b2);
          b2 = y2.s;
          if (!a2 || !b2) return new BigNumber2(NaN);
          if (a2 != b2) {
            y2.s = -b2;
            return x2.minus(y2);
          }
          var xe2 = x2.e / LOG_BASE, ye2 = y2.e / LOG_BASE, xc = x2.c, yc = y2.c;
          if (!xe2 || !ye2) {
            if (!xc || !yc) return new BigNumber2(a2 / 0);
            if (!xc[0] || !yc[0]) return yc[0] ? y2 : new BigNumber2(xc[0] ? x2 : a2 * 0);
          }
          xe2 = bitFloor(xe2);
          ye2 = bitFloor(ye2);
          xc = xc.slice();
          if (a2 = xe2 - ye2) {
            if (a2 > 0) {
              ye2 = xe2;
              t2 = yc;
            } else {
              a2 = -a2;
              t2 = xc;
            }
            t2.reverse();
            for (; a2--; t2.push(0)) ;
            t2.reverse();
          }
          a2 = xc.length;
          b2 = yc.length;
          if (a2 - b2 < 0) {
            t2 = yc;
            yc = xc;
            xc = t2;
            b2 = a2;
          }
          for (a2 = 0; b2; ) {
            a2 = (xc[--b2] = xc[b2] + yc[b2] + a2) / BASE | 0;
            xc[b2] = BASE === xc[b2] ? 0 : xc[b2] % BASE;
          }
          if (a2) {
            xc = [a2].concat(xc);
            ++ye2;
          }
          return normalise(y2, xc, ye2);
        };
        P2.precision = P2.sd = function(sd, rm) {
          var c2, n2, v2, x2 = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x2), sd, rm);
          }
          if (!(c2 = x2.c)) return null;
          v2 = c2.length - 1;
          n2 = v2 * LOG_BASE + 1;
          if (v2 = c2[v2]) {
            for (; v2 % 10 == 0; v2 /= 10, n2--) ;
            for (v2 = c2[0]; v2 >= 10; v2 /= 10, n2++) ;
          }
          if (sd && x2.e + 1 > n2) n2 = x2.e + 1;
          return n2;
        };
        P2.shiftedBy = function(k2) {
          intCheck(k2, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times("1e" + k2);
        };
        P2.squareRoot = P2.sqrt = function() {
          var m2, n2, r2, rep, t2, x2 = this, c2 = x2.c, s2 = x2.s, e2 = x2.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s2 !== 1 || !c2 || !c2[0]) {
            return new BigNumber2(!s2 || s2 < 0 && (!c2 || c2[0]) ? NaN : c2 ? x2 : 1 / 0);
          }
          s2 = Math.sqrt(+valueOf(x2));
          if (s2 == 0 || s2 == 1 / 0) {
            n2 = coeffToString(c2);
            if ((n2.length + e2) % 2 == 0) n2 += "0";
            s2 = Math.sqrt(+n2);
            e2 = bitFloor((e2 + 1) / 2) - (e2 < 0 || e2 % 2);
            if (s2 == 1 / 0) {
              n2 = "5e" + e2;
            } else {
              n2 = s2.toExponential();
              n2 = n2.slice(0, n2.indexOf("e") + 1) + e2;
            }
            r2 = new BigNumber2(n2);
          } else {
            r2 = new BigNumber2(s2 + "");
          }
          if (r2.c[0]) {
            e2 = r2.e;
            s2 = e2 + dp;
            if (s2 < 3) s2 = 0;
            for (; ; ) {
              t2 = r2;
              r2 = half.times(t2.plus(div(x2, t2, dp, 1)));
              if (coeffToString(t2.c).slice(0, s2) === (n2 = coeffToString(r2.c)).slice(0, s2)) {
                if (r2.e < e2) --s2;
                n2 = n2.slice(s2 - 3, s2 + 1);
                if (n2 == "9999" || !rep && n2 == "4999") {
                  if (!rep) {
                    round(t2, t2.e + DECIMAL_PLACES + 2, 0);
                    if (t2.times(t2).eq(x2)) {
                      r2 = t2;
                      break;
                    }
                  }
                  dp += 4;
                  s2 += 4;
                  rep = 1;
                } else {
                  if (!+n2 || !+n2.slice(1) && n2.charAt(0) == "5") {
                    round(r2, r2.e + DECIMAL_PLACES + 2, 1);
                    m2 = !r2.times(r2).eq(x2);
                  }
                  break;
                }
              }
            }
          }
          return round(r2, r2.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m2);
        };
        P2.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format(this, dp, rm, 1);
        };
        P2.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format(this, dp, rm);
        };
        P2.toFormat = function(dp, rm, format2) {
          var str, x2 = this;
          if (format2 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format2 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format2 = dp;
              dp = rm = null;
            } else {
              format2 = FORMAT;
            }
          } else if (typeof format2 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format2);
          }
          str = x2.toFixed(dp, rm);
          if (x2.c) {
            var i2, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x2.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
              i2 = g1;
              g1 = g2;
              g2 = i2;
              len -= i2;
            }
            if (g1 > 0 && len > 0) {
              i2 = len % g1 || g1;
              intPart = intDigits.substr(0, i2);
              for (; i2 < len; i2 += g1) intPart += groupSeparator + intDigits.substr(i2, g1);
              if (g2 > 0) intPart += groupSeparator + intDigits.slice(i2);
              if (isNeg) intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + (format2.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format2.prefix || "") + str + (format2.suffix || "");
        };
        P2.toFraction = function(md) {
          var d2, d0, d1, d22, e2, exp, n2, n0, n1, q2, r2, s2, x2 = this, xc = x2.c;
          if (md != null) {
            n2 = new BigNumber2(md);
            if (!n2.isInteger() && (n2.c || n2.s !== 1) || n2.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n2.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n2));
            }
          }
          if (!xc) return new BigNumber2(x2);
          d2 = new BigNumber2(ONE);
          n1 = d0 = new BigNumber2(ONE);
          d1 = n0 = new BigNumber2(ONE);
          s2 = coeffToString(xc);
          e2 = d2.e = s2.length - x2.e - 1;
          d2.c[0] = POWS_TEN[(exp = e2 % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n2.comparedTo(d2) > 0 ? e2 > 0 ? d2 : n1 : n2;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n2 = new BigNumber2(s2);
          n0.c[0] = 0;
          for (; ; ) {
            q2 = div(n2, d2, 0, 1);
            d22 = d0.plus(q2.times(d1));
            if (d22.comparedTo(md) == 1) break;
            d0 = d1;
            d1 = d22;
            n1 = n0.plus(q2.times(d22 = n1));
            n0 = d22;
            d2 = n2.minus(q2.times(d22 = d2));
            n2 = d22;
          }
          d22 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d22.times(n1));
          d0 = d0.plus(d22.times(d1));
          n0.s = n1.s = x2.s;
          e2 = e2 * 2;
          r2 = div(n1, d1, e2, ROUNDING_MODE).minus(x2).abs().comparedTo(
            div(n0, d0, e2, ROUNDING_MODE).minus(x2).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp;
          return r2;
        };
        P2.toNumber = function() {
          return +valueOf(this);
        };
        P2.toPrecision = function(sd, rm) {
          if (sd != null) intCheck(sd, 1, MAX);
          return format(this, sd, rm, 2);
        };
        P2.toString = function(b2) {
          var str, n2 = this, s2 = n2.s, e2 = n2.e;
          if (e2 === null) {
            if (s2) {
              str = "Infinity";
              if (s2 < 0) str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b2 == null) {
              str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(coeffToString(n2.c), e2) : toFixedPoint(coeffToString(n2.c), e2, "0");
            } else if (b2 === 10 && alphabetHasNormalDecimalDigits) {
              n2 = round(new BigNumber2(n2), DECIMAL_PLACES + e2 + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n2.c), n2.e, "0");
            } else {
              intCheck(b2, 2, ALPHABET.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n2.c), e2, "0"), 10, b2, s2, true);
            }
            if (s2 < 0 && n2.c[0]) str = "-" + str;
          }
          return str;
        };
        P2.valueOf = P2.toJSON = function() {
          return valueOf(this);
        };
        P2._isBigNumber = true;
        if (configObject != null) BigNumber2.set(configObject);
        return BigNumber2;
      }
      function bitFloor(n2) {
        var i2 = n2 | 0;
        return n2 > 0 || n2 === i2 ? i2 : i2 - 1;
      }
      function coeffToString(a2) {
        var s2, z4, i2 = 1, j2 = a2.length, r2 = a2[0] + "";
        for (; i2 < j2; ) {
          s2 = a2[i2++] + "";
          z4 = LOG_BASE - s2.length;
          for (; z4--; s2 = "0" + s2) ;
          r2 += s2;
        }
        for (j2 = r2.length; r2.charCodeAt(--j2) === 48; ) ;
        return r2.slice(0, j2 + 1 || 1);
      }
      function compare(x2, y2) {
        var a2, b2, xc = x2.c, yc = y2.c, i2 = x2.s, j2 = y2.s, k2 = x2.e, l2 = y2.e;
        if (!i2 || !j2) return null;
        a2 = xc && !xc[0];
        b2 = yc && !yc[0];
        if (a2 || b2) return a2 ? b2 ? 0 : -j2 : i2;
        if (i2 != j2) return i2;
        a2 = i2 < 0;
        b2 = k2 == l2;
        if (!xc || !yc) return b2 ? 0 : !xc ^ a2 ? 1 : -1;
        if (!b2) return k2 > l2 ^ a2 ? 1 : -1;
        j2 = (k2 = xc.length) < (l2 = yc.length) ? k2 : l2;
        for (i2 = 0; i2 < j2; i2++) if (xc[i2] != yc[i2]) return xc[i2] > yc[i2] ^ a2 ? 1 : -1;
        return k2 == l2 ? 0 : k2 > l2 ^ a2 ? 1 : -1;
      }
      function intCheck(n2, min, max, name) {
        if (n2 < min || n2 > max || n2 !== mathfloor(n2)) {
          throw Error(bignumberError + (name || "Argument") + (typeof n2 == "number" ? n2 < min || n2 > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n2));
        }
      }
      function isOdd(n2) {
        var k2 = n2.c.length - 1;
        return bitFloor(n2.e / LOG_BASE) == k2 && n2.c[k2] % 2 != 0;
      }
      function toExponential(str, e2) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e2 < 0 ? "e" : "e+") + e2;
      }
      function toFixedPoint(str, e2, z4) {
        var len, zs;
        if (e2 < 0) {
          for (zs = z4 + "."; ++e2; zs += z4) ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e2 > len) {
            for (zs = z4, e2 -= len; --e2; zs += z4) ;
            str += zs;
          } else if (e2 < len) {
            str = str.slice(0, e2) + "." + str.slice(e2);
          }
        }
        return str;
      }
      BigNumber = clone2();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber;
        });
      } else if (typeof module != "undefined" && module.exports) {
        module.exports = BigNumber;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
      }
    })(exports);
  }
});

// ../node_modules/json-bigint/lib/stringify.js
var require_stringify = __commonJS({
  "../node_modules/json-bigint/lib/stringify.js"(exports, module) {
    "use strict";
    var BigNumber = require_bignumber();
    var JSON2 = module.exports;
    (function() {
      "use strict";
      function f2(n2) {
        return n2 < 10 ? "0" + n2 : n2;
      }
      var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
        // table of character substitutions
        "\b": "\\b",
        "	": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        '"': '\\"',
        "\\": "\\\\"
      }, rep;
      function quote(string) {
        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function(a2) {
          var c2 = meta[a2];
          return typeof c2 === "string" ? c2 : "\\u" + ("0000" + a2.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
      }
      function str(key, holder) {
        var i2, k2, v2, length, mind = gap, partial, value = holder[key], isBigNumber = value != null && (value instanceof BigNumber || BigNumber.isBigNumber(value));
        if (value && typeof value === "object" && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        if (typeof rep === "function") {
          value = rep.call(holder, key, value);
        }
        switch (typeof value) {
          case "string":
            if (isBigNumber) {
              return value;
            } else {
              return quote(value);
            }
          case "number":
            return isFinite(value) ? String(value) : "null";
          case "boolean":
          case "null":
          case "bigint":
            return String(value);
          // If the type is 'object', we might be dealing with an object or an array or
          // null.
          case "object":
            if (!value) {
              return "null";
            }
            gap += indent;
            partial = [];
            if (Object.prototype.toString.apply(value) === "[object Array]") {
              length = value.length;
              for (i2 = 0; i2 < length; i2 += 1) {
                partial[i2] = str(i2, value) || "null";
              }
              v2 = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
              gap = mind;
              return v2;
            }
            if (rep && typeof rep === "object") {
              length = rep.length;
              for (i2 = 0; i2 < length; i2 += 1) {
                if (typeof rep[i2] === "string") {
                  k2 = rep[i2];
                  v2 = str(k2, value);
                  if (v2) {
                    partial.push(quote(k2) + (gap ? ": " : ":") + v2);
                  }
                }
              }
            } else {
              Object.keys(value).forEach(function(k3) {
                var v6 = str(k3, value);
                if (v6) {
                  partial.push(quote(k3) + (gap ? ": " : ":") + v6);
                }
              });
            }
            v2 = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
            gap = mind;
            return v2;
        }
      }
      if (typeof JSON2.stringify !== "function") {
        JSON2.stringify = function(value, replacer, space) {
          var i2;
          gap = "";
          indent = "";
          if (typeof space === "number") {
            for (i2 = 0; i2 < space; i2 += 1) {
              indent += " ";
            }
          } else if (typeof space === "string") {
            indent = space;
          }
          rep = replacer;
          if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
            throw new Error("JSON.stringify");
          }
          return str("", { "": value });
        };
      }
    })();
  }
});

// ../node_modules/json-bigint/lib/parse.js
var require_parse = __commonJS({
  "../node_modules/json-bigint/lib/parse.js"(exports, module) {
    "use strict";
    var BigNumber = null;
    var suspectProtoRx = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/;
    var suspectConstructorRx = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
    var json_parse = function(options) {
      "use strict";
      var _options = {
        strict: false,
        // not being strict means do not generate syntax errors for "duplicate key"
        storeAsString: false,
        // toggles whether the values should be stored as BigNumber (default) or a string
        alwaysParseAsBig: false,
        // toggles whether all numbers should be Big
        useNativeBigInt: false,
        // toggles whether to use native BigInt instead of bignumber.js
        protoAction: "error",
        constructorAction: "error"
      };
      if (options !== void 0 && options !== null) {
        if (options.strict === true) {
          _options.strict = true;
        }
        if (options.storeAsString === true) {
          _options.storeAsString = true;
        }
        _options.alwaysParseAsBig = options.alwaysParseAsBig === true ? options.alwaysParseAsBig : false;
        _options.useNativeBigInt = options.useNativeBigInt === true ? options.useNativeBigInt : false;
        if (typeof options.constructorAction !== "undefined") {
          if (options.constructorAction === "error" || options.constructorAction === "ignore" || options.constructorAction === "preserve") {
            _options.constructorAction = options.constructorAction;
          } else {
            throw new Error(
              `Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${options.constructorAction}`
            );
          }
        }
        if (typeof options.protoAction !== "undefined") {
          if (options.protoAction === "error" || options.protoAction === "ignore" || options.protoAction === "preserve") {
            _options.protoAction = options.protoAction;
          } else {
            throw new Error(
              `Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${options.protoAction}`
            );
          }
        }
      }
      var at2, ch, escapee = {
        '"': '"',
        "\\": "\\",
        "/": "/",
        b: "\b",
        f: "\f",
        n: "\n",
        r: "\r",
        t: "	"
      }, text, error = function(m2) {
        throw {
          name: "SyntaxError",
          message: m2,
          at: at2,
          text
        };
      }, next = function(c2) {
        if (c2 && c2 !== ch) {
          error("Expected '" + c2 + "' instead of '" + ch + "'");
        }
        ch = text.charAt(at2);
        at2 += 1;
        return ch;
      }, number = function() {
        var number2, string2 = "";
        if (ch === "-") {
          string2 = "-";
          next("-");
        }
        while (ch >= "0" && ch <= "9") {
          string2 += ch;
          next();
        }
        if (ch === ".") {
          string2 += ".";
          while (next() && ch >= "0" && ch <= "9") {
            string2 += ch;
          }
        }
        if (ch === "e" || ch === "E") {
          string2 += ch;
          next();
          if (ch === "-" || ch === "+") {
            string2 += ch;
            next();
          }
          while (ch >= "0" && ch <= "9") {
            string2 += ch;
            next();
          }
        }
        number2 = +string2;
        if (!isFinite(number2)) {
          error("Bad number");
        } else {
          if (BigNumber == null) BigNumber = require_bignumber();
          if (string2.length > 15)
            return _options.storeAsString ? string2 : _options.useNativeBigInt ? BigInt(string2) : new BigNumber(string2);
          else
            return !_options.alwaysParseAsBig ? number2 : _options.useNativeBigInt ? BigInt(number2) : new BigNumber(number2);
        }
      }, string = function() {
        var hex, i2, string2 = "", uffff;
        if (ch === '"') {
          var startAt = at2;
          while (next()) {
            if (ch === '"') {
              if (at2 - 1 > startAt) string2 += text.substring(startAt, at2 - 1);
              next();
              return string2;
            }
            if (ch === "\\") {
              if (at2 - 1 > startAt) string2 += text.substring(startAt, at2 - 1);
              next();
              if (ch === "u") {
                uffff = 0;
                for (i2 = 0; i2 < 4; i2 += 1) {
                  hex = parseInt(next(), 16);
                  if (!isFinite(hex)) {
                    break;
                  }
                  uffff = uffff * 16 + hex;
                }
                string2 += String.fromCharCode(uffff);
              } else if (typeof escapee[ch] === "string") {
                string2 += escapee[ch];
              } else {
                break;
              }
              startAt = at2;
            }
          }
        }
        error("Bad string");
      }, white = function() {
        while (ch && ch <= " ") {
          next();
        }
      }, word = function() {
        switch (ch) {
          case "t":
            next("t");
            next("r");
            next("u");
            next("e");
            return true;
          case "f":
            next("f");
            next("a");
            next("l");
            next("s");
            next("e");
            return false;
          case "n":
            next("n");
            next("u");
            next("l");
            next("l");
            return null;
        }
        error("Unexpected '" + ch + "'");
      }, value, array = function() {
        var array2 = [];
        if (ch === "[") {
          next("[");
          white();
          if (ch === "]") {
            next("]");
            return array2;
          }
          while (ch) {
            array2.push(value());
            white();
            if (ch === "]") {
              next("]");
              return array2;
            }
            next(",");
            white();
          }
        }
        error("Bad array");
      }, object = function() {
        var key, object2 = /* @__PURE__ */ Object.create(null);
        if (ch === "{") {
          next("{");
          white();
          if (ch === "}") {
            next("}");
            return object2;
          }
          while (ch) {
            key = string();
            white();
            next(":");
            if (_options.strict === true && Object.hasOwnProperty.call(object2, key)) {
              error('Duplicate key "' + key + '"');
            }
            if (suspectProtoRx.test(key) === true) {
              if (_options.protoAction === "error") {
                error("Object contains forbidden prototype property");
              } else if (_options.protoAction === "ignore") {
                value();
              } else {
                object2[key] = value();
              }
            } else if (suspectConstructorRx.test(key) === true) {
              if (_options.constructorAction === "error") {
                error("Object contains forbidden constructor property");
              } else if (_options.constructorAction === "ignore") {
                value();
              } else {
                object2[key] = value();
              }
            } else {
              object2[key] = value();
            }
            white();
            if (ch === "}") {
              next("}");
              return object2;
            }
            next(",");
            white();
          }
        }
        error("Bad object");
      };
      value = function() {
        white();
        switch (ch) {
          case "{":
            return object();
          case "[":
            return array();
          case '"':
            return string();
          case "-":
            return number();
          default:
            return ch >= "0" && ch <= "9" ? number() : word();
        }
      };
      return function(source, reviver) {
        var result;
        text = source + "";
        at2 = 0;
        ch = " ";
        result = value();
        white();
        if (ch) {
          error("Syntax error");
        }
        return typeof reviver === "function" ? function walk(holder, key) {
          var k2, v2, value2 = holder[key];
          if (value2 && typeof value2 === "object") {
            Object.keys(value2).forEach(function(k3) {
              v2 = walk(value2, k3);
              if (v2 !== void 0) {
                value2[k3] = v2;
              } else {
                delete value2[k3];
              }
            });
          }
          return reviver.call(holder, key, value2);
        }({ "": result }, "") : result;
      };
    };
    module.exports = json_parse;
  }
});

// ../node_modules/json-bigint/index.js
var require_json_bigint = __commonJS({
  "../node_modules/json-bigint/index.js"(exports, module) {
    "use strict";
    var json_stringify = require_stringify().stringify;
    var json_parse = require_parse();
    module.exports = function(options) {
      return {
        parse: json_parse(options),
        stringify: json_stringify
      };
    };
    module.exports.parse = json_parse();
    module.exports.stringify = json_stringify;
  }
});

// ../node_modules/gcp-metadata/build/src/gcp-residency.js
var require_gcp_residency = __commonJS({
  "../node_modules/gcp-metadata/build/src/gcp-residency.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GCE_LINUX_BIOS_PATHS = void 0;
    exports.isGoogleCloudServerless = isGoogleCloudServerless;
    exports.isGoogleComputeEngineLinux = isGoogleComputeEngineLinux;
    exports.isGoogleComputeEngineMACAddress = isGoogleComputeEngineMACAddress;
    exports.isGoogleComputeEngine = isGoogleComputeEngine;
    exports.detectGCPResidency = detectGCPResidency;
    var fs_1 = __require("fs");
    var os_1 = __require("os");
    exports.GCE_LINUX_BIOS_PATHS = {
      BIOS_DATE: "/sys/class/dmi/id/bios_date",
      BIOS_VENDOR: "/sys/class/dmi/id/bios_vendor"
    };
    var GCE_MAC_ADDRESS_REGEX = /^42:01/;
    function isGoogleCloudServerless() {
      const isGFEnvironment = process.env.CLOUD_RUN_JOB || process.env.FUNCTION_NAME || process.env.K_SERVICE;
      return !!isGFEnvironment;
    }
    function isGoogleComputeEngineLinux() {
      if ((0, os_1.platform)() !== "linux")
        return false;
      try {
        (0, fs_1.statSync)(exports.GCE_LINUX_BIOS_PATHS.BIOS_DATE);
        const biosVendor = (0, fs_1.readFileSync)(exports.GCE_LINUX_BIOS_PATHS.BIOS_VENDOR, "utf8");
        return /Google/.test(biosVendor);
      } catch (_a3) {
        return false;
      }
    }
    function isGoogleComputeEngineMACAddress() {
      const interfaces = (0, os_1.networkInterfaces)();
      for (const item of Object.values(interfaces)) {
        if (!item)
          continue;
        for (const { mac } of item) {
          if (GCE_MAC_ADDRESS_REGEX.test(mac)) {
            return true;
          }
        }
      }
      return false;
    }
    function isGoogleComputeEngine() {
      return isGoogleComputeEngineLinux() || isGoogleComputeEngineMACAddress();
    }
    function detectGCPResidency() {
      return isGoogleCloudServerless() || isGoogleComputeEngine();
    }
  }
});

// ../node_modules/google-logging-utils/build/src/colours.js
var require_colours = __commonJS({
  "../node_modules/google-logging-utils/build/src/colours.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Colours = void 0;
    var Colours = class _Colours {
      /**
       * @param stream The stream (e.g. process.stderr)
       * @returns true if the stream should have colourization enabled
       */
      static isEnabled(stream) {
        return stream.isTTY && (typeof stream.getColorDepth === "function" ? stream.getColorDepth() > 2 : true);
      }
      static refresh() {
        _Colours.enabled = _Colours.isEnabled(process.stderr);
        if (!this.enabled) {
          _Colours.reset = "";
          _Colours.bright = "";
          _Colours.dim = "";
          _Colours.red = "";
          _Colours.green = "";
          _Colours.yellow = "";
          _Colours.blue = "";
          _Colours.magenta = "";
          _Colours.cyan = "";
          _Colours.white = "";
          _Colours.grey = "";
        } else {
          _Colours.reset = "\x1B[0m";
          _Colours.bright = "\x1B[1m";
          _Colours.dim = "\x1B[2m";
          _Colours.red = "\x1B[31m";
          _Colours.green = "\x1B[32m";
          _Colours.yellow = "\x1B[33m";
          _Colours.blue = "\x1B[34m";
          _Colours.magenta = "\x1B[35m";
          _Colours.cyan = "\x1B[36m";
          _Colours.white = "\x1B[37m";
          _Colours.grey = "\x1B[90m";
        }
      }
    };
    exports.Colours = Colours;
    Colours.enabled = false;
    Colours.reset = "";
    Colours.bright = "";
    Colours.dim = "";
    Colours.red = "";
    Colours.green = "";
    Colours.yellow = "";
    Colours.blue = "";
    Colours.magenta = "";
    Colours.cyan = "";
    Colours.white = "";
    Colours.grey = "";
    Colours.refresh();
  }
});

// ../node_modules/google-logging-utils/build/src/logging-utils.js
var require_logging_utils = __commonJS({
  "../node_modules/google-logging-utils/build/src/logging-utils.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.env = exports.DebugLogBackendBase = exports.placeholder = exports.AdhocDebugLogger = exports.LogSeverity = void 0;
    exports.getNodeBackend = getNodeBackend;
    exports.getDebugBackend = getDebugBackend;
    exports.getStructuredBackend = getStructuredBackend;
    exports.setBackend = setBackend;
    exports.log = log;
    var node_events_1 = __require("events");
    var process2 = __importStar(__require("process"));
    var util = __importStar(__require("util"));
    var colours_1 = require_colours();
    var LogSeverity;
    (function(LogSeverity2) {
      LogSeverity2["DEFAULT"] = "DEFAULT";
      LogSeverity2["DEBUG"] = "DEBUG";
      LogSeverity2["INFO"] = "INFO";
      LogSeverity2["WARNING"] = "WARNING";
      LogSeverity2["ERROR"] = "ERROR";
    })(LogSeverity || (exports.LogSeverity = LogSeverity = {}));
    var AdhocDebugLogger = class extends node_events_1.EventEmitter {
      /**
       * @param upstream The backend will pass a function that will be
       *   called whenever our logger function is invoked.
       */
      constructor(namespace, upstream) {
        super();
        this.namespace = namespace;
        this.upstream = upstream;
        this.func = Object.assign(this.invoke.bind(this), {
          // Also add an instance pointer back to us.
          instance: this,
          // And pull over the EventEmitter functionality.
          on: (event, listener) => this.on(event, listener)
        });
        this.func.debug = (...args) => this.invokeSeverity(LogSeverity.DEBUG, ...args);
        this.func.info = (...args) => this.invokeSeverity(LogSeverity.INFO, ...args);
        this.func.warn = (...args) => this.invokeSeverity(LogSeverity.WARNING, ...args);
        this.func.error = (...args) => this.invokeSeverity(LogSeverity.ERROR, ...args);
        this.func.sublog = (namespace2) => log(namespace2, this.func);
      }
      invoke(fields, ...args) {
        if (this.upstream) {
          this.upstream(fields, ...args);
        }
        this.emit("log", fields, args);
      }
      invokeSeverity(severity, ...args) {
        this.invoke({ severity }, ...args);
      }
    };
    exports.AdhocDebugLogger = AdhocDebugLogger;
    exports.placeholder = new AdhocDebugLogger("", () => {
    }).func;
    var DebugLogBackendBase = class {
      constructor() {
        var _a3;
        this.cached = /* @__PURE__ */ new Map();
        this.filters = [];
        this.filtersSet = false;
        let nodeFlag = (_a3 = process2.env[exports.env.nodeEnables]) !== null && _a3 !== void 0 ? _a3 : "*";
        if (nodeFlag === "all") {
          nodeFlag = "*";
        }
        this.filters = nodeFlag.split(",");
      }
      log(namespace, fields, ...args) {
        try {
          if (!this.filtersSet) {
            this.setFilters();
            this.filtersSet = true;
          }
          let logger2 = this.cached.get(namespace);
          if (!logger2) {
            logger2 = this.makeLogger(namespace);
            this.cached.set(namespace, logger2);
          }
          logger2(fields, ...args);
        } catch (e2) {
          console.error(e2);
        }
      }
    };
    exports.DebugLogBackendBase = DebugLogBackendBase;
    var NodeBackend = class extends DebugLogBackendBase {
      constructor() {
        super(...arguments);
        this.enabledRegexp = /.*/g;
      }
      isEnabled(namespace) {
        return this.enabledRegexp.test(namespace);
      }
      makeLogger(namespace) {
        if (!this.enabledRegexp.test(namespace)) {
          return () => {
          };
        }
        return (fields, ...args) => {
          var _a3;
          const nscolour = `${colours_1.Colours.green}${namespace}${colours_1.Colours.reset}`;
          const pid = `${colours_1.Colours.yellow}${process2.pid}${colours_1.Colours.reset}`;
          let level;
          switch (fields.severity) {
            case LogSeverity.ERROR:
              level = `${colours_1.Colours.red}${fields.severity}${colours_1.Colours.reset}`;
              break;
            case LogSeverity.INFO:
              level = `${colours_1.Colours.magenta}${fields.severity}${colours_1.Colours.reset}`;
              break;
            case LogSeverity.WARNING:
              level = `${colours_1.Colours.yellow}${fields.severity}${colours_1.Colours.reset}`;
              break;
            default:
              level = (_a3 = fields.severity) !== null && _a3 !== void 0 ? _a3 : LogSeverity.DEFAULT;
              break;
          }
          const msg = util.formatWithOptions({ colors: colours_1.Colours.enabled }, ...args);
          const filteredFields = Object.assign({}, fields);
          delete filteredFields.severity;
          const fieldsJson = Object.getOwnPropertyNames(filteredFields).length ? JSON.stringify(filteredFields) : "";
          const fieldsColour = fieldsJson ? `${colours_1.Colours.grey}${fieldsJson}${colours_1.Colours.reset}` : "";
          console.error("%s [%s|%s] %s%s", pid, nscolour, level, msg, fieldsJson ? ` ${fieldsColour}` : "");
        };
      }
      // Regexp patterns below are from here:
      // https://github.com/nodejs/node/blob/c0aebed4b3395bd65d54b18d1fd00f071002ac20/lib/internal/util/debuglog.js#L36
      setFilters() {
        const totalFilters = this.filters.join(",");
        const regexp = totalFilters.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^");
        this.enabledRegexp = new RegExp(`^${regexp}$`, "i");
      }
    };
    function getNodeBackend() {
      return new NodeBackend();
    }
    var DebugBackend = class extends DebugLogBackendBase {
      constructor(pkg) {
        super();
        this.debugPkg = pkg;
      }
      makeLogger(namespace) {
        const debugLogger = this.debugPkg(namespace);
        return (fields, ...args) => {
          debugLogger(args[0], ...args.slice(1));
        };
      }
      setFilters() {
        var _a3;
        const existingFilters = (_a3 = process2.env["NODE_DEBUG"]) !== null && _a3 !== void 0 ? _a3 : "";
        process2.env["NODE_DEBUG"] = `${existingFilters}${existingFilters ? "," : ""}${this.filters.join(",")}`;
      }
    };
    function getDebugBackend(debugPkg) {
      return new DebugBackend(debugPkg);
    }
    var StructuredBackend = class extends DebugLogBackendBase {
      constructor(upstream) {
        var _a3;
        super();
        this.upstream = (_a3 = upstream) !== null && _a3 !== void 0 ? _a3 : new NodeBackend();
      }
      makeLogger(namespace) {
        const debugLogger = this.upstream.makeLogger(namespace);
        return (fields, ...args) => {
          var _a3;
          const severity = (_a3 = fields.severity) !== null && _a3 !== void 0 ? _a3 : LogSeverity.INFO;
          const json = Object.assign({
            severity,
            message: util.format(...args)
          }, fields);
          const jsonString = JSON.stringify(json);
          debugLogger(fields, jsonString);
        };
      }
      setFilters() {
        this.upstream.setFilters();
      }
    };
    function getStructuredBackend(upstream) {
      return new StructuredBackend(upstream);
    }
    exports.env = {
      /**
       * Filter wildcards specific to the Node syntax, and similar to the built-in
       * utils.debuglog() environment variable. If missing, disables logging.
       */
      nodeEnables: "GOOGLE_SDK_NODE_LOGGING"
    };
    var loggerCache = /* @__PURE__ */ new Map();
    var cachedBackend = void 0;
    function setBackend(backend) {
      cachedBackend = backend;
      loggerCache.clear();
    }
    function log(namespace, parent) {
      const enablesFlag = process2.env[exports.env.nodeEnables];
      if (!enablesFlag) {
        return exports.placeholder;
      }
      if (!namespace) {
        return exports.placeholder;
      }
      if (parent) {
        namespace = `${parent.instance.namespace}:${namespace}`;
      }
      const existing = loggerCache.get(namespace);
      if (existing) {
        return existing.func;
      }
      if (cachedBackend === null) {
        return exports.placeholder;
      } else if (cachedBackend === void 0) {
        cachedBackend = getNodeBackend();
      }
      const logger2 = (() => {
        let previousBackend = void 0;
        const newLogger = new AdhocDebugLogger(namespace, (fields, ...args) => {
          if (previousBackend !== cachedBackend) {
            if (cachedBackend === null) {
              return;
            } else if (cachedBackend === void 0) {
              cachedBackend = getNodeBackend();
            }
            previousBackend = cachedBackend;
          }
          cachedBackend === null || cachedBackend === void 0 ? void 0 : cachedBackend.log(namespace, fields, ...args);
        });
        return newLogger;
      })();
      loggerCache.set(namespace, logger2);
      return logger2.func;
    }
  }
});

// ../node_modules/google-logging-utils/build/src/index.js
var require_src3 = __commonJS({
  "../node_modules/google-logging-utils/build/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_logging_utils(), exports);
  }
});

// ../node_modules/gcp-metadata/build/src/index.js
var require_src4 = __commonJS({
  "../node_modules/gcp-metadata/build/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.gcpResidencyCache = exports.METADATA_SERVER_DETECTION = exports.HEADERS = exports.HEADER_VALUE = exports.HEADER_NAME = exports.SECONDARY_HOST_ADDRESS = exports.HOST_ADDRESS = exports.BASE_PATH = void 0;
    exports.instance = instance;
    exports.project = project;
    exports.universe = universe;
    exports.bulk = bulk;
    exports.isAvailable = isAvailable;
    exports.resetIsAvailableCache = resetIsAvailableCache;
    exports.getGCPResidency = getGCPResidency;
    exports.setGCPResidency = setGCPResidency;
    exports.requestTimeout = requestTimeout;
    var gaxios_1 = require_src2();
    var jsonBigint = require_json_bigint();
    var gcp_residency_1 = require_gcp_residency();
    var logger2 = require_src3();
    exports.BASE_PATH = "/computeMetadata/v1";
    exports.HOST_ADDRESS = "http://169.254.169.254";
    exports.SECONDARY_HOST_ADDRESS = "http://metadata.google.internal.";
    exports.HEADER_NAME = "Metadata-Flavor";
    exports.HEADER_VALUE = "Google";
    exports.HEADERS = Object.freeze({ [exports.HEADER_NAME]: exports.HEADER_VALUE });
    var log = logger2.log("gcp metadata");
    exports.METADATA_SERVER_DETECTION = Object.freeze({
      "assume-present": "don't try to ping the metadata server, but assume it's present",
      none: "don't try to ping the metadata server, but don't try to use it either",
      "bios-only": "treat the result of a BIOS probe as canonical (don't fall back to pinging)",
      "ping-only": "skip the BIOS probe, and go straight to pinging"
    });
    function getBaseUrl2(baseUrl) {
      if (!baseUrl) {
        baseUrl = process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST || exports.HOST_ADDRESS;
      }
      if (!/^https?:\/\//.test(baseUrl)) {
        baseUrl = `http://${baseUrl}`;
      }
      return new URL(exports.BASE_PATH, baseUrl).href;
    }
    function validate2(options) {
      Object.keys(options).forEach((key) => {
        switch (key) {
          case "params":
          case "property":
          case "headers":
            break;
          case "qs":
            throw new Error("'qs' is not a valid configuration option. Please use 'params' instead.");
          default:
            throw new Error(`'${key}' is not a valid configuration option.`);
        }
      });
    }
    async function metadataAccessor(type, options = {}, noResponseRetries = 3, fastFail = false) {
      let metadataKey = "";
      let params = {};
      let headers = {};
      if (typeof type === "object") {
        const metadataAccessor2 = type;
        metadataKey = metadataAccessor2.metadataKey;
        params = metadataAccessor2.params || params;
        headers = metadataAccessor2.headers || headers;
        noResponseRetries = metadataAccessor2.noResponseRetries || noResponseRetries;
        fastFail = metadataAccessor2.fastFail || fastFail;
      } else {
        metadataKey = type;
      }
      if (typeof options === "string") {
        metadataKey += `/${options}`;
      } else {
        validate2(options);
        if (options.property) {
          metadataKey += `/${options.property}`;
        }
        headers = options.headers || headers;
        params = options.params || params;
      }
      const requestMethod = fastFail ? fastFailMetadataRequest : gaxios_1.request;
      const req = {
        url: `${getBaseUrl2()}/${metadataKey}`,
        headers: { ...exports.HEADERS, ...headers },
        retryConfig: { noResponseRetries },
        params,
        responseType: "text",
        timeout: requestTimeout()
      };
      log.info("instance request %j", req);
      const res = await requestMethod(req);
      log.info("instance metadata is %s", res.data);
      if (res.headers[exports.HEADER_NAME.toLowerCase()] !== exports.HEADER_VALUE) {
        throw new Error(`Invalid response from metadata service: incorrect ${exports.HEADER_NAME} header. Expected '${exports.HEADER_VALUE}', got ${res.headers[exports.HEADER_NAME.toLowerCase()] ? `'${res.headers[exports.HEADER_NAME.toLowerCase()]}'` : "no header"}`);
      }
      if (typeof res.data === "string") {
        try {
          return jsonBigint.parse(res.data);
        } catch (_a3) {
        }
      }
      return res.data;
    }
    async function fastFailMetadataRequest(options) {
      var _a3;
      const secondaryOptions = {
        ...options,
        url: (_a3 = options.url) === null || _a3 === void 0 ? void 0 : _a3.toString().replace(getBaseUrl2(), getBaseUrl2(exports.SECONDARY_HOST_ADDRESS))
      };
      let responded = false;
      const r1 = (0, gaxios_1.request)(options).then((res) => {
        responded = true;
        return res;
      }).catch((err) => {
        if (responded) {
          return r2;
        } else {
          responded = true;
          throw err;
        }
      });
      const r2 = (0, gaxios_1.request)(secondaryOptions).then((res) => {
        responded = true;
        return res;
      }).catch((err) => {
        if (responded) {
          return r1;
        } else {
          responded = true;
          throw err;
        }
      });
      return Promise.race([r1, r2]);
    }
    function instance(options) {
      return metadataAccessor("instance", options);
    }
    function project(options) {
      return metadataAccessor("project", options);
    }
    function universe(options) {
      return metadataAccessor("universe", options);
    }
    async function bulk(properties) {
      const r2 = {};
      await Promise.all(properties.map((item) => {
        return (async () => {
          const res = await metadataAccessor(item);
          const key = item.metadataKey;
          r2[key] = res;
        })();
      }));
      return r2;
    }
    function detectGCPAvailableRetries() {
      return process.env.DETECT_GCP_RETRIES ? Number(process.env.DETECT_GCP_RETRIES) : 0;
    }
    var cachedIsAvailableResponse;
    async function isAvailable() {
      if (process.env.METADATA_SERVER_DETECTION) {
        const value = process.env.METADATA_SERVER_DETECTION.trim().toLocaleLowerCase();
        if (!(value in exports.METADATA_SERVER_DETECTION)) {
          throw new RangeError(`Unknown \`METADATA_SERVER_DETECTION\` env variable. Got \`${value}\`, but it should be \`${Object.keys(exports.METADATA_SERVER_DETECTION).join("`, `")}\`, or unset`);
        }
        switch (value) {
          case "assume-present":
            return true;
          case "none":
            return false;
          case "bios-only":
            return getGCPResidency();
          case "ping-only":
        }
      }
      try {
        if (cachedIsAvailableResponse === void 0) {
          cachedIsAvailableResponse = metadataAccessor(
            "instance",
            void 0,
            detectGCPAvailableRetries(),
            // If the default HOST_ADDRESS has been overridden, we should not
            // make an effort to try SECONDARY_HOST_ADDRESS (as we are likely in
            // a non-GCP environment):
            !(process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST)
          );
        }
        await cachedIsAvailableResponse;
        return true;
      } catch (e2) {
        const err = e2;
        if (process.env.DEBUG_AUTH) {
          console.info(err);
        }
        if (err.type === "request-timeout") {
          return false;
        }
        if (err.response && err.response.status === 404) {
          return false;
        } else {
          if (!(err.response && err.response.status === 404) && // A warning is emitted if we see an unexpected err.code, or err.code
          // is not populated:
          (!err.code || ![
            "EHOSTDOWN",
            "EHOSTUNREACH",
            "ENETUNREACH",
            "ENOENT",
            "ENOTFOUND",
            "ECONNREFUSED"
          ].includes(err.code))) {
            let code = "UNKNOWN";
            if (err.code)
              code = err.code;
            process.emitWarning(`received unexpected error = ${err.message} code = ${code}`, "MetadataLookupWarning");
          }
          return false;
        }
      }
    }
    function resetIsAvailableCache() {
      cachedIsAvailableResponse = void 0;
    }
    exports.gcpResidencyCache = null;
    function getGCPResidency() {
      if (exports.gcpResidencyCache === null) {
        setGCPResidency();
      }
      return exports.gcpResidencyCache;
    }
    function setGCPResidency(value = null) {
      exports.gcpResidencyCache = value !== null ? value : (0, gcp_residency_1.detectGCPResidency)();
    }
    function requestTimeout() {
      return getGCPResidency() ? 0 : 3e3;
    }
    __exportStar(require_gcp_residency(), exports);
  }
});

// ../node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "../node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i2 = 0, len = code.length; i2 < len; ++i2) {
      lookup[i2] = code[i2];
      revLookup[code.charCodeAt(i2)] = i2;
    }
    var i2;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i3;
      for (i3 = 0; i3 < len2; i3 += 4) {
        tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i3 = start; i3 < end; i3 += 3) {
        tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// ../node_modules/google-auth-library/build/src/crypto/browser/crypto.js
var require_crypto = __commonJS({
  "../node_modules/google-auth-library/build/src/crypto/browser/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BrowserCrypto = void 0;
    var base64js = require_base64_js();
    var crypto_1 = require_crypto3();
    var BrowserCrypto = class _BrowserCrypto {
      constructor() {
        if (typeof window === "undefined" || window.crypto === void 0 || window.crypto.subtle === void 0) {
          throw new Error("SubtleCrypto not found. Make sure it's an https:// website.");
        }
      }
      async sha256DigestBase64(str) {
        const inputBuffer = new TextEncoder().encode(str);
        const outputBuffer = await window.crypto.subtle.digest("SHA-256", inputBuffer);
        return base64js.fromByteArray(new Uint8Array(outputBuffer));
      }
      randomBytesBase64(count) {
        const array = new Uint8Array(count);
        window.crypto.getRandomValues(array);
        return base64js.fromByteArray(array);
      }
      static padBase64(base64) {
        while (base64.length % 4 !== 0) {
          base64 += "=";
        }
        return base64;
      }
      async verify(pubkey, data, signature) {
        const algo = {
          name: "RSASSA-PKCS1-v1_5",
          hash: { name: "SHA-256" }
        };
        const dataArray = new TextEncoder().encode(data);
        const signatureArray = base64js.toByteArray(_BrowserCrypto.padBase64(signature));
        const cryptoKey = await window.crypto.subtle.importKey("jwk", pubkey, algo, true, ["verify"]);
        const result = await window.crypto.subtle.verify(algo, cryptoKey, signatureArray, dataArray);
        return result;
      }
      async sign(privateKey, data) {
        const algo = {
          name: "RSASSA-PKCS1-v1_5",
          hash: { name: "SHA-256" }
        };
        const dataArray = new TextEncoder().encode(data);
        const cryptoKey = await window.crypto.subtle.importKey("jwk", privateKey, algo, true, ["sign"]);
        const result = await window.crypto.subtle.sign(algo, cryptoKey, dataArray);
        return base64js.fromByteArray(new Uint8Array(result));
      }
      decodeBase64StringUtf8(base64) {
        const uint8array = base64js.toByteArray(_BrowserCrypto.padBase64(base64));
        const result = new TextDecoder().decode(uint8array);
        return result;
      }
      encodeBase64StringUtf8(text) {
        const uint8array = new TextEncoder().encode(text);
        const result = base64js.fromByteArray(uint8array);
        return result;
      }
      /**
       * Computes the SHA-256 hash of the provided string.
       * @param str The plain text string to hash.
       * @return A promise that resolves with the SHA-256 hash of the provided
       *   string in hexadecimal encoding.
       */
      async sha256DigestHex(str) {
        const inputBuffer = new TextEncoder().encode(str);
        const outputBuffer = await window.crypto.subtle.digest("SHA-256", inputBuffer);
        return (0, crypto_1.fromArrayBufferToHex)(outputBuffer);
      }
      /**
       * Computes the HMAC hash of a message using the provided crypto key and the
       * SHA-256 algorithm.
       * @param key The secret crypto key in utf-8 or ArrayBuffer format.
       * @param msg The plain text message.
       * @return A promise that resolves with the HMAC-SHA256 hash in ArrayBuffer
       *   format.
       */
      async signWithHmacSha256(key, msg) {
        const rawKey = typeof key === "string" ? key : String.fromCharCode(...new Uint16Array(key));
        const enc = new TextEncoder();
        const cryptoKey = await window.crypto.subtle.importKey("raw", enc.encode(rawKey), {
          name: "HMAC",
          hash: {
            name: "SHA-256"
          }
        }, false, ["sign"]);
        return window.crypto.subtle.sign("HMAC", cryptoKey, enc.encode(msg));
      }
    };
    exports.BrowserCrypto = BrowserCrypto;
  }
});

// ../node_modules/google-auth-library/build/src/crypto/node/crypto.js
var require_crypto2 = __commonJS({
  "../node_modules/google-auth-library/build/src/crypto/node/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NodeCrypto = void 0;
    var crypto6 = __require("crypto");
    var NodeCrypto = class {
      async sha256DigestBase64(str) {
        return crypto6.createHash("sha256").update(str).digest("base64");
      }
      randomBytesBase64(count) {
        return crypto6.randomBytes(count).toString("base64");
      }
      async verify(pubkey, data, signature) {
        const verifier = crypto6.createVerify("RSA-SHA256");
        verifier.update(data);
        verifier.end();
        return verifier.verify(pubkey, signature, "base64");
      }
      async sign(privateKey, data) {
        const signer = crypto6.createSign("RSA-SHA256");
        signer.update(data);
        signer.end();
        return signer.sign(privateKey, "base64");
      }
      decodeBase64StringUtf8(base64) {
        return Buffer.from(base64, "base64").toString("utf-8");
      }
      encodeBase64StringUtf8(text) {
        return Buffer.from(text, "utf-8").toString("base64");
      }
      /**
       * Computes the SHA-256 hash of the provided string.
       * @param str The plain text string to hash.
       * @return A promise that resolves with the SHA-256 hash of the provided
       *   string in hexadecimal encoding.
       */
      async sha256DigestHex(str) {
        return crypto6.createHash("sha256").update(str).digest("hex");
      }
      /**
       * Computes the HMAC hash of a message using the provided crypto key and the
       * SHA-256 algorithm.
       * @param key The secret crypto key in utf-8 or ArrayBuffer format.
       * @param msg The plain text message.
       * @return A promise that resolves with the HMAC-SHA256 hash in ArrayBuffer
       *   format.
       */
      async signWithHmacSha256(key, msg) {
        const cryptoKey = typeof key === "string" ? key : toBuffer(key);
        return toArrayBuffer(crypto6.createHmac("sha256", cryptoKey).update(msg).digest());
      }
    };
    exports.NodeCrypto = NodeCrypto;
    function toArrayBuffer(buffer) {
      return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
    }
    function toBuffer(arrayBuffer) {
      return Buffer.from(arrayBuffer);
    }
  }
});

// ../node_modules/google-auth-library/build/src/crypto/crypto.js
var require_crypto3 = __commonJS({
  "../node_modules/google-auth-library/build/src/crypto/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCrypto = createCrypto;
    exports.hasBrowserCrypto = hasBrowserCrypto;
    exports.fromArrayBufferToHex = fromArrayBufferToHex;
    var crypto_1 = require_crypto();
    var crypto_2 = require_crypto2();
    function createCrypto() {
      if (hasBrowserCrypto()) {
        return new crypto_1.BrowserCrypto();
      }
      return new crypto_2.NodeCrypto();
    }
    function hasBrowserCrypto() {
      return typeof window !== "undefined" && typeof window.crypto !== "undefined" && typeof window.crypto.subtle !== "undefined";
    }
    function fromArrayBufferToHex(arrayBuffer) {
      const byteArray = Array.from(new Uint8Array(arrayBuffer));
      return byteArray.map((byte) => {
        return byte.toString(16).padStart(2, "0");
      }).join("");
    }
  }
});

// ../node_modules/google-auth-library/build/src/options.js
var require_options = __commonJS({
  "../node_modules/google-auth-library/build/src/options.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validate = validate2;
    function validate2(options) {
      const vpairs = [
        { invalid: "uri", expected: "url" },
        { invalid: "json", expected: "data" },
        { invalid: "qs", expected: "params" }
      ];
      for (const pair of vpairs) {
        if (options[pair.invalid]) {
          const e2 = `'${pair.invalid}' is not a valid configuration option. Please use '${pair.expected}' instead. This library is using Axios for requests. Please see https://github.com/axios/axios to learn more about the valid request options.`;
          throw new Error(e2);
        }
      }
    }
  }
});

// ../node_modules/google-auth-library/package.json
var require_package2 = __commonJS({
  "../node_modules/google-auth-library/package.json"(exports, module) {
    module.exports = {
      name: "google-auth-library",
      version: "9.15.1",
      author: "Google Inc.",
      description: "Google APIs Authentication Client Library for Node.js",
      engines: {
        node: ">=14"
      },
      main: "./build/src/index.js",
      types: "./build/src/index.d.ts",
      repository: "googleapis/google-auth-library-nodejs.git",
      keywords: [
        "google",
        "api",
        "google apis",
        "client",
        "client library"
      ],
      dependencies: {
        "base64-js": "^1.3.0",
        "ecdsa-sig-formatter": "^1.0.11",
        gaxios: "^6.1.1",
        "gcp-metadata": "^6.1.0",
        gtoken: "^7.0.0",
        jws: "^4.0.0"
      },
      devDependencies: {
        "@types/base64-js": "^1.2.5",
        "@types/chai": "^4.1.7",
        "@types/jws": "^3.1.0",
        "@types/mocha": "^9.0.0",
        "@types/mv": "^2.1.0",
        "@types/ncp": "^2.0.1",
        "@types/node": "^20.4.2",
        "@types/sinon": "^17.0.0",
        "assert-rejects": "^1.0.0",
        c8: "^8.0.0",
        chai: "^4.2.0",
        cheerio: "1.0.0-rc.12",
        codecov: "^3.0.2",
        "engine.io": "6.6.2",
        gts: "^5.0.0",
        "is-docker": "^2.0.0",
        jsdoc: "^4.0.0",
        "jsdoc-fresh": "^3.0.0",
        "jsdoc-region-tag": "^3.0.0",
        karma: "^6.0.0",
        "karma-chrome-launcher": "^3.0.0",
        "karma-coverage": "^2.0.0",
        "karma-firefox-launcher": "^2.0.0",
        "karma-mocha": "^2.0.0",
        "karma-sourcemap-loader": "^0.4.0",
        "karma-webpack": "5.0.0",
        keypair: "^1.0.4",
        linkinator: "^4.0.0",
        mocha: "^9.2.2",
        mv: "^2.1.1",
        ncp: "^2.0.0",
        nock: "^13.0.0",
        "null-loader": "^4.0.0",
        pdfmake: "0.2.12",
        puppeteer: "^21.0.0",
        sinon: "^18.0.0",
        "ts-loader": "^8.0.0",
        typescript: "^5.1.6",
        webpack: "^5.21.2",
        "webpack-cli": "^4.0.0"
      },
      files: [
        "build/src",
        "!build/src/**/*.map"
      ],
      scripts: {
        test: "c8 mocha build/test",
        clean: "gts clean",
        prepare: "npm run compile",
        lint: "gts check",
        compile: "tsc -p .",
        fix: "gts fix",
        pretest: "npm run compile -- --sourceMap",
        docs: "jsdoc -c .jsdoc.json",
        "samples-setup": "cd samples/ && npm link ../ && npm run setup && cd ../",
        "samples-test": "cd samples/ && npm link ../ && npm test && cd ../",
        "system-test": "mocha build/system-test --timeout 60000",
        "presystem-test": "npm run compile -- --sourceMap",
        webpack: "webpack",
        "browser-test": "karma start",
        "docs-test": "linkinator docs",
        "predocs-test": "npm run docs",
        prelint: "cd samples; npm link ../; npm install",
        precompile: "gts clean"
      },
      license: "Apache-2.0"
    };
  }
});

// ../node_modules/google-auth-library/build/src/transporters.js
var require_transporters = __commonJS({
  "../node_modules/google-auth-library/build/src/transporters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultTransporter = void 0;
    var gaxios_1 = require_src2();
    var options_1 = require_options();
    var pkg = require_package2();
    var PRODUCT_NAME = "google-api-nodejs-client";
    var DefaultTransporter = class _DefaultTransporter {
      constructor() {
        this.instance = new gaxios_1.Gaxios();
      }
      /**
       * Configures request options before making a request.
       * @param opts GaxiosOptions options.
       * @return Configured options.
       */
      configure(opts = {}) {
        opts.headers = opts.headers || {};
        if (typeof window === "undefined") {
          const uaValue = opts.headers["User-Agent"];
          if (!uaValue) {
            opts.headers["User-Agent"] = _DefaultTransporter.USER_AGENT;
          } else if (!uaValue.includes(`${PRODUCT_NAME}/`)) {
            opts.headers["User-Agent"] = `${uaValue} ${_DefaultTransporter.USER_AGENT}`;
          }
          if (!opts.headers["x-goog-api-client"]) {
            const nodeVersion = process.version.replace(/^v/, "");
            opts.headers["x-goog-api-client"] = `gl-node/${nodeVersion}`;
          }
        }
        return opts;
      }
      /**
       * Makes a request using Gaxios with given options.
       * @param opts GaxiosOptions options.
       * @param callback optional callback that contains GaxiosResponse object.
       * @return GaxiosPromise, assuming no callback is passed.
       */
      request(opts) {
        opts = this.configure(opts);
        (0, options_1.validate)(opts);
        return this.instance.request(opts).catch((e2) => {
          throw this.processError(e2);
        });
      }
      get defaults() {
        return this.instance.defaults;
      }
      set defaults(opts) {
        this.instance.defaults = opts;
      }
      /**
       * Changes the error to include details from the body.
       */
      processError(e2) {
        const res = e2.response;
        const err = e2;
        const body = res ? res.data : null;
        if (res && body && body.error && res.status !== 200) {
          if (typeof body.error === "string") {
            err.message = body.error;
            err.status = res.status;
          } else if (Array.isArray(body.error.errors)) {
            err.message = body.error.errors.map((err2) => err2.message).join("\n");
            err.code = body.error.code;
            err.errors = body.error.errors;
          } else {
            err.message = body.error.message;
            err.code = body.error.code;
          }
        } else if (res && res.status >= 400) {
          err.message = body;
          err.status = res.status;
        }
        return err;
      }
    };
    exports.DefaultTransporter = DefaultTransporter;
    DefaultTransporter.USER_AGENT = `${PRODUCT_NAME}/${pkg.version}`;
  }
});

// ../node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "../node_modules/safe-buffer/index.js"(exports, module) {
    "use strict";
    var buffer = __require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS({
  "../node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js"(exports, module) {
    "use strict";
    function getParamSize(keySize) {
      var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
      return result;
    }
    var paramBytesForAlg = {
      ES256: getParamSize(256),
      ES384: getParamSize(384),
      ES512: getParamSize(521)
    };
    function getParamBytesForAlg(alg) {
      var paramBytes = paramBytesForAlg[alg];
      if (paramBytes) {
        return paramBytes;
      }
      throw new Error('Unknown algorithm "' + alg + '"');
    }
    module.exports = getParamBytesForAlg;
  }
});

// ../node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS({
  "../node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js"(exports, module) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var getParamBytesForAlg = require_param_bytes_for_alg();
    var MAX_OCTET = 128;
    var CLASS_UNIVERSAL = 0;
    var PRIMITIVE_BIT = 32;
    var TAG_SEQ = 16;
    var TAG_INT = 2;
    var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
    var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
    function base64Url(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function signatureAsBuffer(signature) {
      if (Buffer2.isBuffer(signature)) {
        return signature;
      } else if ("string" === typeof signature) {
        return Buffer2.from(signature, "base64");
      }
      throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
    }
    function derToJose(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var maxEncodedParamLength = paramBytes + 1;
      var inputLength = signature.length;
      var offset = 0;
      if (signature[offset++] !== ENCODED_TAG_SEQ) {
        throw new Error('Could not find expected "seq"');
      }
      var seqLength = signature[offset++];
      if (seqLength === (MAX_OCTET | 1)) {
        seqLength = signature[offset++];
      }
      if (inputLength - offset < seqLength) {
        throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
      }
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "r"');
      }
      var rLength = signature[offset++];
      if (inputLength - offset - 2 < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
      }
      if (maxEncodedParamLength < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var rOffset = offset;
      offset += rLength;
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "s"');
      }
      var sLength = signature[offset++];
      if (inputLength - offset !== sLength) {
        throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
      }
      if (maxEncodedParamLength < sLength) {
        throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var sOffset = offset;
      offset += sLength;
      if (offset !== inputLength) {
        throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
      }
      var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
      var dst = Buffer2.allocUnsafe(rPadding + rLength + sPadding + sLength);
      for (offset = 0; offset < rPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
      offset = paramBytes;
      for (var o2 = offset; offset < o2 + sPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
      dst = dst.toString("base64");
      dst = base64Url(dst);
      return dst;
    }
    function countPadding(buf, start, stop) {
      var padding = 0;
      while (start + padding < stop && buf[start + padding] === 0) {
        ++padding;
      }
      var needsSign = buf[start + padding] >= MAX_OCTET;
      if (needsSign) {
        --padding;
      }
      return padding;
    }
    function joseToDer(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var signatureBytes = signature.length;
      if (signatureBytes !== paramBytes * 2) {
        throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
      }
      var rPadding = countPadding(signature, 0, paramBytes);
      var sPadding = countPadding(signature, paramBytes, signature.length);
      var rLength = paramBytes - rPadding;
      var sLength = paramBytes - sPadding;
      var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
      var shortLength = rsBytes < MAX_OCTET;
      var dst = Buffer2.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
      var offset = 0;
      dst[offset++] = ENCODED_TAG_SEQ;
      if (shortLength) {
        dst[offset++] = rsBytes;
      } else {
        dst[offset++] = MAX_OCTET | 1;
        dst[offset++] = rsBytes & 255;
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = rLength;
      if (rPadding < 0) {
        dst[offset++] = 0;
        offset += signature.copy(dst, offset, 0, paramBytes);
      } else {
        offset += signature.copy(dst, offset, rPadding, paramBytes);
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = sLength;
      if (sPadding < 0) {
        dst[offset++] = 0;
        signature.copy(dst, offset, paramBytes);
      } else {
        signature.copy(dst, offset, paramBytes + sPadding);
      }
      return dst;
    }
    module.exports = {
      derToJose,
      joseToDer
    };
  }
});

// ../node_modules/google-auth-library/build/src/util.js
var require_util2 = __commonJS({
  "../node_modules/google-auth-library/build/src/util.js"(exports) {
    "use strict";
    var __classPrivateFieldGet11 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind3, f2) {
      if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind3 === "m" ? f2 : kind3 === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
    };
    var _LRUCache_instances;
    var _LRUCache_cache;
    var _LRUCache_moveToEnd;
    var _LRUCache_evict;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LRUCache = void 0;
    exports.snakeToCamel = snakeToCamel;
    exports.originalOrCamelOptions = originalOrCamelOptions;
    function snakeToCamel(str) {
      return str.replace(/([_][^_])/g, (match7) => match7.slice(1).toUpperCase());
    }
    function originalOrCamelOptions(obj) {
      function get(key) {
        var _a3;
        const o2 = obj || {};
        return (_a3 = o2[key]) !== null && _a3 !== void 0 ? _a3 : o2[snakeToCamel(key)];
      }
      return { get };
    }
    var LRUCache = class {
      constructor(options) {
        _LRUCache_instances.add(this);
        _LRUCache_cache.set(this, /* @__PURE__ */ new Map());
        this.capacity = options.capacity;
        this.maxAge = options.maxAge;
      }
      /**
       * Add an item to the cache.
       *
       * @param key the key to upsert
       * @param value the value of the key
       */
      set(key, value) {
        __classPrivateFieldGet11(this, _LRUCache_instances, "m", _LRUCache_moveToEnd).call(this, key, value);
        __classPrivateFieldGet11(this, _LRUCache_instances, "m", _LRUCache_evict).call(this);
      }
      /**
       * Get an item from the cache.
       *
       * @param key the key to retrieve
       */
      get(key) {
        const item = __classPrivateFieldGet11(this, _LRUCache_cache, "f").get(key);
        if (!item)
          return;
        __classPrivateFieldGet11(this, _LRUCache_instances, "m", _LRUCache_moveToEnd).call(this, key, item.value);
        __classPrivateFieldGet11(this, _LRUCache_instances, "m", _LRUCache_evict).call(this);
        return item.value;
      }
    };
    exports.LRUCache = LRUCache;
    _LRUCache_cache = /* @__PURE__ */ new WeakMap(), _LRUCache_instances = /* @__PURE__ */ new WeakSet(), _LRUCache_moveToEnd = function _LRUCache_moveToEnd2(key, value) {
      __classPrivateFieldGet11(this, _LRUCache_cache, "f").delete(key);
      __classPrivateFieldGet11(this, _LRUCache_cache, "f").set(key, {
        value,
        lastAccessed: Date.now()
      });
    }, _LRUCache_evict = function _LRUCache_evict2() {
      const cutoffDate = this.maxAge ? Date.now() - this.maxAge : 0;
      let oldestItem = __classPrivateFieldGet11(this, _LRUCache_cache, "f").entries().next();
      while (!oldestItem.done && (__classPrivateFieldGet11(this, _LRUCache_cache, "f").size > this.capacity || // too many
      oldestItem.value[1].lastAccessed < cutoffDate)) {
        __classPrivateFieldGet11(this, _LRUCache_cache, "f").delete(oldestItem.value[0]);
        oldestItem = __classPrivateFieldGet11(this, _LRUCache_cache, "f").entries().next();
      }
    };
  }
});

// ../node_modules/google-auth-library/build/src/auth/authclient.js
var require_authclient = __commonJS({
  "../node_modules/google-auth-library/build/src/auth/authclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AuthClient = exports.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS = exports.DEFAULT_UNIVERSE = void 0;
    var events_1 = __require("events");
    var gaxios_1 = require_src2();
    var transporters_1 = require_transporters();
    var util_1 = require_util2();
    exports.DEFAULT_UNIVERSE = "googleapis.com";
    exports.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS = 5 * 60 * 1e3;
    var AuthClient = class extends events_1.EventEmitter {
      constructor(opts = {}) {
        var _a3, _b, _c, _d, _e2;
        super();
        this.credentials = {};
        this.eagerRefreshThresholdMillis = exports.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS;
        this.forceRefreshOnFailure = false;
        this.universeDomain = exports.DEFAULT_UNIVERSE;
        const options = (0, util_1.originalOrCamelOptions)(opts);
        this.apiKey = opts.apiKey;
        this.projectId = (_a3 = options.get("project_id")) !== null && _a3 !== void 0 ? _a3 : null;
        this.quotaProjectId = options.get("quota_project_id");
        this.credentials = (_b = options.get("credentials")) !== null && _b !== void 0 ? _b : {};
        this.universeDomain = (_c = options.get("universe_domain")) !== null && _c !== void 0 ? _c : exports.DEFAULT_UNIVERSE;
        this.transporter = (_d = opts.transporter) !== null && _d !== void 0 ? _d : new transporters_1.DefaultTransporter();
        if (opts.transporterOptions) {
          this.transporter.defaults = opts.transporterOptions;
        }
        if (opts.eagerRefreshThresholdMillis) {
          this.eagerRefreshThresholdMillis = opts.eagerRefreshThresholdMillis;
        }
        this.forceRefreshOnFailure = (_e2 = opts.forceRefreshOnFailure) !== null && _e2 !== void 0 ? _e2 : false;
      }
      /**
       * Return the {@link Gaxios `Gaxios`} instance from the {@link AuthClient.transporter}.
       *
       * @expiremental
       */
      get gaxios() {
        if (this.transporter instanceof gaxios_1.Gaxios) {
          return this.transporter;
        } else if (this.transporter instanceof transporters_1.DefaultTransporter) {
          return this.transporter.instance;
        } else if ("instance" in this.transporter && this.transporter.instance instanceof gaxios_1.Gaxios) {
          return this.transporter.instance;
        }
        return null;
      }
      /**
       * Sets the auth credentials.
       */
      setCredentials(credentials) {
        this.credentials = credentials;
      }
      /**
       * Append additional headers, e.g., x-goog-user-project, shared across the
       * classes inheriting AuthClient. This method should be used by any method
       * that overrides getRequestMetadataAsync(), which is a shared helper for
       * setting request information in both gRPC and HTTP API calls.
       *
       * @param headers object to append additional headers to.
       */
      addSharedMetadataHeaders(headers) {
        if (!headers["x-goog-user-project"] && // don't override a value the user sets.
        this.quotaProjectId) {
          headers["x-goog-user-project"] = this.quotaProjectId;
        }
        return headers;
      }
      /**
       * Retry config for Auth-related requests.
       *
       * @remarks
       *
       * This is not a part of the default {@link AuthClient.transporter transporter/gaxios}
       * config as some downstream APIs would prefer if customers explicitly enable retries,
       * such as GCS.
       */
      static get RETRY_CONFIG() {
        return {
          retry: true,
          retryConfig: {
            httpMethodsToRetry: ["GET", "PUT", "POST", "HEAD", "OPTIONS", "DELETE"]
          }
        };
      }
    };
    exports.AuthClient = AuthClient;
  }
});

// ../node_modules/google-auth-library/build/src/auth/loginticket.js
var require_loginticket = __commonJS({
  "../node_modules/google-auth-library/build/src/auth/loginticket.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LoginTicket = void 0;
    var LoginTicket = class {
      /**
       * Create a simple class to extract user ID from an ID Token
       *
       * @param {string} env Envelope of the jwt
       * @param {TokenPayload} pay Payload of the jwt
       * @constructor
       */
      constructor(env, pay) {
        this.envelope = env;
        this.payload = pay;
      }
      getEnvelope() {
        return this.envelope;
      }
      getPayload() {
        return this.payload;
      }
      /**
       * Create a simple class to extract user ID from an ID Token
       *
       * @return The user ID
       */
      getUserId() {
        const payload = this.getPayload();
        if (payload && payload.sub) {
          return payload.sub;
        }
        return null;
      }
      /**
       * Returns attributes from the login ticket.  This can contain
       * various information about the user session.
       *
       * @return The envelope and payload
       */
      getAttributes() {
        return { envelope: this.getEnvelope(), payload: this.getPayload() };
      }
    };
    exports.LoginTicket = LoginTicket;
  }
});

// ../node_modules/google-auth-library/build/src/auth/oauth2client.js
var require_oauth2client = __commonJS({
  "../node_modules/google-auth-library/build/src/auth/oauth2client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OAuth2Client = exports.ClientAuthentication = exports.CertificateFormat = exports.CodeChallengeMethod = void 0;
    var gaxios_1 = require_src2();
    var querystring = __require("querystring");
    var stream = __require("stream");
    var formatEcdsa = require_ecdsa_sig_formatter();
    var crypto_1 = require_crypto3();
    var authclient_1 = require_authclient();
    var loginticket_1 = require_loginticket();
    var CodeChallengeMethod;
    (function(CodeChallengeMethod2) {
      CodeChallengeMethod2["Plain"] = "plain";
      CodeChallengeMethod2["S256"] = "S256";
    })(CodeChallengeMethod || (exports.CodeChallengeMethod = CodeChallengeMethod = {}));
    var CertificateFormat;
    (function(CertificateFormat2) {
      CertificateFormat2["PEM"] = "PEM";
      CertificateFormat2["JWK"] = "JWK";
    })(CertificateFormat || (exports.CertificateFormat = CertificateFormat = {}));
    var ClientAuthentication;
    (function(ClientAuthentication2) {
      ClientAuthentication2["ClientSecretPost"] = "ClientSecretPost";
      ClientAuthentication2["ClientSecretBasic"] = "ClientSecretBasic";
      ClientAuthentication2["None"] = "None";
    })(ClientAuthentication || (exports.ClientAuthentication = ClientAuthentication = {}));
    var OAuth2Client = class _OAuth2Client extends authclient_1.AuthClient {
      constructor(optionsOrClientId, clientSecret, redirectUri) {
        const opts = optionsOrClientId && typeof optionsOrClientId === "object" ? optionsOrClientId : { clientId: optionsOrClientId, clientSecret, redirectUri };
        super(opts);
        this.certificateCache = {};
        this.certificateExpiry = null;
        this.certificateCacheFormat = CertificateFormat.PEM;
        this.refreshTokenPromises = /* @__PURE__ */ new Map();
        this._clientId = opts.clientId;
        this._clientSecret = opts.clientSecret;
        this.redirectUri = opts.redirectUri;
        this.endpoints = {
          tokenInfoUrl: "https://oauth2.googleapis.com/tokeninfo",
          oauth2AuthBaseUrl: "https://accounts.google.com/o/oauth2/v2/auth",
          oauth2TokenUrl: "https://oauth2.googleapis.com/token",
          oauth2RevokeUrl: "https://oauth2.googleapis.com/revoke",
          oauth2FederatedSignonPemCertsUrl: "https://www.googleapis.com/oauth2/v1/certs",
          oauth2FederatedSignonJwkCertsUrl: "https://www.googleapis.com/oauth2/v3/certs",
          oauth2IapPublicKeyUrl: "https://www.gstatic.com/iap/verify/public_key",
          ...opts.endpoints
        };
        this.clientAuthentication = opts.clientAuthentication || ClientAuthentication.ClientSecretPost;
        this.issuers = opts.issuers || [
          "accounts.google.com",
          "https://accounts.google.com",
          this.universeDomain
        ];
      }
      /**
       * Generates URL for consent page landing.
       * @param opts Options.
       * @return URL to consent page.
       */
      generateAuthUrl(opts = {}) {
        if (opts.code_challenge_method && !opts.code_challenge) {
          throw new Error("If a code_challenge_method is provided, code_challenge must be included.");
        }
        opts.response_type = opts.response_type || "code";
        opts.client_id = opts.client_id || this._clientId;
        opts.redirect_uri = opts.redirect_uri || this.redirectUri;
        if (Array.isArray(opts.scope)) {
          opts.scope = opts.scope.join(" ");
        }
        const rootUrl = this.endpoints.oauth2AuthBaseUrl.toString();
        return rootUrl + "?" + querystring.stringify(opts);
      }
      generateCodeVerifier() {
        throw new Error("generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.");
      }
      /**
       * Convenience method to automatically generate a code_verifier, and its
       * resulting SHA256. If used, this must be paired with a S256
       * code_challenge_method.
       *
       * For a full example see:
       * https://github.com/googleapis/google-auth-library-nodejs/blob/main/samples/oauth2-codeVerifier.js
       */
      async generateCodeVerifierAsync() {
        const crypto6 = (0, crypto_1.createCrypto)();
        const randomString = crypto6.randomBytesBase64(96);
        const codeVerifier = randomString.replace(/\+/g, "~").replace(/=/g, "_").replace(/\//g, "-");
        const unencodedCodeChallenge = await crypto6.sha256DigestBase64(codeVerifier);
        const codeChallenge = unencodedCodeChallenge.split("=")[0].replace(/\+/g, "-").replace(/\//g, "_");
        return { codeVerifier, codeChallenge };
      }
      getToken(codeOrOptions, callback) {
        const options = typeof codeOrOptions === "string" ? { code: codeOrOptions } : codeOrOptions;
        if (callback) {
          this.getTokenAsync(options).then((r2) => callback(null, r2.tokens, r2.res), (e2) => callback(e2, null, e2.response));
        } else {
          return this.getTokenAsync(options);
        }
      }
      async getTokenAsync(options) {
        const url = this.endpoints.oauth2TokenUrl.toString();
        const headers = {
          "Content-Type": "application/x-www-form-urlencoded"
        };
        const values = {
          client_id: options.client_id || this._clientId,
          code_verifier: options.codeVerifier,
          code: options.code,
          grant_type: "authorization_code",
          redirect_uri: options.redirect_uri || this.redirectUri
        };
        if (this.clientAuthentication === ClientAuthentication.ClientSecretBasic) {
          const basic = Buffer.from(`${this._clientId}:${this._clientSecret}`);
          headers["Authorization"] = `Basic ${basic.toString("base64")}`;
        }
        if (this.clientAuthentication === ClientAuthentication.ClientSecretPost) {
          values.client_secret = this._clientSecret;
        }
        const res = await this.transporter.request({
          ..._OAuth2Client.RETRY_CONFIG,
          method: "POST",
          url,
          data: querystring.stringify(values),
          headers
        });
        const tokens = res.data;
        if (res.data && res.data.expires_in) {
          tokens.expiry_date = (/* @__PURE__ */ new Date()).getTime() + res.data.expires_in * 1e3;
          delete tokens.expires_in;
        }
        this.emit("tokens", tokens);
        return { tokens, res };
      }
      /**
       * Refreshes the access token.
       * @param refresh_token Existing refresh token.
       * @private
       */
      async refreshToken(refreshToken) {
        if (!refreshToken) {
          return this.refreshTokenNoCache(refreshToken);
        }
        if (this.refreshTokenPromises.has(refreshToken)) {
          return this.refreshTokenPromises.get(refreshToken);
        }
        const p2 = this.refreshTokenNoCache(refreshToken).then((r2) => {
          this.refreshTokenPromises.delete(refreshToken);
          return r2;
        }, (e2) => {
          this.refreshTokenPromises.delete(refreshToken);
          throw e2;
        });
        this.refreshTokenPromises.set(refreshToken, p2);
        return p2;
      }
      async refreshTokenNoCache(refreshToken) {
        var _a3;
        if (!refreshToken) {
          throw new Error("No refresh token is set.");
        }
        const url = this.endpoints.oauth2TokenUrl.toString();
        const data = {
          refresh_token: refreshToken,
          client_id: this._clientId,
          client_secret: this._clientSecret,
          grant_type: "refresh_token"
        };
        let res;
        try {
          res = await this.transporter.request({
            ..._OAuth2Client.RETRY_CONFIG,
            method: "POST",
            url,
            data: querystring.stringify(data),
            headers: { "Content-Type": "application/x-www-form-urlencoded" }
          });
        } catch (e2) {
          if (e2 instanceof gaxios_1.GaxiosError && e2.message === "invalid_grant" && ((_a3 = e2.response) === null || _a3 === void 0 ? void 0 : _a3.data) && /ReAuth/i.test(e2.response.data.error_description)) {
            e2.message = JSON.stringify(e2.response.data);
          }
          throw e2;
        }
        const tokens = res.data;
        if (res.data && res.data.expires_in) {
          tokens.expiry_date = (/* @__PURE__ */ new Date()).getTime() + res.data.expires_in * 1e3;
          delete tokens.expires_in;
        }
        this.emit("tokens", tokens);
        return { tokens, res };
      }
      refreshAccessToken(callback) {
        if (callback) {
          this.refreshAccessTokenAsync().then((r2) => callback(null, r2.credentials, r2.res), callback);
        } else {
          return this.refreshAccessTokenAsync();
        }
      }
      async refreshAccessTokenAsync() {
        const r2 = await this.refreshToken(this.credentials.refresh_token);
        const tokens = r2.tokens;
        tokens.refresh_token = this.credentials.refresh_token;
        this.credentials = tokens;
        return { credentials: this.credentials, res: r2.res };
      }
      getAccessToken(callback) {
        if (callback) {
          this.getAccessTokenAsync().then((r2) => callback(null, r2.token, r2.res), callback);
        } else {
          return this.getAccessTokenAsync();
        }
      }
      async getAccessTokenAsync() {
        const shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();
        if (shouldRefresh) {
          if (!this.credentials.refresh_token) {
            if (this.refreshHandler) {
              const refreshedAccessToken = await this.processAndValidateRefreshHandler();
              if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {
                this.setCredentials(refreshedAccessToken);
                return { token: this.credentials.access_token };
              }
            } else {
              throw new Error("No refresh token or refresh handler callback is set.");
            }
          }
          const r2 = await this.refreshAccessTokenAsync();
          if (!r2.credentials || r2.credentials && !r2.credentials.access_token) {
            throw new Error("Could not refresh access token.");
          }
          return { token: r2.credentials.access_token, res: r2.res };
        } else {
          return { token: this.credentials.access_token };
        }
      }
      /**
       * The main authentication interface.  It takes an optional url which when
       * present is the endpoint being accessed, and returns a Promise which
       * resolves with authorization header fields.
       *
       * In OAuth2Client, the result has the form:
       * { Authorization: 'Bearer <access_token_value>' }
       * @param url The optional url being authorized
       */
      async getRequestHeaders(url) {
        const headers = (await this.getRequestMetadataAsync(url)).headers;
        return headers;
      }
      async getRequestMetadataAsync(url) {
        const thisCreds = this.credentials;
        if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey && !this.refreshHandler) {
          throw new Error("No access, refresh token, API key or refresh handler callback is set.");
        }
        if (thisCreds.access_token && !this.isTokenExpiring()) {
          thisCreds.token_type = thisCreds.token_type || "Bearer";
          const headers2 = {
            Authorization: thisCreds.token_type + " " + thisCreds.access_token
          };
          return { headers: this.addSharedMetadataHeaders(headers2) };
        }
        if (this.refreshHandler) {
          const refreshedAccessToken = await this.processAndValidateRefreshHandler();
          if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {
            this.setCredentials(refreshedAccessToken);
            const headers2 = {
              Authorization: "Bearer " + this.credentials.access_token
            };
            return { headers: this.addSharedMetadataHeaders(headers2) };
          }
        }
        if (this.apiKey) {
          return { headers: { "X-Goog-Api-Key": this.apiKey } };
        }
        let r2 = null;
        let tokens = null;
        try {
          r2 = await this.refreshToken(thisCreds.refresh_token);
          tokens = r2.tokens;
        } catch (err) {
          const e2 = err;
          if (e2.response && (e2.response.status === 403 || e2.response.status === 404)) {
            e2.message = `Could not refresh access token: ${e2.message}`;
          }
          throw e2;
        }
        const credentials = this.credentials;
        credentials.token_type = credentials.token_type || "Bearer";
        tokens.refresh_token = credentials.refresh_token;
        this.credentials = tokens;
        const headers = {
          Authorization: credentials.token_type + " " + tokens.access_token
        };
        return { headers: this.addSharedMetadataHeaders(headers), res: r2.res };
      }
      /**
       * Generates an URL to revoke the given token.
       * @param token The existing token to be revoked.
       *
       * @deprecated use instance method {@link OAuth2Client.getRevokeTokenURL}
       */
      static getRevokeTokenUrl(token) {
        return new _OAuth2Client().getRevokeTokenURL(token).toString();
      }
      /**
       * Generates a URL to revoke the given token.
       *
       * @param token The existing token to be revoked.
       */
      getRevokeTokenURL(token) {
        const url = new URL(this.endpoints.oauth2RevokeUrl);
        url.searchParams.append("token", token);
        return url;
      }
      revokeToken(token, callback) {
        const opts = {
          ..._OAuth2Client.RETRY_CONFIG,
          url: this.getRevokeTokenURL(token).toString(),
          method: "POST"
        };
        if (callback) {
          this.transporter.request(opts).then((r2) => callback(null, r2), callback);
        } else {
          return this.transporter.request(opts);
        }
      }
      revokeCredentials(callback) {
        if (callback) {
          this.revokeCredentialsAsync().then((res) => callback(null, res), callback);
        } else {
          return this.revokeCredentialsAsync();
        }
      }
      async revokeCredentialsAsync() {
        const token = this.credentials.access_token;
        this.credentials = {};
        if (token) {
          return this.revokeToken(token);
        } else {
          throw new Error("No access token to revoke.");
        }
      }
      request(opts, callback) {
        if (callback) {
          this.requestAsync(opts).then((r2) => callback(null, r2), (e2) => {
            return callback(e2, e2.response);
          });
        } else {
          return this.requestAsync(opts);
        }
      }
      async requestAsync(opts, reAuthRetried = false) {
        let r2;
        try {
          const r3 = await this.getRequestMetadataAsync(opts.url);
          opts.headers = opts.headers || {};
          if (r3.headers && r3.headers["x-goog-user-project"]) {
            opts.headers["x-goog-user-project"] = r3.headers["x-goog-user-project"];
          }
          if (r3.headers && r3.headers.Authorization) {
            opts.headers.Authorization = r3.headers.Authorization;
          }
          if (this.apiKey) {
            opts.headers["X-Goog-Api-Key"] = this.apiKey;
          }
          r2 = await this.transporter.request(opts);
        } catch (e2) {
          const res = e2.response;
          if (res) {
            const statusCode = res.status;
            const mayRequireRefresh = this.credentials && this.credentials.access_token && this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure);
            const mayRequireRefreshWithNoRefreshToken = this.credentials && this.credentials.access_token && !this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure) && this.refreshHandler;
            const isReadableStream = res.config.data instanceof stream.Readable;
            const isAuthErr = statusCode === 401 || statusCode === 403;
            if (!reAuthRetried && isAuthErr && !isReadableStream && mayRequireRefresh) {
              await this.refreshAccessTokenAsync();
              return this.requestAsync(opts, true);
            } else if (!reAuthRetried && isAuthErr && !isReadableStream && mayRequireRefreshWithNoRefreshToken) {
              const refreshedAccessToken = await this.processAndValidateRefreshHandler();
              if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {
                this.setCredentials(refreshedAccessToken);
              }
              return this.requestAsync(opts, true);
            }
          }
          throw e2;
        }
        return r2;
      }
      verifyIdToken(options, callback) {
        if (callback && typeof callback !== "function") {
          throw new Error("This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.");
        }
        if (callback) {
          this.verifyIdTokenAsync(options).then((r2) => callback(null, r2), callback);
        } else {
          return this.verifyIdTokenAsync(options);
        }
      }
      async verifyIdTokenAsync(options) {
        if (!options.idToken) {
          throw new Error("The verifyIdToken method requires an ID Token");
        }
        const response = await this.getFederatedSignonCertsAsync();
        const login = await this.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, this.issuers, options.maxExpiry);
        return login;
      }
      /**
       * Obtains information about the provisioned access token.  Especially useful
       * if you want to check the scopes that were provisioned to a given token.
       *
       * @param accessToken Required.  The Access Token for which you want to get
       * user info.
       */
      async getTokenInfo(accessToken) {
        const { data } = await this.transporter.request({
          ..._OAuth2Client.RETRY_CONFIG,
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
            Authorization: `Bearer ${accessToken}`
          },
          url: this.endpoints.tokenInfoUrl.toString()
        });
        const info = Object.assign({
          expiry_date: (/* @__PURE__ */ new Date()).getTime() + data.expires_in * 1e3,
          scopes: data.scope.split(" ")
        }, data);
        delete info.expires_in;
        delete info.scope;
        return info;
      }
      getFederatedSignonCerts(callback) {
        if (callback) {
          this.getFederatedSignonCertsAsync().then((r2) => callback(null, r2.certs, r2.res), callback);
        } else {
          return this.getFederatedSignonCertsAsync();
        }
      }
      async getFederatedSignonCertsAsync() {
        const nowTime = (/* @__PURE__ */ new Date()).getTime();
        const format = (0, crypto_1.hasBrowserCrypto)() ? CertificateFormat.JWK : CertificateFormat.PEM;
        if (this.certificateExpiry && nowTime < this.certificateExpiry.getTime() && this.certificateCacheFormat === format) {
          return { certs: this.certificateCache, format };
        }
        let res;
        let url;
        switch (format) {
          case CertificateFormat.PEM:
            url = this.endpoints.oauth2FederatedSignonPemCertsUrl.toString();
            break;
          case CertificateFormat.JWK:
            url = this.endpoints.oauth2FederatedSignonJwkCertsUrl.toString();
            break;
          default:
            throw new Error(`Unsupported certificate format ${format}`);
        }
        try {
          res = await this.transporter.request({
            ..._OAuth2Client.RETRY_CONFIG,
            url
          });
        } catch (e2) {
          if (e2 instanceof Error) {
            e2.message = `Failed to retrieve verification certificates: ${e2.message}`;
          }
          throw e2;
        }
        const cacheControl = res ? res.headers["cache-control"] : void 0;
        let cacheAge = -1;
        if (cacheControl) {
          const pattern = new RegExp("max-age=([0-9]*)");
          const regexResult = pattern.exec(cacheControl);
          if (regexResult && regexResult.length === 2) {
            cacheAge = Number(regexResult[1]) * 1e3;
          }
        }
        let certificates = {};
        switch (format) {
          case CertificateFormat.PEM:
            certificates = res.data;
            break;
          case CertificateFormat.JWK:
            for (const key of res.data.keys) {
              certificates[key.kid] = key;
            }
            break;
          default:
            throw new Error(`Unsupported certificate format ${format}`);
        }
        const now = /* @__PURE__ */ new Date();
        this.certificateExpiry = cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);
        this.certificateCache = certificates;
        this.certificateCacheFormat = format;
        return { certs: certificates, format, res };
      }
      getIapPublicKeys(callback) {
        if (callback) {
          this.getIapPublicKeysAsync().then((r2) => callback(null, r2.pubkeys, r2.res), callback);
        } else {
          return this.getIapPublicKeysAsync();
        }
      }
      async getIapPublicKeysAsync() {
        let res;
        const url = this.endpoints.oauth2IapPublicKeyUrl.toString();
        try {
          res = await this.transporter.request({
            ..._OAuth2Client.RETRY_CONFIG,
            url
          });
        } catch (e2) {
          if (e2 instanceof Error) {
            e2.message = `Failed to retrieve verification certificates: ${e2.message}`;
          }
          throw e2;
        }
        return { pubkeys: res.data, res };
      }
      verifySignedJwtWithCerts() {
        throw new Error("verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.");
      }
      /**
       * Verify the id token is signed with the correct certificate
       * and is from the correct audience.
       * @param jwt The jwt to verify (The ID Token in this case).
       * @param certs The array of certs to test the jwt against.
       * @param requiredAudience The audience to test the jwt against.
       * @param issuers The allowed issuers of the jwt (Optional).
       * @param maxExpiry The max expiry the certificate can be (Optional).
       * @return Returns a promise resolving to LoginTicket on verification.
       */
      async verifySignedJwtWithCertsAsync(jwt, certs, requiredAudience, issuers, maxExpiry) {
        const crypto6 = (0, crypto_1.createCrypto)();
        if (!maxExpiry) {
          maxExpiry = _OAuth2Client.DEFAULT_MAX_TOKEN_LIFETIME_SECS_;
        }
        const segments = jwt.split(".");
        if (segments.length !== 3) {
          throw new Error("Wrong number of segments in token: " + jwt);
        }
        const signed = segments[0] + "." + segments[1];
        let signature = segments[2];
        let envelope;
        let payload;
        try {
          envelope = JSON.parse(crypto6.decodeBase64StringUtf8(segments[0]));
        } catch (err) {
          if (err instanceof Error) {
            err.message = `Can't parse token envelope: ${segments[0]}': ${err.message}`;
          }
          throw err;
        }
        if (!envelope) {
          throw new Error("Can't parse token envelope: " + segments[0]);
        }
        try {
          payload = JSON.parse(crypto6.decodeBase64StringUtf8(segments[1]));
        } catch (err) {
          if (err instanceof Error) {
            err.message = `Can't parse token payload '${segments[0]}`;
          }
          throw err;
        }
        if (!payload) {
          throw new Error("Can't parse token payload: " + segments[1]);
        }
        if (!Object.prototype.hasOwnProperty.call(certs, envelope.kid)) {
          throw new Error("No pem found for envelope: " + JSON.stringify(envelope));
        }
        const cert = certs[envelope.kid];
        if (envelope.alg === "ES256") {
          signature = formatEcdsa.joseToDer(signature, "ES256").toString("base64");
        }
        const verified = await crypto6.verify(cert, signed, signature);
        if (!verified) {
          throw new Error("Invalid token signature: " + jwt);
        }
        if (!payload.iat) {
          throw new Error("No issue time in token: " + JSON.stringify(payload));
        }
        if (!payload.exp) {
          throw new Error("No expiration time in token: " + JSON.stringify(payload));
        }
        const iat = Number(payload.iat);
        if (isNaN(iat))
          throw new Error("iat field using invalid format");
        const exp = Number(payload.exp);
        if (isNaN(exp))
          throw new Error("exp field using invalid format");
        const now = (/* @__PURE__ */ new Date()).getTime() / 1e3;
        if (exp >= now + maxExpiry) {
          throw new Error("Expiration time too far in future: " + JSON.stringify(payload));
        }
        const earliest = iat - _OAuth2Client.CLOCK_SKEW_SECS_;
        const latest = exp + _OAuth2Client.CLOCK_SKEW_SECS_;
        if (now < earliest) {
          throw new Error("Token used too early, " + now + " < " + earliest + ": " + JSON.stringify(payload));
        }
        if (now > latest) {
          throw new Error("Token used too late, " + now + " > " + latest + ": " + JSON.stringify(payload));
        }
        if (issuers && issuers.indexOf(payload.iss) < 0) {
          throw new Error("Invalid issuer, expected one of [" + issuers + "], but got " + payload.iss);
        }
        if (typeof requiredAudience !== "undefined" && requiredAudience !== null) {
          const aud = payload.aud;
          let audVerified = false;
          if (requiredAudience.constructor === Array) {
            audVerified = requiredAudience.indexOf(aud) > -1;
          } else {
            audVerified = aud === requiredAudience;
          }
          if (!audVerified) {
            throw new Error("Wrong recipient, payload audience != requiredAudience");
          }
        }
        return new loginticket_1.LoginTicket(envelope, payload);
      }
      /**
       * Returns a promise that resolves with AccessTokenResponse type if
       * refreshHandler is defined.
       * If not, nothing is returned.
       */
      async processAndValidateRefreshHandler() {
        if (this.refreshHandler) {
          const accessTokenResponse = await this.refreshHandler();
          if (!accessTokenResponse.access_token) {
            throw new Error("No access token is returned by the refreshHandler callback.");
          }
          return accessTokenResponse;
        }
        return;
      }
      /**
       * Returns true if a token is expired or will expire within
       * eagerRefreshThresholdMillismilliseconds.
       * If there is no expiry time, assumes the token is not expired or expiring.
       */
      isTokenExpiring() {
        const expiryDate = this.credentials.expiry_date;
        return expiryDate ? expiryDate <= (/* @__PURE__ */ new Date()).getTime() + this.eagerRefreshThresholdMillis : false;
      }
    };
    exports.OAuth2Client = OAuth2Client;
    OAuth2Client.GOOGLE_TOKEN_INFO_URL = "https://oauth2.googleapis.com/tokeninfo";
    OAuth2Client.CLOCK_SKEW_SECS_ = 300;
    OAuth2Client.DEFAULT_MAX_TOKEN_LIFETIME_SECS_ = 86400;
  }
});

// ../node_modules/google-auth-library/build/src/auth/computeclient.js
var require_computeclient = __commonJS({
  "../node_modules/google-auth-library/build/src/auth/computeclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Compute = void 0;
    var gaxios_1 = require_src2();
    var gcpMetadata = require_src4();
    var oauth2client_1 = require_oauth2client();
    var Compute = class extends oauth2client_1.OAuth2Client {
      /**
       * Google Compute Engine service account credentials.
       *
       * Retrieve access token from the metadata server.
       * See: https://cloud.google.com/compute/docs/access/authenticate-workloads#applications
       */
      constructor(options = {}) {
        super(options);
        this.credentials = { expiry_date: 1, refresh_token: "compute-placeholder" };
        this.serviceAccountEmail = options.serviceAccountEmail || "default";
        this.scopes = Array.isArray(options.scopes) ? options.scopes : options.scopes ? [options.scopes] : [];
      }
      /**
       * Refreshes the access token.
       * @param refreshToken Unused parameter
       */
      async refreshTokenNoCache(refreshToken) {
        const tokenPath = `service-accounts/${this.serviceAccountEmail}/token`;
        let data;
        try {
          const instanceOptions = {
            property: tokenPath
          };
          if (this.scopes.length > 0) {
            instanceOptions.params = {
              scopes: this.scopes.join(",")
            };
          }
          data = await gcpMetadata.instance(instanceOptions);
        } catch (e2) {
          if (e2 instanceof gaxios_1.GaxiosError) {
            e2.message = `Could not refresh access token: ${e2.message}`;
            this.wrapError(e2);
          }
          throw e2;
        }
        const tokens = data;
        if (data && data.expires_in) {
          tokens.expiry_date = (/* @__PURE__ */ new Date()).getTime() + data.expires_in * 1e3;
          delete tokens.expires_in;
        }
        this.emit("tokens", tokens);
        return { tokens, res: null };
      }
      /**
       * Fetches an ID token.
       * @param targetAudience the audience for the fetched ID token.
       */
      async fetchIdToken(targetAudience) {
        const idTokenPath = `service-accounts/${this.serviceAccountEmail}/identity?format=full&audience=${targetAudience}`;
        let idToken;
        try {
          const instanceOptions = {
            property: idTokenPath
          };
          idToken = await gcpMetadata.instance(instanceOptions);
        } catch (e2) {
          if (e2 instanceof Error) {
            e2.message = `Could not fetch ID token: ${e2.message}`;
          }
          throw e2;
        }
        return idToken;
      }
      wrapError(e2) {
        const res = e2.response;
        if (res && res.status) {
          e2.status = res.status;
          if (res.status === 403) {
            e2.message = "A Forbidden error was returned while attempting to retrieve an access token for the Compute Engine built-in service account. This may be because the Compute Engine instance does not have the correct permission scopes specified: " + e2.message;
          } else if (res.status === 404) {
            e2.message = "A Not Found error was returned while attempting to retrieve an accesstoken for the Compute Engine built-in service account. This may be because the Compute Engine instance does not have any permission scopes specified: " + e2.message;
          }
        }
      }
    };
    exports.Compute = Compute;
  }
});

// ../node_modules/google-auth-library/build/src/auth/idtokenclient.js
var require_idtokenclient = __commonJS({
  "../node_modules/google-auth-library/build/src/auth/idtokenclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IdTokenClient = void 0;
    var oauth2client_1 = require_oauth2client();
    var IdTokenClient = class extends oauth2client_1.OAuth2Client {
      /**
       * Google ID Token client
       *
       * Retrieve ID token from the metadata server.
       * See: https://cloud.google.com/docs/authentication/get-id-token#metadata-server
       */
      constructor(options) {
        super(options);
        this.targetAudience = options.targetAudience;
        this.idTokenProvider = options.idTokenProvider;
      }
      async getRequestMetadataAsync(url) {
        if (!this.credentials.id_token || !this.credentials.expiry_date || this.isTokenExpiring()) {
          const idToken = await this.idTokenProvider.fetchIdToken(this.targetAudience);
          this.credentials = {
            id_token: idToken,
            expiry_date: this.getIdTokenExpiryDate(idToken)
          };
        }
        const headers = {
          Authorization: "Bearer " + this.credentials.id_token
        };
        return { headers };
      }
      getIdTokenExpiryDate(idToken) {
        const payloadB64 = idToken.split(".")[1];
        if (payloadB64) {
          const payload = JSON.parse(Buffer.from(payloadB64, "base64").toString("ascii"));
          return payload.exp * 1e3;
        }
      }
    };
    exports.IdTokenClient = IdTokenClient;
  }
});

// ../node_modules/google-auth-library/build/src/auth/envDetect.js
var require_envDetect = __commonJS({
  "../node_modules/google-auth-library/build/src/auth/envDetect.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GCPEnv = void 0;
    exports.clear = clear;
    exports.getEnv = getEnv2;
    var gcpMetadata = require_src4();
    var GCPEnv;
    (function(GCPEnv2) {
      GCPEnv2["APP_ENGINE"] = "APP_ENGINE";
      GCPEnv2["KUBERNETES_ENGINE"] = "KUBERNETES_ENGINE";
      GCPEnv2["CLOUD_FUNCTIONS"] = "CLOUD_FUNCTIONS";
      GCPEnv2["COMPUTE_ENGINE"] = "COMPUTE_ENGINE";
      GCPEnv2["CLOUD_RUN"] = "CLOUD_RUN";
      GCPEnv2["NONE"] = "NONE";
    })(GCPEnv || (exports.GCPEnv = GCPEnv = {}));
    var envPromise;
    function clear() {
      envPromise = void 0;
    }
    async function getEnv2() {
      if (envPromise) {
        return envPromise;
      }
      envPromise = getEnvMemoized();
      return envPromise;
    }
    async function getEnvMemoized() {
      let env = GCPEnv.NONE;
      if (isAppEngine()) {
        env = GCPEnv.APP_ENGINE;
      } else if (isCloudFunction()) {
        env = GCPEnv.CLOUD_FUNCTIONS;
      } else if (await isComputeEngine()) {
        if (await isKubernetesEngine()) {
          env = GCPEnv.KUBERNETES_ENGINE;
        } else if (isCloudRun()) {
          env = GCPEnv.CLOUD_RUN;
        } else {
          env = GCPEnv.COMPUTE_ENGINE;
        }
      } else {
        env = GCPEnv.NONE;
      }
      return env;
    }
    function isAppEngine() {
      return !!(process.env.GAE_SERVICE || process.env.GAE_MODULE_NAME);
    }
    function isCloudFunction() {
      return !!(process.env.FUNCTION_NAME || process.env.FUNCTION_TARGET);
    }
    function isCloudRun() {
      return !!process.env.K_CONFIGURATION;
    }
    async function isKubernetesEngine() {
      try {
        await gcpMetadata.instance("attributes/cluster-name");
        return true;
      } catch (e2) {
        return false;
      }
    }
    async function isComputeEngine() {
      return gcpMetadata.isAvailable();
    }
  }
});

// ../node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS({
  "../node_modules/jws/lib/data-stream.js"(exports, module) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var Stream4 = __require("stream");
    var util = __require("util");
    function DataStream(data) {
      this.buffer = null;
      this.writable = true;
      this.readable = true;
      if (!data) {
        this.buffer = Buffer2.alloc(0);
        return this;
      }
      if (typeof data.pipe === "function") {
        this.buffer = Buffer2.alloc(0);
        data.pipe(this);
        return this;
      }
      if (data.length || typeof data === "object") {
        this.buffer = data;
        this.writable = false;
        process.nextTick(function() {
          this.emit("end", data);
          this.readable = false;
          this.emit("close");
        }.bind(this));
        return this;
      }
      throw new TypeError("Unexpected data type (" + typeof data + ")");
    }
    util.inherits(DataStream, Stream4);
    DataStream.prototype.write = function write(data) {
      this.buffer = Buffer2.concat([this.buffer, Buffer2.from(data)]);
      this.emit("data", data);
    };
    DataStream.prototype.end = function end(data) {
      if (data)
        this.write(data);
      this.emit("end", data);
      this.emit("close");
      this.writable = false;
      this.readable = false;
    };
    module.exports = DataStream;
  }
});

// ../node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS({
  "../node_modules/buffer-equal-constant-time/index.js"(exports, module) {
    "use strict";
    var Buffer2 = __require("buffer").Buffer;
    var SlowBuffer = __require("buffer").SlowBuffer;
    module.exports = bufferEq;
    function bufferEq(a2, b2) {
      if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b2)) {
        return false;
      }
      if (a2.length !== b2.length) {
        return false;
      }
      var c2 = 0;
      for (var i2 = 0; i2 < a2.length; i2++) {
        c2 |= a2[i2] ^ b2[i2];
      }
      return c2 === 0;
    }
    bufferEq.install = function() {
      Buffer2.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
        return bufferEq(this, that);
      };
    };
    var origBufEqual = Buffer2.prototype.equal;
    var origSlowBufEqual = SlowBuffer.prototype.equal;
    bufferEq.restore = function() {
      Buffer2.prototype.equal = origBufEqual;
      SlowBuffer.prototype.equal = origSlowBufEqual;
    };
  }
});

// ../node_modules/jwa/index.js
var require_jwa = __commonJS({
  "../node_modules/jwa/index.js"(exports, module) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var crypto6 = __require("crypto");
    var formatEcdsa = require_ecdsa_sig_formatter();
    var util = __require("util");
    var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
    var MSG_INVALID_SECRET = "secret must be a string or buffer";
    var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
    var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
    var supportsKeyObjects = typeof crypto6.createPublicKey === "function";
    if (supportsKeyObjects) {
      MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
      MSG_INVALID_SECRET += "or a KeyObject";
    }
    function checkIsPublicKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.type !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.asymmetricKeyType !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
    }
    function checkIsPrivateKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (typeof key === "object") {
        return;
      }
      throw typeError(MSG_INVALID_SIGNER_KEY);
    }
    function checkIsSecretKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return key;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (key.type !== "secret") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_SECRET);
      }
    }
    function fromBase64(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function toBase64(base64url) {
      base64url = base64url.toString();
      var padding = 4 - base64url.length % 4;
      if (padding !== 4) {
        for (var i2 = 0; i2 < padding; ++i2) {
          base64url += "=";
        }
      }
      return base64url.replace(/\-/g, "+").replace(/_/g, "/");
    }
    function typeError(template) {
      var args = [].slice.call(arguments, 1);
      var errMsg = util.format.bind(util, template).apply(null, args);
      return new TypeError(errMsg);
    }
    function bufferOrString(obj) {
      return Buffer2.isBuffer(obj) || typeof obj === "string";
    }
    function normalizeInput(thing) {
      if (!bufferOrString(thing))
        thing = JSON.stringify(thing);
      return thing;
    }
    function createHmacSigner(bits) {
      return function sign(thing, secret) {
        checkIsSecretKey(secret);
        thing = normalizeInput(thing);
        var hmac = crypto6.createHmac("sha" + bits, secret);
        var sig = (hmac.update(thing), hmac.digest("base64"));
        return fromBase64(sig);
      };
    }
    var bufferEqual;
    var timingSafeEqual = "timingSafeEqual" in crypto6 ? function timingSafeEqual2(a2, b2) {
      if (a2.byteLength !== b2.byteLength) {
        return false;
      }
      return crypto6.timingSafeEqual(a2, b2);
    } : function timingSafeEqual2(a2, b2) {
      if (!bufferEqual) {
        bufferEqual = require_buffer_equal_constant_time();
      }
      return bufferEqual(a2, b2);
    };
    function createHmacVerifier(bits) {
      return function verify(thing, signature, secret) {
        var computedSig = createHmacSigner(bits)(thing, secret);
        return timingSafeEqual(Buffer2.from(signature), Buffer2.from(computedSig));
      };
    }
    function createKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto6.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
        return fromBase64(sig);
      };
    }
    function createKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto6.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify(publicKey, signature, "base64");
      };
    }
    function createPSSKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto6.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign({
          key: privateKey,
          padding: crypto6.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto6.constants.RSA_PSS_SALTLEN_DIGEST
        }, "base64"));
        return fromBase64(sig);
      };
    }
    function createPSSKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto6.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify({
          key: publicKey,
          padding: crypto6.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto6.constants.RSA_PSS_SALTLEN_DIGEST
        }, signature, "base64");
      };
    }
    function createECDSASigner(bits) {
      var inner = createKeySigner(bits);
      return function sign() {
        var signature = inner.apply(null, arguments);
        signature = formatEcdsa.derToJose(signature, "ES" + bits);
        return signature;
      };
    }
    function createECDSAVerifer(bits) {
      var inner = createKeyVerifier(bits);
      return function verify(thing, signature, publicKey) {
        signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
        var result = inner(thing, signature, publicKey);
        return result;
      };
    }
    function createNoneSigner() {
      return function sign() {
        return "";
      };
    }
    function createNoneVerifier() {
      return function verify(thing, signature) {
        return signature === "";
      };
    }
    module.exports = function jwa(algorithm) {
      var signerFactories = {
        hs: createHmacSigner,
        rs: createKeySigner,
        ps: createPSSKeySigner,
        es: createECDSASigner,
        none: createNoneSigner
      };
      var verifierFactories = {
        hs: createHmacVerifier,
        rs: createKeyVerifier,
        ps: createPSSKeyVerifier,
        es: createECDSAVerifer,
        none: createNoneVerifier
      };
      var match7 = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/);
      if (!match7)
        throw typeError(MSG_INVALID_ALGORITHM, algorithm);
      var algo = (match7[1] || match7[3]).toLowerCase();
      var bits = match7[2];
      return {
        sign: signerFactories[algo](bits),
        verify: verifierFactories[algo](bits)
      };
    };
  }
});

// ../node_modules/jws/lib/tostring.js
var require_tostring = __commonJS({
  "../node_modules/jws/lib/tostring.js"(exports, module) {
    "use strict";
    var Buffer2 = __require("buffer").Buffer;
    module.exports = function toString(obj) {
      if (typeof obj === "string")
        return obj;
      if (typeof obj === "number" || Buffer2.isBuffer(obj))
        return obj.toString();
      return JSON.stringify(obj);
    };
  }
});

// ../node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS({
  "../node_modules/jws/lib/sign-stream.js"(exports, module) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream4 = __require("stream");
    var toString = require_tostring();
    var util = __require("util");
    function base64url(string, encoding) {
      return Buffer2.from(string, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function jwsSecuredInput(header, payload, encoding) {
      encoding = encoding || "utf8";
      var encodedHeader = base64url(toString(header), "binary");
      var encodedPayload = base64url(toString(payload), encoding);
      return util.format("%s.%s", encodedHeader, encodedPayload);
    }
    function jwsSign(opts) {
      var header = opts.header;
      var payload = opts.payload;
      var secretOrKey = opts.secret || opts.privateKey;
      var encoding = opts.encoding;
      var algo = jwa(header.alg);
      var securedInput = jwsSecuredInput(header, payload, encoding);
      var signature = algo.sign(securedInput, secretOrKey);
      return util.format("%s.%s", securedInput, signature);
    }
    function SignStream(opts) {
      var secret = opts.secret || opts.privateKey || opts.key;
      var secretStream = new DataStream(secret);
      this.readable = true;
      this.header = opts.header;
      this.encoding = opts.encoding;
      this.secret = this.privateKey = this.key = secretStream;
      this.payload = new DataStream(opts.payload);
      this.secret.once("close", function() {
        if (!this.payload.writable && this.readable)
          this.sign();
      }.bind(this));
      this.payload.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.sign();
      }.bind(this));
    }
    util.inherits(SignStream, Stream4);
    SignStream.prototype.sign = function sign() {
      try {
        var signature = jwsSign({
          header: this.header,
          payload: this.payload.buffer,
          secret: this.secret.buffer,
          encoding: this.encoding
        });
        this.emit("done", signature);
        this.emit("data", signature);
        this.emit("end");
        this.readable = false;
        return signature;
      } catch (e2) {
        this.readable = false;
        this.emit("error", e2);
        this.emit("close");
      }
    };
    SignStream.sign = jwsSign;
    module.exports = SignStream;
  }
});

// ../node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS({
  "../node_modules/jws/lib/verify-stream.js"(exports, module) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream4 = __require("stream");
    var toString = require_tostring();
    var util = __require("util");
    var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
    function isObject(thing) {
      return Object.prototype.toString.call(thing) === "[object Object]";
    }
    function safeJsonParse(thing) {
      if (isObject(thing))
        return thing;
      try {
        return JSON.parse(thing);
      } catch (e2) {
        return void 0;
      }
    }
    function headerFromJWS(jwsSig) {
      var encodedHeader = jwsSig.split(".", 1)[0];
      return safeJsonParse(Buffer2.from(encodedHeader, "base64").toString("binary"));
    }
    function securedInputFromJWS(jwsSig) {
      return jwsSig.split(".", 2).join(".");
    }
    function signatureFromJWS(jwsSig) {
      return jwsSig.split(".")[2];
    }
    function payloadFromJWS(jwsSig, encoding) {
      encoding = encoding || "utf8";
      var payload = jwsSig.split(".")[1];
      return Buffer2.from(payload, "base64").toString(encoding);
    }
    function isValidJws(string) {
      return JWS_REGEX.test(string) && !!headerFromJWS(string);
    }
    function jwsVerify(jwsSig, algorithm, secretOrKey) {
      if (!algorithm) {
        var err = new Error("Missing algorithm parameter for jws.verify");
        err.code = "MISSING_ALGORITHM";
        throw err;
      }
      jwsSig = toString(jwsSig);
      var signature = signatureFromJWS(jwsSig);
      var securedInput = securedInputFromJWS(jwsSig);
      var algo = jwa(algorithm);
      return algo.verify(securedInput, signature, secretOrKey);
    }
    function jwsDecode(jwsSig, opts) {
      opts = opts || {};
      jwsSig = toString(jwsSig);
      if (!isValidJws(jwsSig))
        return null;
      var header = headerFromJWS(jwsSig);
      if (!header)
        return null;
      var payload = payloadFromJWS(jwsSig);
      if (header.typ === "JWT" || opts.json)
        payload = JSON.parse(payload, opts.encoding);
      return {
        header,
        payload,
        signature: signatureFromJWS(jwsSig)
      };
    }
    function VerifyStream(opts) {
      opts = opts || {};
      var secretOrKey = opts.secret || opts.publicKey || opts.key;
      var secretStream = new DataStream(secretOrKey);
      this.readable = true;
      this.algorithm = opts.algorithm;
      this.encoding = opts.encoding;
      this.secret = this.publicKey = this.key = secretStream;
      this.signature = new DataStream(opts.signature);
      this.secret.once("close", function() {
        if (!this.signature.writable && this.readable)
          this.verify();
      }.bind(this));
      this.signature.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.verify();
      }.bind(this));
    }
    util.inherits(VerifyStream, Stream4);
    VerifyStream.prototype.verify = function verify() {
      try {
        var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
        var obj = jwsDecode(this.signature.buffer, this.encoding);
        this.emit("done", valid, obj);
        this.emit("data", valid);
        this.emit("end");
        this.readable = false;
        return valid;
      } catch (e2) {
        this.readable = false;
        this.emit("error", e2);
        this.emit("close");
      }
    };
    VerifyStream.decode = jwsDecode;
    VerifyStream.isValid = isValidJws;
    VerifyStream.verify = jwsVerify;
    module.exports = VerifyStream;
  }
});

// ../node_modules/jws/index.js
var require_jws = __commonJS({
  "../node_modules/jws/index.js"(exports) {
    "use strict";
    var SignStream = require_sign_stream();
    var VerifyStream = require_verify_stream();
    var ALGORITHMS = [
      "HS256",
      "HS384",
      "HS512",
      "RS256",
      "RS384",
      "RS512",
      "PS256",
      "PS384",
      "PS512",
      "ES256",
      "ES384",
      "ES512"
    ];
    exports.ALGORITHMS = ALGORITHMS;
    exports.sign = SignStream.sign;
    exports.verify = VerifyStream.verify;
    exports.decode = VerifyStream.decode;
    exports.isValid = VerifyStream.isValid;
    exports.createSign = function createSign(opts) {
      return new SignStream(opts);
    };
    exports.createVerify = function createVerify(opts) {
      return new VerifyStream(opts);
    };
  }
});

// ../node_modules/gtoken/build/src/index.js
var require_src5 = __commonJS({
  "../node_modules/gtoken/build/src/index.js"(exports) {
    "use strict";
    var __classPrivateFieldGet11 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind3, f2) {
      if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind3 === "m" ? f2 : kind3 === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
    };
    var __classPrivateFieldSet10 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind3, f2) {
      if (kind3 === "m") throw new TypeError("Private method is not writable");
      if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind3 === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
    };
    var _GoogleToken_instances;
    var _GoogleToken_inFlightRequest;
    var _GoogleToken_getTokenAsync;
    var _GoogleToken_getTokenAsyncInner;
    var _GoogleToken_ensureEmail;
    var _GoogleToken_revokeTokenAsync;
    var _GoogleToken_configure;
    var _GoogleToken_requestToken;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GoogleToken = void 0;
    var fs3 = __require("fs");
    var gaxios_1 = require_src2();
    var jws = require_jws();
    var path2 = __require("path");
    var util_1 = __require("util");
    var readFile = fs3.readFile ? (0, util_1.promisify)(fs3.readFile) : async () => {
      throw new ErrorWithCode("use key rather than keyFile.", "MISSING_CREDENTIALS");
    };
    var GOOGLE_TOKEN_URL = "https://www.googleapis.com/oauth2/v4/token";
    var GOOGLE_REVOKE_TOKEN_URL = "https://accounts.google.com/o/oauth2/revoke?token=";
    var ErrorWithCode = class extends Error {
      constructor(message, code) {
        super(message);
        this.code = code;
      }
    };
    var GoogleToken = class {
      get accessToken() {
        return this.rawToken ? this.rawToken.access_token : void 0;
      }
      get idToken() {
        return this.rawToken ? this.rawToken.id_token : void 0;
      }
      get tokenType() {
        return this.rawToken ? this.rawToken.token_type : void 0;
      }
      get refreshToken() {
        return this.rawToken ? this.rawToken.refresh_token : void 0;
      }
      /**
       * Create a GoogleToken.
       *
       * @param options  Configuration object.
       */
      constructor(options) {
        _GoogleToken_instances.add(this);
        this.transporter = {
          request: (opts) => (0, gaxios_1.request)(opts)
        };
        _GoogleToken_inFlightRequest.set(this, void 0);
        __classPrivateFieldGet11(this, _GoogleToken_instances, "m", _GoogleToken_configure).call(this, options);
      }
      /**
       * Returns whether the token has expired.
       *
       * @return true if the token has expired, false otherwise.
       */
      hasExpired() {
        const now = (/* @__PURE__ */ new Date()).getTime();
        if (this.rawToken && this.expiresAt) {
          return now >= this.expiresAt;
        } else {
          return true;
        }
      }
      /**
       * Returns whether the token will expire within eagerRefreshThresholdMillis
       *
       * @return true if the token will be expired within eagerRefreshThresholdMillis, false otherwise.
       */
      isTokenExpiring() {
        var _a3;
        const now = (/* @__PURE__ */ new Date()).getTime();
        const eagerRefreshThresholdMillis = (_a3 = this.eagerRefreshThresholdMillis) !== null && _a3 !== void 0 ? _a3 : 0;
        if (this.rawToken && this.expiresAt) {
          return this.expiresAt <= now + eagerRefreshThresholdMillis;
        } else {
          return true;
        }
      }
      getToken(callback, opts = {}) {
        if (typeof callback === "object") {
          opts = callback;
          callback = void 0;
        }
        opts = Object.assign({
          forceRefresh: false
        }, opts);
        if (callback) {
          const cb = callback;
          __classPrivateFieldGet11(this, _GoogleToken_instances, "m", _GoogleToken_getTokenAsync).call(this, opts).then((t2) => cb(null, t2), callback);
          return;
        }
        return __classPrivateFieldGet11(this, _GoogleToken_instances, "m", _GoogleToken_getTokenAsync).call(this, opts);
      }
      /**
       * Given a keyFile, extract the key and client email if available
       * @param keyFile Path to a json, pem, or p12 file that contains the key.
       * @returns an object with privateKey and clientEmail properties
       */
      async getCredentials(keyFile) {
        const ext2 = path2.extname(keyFile);
        switch (ext2) {
          case ".json": {
            const key = await readFile(keyFile, "utf8");
            const body = JSON.parse(key);
            const privateKey = body.private_key;
            const clientEmail = body.client_email;
            if (!privateKey || !clientEmail) {
              throw new ErrorWithCode("private_key and client_email are required.", "MISSING_CREDENTIALS");
            }
            return { privateKey, clientEmail };
          }
          case ".der":
          case ".crt":
          case ".pem": {
            const privateKey = await readFile(keyFile, "utf8");
            return { privateKey };
          }
          case ".p12":
          case ".pfx": {
            throw new ErrorWithCode("*.p12 certificates are not supported after v6.1.2. Consider utilizing *.json format or converting *.p12 to *.pem using the OpenSSL CLI.", "UNKNOWN_CERTIFICATE_TYPE");
          }
          default:
            throw new ErrorWithCode("Unknown certificate type. Type is determined based on file extension. Current supported extensions are *.json, and *.pem.", "UNKNOWN_CERTIFICATE_TYPE");
        }
      }
      revokeToken(callback) {
        if (callback) {
          __classPrivateFieldGet11(this, _GoogleToken_instances, "m", _GoogleToken_revokeTokenAsync).call(this).then(() => callback(), callback);
          return;
        }
        return __classPrivateFieldGet11(this, _GoogleToken_instances, "m", _GoogleToken_revokeTokenAsync).call(this);
      }
    };
    exports.GoogleToken = GoogleToken;
    _GoogleToken_inFlightRequest = /* @__PURE__ */ new WeakMap(), _GoogleToken_instances = /* @__PURE__ */ new WeakSet(), _GoogleToken_getTokenAsync = async function _GoogleToken_getTokenAsync2(opts) {
      if (__classPrivateFieldGet11(this, _GoogleToken_inFlightRequest, "f") && !opts.forceRefresh) {
        return __classPrivateFieldGet11(this, _GoogleToken_inFlightRequest, "f");
      }
      try {
        return await __classPrivateFieldSet10(this, _GoogleToken_inFlightRequest, __classPrivateFieldGet11(this, _GoogleToken_instances, "m", _GoogleToken_getTokenAsyncInner).call(this, opts), "f");
      } finally {
        __classPrivateFieldSet10(this, _GoogleToken_inFlightRequest, void 0, "f");
      }
    }, _GoogleToken_getTokenAsyncInner = async function _GoogleToken_getTokenAsyncInner2(opts) {
      if (this.isTokenExpiring() === false && opts.forceRefresh === false) {
        return Promise.resolve(this.rawToken);
      }
      if (!this.key && !this.keyFile) {
        throw new Error("No key or keyFile set.");
      }
      if (!this.key && this.keyFile) {
        const creds = await this.getCredentials(this.keyFile);
        this.key = creds.privateKey;
        this.iss = creds.clientEmail || this.iss;
        if (!creds.clientEmail) {
          __classPrivateFieldGet11(this, _GoogleToken_instances, "m", _GoogleToken_ensureEmail).call(this);
        }
      }
      return __classPrivateFieldGet11(this, _GoogleToken_instances, "m", _GoogleToken_requestToken).call(this);
    }, _GoogleToken_ensureEmail = function _GoogleToken_ensureEmail2() {
      if (!this.iss) {
        throw new ErrorWithCode("email is required.", "MISSING_CREDENTIALS");
      }
    }, _GoogleToken_revokeTokenAsync = async function _GoogleToken_revokeTokenAsync2() {
      if (!this.accessToken) {
        throw new Error("No token to revoke.");
      }
      const url = GOOGLE_REVOKE_TOKEN_URL + this.accessToken;
      await this.transporter.request({
        url,
        retry: true
      });
      __classPrivateFieldGet11(this, _GoogleToken_instances, "m", _GoogleToken_configure).call(this, {
        email: this.iss,
        sub: this.sub,
        key: this.key,
        keyFile: this.keyFile,
        scope: this.scope,
        additionalClaims: this.additionalClaims
      });
    }, _GoogleToken_configure = function _GoogleToken_configure2(options = {}) {
      this.keyFile = options.keyFile;
      this.key = options.key;
      this.rawToken = void 0;
      this.iss = options.email || options.iss;
      this.sub = options.sub;
      this.additionalClaims = options.additionalClaims;
      if (typeof options.scope === "object") {
        this.scope = options.scope.join(" ");
      } else {
        this.scope = options.scope;
      }
      this.eagerRefreshThresholdMillis = options.eagerRefreshThresholdMillis;
      if (options.transporter) {
        this.transporter = options.transporter;
      }
    }, _GoogleToken_requestToken = /**
     * Request the token from Google.
     */
    async function _GoogleToken_requestToken2() {
      var _a3, _b;
      const iat = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
      const additionalClaims = this.additionalClaims || {};
      const payload = Object.assign({
        iss: this.iss,
        scope: this.scope,
        aud: GOOGLE_TOKEN_URL,
        exp: iat + 3600,
        iat,
        sub: this.sub
      }, additionalClaims);
      const signedJWT = jws.sign({
        header: { alg: "RS256" },
        payload,
        secret: this.key
      });
      try {
        const r2 = await this.transporter.request({
          method: "POST",
          url: GOOGLE_TOKEN_URL,
          data: {
            grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
            assertion: signedJWT
          },
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          responseType: "json",
          retryConfig: {
            httpMethodsToRetry: ["POST"]
          }
        });
        this.rawToken = r2.data;
        this.expiresAt = r2.data.expires_in === null || r2.data.expires_in === void 0 ? void 0 : (iat + r2.data.expires_in) * 1e3;
        return this.rawToken;
      } catch (e2) {
        this.rawToken = void 0;
        this.tokenExpires = void 0;
        const body = e2.response && ((_a3 = e2.response) === null || _a3 === void 0 ? void 0 : _a3.data) ? (_b = e2.response) === null || _b === void 0 ? void 0 : _b.data : {};
        if (body.error) {
          const desc = body.error_description ? `: ${body.error_description}` : "";
          e2.message = `${body.error}${desc}`;
        }
        throw e2;
      }
    };
  }
});

// ../node_modules/google-auth-library/build/src/auth/jwtaccess.js
var require_jwtaccess = __commonJS({
  "../node_modules/google-auth-library/build/src/auth/jwtaccess.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JWTAccess = void 0;
    var jws = require_jws();
    var util_1 = require_util2();
    var DEFAULT_HEADER = {
      alg: "RS256",
      typ: "JWT"
    };
    var JWTAccess = class _JWTAccess {
      /**
       * JWTAccess service account credentials.
       *
       * Create a new access token by using the credential to create a new JWT token
       * that's recognized as the access token.
       *
       * @param email the service account email address.
       * @param key the private key that will be used to sign the token.
       * @param keyId the ID of the private key used to sign the token.
       */
      constructor(email, key, keyId, eagerRefreshThresholdMillis) {
        this.cache = new util_1.LRUCache({
          capacity: 500,
          maxAge: 60 * 60 * 1e3
        });
        this.email = email;
        this.key = key;
        this.keyId = keyId;
        this.eagerRefreshThresholdMillis = eagerRefreshThresholdMillis !== null && eagerRefreshThresholdMillis !== void 0 ? eagerRefreshThresholdMillis : 5 * 60 * 1e3;
      }
      /**
       * Ensures that we're caching a key appropriately, giving precedence to scopes vs. url
       *
       * @param url The URI being authorized.
       * @param scopes The scope or scopes being authorized
       * @returns A string that returns the cached key.
       */
      getCachedKey(url, scopes) {
        let cacheKey = url;
        if (scopes && Array.isArray(scopes) && scopes.length) {
          cacheKey = url ? `${url}_${scopes.join("_")}` : `${scopes.join("_")}`;
        } else if (typeof scopes === "string") {
          cacheKey = url ? `${url}_${scopes}` : scopes;
        }
        if (!cacheKey) {
          throw Error("Scopes or url must be provided");
        }
        return cacheKey;
      }
      /**
       * Get a non-expired access token, after refreshing if necessary.
       *
       * @param url The URI being authorized.
       * @param additionalClaims An object with a set of additional claims to
       * include in the payload.
       * @returns An object that includes the authorization header.
       */
      getRequestHeaders(url, additionalClaims, scopes) {
        const key = this.getCachedKey(url, scopes);
        const cachedToken = this.cache.get(key);
        const now = Date.now();
        if (cachedToken && cachedToken.expiration - now > this.eagerRefreshThresholdMillis) {
          return cachedToken.headers;
        }
        const iat = Math.floor(Date.now() / 1e3);
        const exp = _JWTAccess.getExpirationTime(iat);
        let defaultClaims;
        if (Array.isArray(scopes)) {
          scopes = scopes.join(" ");
        }
        if (scopes) {
          defaultClaims = {
            iss: this.email,
            sub: this.email,
            scope: scopes,
            exp,
            iat
          };
        } else {
          defaultClaims = {
            iss: this.email,
            sub: this.email,
            aud: url,
            exp,
            iat
          };
        }
        if (additionalClaims) {
          for (const claim in defaultClaims) {
            if (additionalClaims[claim]) {
              throw new Error(`The '${claim}' property is not allowed when passing additionalClaims. This claim is included in the JWT by default.`);
            }
          }
        }
        const header = this.keyId ? { ...DEFAULT_HEADER, kid: this.keyId } : DEFAULT_HEADER;
        const payload = Object.assign(defaultClaims, additionalClaims);
        const signedJWT = jws.sign({ header, payload, secret: this.key });
        const headers = { Authorization: `Bearer ${signedJWT}` };
        this.cache.set(key, {
          expiration: exp * 1e3,
          headers
        });
        return headers;
      }
      /**
       * Returns an expiration time for the JWT token.
       *
       * @param iat The issued at time for the JWT.
       * @returns An expiration time for the JWT.
       */
      static getExpirationTime(iat) {
        const exp = iat + 3600;
        return exp;
      }
      /**
       * Create a JWTAccess credentials instance using the given input options.
       * @param json The input object.
       */
      fromJSON(json) {
        if (!json) {
          throw new Error("Must pass in a JSON object containing the service account auth settings.");
        }
        if (!json.client_email) {
          throw new Error("The incoming JSON object does not contain a client_email field");
        }
        if (!json.private_key) {
          throw new Error("The incoming JSON object does not contain a private_key field");
        }
        this.email = json.client_email;
        this.key = json.private_key;
        this.keyId = json.private_key_id;
        this.projectId = json.project_id;
      }
      fromStream(inputStream, callback) {
        if (callback) {
          this.fromStreamAsync(inputStream).then(() => callback(), callback);
        } else {
          return this.fromStreamAsync(inputStream);
        }
      }
      fromStreamAsync(inputStream) {
        return new Promise((resolve, reject) => {
          if (!inputStream) {
            reject(new Error("Must pass in a stream containing the service account auth settings."));
          }
          let s2 = "";
          inputStream.setEncoding("utf8").on("data", (chunk) => s2 += chunk).on("error", reject).on("end", () => {
            try {
              const data = JSON.parse(s2);
              this.fromJSON(data);
              resolve();
            } catch (err) {
              reject(err);
            }
          });
        });
      }
    };
    exports.JWTAccess = JWTAccess;
  }
});

// ../node_modules/google-auth-library/build/src/auth/jwtclient.js
var require_jwtclient = __commonJS({
  "../node_modules/google-auth-library/build/src/auth/jwtclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JWT = void 0;
    var gtoken_1 = require_src5();
    var jwtaccess_1 = require_jwtaccess();
    var oauth2client_1 = require_oauth2client();
    var authclient_1 = require_authclient();
    var JWT = class _JWT extends oauth2client_1.OAuth2Client {
      constructor(optionsOrEmail, keyFile, key, scopes, subject, keyId) {
        const opts = optionsOrEmail && typeof optionsOrEmail === "object" ? optionsOrEmail : { email: optionsOrEmail, keyFile, key, keyId, scopes, subject };
        super(opts);
        this.email = opts.email;
        this.keyFile = opts.keyFile;
        this.key = opts.key;
        this.keyId = opts.keyId;
        this.scopes = opts.scopes;
        this.subject = opts.subject;
        this.additionalClaims = opts.additionalClaims;
        this.credentials = { refresh_token: "jwt-placeholder", expiry_date: 1 };
      }
      /**
       * Creates a copy of the credential with the specified scopes.
       * @param scopes List of requested scopes or a single scope.
       * @return The cloned instance.
       */
      createScoped(scopes) {
        const jwt = new _JWT(this);
        jwt.scopes = scopes;
        return jwt;
      }
      /**
       * Obtains the metadata to be sent with the request.
       *
       * @param url the URI being authorized.
       */
      async getRequestMetadataAsync(url) {
        url = this.defaultServicePath ? `https://${this.defaultServicePath}/` : url;
        const useSelfSignedJWT = !this.hasUserScopes() && url || this.useJWTAccessWithScope && this.hasAnyScopes() || this.universeDomain !== authclient_1.DEFAULT_UNIVERSE;
        if (this.subject && this.universeDomain !== authclient_1.DEFAULT_UNIVERSE) {
          throw new RangeError(`Service Account user is configured for the credential. Domain-wide delegation is not supported in universes other than ${authclient_1.DEFAULT_UNIVERSE}`);
        }
        if (!this.apiKey && useSelfSignedJWT) {
          if (this.additionalClaims && this.additionalClaims.target_audience) {
            const { tokens } = await this.refreshToken();
            return {
              headers: this.addSharedMetadataHeaders({
                Authorization: `Bearer ${tokens.id_token}`
              })
            };
          } else {
            if (!this.access) {
              this.access = new jwtaccess_1.JWTAccess(this.email, this.key, this.keyId, this.eagerRefreshThresholdMillis);
            }
            let scopes;
            if (this.hasUserScopes()) {
              scopes = this.scopes;
            } else if (!url) {
              scopes = this.defaultScopes;
            }
            const useScopes = this.useJWTAccessWithScope || this.universeDomain !== authclient_1.DEFAULT_UNIVERSE;
            const headers = await this.access.getRequestHeaders(
              url !== null && url !== void 0 ? url : void 0,
              this.additionalClaims,
              // Scopes take precedent over audience for signing,
              // so we only provide them if `useJWTAccessWithScope` is on or
              // if we are in a non-default universe
              useScopes ? scopes : void 0
            );
            return { headers: this.addSharedMetadataHeaders(headers) };
          }
        } else if (this.hasAnyScopes() || this.apiKey) {
          return super.getRequestMetadataAsync(url);
        } else {
          return { headers: {} };
        }
      }
      /**
       * Fetches an ID token.
       * @param targetAudience the audience for the fetched ID token.
       */
      async fetchIdToken(targetAudience) {
        const gtoken = new gtoken_1.GoogleToken({
          iss: this.email,
          sub: this.subject,
          scope: this.scopes || this.defaultScopes,
          keyFile: this.keyFile,
          key: this.key,
          additionalClaims: { target_audience: targetAudience },
          transporter: this.transporter
        });
        await gtoken.getToken({
          forceRefresh: true
        });
        if (!gtoken.idToken) {
          throw new Error("Unknown error: Failed to fetch ID token");
        }
        return gtoken.idToken;
      }
      /**
       * Determine if there are currently scopes available.
       */
      hasUserScopes() {
        if (!this.scopes) {
          return false;
        }
        return this.scopes.length > 0;
      }
      /**
       * Are there any default or user scopes defined.
       */
      hasAnyScopes() {
        if (this.scopes && this.scopes.length > 0)
          return true;
        if (this.defaultScopes && this.defaultScopes.length > 0)
          return true;
        return false;
      }
      authorize(callback) {
        if (callback) {
          this.authorizeAsync().then((r2) => callback(null, r2), callback);
        } else {
          return this.authorizeAsync();
        }
      }
      async authorizeAsync() {
        const result = await this.refreshToken();
        if (!result) {
          throw new Error("No result returned");
        }
        this.credentials = result.tokens;
        this.credentials.refresh_token = "jwt-placeholder";
        this.key = this.gtoken.key;
        this.email = this.gtoken.iss;
        return result.tokens;
      }
      /**
       * Refreshes the access token.
       * @param refreshToken ignored
       * @private
       */
      async refreshTokenNoCache(refreshToken) {
        const gtoken = this.createGToken();
        const token = await gtoken.getToken({
          forceRefresh: this.isTokenExpiring()
        });
        const tokens = {
          access_token: token.access_token,
          token_type: "Bearer",
          expiry_date: gtoken.expiresAt,
          id_token: gtoken.idToken
        };
        this.emit("tokens", tokens);
        return { res: null, tokens };
      }
      /**
       * Create a gToken if it doesn't already exist.
       */
      createGToken() {
        if (!this.gtoken) {
          this.gtoken = new gtoken_1.GoogleToken({
            iss: this.email,
            sub: this.subject,
            scope: this.scopes || this.defaultScopes,
            keyFile: this.keyFile,
            key: this.key,
            additionalClaims: this.additionalClaims,
            transporter: this.transporter
          });
        }
        return this.gtoken;
      }
      /**
       * Create a JWT credentials instance using the given input options.
       * @param json The input object.
       *
       * @remarks
       *
       * **Important**: If you accept a credential configuration (credential JSON/File/Stream) from an external source for authentication to Google Cloud, you must validate it before providing it to any Google API or library. Providing an unvalidated credential configuration to Google APIs can compromise the security of your systems and data. For more information, refer to {@link https://cloud.google.com/docs/authentication/external/externally-sourced-credentials Validate credential configurations from external sources}.
       */
      fromJSON(json) {
        if (!json) {
          throw new Error("Must pass in a JSON object containing the service account auth settings.");
        }
        if (!json.client_email) {
          throw new Error("The incoming JSON object does not contain a client_email field");
        }
        if (!json.private_key) {
          throw new Error("The incoming JSON object does not contain a private_key field");
        }
        this.email = json.client_email;
        this.key = json.private_key;
        this.keyId = json.private_key_id;
        this.projectId = json.project_id;
        this.quotaProjectId = json.quota_project_id;
        this.universeDomain = json.universe_domain || this.universeDomain;
      }
      fromStream(inputStream, callback) {
        if (callback) {
          this.fromStreamAsync(inputStream).then(() => callback(), callback);
        } else {
          return this.fromStreamAsync(inputStream);
        }
      }
      fromStreamAsync(inputStream) {
        return new Promise((resolve, reject) => {
          if (!inputStream) {
            throw new Error("Must pass in a stream containing the service account auth settings.");
          }
          let s2 = "";
          inputStream.setEncoding("utf8").on("error", reject).on("data", (chunk) => s2 += chunk).on("end", () => {
            try {
              const data = JSON.parse(s2);
              this.fromJSON(data);
              resolve();
            } catch (e2) {
              reject(e2);
            }
          });
        });
      }
      /**
       * Creates a JWT credentials instance using an API Key for authentication.
       * @param apiKey The API Key in string form.
       */
      fromAPIKey(apiKey) {
        if (typeof apiKey !== "string") {
          throw new Error("Must provide an API Key string.");
        }
        this.apiKey = apiKey;
      }
      /**
       * Using the key or keyFile on the JWT client, obtain an object that contains
       * the key and the client email.
       */
      async getCredentials() {
        if (this.key) {
          return { private_key: this.key, client_email: this.email };
        } else if (this.keyFile) {
          const gtoken = this.createGToken();
          const creds = await gtoken.getCredentials(this.keyFile);
          return { private_key: creds.privateKey, client_email: creds.clientEmail };
        }
        throw new Error("A key or a keyFile must be provided to getCredentials.");
      }
    };
    exports.JWT = JWT;
  }
});

// ../node_modules/google-auth-library/build/src/auth/refreshclient.js
var require_refreshclient = __commonJS({
  "../node_modules/google-auth-library/build/src/auth/refreshclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UserRefreshClient = exports.USER_REFRESH_ACCOUNT_TYPE = void 0;
    var oauth2client_1 = require_oauth2client();
    var querystring_1 = __require("querystring");
    exports.USER_REFRESH_ACCOUNT_TYPE = "authorized_user";
    var UserRefreshClient = class _UserRefreshClient extends oauth2client_1.OAuth2Client {
      constructor(optionsOrClientId, clientSecret, refreshToken, eagerRefreshThresholdMillis, forceRefreshOnFailure) {
        const opts = optionsOrClientId && typeof optionsOrClientId === "object" ? optionsOrClientId : {
          clientId: optionsOrClientId,
          clientSecret,
          refreshToken,
          eagerRefreshThresholdMillis,
          forceRefreshOnFailure
        };
        super(opts);
        this._refreshToken = opts.refreshToken;
        this.credentials.refresh_token = opts.refreshToken;
      }
      /**
       * Refreshes the access token.
       * @param refreshToken An ignored refreshToken..
       * @param callback Optional callback.
       */
      async refreshTokenNoCache(refreshToken) {
        return super.refreshTokenNoCache(this._refreshToken);
      }
      async fetchIdToken(targetAudience) {
        const res = await this.transporter.request({
          ..._UserRefreshClient.RETRY_CONFIG,
          url: this.endpoints.oauth2TokenUrl,
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          },
          method: "POST",
          data: (0, querystring_1.stringify)({
            client_id: this._clientId,
            client_secret: this._clientSecret,
            grant_type: "refresh_token",
            refresh_token: this._refreshToken,
            target_audience: targetAudience
          })
        });
        return res.data.id_token;
      }
      /**
       * Create a UserRefreshClient credentials instance using the given input
       * options.
       * @param json The input object.
       */
      fromJSON(json) {
        if (!json) {
          throw new Error("Must pass in a JSON object containing the user refresh token");
        }
        if (json.type !== "authorized_user") {
          throw new Error('The incoming JSON object does not have the "authorized_user" type');
        }
        if (!json.client_id) {
          throw new Error("The incoming JSON object does not contain a client_id field");
        }
        if (!json.client_secret) {
          throw new Error("The incoming JSON object does not contain a client_secret field");
        }
        if (!json.refresh_token) {
          throw new Error("The incoming JSON object does not contain a refresh_token field");
        }
        this._clientId = json.client_id;
        this._clientSecret = json.client_secret;
        this._refreshToken = json.refresh_token;
        this.credentials.refresh_token = json.refresh_token;
        this.quotaProjectId = json.quota_project_id;
        this.universeDomain = json.universe_domain || this.universeDomain;
      }
      fromStream(inputStream, callback) {
        if (callback) {
          this.fromStreamAsync(inputStream).then(() => callback(), callback);
        } else {
          return this.fromStreamAsync(inputStream);
        }
      }
      async fromStreamAsync(inputStream) {
        return new Promise((resolve, reject) => {
          if (!inputStream) {
            return reject(new Error("Must pass in a stream containing the user refresh token."));
          }
          let s2 = "";
          inputStream.setEncoding("utf8").on("error", reject).on("data", (chunk) => s2 += chunk).on("end", () => {
            try {
              const data = JSON.parse(s2);
              this.fromJSON(data);
              return resolve();
            } catch (err) {
              return reject(err);
            }
          });
        });
      }
      /**
       * Create a UserRefreshClient credentials instance using the given input
       * options.
       * @param json The input object.
       */
      static fromJSON(json) {
        const client = new _UserRefreshClient();
        client.fromJSON(json);
        return client;
      }
    };
    exports.UserRefreshClient = UserRefreshClient;
  }
});

// ../node_modules/google-auth-library/build/src/auth/impersonated.js
var require_impersonated = __commonJS({
  "../node_modules/google-auth-library/build/src/auth/impersonated.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Impersonated = exports.IMPERSONATED_ACCOUNT_TYPE = void 0;
    var oauth2client_1 = require_oauth2client();
    var gaxios_1 = require_src2();
    var util_1 = require_util2();
    exports.IMPERSONATED_ACCOUNT_TYPE = "impersonated_service_account";
    var Impersonated = class _Impersonated extends oauth2client_1.OAuth2Client {
      /**
       * Impersonated service account credentials.
       *
       * Create a new access token by impersonating another service account.
       *
       * Impersonated Credentials allowing credentials issued to a user or
       * service account to impersonate another. The source project using
       * Impersonated Credentials must enable the "IAMCredentials" API.
       * Also, the target service account must grant the orginating principal
       * the "Service Account Token Creator" IAM role.
       *
       * @param {object} options - The configuration object.
       * @param {object} [options.sourceClient] the source credential used as to
       * acquire the impersonated credentials.
       * @param {string} [options.targetPrincipal] the service account to
       * impersonate.
       * @param {string[]} [options.delegates] the chained list of delegates
       * required to grant the final access_token. If set, the sequence of
       * identities must have "Service Account Token Creator" capability granted to
       * the preceding identity. For example, if set to [serviceAccountB,
       * serviceAccountC], the sourceCredential must have the Token Creator role on
       * serviceAccountB. serviceAccountB must have the Token Creator on
       * serviceAccountC. Finally, C must have Token Creator on target_principal.
       * If left unset, sourceCredential must have that role on targetPrincipal.
       * @param {string[]} [options.targetScopes] scopes to request during the
       * authorization grant.
       * @param {number} [options.lifetime] number of seconds the delegated
       * credential should be valid for up to 3600 seconds by default, or 43,200
       * seconds by extending the token's lifetime, see:
       * https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials#sa-credentials-oauth
       * @param {string} [options.endpoint] api endpoint override.
       */
      constructor(options = {}) {
        var _a3, _b, _c, _d, _e2, _f;
        super(options);
        this.credentials = {
          expiry_date: 1,
          refresh_token: "impersonated-placeholder"
        };
        this.sourceClient = (_a3 = options.sourceClient) !== null && _a3 !== void 0 ? _a3 : new oauth2client_1.OAuth2Client();
        this.targetPrincipal = (_b = options.targetPrincipal) !== null && _b !== void 0 ? _b : "";
        this.delegates = (_c = options.delegates) !== null && _c !== void 0 ? _c : [];
        this.targetScopes = (_d = options.targetScopes) !== null && _d !== void 0 ? _d : [];
        this.lifetime = (_e2 = options.lifetime) !== null && _e2 !== void 0 ? _e2 : 3600;
        const usingExplicitUniverseDomain = !!(0, util_1.originalOrCamelOptions)(options).get("universe_domain");
        if (!usingExplicitUniverseDomain) {
          this.universeDomain = this.sourceClient.universeDomain;
        } else if (this.sourceClient.universeDomain !== this.universeDomain) {
          throw new RangeError(`Universe domain ${this.sourceClient.universeDomain} in source credentials does not match ${this.universeDomain} universe domain set for impersonated credentials.`);
        }
        this.endpoint = (_f = options.endpoint) !== null && _f !== void 0 ? _f : `https://iamcredentials.${this.universeDomain}`;
      }
      /**
       * Signs some bytes.
       *
       * {@link https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/signBlob Reference Documentation}
       * @param blobToSign String to sign.
       *
       * @returns A {@link SignBlobResponse} denoting the keyID and signedBlob in base64 string
       */
      async sign(blobToSign) {
        await this.sourceClient.getAccessToken();
        const name = `projects/-/serviceAccounts/${this.targetPrincipal}`;
        const u2 = `${this.endpoint}/v1/${name}:signBlob`;
        const body = {
          delegates: this.delegates,
          payload: Buffer.from(blobToSign).toString("base64")
        };
        const res = await this.sourceClient.request({
          ..._Impersonated.RETRY_CONFIG,
          url: u2,
          data: body,
          method: "POST"
        });
        return res.data;
      }
      /** The service account email to be impersonated. */
      getTargetPrincipal() {
        return this.targetPrincipal;
      }
      /**
       * Refreshes the access token.
       */
      async refreshToken() {
        var _a3, _b, _c, _d, _e2, _f;
        try {
          await this.sourceClient.getAccessToken();
          const name = "projects/-/serviceAccounts/" + this.targetPrincipal;
          const u2 = `${this.endpoint}/v1/${name}:generateAccessToken`;
          const body = {
            delegates: this.delegates,
            scope: this.targetScopes,
            lifetime: this.lifetime + "s"
          };
          const res = await this.sourceClient.request({
            ..._Impersonated.RETRY_CONFIG,
            url: u2,
            data: body,
            method: "POST"
          });
          const tokenResponse = res.data;
          this.credentials.access_token = tokenResponse.accessToken;
          this.credentials.expiry_date = Date.parse(tokenResponse.expireTime);
          return {
            tokens: this.credentials,
            res
          };
        } catch (error) {
          if (!(error instanceof Error))
            throw error;
          let status = 0;
          let message = "";
          if (error instanceof gaxios_1.GaxiosError) {
            status = (_c = (_b = (_a3 = error === null || error === void 0 ? void 0 : error.response) === null || _a3 === void 0 ? void 0 : _a3.data) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.status;
            message = (_f = (_e2 = (_d = error === null || error === void 0 ? void 0 : error.response) === null || _d === void 0 ? void 0 : _d.data) === null || _e2 === void 0 ? void 0 : _e2.error) === null || _f === void 0 ? void 0 : _f.message;
          }
          if (status && message) {
            error.message = `${status}: unable to impersonate: ${message}`;
            throw error;
          } else {
            error.message = `unable to impersonate: ${error}`;
            throw error;
          }
        }
      }
      /**
       * Generates an OpenID Connect ID token for a service account.
       *
       * {@link https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/generateIdToken Reference Documentation}
       *
       * @param targetAudience the audience for the fetched ID token.
       * @param options the for the request
       * @return an OpenID Connect ID token
       */
      async fetchIdToken(targetAudience, options) {
        var _a3, _b;
        await this.sourceClient.getAccessToken();
        const name = `projects/-/serviceAccounts/${this.targetPrincipal}`;
        const u2 = `${this.endpoint}/v1/${name}:generateIdToken`;
        const body = {
          delegates: this.delegates,
          audience: targetAudience,
          includeEmail: (_a3 = options === null || options === void 0 ? void 0 : options.includeEmail) !== null && _a3 !== void 0 ? _a3 : true,
          useEmailAzp: (_b = options === null || options === void 0 ? void 0 : options.includeEmail) !== null && _b !== void 0 ? _b : true
        };
        const res = await this.sourceClient.request({
          ..._Impersonated.RETRY_CONFIG,
          url: u2,
          data: body,
          method: "POST"
        });
        return res.data.token;
      }
    };
    exports.Impersonated = Impersonated;
  }
});

// ../node_modules/google-auth-library/build/src/auth/oauth2common.js
var require_oauth2common = __commonJS({
  "../node_modules/google-auth-library/build/src/auth/oauth2common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OAuthClientAuthHandler = void 0;
    exports.getErrorFromOAuthErrorResponse = getErrorFromOAuthErrorResponse;
    var querystring = __require("querystring");
    var crypto_1 = require_crypto3();
    var METHODS_SUPPORTING_REQUEST_BODY = ["PUT", "POST", "PATCH"];
    var OAuthClientAuthHandler = class {
      /**
       * Instantiates an OAuth client authentication handler.
       * @param clientAuthentication The client auth credentials.
       */
      constructor(clientAuthentication) {
        this.clientAuthentication = clientAuthentication;
        this.crypto = (0, crypto_1.createCrypto)();
      }
      /**
       * Applies client authentication on the OAuth request's headers or POST
       * body but does not process the request.
       * @param opts The GaxiosOptions whose headers or data are to be modified
       *   depending on the client authentication mechanism to be used.
       * @param bearerToken The optional bearer token to use for authentication.
       *   When this is used, no client authentication credentials are needed.
       */
      applyClientAuthenticationOptions(opts, bearerToken) {
        this.injectAuthenticatedHeaders(opts, bearerToken);
        if (!bearerToken) {
          this.injectAuthenticatedRequestBody(opts);
        }
      }
      /**
       * Applies client authentication on the request's header if either
       * basic authentication or bearer token authentication is selected.
       *
       * @param opts The GaxiosOptions whose headers or data are to be modified
       *   depending on the client authentication mechanism to be used.
       * @param bearerToken The optional bearer token to use for authentication.
       *   When this is used, no client authentication credentials are needed.
       */
      injectAuthenticatedHeaders(opts, bearerToken) {
        var _a3;
        if (bearerToken) {
          opts.headers = opts.headers || {};
          Object.assign(opts.headers, {
            Authorization: `Bearer ${bearerToken}}`
          });
        } else if (((_a3 = this.clientAuthentication) === null || _a3 === void 0 ? void 0 : _a3.confidentialClientType) === "basic") {
          opts.headers = opts.headers || {};
          const clientId = this.clientAuthentication.clientId;
          const clientSecret = this.clientAuthentication.clientSecret || "";
          const base64EncodedCreds = this.crypto.encodeBase64StringUtf8(`${clientId}:${clientSecret}`);
          Object.assign(opts.headers, {
            Authorization: `Basic ${base64EncodedCreds}`
          });
        }
      }
      /**
       * Applies client authentication on the request's body if request-body
       * client authentication is selected.
       *
       * @param opts The GaxiosOptions whose headers or data are to be modified
       *   depending on the client authentication mechanism to be used.
       */
      injectAuthenticatedRequestBody(opts) {
        var _a3;
        if (((_a3 = this.clientAuthentication) === null || _a3 === void 0 ? void 0 : _a3.confidentialClientType) === "request-body") {
          const method = (opts.method || "GET").toUpperCase();
          if (METHODS_SUPPORTING_REQUEST_BODY.indexOf(method) !== -1) {
            let contentType;
            const headers = opts.headers || {};
            for (const key in headers) {
              if (key.toLowerCase() === "content-type" && headers[key]) {
                contentType = headers[key].toLowerCase();
                break;
              }
            }
            if (contentType === "application/x-www-form-urlencoded") {
              opts.data = opts.data || "";
              const data = querystring.parse(opts.data);
              Object.assign(data, {
                client_id: this.clientAuthentication.clientId,
                client_secret: this.clientAuthentication.clientSecret || ""
              });
              opts.data = querystring.stringify(data);
            } else if (contentType === "application/json") {
              opts.data = opts.data || {};
              Object.assign(opts.data, {
                client_id: this.clientAuthentication.clientId,
                client_secret: this.clientAuthentication.clientSecret || ""
              });
            } else {
              throw new Error(`${contentType} content-types are not supported with ${this.clientAuthentication.confidentialClientType} client authentication`);
            }
          } else {
            throw new Error(`${method} HTTP method does not support ${this.clientAuthentication.confidentialClientType} client authentication`);
          }
        }
      }
      /**
       * Retry config for Auth-related requests.
       *
       * @remarks
       *
       * This is not a part of the default {@link AuthClient.transporter transporter/gaxios}
       * config as some downstream APIs would prefer if customers explicitly enable retries,
       * such as GCS.
       */
      static get RETRY_CONFIG() {
        return {
          retry: true,
          retryConfig: {
            httpMethodsToRetry: ["GET", "PUT", "POST", "HEAD", "OPTIONS", "DELETE"]
          }
        };
      }
    };
    exports.OAuthClientAuthHandler = OAuthClientAuthHandler;
    function getErrorFromOAuthErrorResponse(resp, err) {
      const errorCode = resp.error;
      const errorDescription = resp.error_description;
      const errorUri = resp.error_uri;
      let message = `Error code ${errorCode}`;
      if (typeof errorDescription !== "undefined") {
        message += `: ${errorDescription}`;
      }
      if (typeof errorUri !== "undefined") {
        message += ` - ${errorUri}`;
      }
      const newError = new Error(message);
      if (err) {
        const keys = Object.keys(err);
        if (err.stack) {
          keys.push("stack");
        }
        keys.forEach((key) => {
          if (key !== "message") {
            Object.defineProperty(newError, key, {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              value: err[key],
              writable: false,
              enumerable: true
            });
          }
        });
      }
      return newError;
    }
  }
});

// ../node_modules/google-auth-library/build/src/auth/stscredentials.js
var require_stscredentials = __commonJS({
  "../node_modules/google-auth-library/build/src/auth/stscredentials.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StsCredentials = void 0;
    var gaxios_1 = require_src2();
    var querystring = __require("querystring");
    var transporters_1 = require_transporters();
    var oauth2common_1 = require_oauth2common();
    var StsCredentials = class _StsCredentials extends oauth2common_1.OAuthClientAuthHandler {
      /**
       * Initializes an STS credentials instance.
       * @param tokenExchangeEndpoint The token exchange endpoint.
       * @param clientAuthentication The client authentication credentials if
       *   available.
       */
      constructor(tokenExchangeEndpoint, clientAuthentication) {
        super(clientAuthentication);
        this.tokenExchangeEndpoint = tokenExchangeEndpoint;
        this.transporter = new transporters_1.DefaultTransporter();
      }
      /**
       * Exchanges the provided token for another type of token based on the
       * rfc8693 spec.
       * @param stsCredentialsOptions The token exchange options used to populate
       *   the token exchange request.
       * @param additionalHeaders Optional additional headers to pass along the
       *   request.
       * @param options Optional additional GCP-specific non-spec defined options
       *   to send with the request.
       *   Example: `&options=${encodeUriComponent(JSON.stringified(options))}`
       * @return A promise that resolves with the token exchange response containing
       *   the requested token and its expiration time.
       */
      async exchangeToken(stsCredentialsOptions, additionalHeaders, options) {
        var _a3, _b, _c;
        const values = {
          grant_type: stsCredentialsOptions.grantType,
          resource: stsCredentialsOptions.resource,
          audience: stsCredentialsOptions.audience,
          scope: (_a3 = stsCredentialsOptions.scope) === null || _a3 === void 0 ? void 0 : _a3.join(" "),
          requested_token_type: stsCredentialsOptions.requestedTokenType,
          subject_token: stsCredentialsOptions.subjectToken,
          subject_token_type: stsCredentialsOptions.subjectTokenType,
          actor_token: (_b = stsCredentialsOptions.actingParty) === null || _b === void 0 ? void 0 : _b.actorToken,
          actor_token_type: (_c = stsCredentialsOptions.actingParty) === null || _c === void 0 ? void 0 : _c.actorTokenType,
          // Non-standard GCP-specific options.
          options: options && JSON.stringify(options)
        };
        Object.keys(values).forEach((key) => {
          if (typeof values[key] === "undefined") {
            delete values[key];
          }
        });
        const headers = {
          "Content-Type": "application/x-www-form-urlencoded"
        };
        Object.assign(headers, additionalHeaders || {});
        const opts = {
          ..._StsCredentials.RETRY_CONFIG,
          url: this.tokenExchangeEndpoint.toString(),
          method: "POST",
          headers,
          data: querystring.stringify(values),
          responseType: "json"
        };
        this.applyClientAuthenticationOptions(opts);
        try {
          const response = await this.transporter.request(opts);
          const stsSuccessfulResponse = response.data;
          stsSuccessfulResponse.res = response;
          return stsSuccessfulResponse;
        } catch (error) {
          if (error instanceof gaxios_1.GaxiosError && error.response) {
            throw (0, oauth2common_1.getErrorFromOAuthErrorResponse)(
              error.response.data,
              // Preserve other fields from the original error.
              error
            );
          }
          throw error;
        }
      }
    };
    exports.StsCredentials = StsCredentials;
  }
});

// ../node_modules/google-auth-library/build/src/auth/baseexternalclient.js
var require_baseexternalclient = __commonJS({
  "../node_modules/google-auth-library/build/src/auth/baseexternalclient.js"(exports) {
    "use strict";
    var __classPrivateFieldGet11 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind3, f2) {
      if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind3 === "m" ? f2 : kind3 === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
    };
    var __classPrivateFieldSet10 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind3, f2) {
      if (kind3 === "m") throw new TypeError("Private method is not writable");
      if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind3 === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
    };
    var _BaseExternalAccountClient_instances;
    var _BaseExternalAccountClient_pendingAccessToken;
    var _BaseExternalAccountClient_internalRefreshAccessTokenAsync;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseExternalAccountClient = exports.DEFAULT_UNIVERSE = exports.CLOUD_RESOURCE_MANAGER = exports.EXTERNAL_ACCOUNT_TYPE = exports.EXPIRATION_TIME_OFFSET = void 0;
    var stream = __require("stream");
    var authclient_1 = require_authclient();
    var sts = require_stscredentials();
    var util_1 = require_util2();
    var STS_GRANT_TYPE = "urn:ietf:params:oauth:grant-type:token-exchange";
    var STS_REQUEST_TOKEN_TYPE = "urn:ietf:params:oauth:token-type:access_token";
    var DEFAULT_OAUTH_SCOPE = "https://www.googleapis.com/auth/cloud-platform";
    var DEFAULT_TOKEN_LIFESPAN = 3600;
    exports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1e3;
    exports.EXTERNAL_ACCOUNT_TYPE = "external_account";
    exports.CLOUD_RESOURCE_MANAGER = "https://cloudresourcemanager.googleapis.com/v1/projects/";
    var WORKFORCE_AUDIENCE_PATTERN = "//iam\\.googleapis\\.com/locations/[^/]+/workforcePools/[^/]+/providers/.+";
    var DEFAULT_TOKEN_URL = "https://sts.{universeDomain}/v1/token";
    var pkg = require_package2();
    var authclient_2 = require_authclient();
    Object.defineProperty(exports, "DEFAULT_UNIVERSE", { enumerable: true, get: function() {
      return authclient_2.DEFAULT_UNIVERSE;
    } });
    var BaseExternalAccountClient = class _BaseExternalAccountClient extends authclient_1.AuthClient {
      /**
       * Instantiate a BaseExternalAccountClient instance using the provided JSON
       * object loaded from an external account credentials file.
       * @param options The external account options object typically loaded
       *   from the external account JSON credential file. The camelCased options
       *   are aliases for the snake_cased options.
       * @param additionalOptions **DEPRECATED, all options are available in the
       *   `options` parameter.** Optional additional behavior customization options.
       *   These currently customize expiration threshold time and whether to retry
       *   on 401/403 API request errors.
       */
      constructor(options, additionalOptions) {
        var _a3;
        super({ ...options, ...additionalOptions });
        _BaseExternalAccountClient_instances.add(this);
        _BaseExternalAccountClient_pendingAccessToken.set(this, null);
        const opts = (0, util_1.originalOrCamelOptions)(options);
        const type = opts.get("type");
        if (type && type !== exports.EXTERNAL_ACCOUNT_TYPE) {
          throw new Error(`Expected "${exports.EXTERNAL_ACCOUNT_TYPE}" type but received "${options.type}"`);
        }
        const clientId = opts.get("client_id");
        const clientSecret = opts.get("client_secret");
        const tokenUrl = (_a3 = opts.get("token_url")) !== null && _a3 !== void 0 ? _a3 : DEFAULT_TOKEN_URL.replace("{universeDomain}", this.universeDomain);
        const subjectTokenType = opts.get("subject_token_type");
        const workforcePoolUserProject = opts.get("workforce_pool_user_project");
        const serviceAccountImpersonationUrl = opts.get("service_account_impersonation_url");
        const serviceAccountImpersonation = opts.get("service_account_impersonation");
        const serviceAccountImpersonationLifetime = (0, util_1.originalOrCamelOptions)(serviceAccountImpersonation).get("token_lifetime_seconds");
        this.cloudResourceManagerURL = new URL(opts.get("cloud_resource_manager_url") || `https://cloudresourcemanager.${this.universeDomain}/v1/projects/`);
        if (clientId) {
          this.clientAuth = {
            confidentialClientType: "basic",
            clientId,
            clientSecret
          };
        }
        this.stsCredential = new sts.StsCredentials(tokenUrl, this.clientAuth);
        this.scopes = opts.get("scopes") || [DEFAULT_OAUTH_SCOPE];
        this.cachedAccessToken = null;
        this.audience = opts.get("audience");
        this.subjectTokenType = subjectTokenType;
        this.workforcePoolUserProject = workforcePoolUserProject;
        const workforceAudiencePattern = new RegExp(WORKFORCE_AUDIENCE_PATTERN);
        if (this.workforcePoolUserProject && !this.audience.match(workforceAudiencePattern)) {
          throw new Error("workforcePoolUserProject should not be set for non-workforce pool credentials.");
        }
        this.serviceAccountImpersonationUrl = serviceAccountImpersonationUrl;
        this.serviceAccountImpersonationLifetime = serviceAccountImpersonationLifetime;
        if (this.serviceAccountImpersonationLifetime) {
          this.configLifetimeRequested = true;
        } else {
          this.configLifetimeRequested = false;
          this.serviceAccountImpersonationLifetime = DEFAULT_TOKEN_LIFESPAN;
        }
        this.projectNumber = this.getProjectNumber(this.audience);
        this.supplierContext = {
          audience: this.audience,
          subjectTokenType: this.subjectTokenType,
          transporter: this.transporter
        };
      }
      /** The service account email to be impersonated, if available. */
      getServiceAccountEmail() {
        var _a3;
        if (this.serviceAccountImpersonationUrl) {
          if (this.serviceAccountImpersonationUrl.length > 256) {
            throw new RangeError(`URL is too long: ${this.serviceAccountImpersonationUrl}`);
          }
          const re2 = /serviceAccounts\/(?<email>[^:]+):generateAccessToken$/;
          const result = re2.exec(this.serviceAccountImpersonationUrl);
          return ((_a3 = result === null || result === void 0 ? void 0 : result.groups) === null || _a3 === void 0 ? void 0 : _a3.email) || null;
        }
        return null;
      }
      /**
       * Provides a mechanism to inject GCP access tokens directly.
       * When the provided credential expires, a new credential, using the
       * external account options, is retrieved.
       * @param credentials The Credentials object to set on the current client.
       */
      setCredentials(credentials) {
        super.setCredentials(credentials);
        this.cachedAccessToken = credentials;
      }
      /**
       * @return A promise that resolves with the current GCP access token
       *   response. If the current credential is expired, a new one is retrieved.
       */
      async getAccessToken() {
        if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) {
          await this.refreshAccessTokenAsync();
        }
        return {
          token: this.cachedAccessToken.access_token,
          res: this.cachedAccessToken.res
        };
      }
      /**
       * The main authentication interface. It takes an optional url which when
       * present is the endpoint being accessed, and returns a Promise which
       * resolves with authorization header fields.
       *
       * The result has the form:
       * { Authorization: 'Bearer <access_token_value>' }
       */
      async getRequestHeaders() {
        const accessTokenResponse = await this.getAccessToken();
        const headers = {
          Authorization: `Bearer ${accessTokenResponse.token}`
        };
        return this.addSharedMetadataHeaders(headers);
      }
      request(opts, callback) {
        if (callback) {
          this.requestAsync(opts).then((r2) => callback(null, r2), (e2) => {
            return callback(e2, e2.response);
          });
        } else {
          return this.requestAsync(opts);
        }
      }
      /**
       * @return A promise that resolves with the project ID corresponding to the
       *   current workload identity pool or current workforce pool if
       *   determinable. For workforce pool credential, it returns the project ID
       *   corresponding to the workforcePoolUserProject.
       *   This is introduced to match the current pattern of using the Auth
       *   library:
       *   const projectId = await auth.getProjectId();
       *   const url = `https://dns.googleapis.com/dns/v1/projects/${projectId}`;
       *   const res = await client.request({ url });
       *   The resource may not have permission
       *   (resourcemanager.projects.get) to call this API or the required
       *   scopes may not be selected:
       *   https://cloud.google.com/resource-manager/reference/rest/v1/projects/get#authorization-scopes
       */
      async getProjectId() {
        const projectNumber = this.projectNumber || this.workforcePoolUserProject;
        if (this.projectId) {
          return this.projectId;
        } else if (projectNumber) {
          const headers = await this.getRequestHeaders();
          const response = await this.transporter.request({
            ..._BaseExternalAccountClient.RETRY_CONFIG,
            headers,
            url: `${this.cloudResourceManagerURL.toString()}${projectNumber}`,
            responseType: "json"
          });
          this.projectId = response.data.projectId;
          return this.projectId;
        }
        return null;
      }
      /**
       * Authenticates the provided HTTP request, processes it and resolves with the
       * returned response.
       * @param opts The HTTP request options.
       * @param reAuthRetried Whether the current attempt is a retry after a failed attempt due to an auth failure.
       * @return A promise that resolves with the successful response.
       */
      async requestAsync(opts, reAuthRetried = false) {
        let response;
        try {
          const requestHeaders = await this.getRequestHeaders();
          opts.headers = opts.headers || {};
          if (requestHeaders && requestHeaders["x-goog-user-project"]) {
            opts.headers["x-goog-user-project"] = requestHeaders["x-goog-user-project"];
          }
          if (requestHeaders && requestHeaders.Authorization) {
            opts.headers.Authorization = requestHeaders.Authorization;
          }
          response = await this.transporter.request(opts);
        } catch (e2) {
          const res = e2.response;
          if (res) {
            const statusCode = res.status;
            const isReadableStream = res.config.data instanceof stream.Readable;
            const isAuthErr = statusCode === 401 || statusCode === 403;
            if (!reAuthRetried && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {
              await this.refreshAccessTokenAsync();
              return await this.requestAsync(opts, true);
            }
          }
          throw e2;
        }
        return response;
      }
      /**
       * Forces token refresh, even if unexpired tokens are currently cached.
       * External credentials are exchanged for GCP access tokens via the token
       * exchange endpoint and other settings provided in the client options
       * object.
       * If the service_account_impersonation_url is provided, an additional
       * step to exchange the external account GCP access token for a service
       * account impersonated token is performed.
       * @return A promise that resolves with the fresh GCP access tokens.
       */
      async refreshAccessTokenAsync() {
        __classPrivateFieldSet10(this, _BaseExternalAccountClient_pendingAccessToken, __classPrivateFieldGet11(this, _BaseExternalAccountClient_pendingAccessToken, "f") || __classPrivateFieldGet11(this, _BaseExternalAccountClient_instances, "m", _BaseExternalAccountClient_internalRefreshAccessTokenAsync).call(this), "f");
        try {
          return await __classPrivateFieldGet11(this, _BaseExternalAccountClient_pendingAccessToken, "f");
        } finally {
          __classPrivateFieldSet10(this, _BaseExternalAccountClient_pendingAccessToken, null, "f");
        }
      }
      /**
       * Returns the workload identity pool project number if it is determinable
       * from the audience resource name.
       * @param audience The STS audience used to determine the project number.
       * @return The project number associated with the workload identity pool, if
       *   this can be determined from the STS audience field. Otherwise, null is
       *   returned.
       */
      getProjectNumber(audience) {
        const match7 = audience.match(/\/projects\/([^/]+)/);
        if (!match7) {
          return null;
        }
        return match7[1];
      }
      /**
       * Exchanges an external account GCP access token for a service
       * account impersonated access token using iamcredentials
       * GenerateAccessToken API.
       * @param token The access token to exchange for a service account access
       *   token.
       * @return A promise that resolves with the service account impersonated
       *   credentials response.
       */
      async getImpersonatedAccessToken(token) {
        const opts = {
          ..._BaseExternalAccountClient.RETRY_CONFIG,
          url: this.serviceAccountImpersonationUrl,
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`
          },
          data: {
            scope: this.getScopesArray(),
            lifetime: this.serviceAccountImpersonationLifetime + "s"
          },
          responseType: "json"
        };
        const response = await this.transporter.request(opts);
        const successResponse = response.data;
        return {
          access_token: successResponse.accessToken,
          // Convert from ISO format to timestamp.
          expiry_date: new Date(successResponse.expireTime).getTime(),
          res: response
        };
      }
      /**
       * Returns whether the provided credentials are expired or not.
       * If there is no expiry time, assumes the token is not expired or expiring.
       * @param accessToken The credentials to check for expiration.
       * @return Whether the credentials are expired or not.
       */
      isExpired(accessToken) {
        const now = (/* @__PURE__ */ new Date()).getTime();
        return accessToken.expiry_date ? now >= accessToken.expiry_date - this.eagerRefreshThresholdMillis : false;
      }
      /**
       * @return The list of scopes for the requested GCP access token.
       */
      getScopesArray() {
        if (typeof this.scopes === "string") {
          return [this.scopes];
        }
        return this.scopes || [DEFAULT_OAUTH_SCOPE];
      }
      getMetricsHeaderValue() {
        const nodeVersion = process.version.replace(/^v/, "");
        const saImpersonation = this.serviceAccountImpersonationUrl !== void 0;
        const credentialSourceType = this.credentialSourceType ? this.credentialSourceType : "unknown";
        return `gl-node/${nodeVersion} auth/${pkg.version} google-byoid-sdk source/${credentialSourceType} sa-impersonation/${saImpersonation} config-lifetime/${this.configLifetimeRequested}`;
      }
    };
    exports.BaseExternalAccountClient = BaseExternalAccountClient;
    _BaseExternalAccountClient_pendingAccessToken = /* @__PURE__ */ new WeakMap(), _BaseExternalAccountClient_instances = /* @__PURE__ */ new WeakSet(), _BaseExternalAccountClient_internalRefreshAccessTokenAsync = async function _BaseExternalAccountClient_internalRefreshAccessTokenAsync2() {
      const subjectToken = await this.retrieveSubjectToken();
      const stsCredentialsOptions = {
        grantType: STS_GRANT_TYPE,
        audience: this.audience,
        requestedTokenType: STS_REQUEST_TOKEN_TYPE,
        subjectToken,
        subjectTokenType: this.subjectTokenType,
        // generateAccessToken requires the provided access token to have
        // scopes:
        // https://www.googleapis.com/auth/iam or
        // https://www.googleapis.com/auth/cloud-platform
        // The new service account access token scopes will match the user
        // provided ones.
        scope: this.serviceAccountImpersonationUrl ? [DEFAULT_OAUTH_SCOPE] : this.getScopesArray()
      };
      const additionalOptions = !this.clientAuth && this.workforcePoolUserProject ? { userProject: this.workforcePoolUserProject } : void 0;
      const additionalHeaders = {
        "x-goog-api-client": this.getMetricsHeaderValue()
      };
      const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, additionalHeaders, additionalOptions);
      if (this.serviceAccountImpersonationUrl) {
        this.cachedAccessToken = await this.getImpersonatedAccessToken(stsResponse.access_token);
      } else if (stsResponse.expires_in) {
        this.cachedAccessToken = {
          access_token: stsResponse.access_token,
          expiry_date: (/* @__PURE__ */ new Date()).getTime() + stsResponse.expires_in * 1e3,
          res: stsResponse.res
        };
      } else {
        this.cachedAccessToken = {
          access_token: stsResponse.access_token,
          res: stsResponse.res
        };
      }
      this.credentials = {};
      Object.assign(this.credentials, this.cachedAccessToken);
      delete this.credentials.res;
      this.emit("tokens", {
        refresh_token: null,
        expiry_date: this.cachedAccessToken.expiry_date,
        access_token: this.cachedAccessToken.access_token,
        token_type: "Bearer",
        id_token: null
      });
      return this.cachedAccessToken;
    };
  }
});

// ../node_modules/google-auth-library/build/src/auth/filesubjecttokensupplier.js
var require_filesubjecttokensupplier = __commonJS({
  "../node_modules/google-auth-library/build/src/auth/filesubjecttokensupplier.js"(exports) {
    "use strict";
    var _a3;
    var _b;
    var _c;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FileSubjectTokenSupplier = void 0;
    var util_1 = __require("util");
    var fs3 = __require("fs");
    var readFile = (0, util_1.promisify)((_a3 = fs3.readFile) !== null && _a3 !== void 0 ? _a3 : () => {
    });
    var realpath = (0, util_1.promisify)((_b = fs3.realpath) !== null && _b !== void 0 ? _b : () => {
    });
    var lstat = (0, util_1.promisify)((_c = fs3.lstat) !== null && _c !== void 0 ? _c : () => {
    });
    var FileSubjectTokenSupplier = class {
      /**
       * Instantiates a new file based subject token supplier.
       * @param opts The file subject token supplier options to build the supplier
       *   with.
       */
      constructor(opts) {
        this.filePath = opts.filePath;
        this.formatType = opts.formatType;
        this.subjectTokenFieldName = opts.subjectTokenFieldName;
      }
      /**
       * Returns the subject token stored at the file specified in the constructor.
       * @param context {@link ExternalAccountSupplierContext} from the calling
       *   {@link IdentityPoolClient}, contains the requested audience and subject
       *   token type for the external account identity. Not used.
       */
      async getSubjectToken(context) {
        let parsedFilePath = this.filePath;
        try {
          parsedFilePath = await realpath(parsedFilePath);
          if (!(await lstat(parsedFilePath)).isFile()) {
            throw new Error();
          }
        } catch (err) {
          if (err instanceof Error) {
            err.message = `The file at ${parsedFilePath} does not exist, or it is not a file. ${err.message}`;
          }
          throw err;
        }
        let subjectToken;
        const rawText = await readFile(parsedFilePath, { encoding: "utf8" });
        if (this.formatType === "text") {
          subjectToken = rawText;
        } else if (this.formatType === "json" && this.subjectTokenFieldName) {
          const json = JSON.parse(rawText);
          subjectToken = json[this.subjectTokenFieldName];
        }
        if (!subjectToken) {
          throw new Error("Unable to parse the subject_token from the credential_source file");
        }
        return subjectToken;
      }
    };
    exports.FileSubjectTokenSupplier = FileSubjectTokenSupplier;
  }
});

// ../node_modules/google-auth-library/build/src/auth/urlsubjecttokensupplier.js
var require_urlsubjecttokensupplier = __commonJS({
  "../node_modules/google-auth-library/build/src/auth/urlsubjecttokensupplier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UrlSubjectTokenSupplier = void 0;
    var UrlSubjectTokenSupplier = class {
      /**
       * Instantiates a URL subject token supplier.
       * @param opts The URL subject token supplier options to build the supplier with.
       */
      constructor(opts) {
        this.url = opts.url;
        this.formatType = opts.formatType;
        this.subjectTokenFieldName = opts.subjectTokenFieldName;
        this.headers = opts.headers;
        this.additionalGaxiosOptions = opts.additionalGaxiosOptions;
      }
      /**
       * Sends a GET request to the URL provided in the constructor and resolves
       * with the returned external subject token.
       * @param context {@link ExternalAccountSupplierContext} from the calling
       *   {@link IdentityPoolClient}, contains the requested audience and subject
       *   token type for the external account identity. Not used.
       */
      async getSubjectToken(context) {
        const opts = {
          ...this.additionalGaxiosOptions,
          url: this.url,
          method: "GET",
          headers: this.headers,
          responseType: this.formatType
        };
        let subjectToken;
        if (this.formatType === "text") {
          const response = await context.transporter.request(opts);
          subjectToken = response.data;
        } else if (this.formatType === "json" && this.subjectTokenFieldName) {
          const response = await context.transporter.request(opts);
          subjectToken = response.data[this.subjectTokenFieldName];
        }
        if (!subjectToken) {
          throw new Error("Unable to parse the subject_token from the credential_source URL");
        }
        return subjectToken;
      }
    };
    exports.UrlSubjectTokenSupplier = UrlSubjectTokenSupplier;
  }
});

// ../node_modules/google-auth-library/build/src/auth/identitypoolclient.js
var require_identitypoolclient = __commonJS({
  "../node_modules/google-auth-library/build/src/auth/identitypoolclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IdentityPoolClient = void 0;
    var baseexternalclient_1 = require_baseexternalclient();
    var util_1 = require_util2();
    var filesubjecttokensupplier_1 = require_filesubjecttokensupplier();
    var urlsubjecttokensupplier_1 = require_urlsubjecttokensupplier();
    var IdentityPoolClient = class _IdentityPoolClient extends baseexternalclient_1.BaseExternalAccountClient {
      /**
       * Instantiate an IdentityPoolClient instance using the provided JSON
       * object loaded from an external account credentials file.
       * An error is thrown if the credential is not a valid file-sourced or
       * url-sourced credential or a workforce pool user project is provided
       * with a non workforce audience.
       * @param options The external account options object typically loaded
       *   from the external account JSON credential file. The camelCased options
       *   are aliases for the snake_cased options.
       * @param additionalOptions **DEPRECATED, all options are available in the
       *   `options` parameter.** Optional additional behavior customization options.
       *   These currently customize expiration threshold time and whether to retry
       *   on 401/403 API request errors.
       */
      constructor(options, additionalOptions) {
        super(options, additionalOptions);
        const opts = (0, util_1.originalOrCamelOptions)(options);
        const credentialSource = opts.get("credential_source");
        const subjectTokenSupplier = opts.get("subject_token_supplier");
        if (!credentialSource && !subjectTokenSupplier) {
          throw new Error("A credential source or subject token supplier must be specified.");
        }
        if (credentialSource && subjectTokenSupplier) {
          throw new Error("Only one of credential source or subject token supplier can be specified.");
        }
        if (subjectTokenSupplier) {
          this.subjectTokenSupplier = subjectTokenSupplier;
          this.credentialSourceType = "programmatic";
        } else {
          const credentialSourceOpts = (0, util_1.originalOrCamelOptions)(credentialSource);
          const formatOpts = (0, util_1.originalOrCamelOptions)(credentialSourceOpts.get("format"));
          const formatType = formatOpts.get("type") || "text";
          const formatSubjectTokenFieldName = formatOpts.get("subject_token_field_name");
          if (formatType !== "json" && formatType !== "text") {
            throw new Error(`Invalid credential_source format "${formatType}"`);
          }
          if (formatType === "json" && !formatSubjectTokenFieldName) {
            throw new Error("Missing subject_token_field_name for JSON credential_source format");
          }
          const file = credentialSourceOpts.get("file");
          const url = credentialSourceOpts.get("url");
          const headers = credentialSourceOpts.get("headers");
          if (file && url) {
            throw new Error('No valid Identity Pool "credential_source" provided, must be either file or url.');
          } else if (file && !url) {
            this.credentialSourceType = "file";
            this.subjectTokenSupplier = new filesubjecttokensupplier_1.FileSubjectTokenSupplier({
              filePath: file,
              formatType,
              subjectTokenFieldName: formatSubjectTokenFieldName
            });
          } else if (!file && url) {
            this.credentialSourceType = "url";
            this.subjectTokenSupplier = new urlsubjecttokensupplier_1.UrlSubjectTokenSupplier({
              url,
              formatType,
              subjectTokenFieldName: formatSubjectTokenFieldName,
              headers,
              additionalGaxiosOptions: _IdentityPoolClient.RETRY_CONFIG
            });
          } else {
            throw new Error('No valid Identity Pool "credential_source" provided, must be either file or url.');
          }
        }
      }
      /**
       * Triggered when a external subject token is needed to be exchanged for a GCP
       * access token via GCP STS endpoint. Gets a subject token by calling
       * the configured {@link SubjectTokenSupplier}
       * @return A promise that resolves with the external subject token.
       */
      async retrieveSubjectToken() {
        return this.subjectTokenSupplier.getSubjectToken(this.supplierContext);
      }
    };
    exports.IdentityPoolClient = IdentityPoolClient;
  }
});

// ../node_modules/google-auth-library/build/src/auth/awsrequestsigner.js
var require_awsrequestsigner = __commonJS({
  "../node_modules/google-auth-library/build/src/auth/awsrequestsigner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwsRequestSigner = void 0;
    var crypto_1 = require_crypto3();
    var AWS_ALGORITHM = "AWS4-HMAC-SHA256";
    var AWS_REQUEST_TYPE = "aws4_request";
    var AwsRequestSigner = class {
      /**
       * Instantiates an AWS API request signer used to send authenticated signed
       * requests to AWS APIs based on the AWS Signature Version 4 signing process.
       * This also provides a mechanism to generate the signed request without
       * sending it.
       * @param getCredentials A mechanism to retrieve AWS security credentials
       *   when needed.
       * @param region The AWS region to use.
       */
      constructor(getCredentials, region) {
        this.getCredentials = getCredentials;
        this.region = region;
        this.crypto = (0, crypto_1.createCrypto)();
      }
      /**
       * Generates the signed request for the provided HTTP request for calling
       * an AWS API. This follows the steps described at:
       * https://docs.aws.amazon.com/general/latest/gr/sigv4_signing.html
       * @param amzOptions The AWS request options that need to be signed.
       * @return A promise that resolves with the GaxiosOptions containing the
       *   signed HTTP request parameters.
       */
      async getRequestOptions(amzOptions) {
        if (!amzOptions.url) {
          throw new Error('"url" is required in "amzOptions"');
        }
        const requestPayloadData = typeof amzOptions.data === "object" ? JSON.stringify(amzOptions.data) : amzOptions.data;
        const url = amzOptions.url;
        const method = amzOptions.method || "GET";
        const requestPayload = amzOptions.body || requestPayloadData;
        const additionalAmzHeaders = amzOptions.headers;
        const awsSecurityCredentials = await this.getCredentials();
        const uri = new URL(url);
        const headerMap = await generateAuthenticationHeaderMap({
          crypto: this.crypto,
          host: uri.host,
          canonicalUri: uri.pathname,
          canonicalQuerystring: uri.search.substr(1),
          method,
          region: this.region,
          securityCredentials: awsSecurityCredentials,
          requestPayload,
          additionalAmzHeaders
        });
        const headers = Object.assign(
          // Add x-amz-date if available.
          headerMap.amzDate ? { "x-amz-date": headerMap.amzDate } : {},
          {
            Authorization: headerMap.authorizationHeader,
            host: uri.host
          },
          additionalAmzHeaders || {}
        );
        if (awsSecurityCredentials.token) {
          Object.assign(headers, {
            "x-amz-security-token": awsSecurityCredentials.token
          });
        }
        const awsSignedReq = {
          url,
          method,
          headers
        };
        if (typeof requestPayload !== "undefined") {
          awsSignedReq.body = requestPayload;
        }
        return awsSignedReq;
      }
    };
    exports.AwsRequestSigner = AwsRequestSigner;
    async function sign(crypto6, key, msg) {
      return await crypto6.signWithHmacSha256(key, msg);
    }
    async function getSigningKey(crypto6, key, dateStamp, region, serviceName) {
      const kDate = await sign(crypto6, `AWS4${key}`, dateStamp);
      const kRegion = await sign(crypto6, kDate, region);
      const kService = await sign(crypto6, kRegion, serviceName);
      const kSigning = await sign(crypto6, kService, "aws4_request");
      return kSigning;
    }
    async function generateAuthenticationHeaderMap(options) {
      const additionalAmzHeaders = options.additionalAmzHeaders || {};
      const requestPayload = options.requestPayload || "";
      const serviceName = options.host.split(".")[0];
      const now = /* @__PURE__ */ new Date();
      const amzDate = now.toISOString().replace(/[-:]/g, "").replace(/\.[0-9]+/, "");
      const dateStamp = now.toISOString().replace(/[-]/g, "").replace(/T.*/, "");
      const reformattedAdditionalAmzHeaders = {};
      Object.keys(additionalAmzHeaders).forEach((key) => {
        reformattedAdditionalAmzHeaders[key.toLowerCase()] = additionalAmzHeaders[key];
      });
      if (options.securityCredentials.token) {
        reformattedAdditionalAmzHeaders["x-amz-security-token"] = options.securityCredentials.token;
      }
      const amzHeaders = Object.assign(
        {
          host: options.host
        },
        // Previously the date was not fixed with x-amz- and could be provided manually.
        // https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-header-value-trim.req
        reformattedAdditionalAmzHeaders.date ? {} : { "x-amz-date": amzDate },
        reformattedAdditionalAmzHeaders
      );
      let canonicalHeaders = "";
      const signedHeadersList = Object.keys(amzHeaders).sort();
      signedHeadersList.forEach((key) => {
        canonicalHeaders += `${key}:${amzHeaders[key]}
`;
      });
      const signedHeaders = signedHeadersList.join(";");
      const payloadHash = await options.crypto.sha256DigestHex(requestPayload);
      const canonicalRequest = `${options.method}
${options.canonicalUri}
${options.canonicalQuerystring}
${canonicalHeaders}
${signedHeaders}
${payloadHash}`;
      const credentialScope = `${dateStamp}/${options.region}/${serviceName}/${AWS_REQUEST_TYPE}`;
      const stringToSign = `${AWS_ALGORITHM}
${amzDate}
${credentialScope}
` + await options.crypto.sha256DigestHex(canonicalRequest);
      const signingKey = await getSigningKey(options.crypto, options.securityCredentials.secretAccessKey, dateStamp, options.region, serviceName);
      const signature = await sign(options.crypto, signingKey, stringToSign);
      const authorizationHeader = `${AWS_ALGORITHM} Credential=${options.securityCredentials.accessKeyId}/${credentialScope}, SignedHeaders=${signedHeaders}, Signature=${(0, crypto_1.fromArrayBufferToHex)(signature)}`;
      return {
        // Do not return x-amz-date if date is available.
        amzDate: reformattedAdditionalAmzHeaders.date ? void 0 : amzDate,
        authorizationHeader,
        canonicalQuerystring: options.canonicalQuerystring
      };
    }
  }
});

// ../node_modules/google-auth-library/build/src/auth/defaultawssecuritycredentialssupplier.js
var require_defaultawssecuritycredentialssupplier = __commonJS({
  "../node_modules/google-auth-library/build/src/auth/defaultawssecuritycredentialssupplier.js"(exports) {
    "use strict";
    var __classPrivateFieldGet11 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind3, f2) {
      if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind3 === "m" ? f2 : kind3 === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
    };
    var _DefaultAwsSecurityCredentialsSupplier_instances;
    var _DefaultAwsSecurityCredentialsSupplier_getImdsV2SessionToken;
    var _DefaultAwsSecurityCredentialsSupplier_getAwsRoleName;
    var _DefaultAwsSecurityCredentialsSupplier_retrieveAwsSecurityCredentials;
    var _DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get;
    var _DefaultAwsSecurityCredentialsSupplier_securityCredentialsFromEnv_get;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultAwsSecurityCredentialsSupplier = void 0;
    var DefaultAwsSecurityCredentialsSupplier = class {
      /**
       * Instantiates a new DefaultAwsSecurityCredentialsSupplier using information
       * from the credential_source stored in the ADC file.
       * @param opts The default aws security credentials supplier options object to
       *   build the supplier with.
       */
      constructor(opts) {
        _DefaultAwsSecurityCredentialsSupplier_instances.add(this);
        this.regionUrl = opts.regionUrl;
        this.securityCredentialsUrl = opts.securityCredentialsUrl;
        this.imdsV2SessionTokenUrl = opts.imdsV2SessionTokenUrl;
        this.additionalGaxiosOptions = opts.additionalGaxiosOptions;
      }
      /**
       * Returns the active AWS region. This first checks to see if the region
       * is available as an environment variable. If it is not, then the supplier
       * will call the region URL.
       * @param context {@link ExternalAccountSupplierContext} from the calling
       *   {@link AwsClient}, contains the requested audience and subject token type
       *   for the external account identity.
       * @return A promise that resolves with the AWS region string.
       */
      async getAwsRegion(context) {
        if (__classPrivateFieldGet11(this, _DefaultAwsSecurityCredentialsSupplier_instances, "a", _DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get)) {
          return __classPrivateFieldGet11(this, _DefaultAwsSecurityCredentialsSupplier_instances, "a", _DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get);
        }
        const metadataHeaders = {};
        if (!__classPrivateFieldGet11(this, _DefaultAwsSecurityCredentialsSupplier_instances, "a", _DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get) && this.imdsV2SessionTokenUrl) {
          metadataHeaders["x-aws-ec2-metadata-token"] = await __classPrivateFieldGet11(this, _DefaultAwsSecurityCredentialsSupplier_instances, "m", _DefaultAwsSecurityCredentialsSupplier_getImdsV2SessionToken).call(this, context.transporter);
        }
        if (!this.regionUrl) {
          throw new Error('Unable to determine AWS region due to missing "options.credential_source.region_url"');
        }
        const opts = {
          ...this.additionalGaxiosOptions,
          url: this.regionUrl,
          method: "GET",
          responseType: "text",
          headers: metadataHeaders
        };
        const response = await context.transporter.request(opts);
        return response.data.substr(0, response.data.length - 1);
      }
      /**
       * Returns AWS security credentials. This first checks to see if the credentials
       * is available as environment variables. If it is not, then the supplier
       * will call the security credentials URL.
       * @param context {@link ExternalAccountSupplierContext} from the calling
       *   {@link AwsClient}, contains the requested audience and subject token type
       *   for the external account identity.
       * @return A promise that resolves with the AWS security credentials.
       */
      async getAwsSecurityCredentials(context) {
        if (__classPrivateFieldGet11(this, _DefaultAwsSecurityCredentialsSupplier_instances, "a", _DefaultAwsSecurityCredentialsSupplier_securityCredentialsFromEnv_get)) {
          return __classPrivateFieldGet11(this, _DefaultAwsSecurityCredentialsSupplier_instances, "a", _DefaultAwsSecurityCredentialsSupplier_securityCredentialsFromEnv_get);
        }
        const metadataHeaders = {};
        if (this.imdsV2SessionTokenUrl) {
          metadataHeaders["x-aws-ec2-metadata-token"] = await __classPrivateFieldGet11(this, _DefaultAwsSecurityCredentialsSupplier_instances, "m", _DefaultAwsSecurityCredentialsSupplier_getImdsV2SessionToken).call(this, context.transporter);
        }
        const roleName = await __classPrivateFieldGet11(this, _DefaultAwsSecurityCredentialsSupplier_instances, "m", _DefaultAwsSecurityCredentialsSupplier_getAwsRoleName).call(this, metadataHeaders, context.transporter);
        const awsCreds = await __classPrivateFieldGet11(this, _DefaultAwsSecurityCredentialsSupplier_instances, "m", _DefaultAwsSecurityCredentialsSupplier_retrieveAwsSecurityCredentials).call(this, roleName, metadataHeaders, context.transporter);
        return {
          accessKeyId: awsCreds.AccessKeyId,
          secretAccessKey: awsCreds.SecretAccessKey,
          token: awsCreds.Token
        };
      }
    };
    exports.DefaultAwsSecurityCredentialsSupplier = DefaultAwsSecurityCredentialsSupplier;
    _DefaultAwsSecurityCredentialsSupplier_instances = /* @__PURE__ */ new WeakSet(), _DefaultAwsSecurityCredentialsSupplier_getImdsV2SessionToken = /**
     * @param transporter The transporter to use for requests.
     * @return A promise that resolves with the IMDSv2 Session Token.
     */
    async function _DefaultAwsSecurityCredentialsSupplier_getImdsV2SessionToken2(transporter) {
      const opts = {
        ...this.additionalGaxiosOptions,
        url: this.imdsV2SessionTokenUrl,
        method: "PUT",
        responseType: "text",
        headers: { "x-aws-ec2-metadata-token-ttl-seconds": "300" }
      };
      const response = await transporter.request(opts);
      return response.data;
    }, _DefaultAwsSecurityCredentialsSupplier_getAwsRoleName = /**
     * @param headers The headers to be used in the metadata request.
     * @param transporter The transporter to use for requests.
     * @return A promise that resolves with the assigned role to the current
     *   AWS VM. This is needed for calling the security-credentials endpoint.
     */
    async function _DefaultAwsSecurityCredentialsSupplier_getAwsRoleName2(headers, transporter) {
      if (!this.securityCredentialsUrl) {
        throw new Error('Unable to determine AWS role name due to missing "options.credential_source.url"');
      }
      const opts = {
        ...this.additionalGaxiosOptions,
        url: this.securityCredentialsUrl,
        method: "GET",
        responseType: "text",
        headers
      };
      const response = await transporter.request(opts);
      return response.data;
    }, _DefaultAwsSecurityCredentialsSupplier_retrieveAwsSecurityCredentials = /**
     * Retrieves the temporary AWS credentials by calling the security-credentials
     * endpoint as specified in the `credential_source` object.
     * @param roleName The role attached to the current VM.
     * @param headers The headers to be used in the metadata request.
     * @param transporter The transporter to use for requests.
     * @return A promise that resolves with the temporary AWS credentials
     *   needed for creating the GetCallerIdentity signed request.
     */
    async function _DefaultAwsSecurityCredentialsSupplier_retrieveAwsSecurityCredentials2(roleName, headers, transporter) {
      const response = await transporter.request({
        ...this.additionalGaxiosOptions,
        url: `${this.securityCredentialsUrl}/${roleName}`,
        responseType: "json",
        headers
      });
      return response.data;
    }, _DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get = function _DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get2() {
      return process.env["AWS_REGION"] || process.env["AWS_DEFAULT_REGION"] || null;
    }, _DefaultAwsSecurityCredentialsSupplier_securityCredentialsFromEnv_get = function _DefaultAwsSecurityCredentialsSupplier_securityCredentialsFromEnv_get2() {
      if (process.env["AWS_ACCESS_KEY_ID"] && process.env["AWS_SECRET_ACCESS_KEY"]) {
        return {
          accessKeyId: process.env["AWS_ACCESS_KEY_ID"],
          secretAccessKey: process.env["AWS_SECRET_ACCESS_KEY"],
          token: process.env["AWS_SESSION_TOKEN"]
        };
      }
      return null;
    };
  }
});

// ../node_modules/google-auth-library/build/src/auth/awsclient.js
var require_awsclient = __commonJS({
  "../node_modules/google-auth-library/build/src/auth/awsclient.js"(exports) {
    "use strict";
    var __classPrivateFieldGet11 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind3, f2) {
      if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind3 === "m" ? f2 : kind3 === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
    };
    var _a3;
    var _AwsClient_DEFAULT_AWS_REGIONAL_CREDENTIAL_VERIFICATION_URL;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwsClient = void 0;
    var awsrequestsigner_1 = require_awsrequestsigner();
    var baseexternalclient_1 = require_baseexternalclient();
    var defaultawssecuritycredentialssupplier_1 = require_defaultawssecuritycredentialssupplier();
    var util_1 = require_util2();
    var AwsClient = class extends baseexternalclient_1.BaseExternalAccountClient {
      /**
       * Instantiates an AwsClient instance using the provided JSON
       * object loaded from an external account credentials file.
       * An error is thrown if the credential is not a valid AWS credential.
       * @param options The external account options object typically loaded
       *   from the external account JSON credential file.
       * @param additionalOptions **DEPRECATED, all options are available in the
       *   `options` parameter.** Optional additional behavior customization options.
       *   These currently customize expiration threshold time and whether to retry
       *   on 401/403 API request errors.
       */
      constructor(options, additionalOptions) {
        super(options, additionalOptions);
        const opts = (0, util_1.originalOrCamelOptions)(options);
        const credentialSource = opts.get("credential_source");
        const awsSecurityCredentialsSupplier = opts.get("aws_security_credentials_supplier");
        if (!credentialSource && !awsSecurityCredentialsSupplier) {
          throw new Error("A credential source or AWS security credentials supplier must be specified.");
        }
        if (credentialSource && awsSecurityCredentialsSupplier) {
          throw new Error("Only one of credential source or AWS security credentials supplier can be specified.");
        }
        if (awsSecurityCredentialsSupplier) {
          this.awsSecurityCredentialsSupplier = awsSecurityCredentialsSupplier;
          this.regionalCredVerificationUrl = __classPrivateFieldGet11(_a3, _a3, "f", _AwsClient_DEFAULT_AWS_REGIONAL_CREDENTIAL_VERIFICATION_URL);
          this.credentialSourceType = "programmatic";
        } else {
          const credentialSourceOpts = (0, util_1.originalOrCamelOptions)(credentialSource);
          this.environmentId = credentialSourceOpts.get("environment_id");
          const regionUrl = credentialSourceOpts.get("region_url");
          const securityCredentialsUrl = credentialSourceOpts.get("url");
          const imdsV2SessionTokenUrl = credentialSourceOpts.get("imdsv2_session_token_url");
          this.awsSecurityCredentialsSupplier = new defaultawssecuritycredentialssupplier_1.DefaultAwsSecurityCredentialsSupplier({
            regionUrl,
            securityCredentialsUrl,
            imdsV2SessionTokenUrl
          });
          this.regionalCredVerificationUrl = credentialSourceOpts.get("regional_cred_verification_url");
          this.credentialSourceType = "aws";
          this.validateEnvironmentId();
        }
        this.awsRequestSigner = null;
        this.region = "";
      }
      validateEnvironmentId() {
        var _b;
        const match7 = (_b = this.environmentId) === null || _b === void 0 ? void 0 : _b.match(/^(aws)(\d+)$/);
        if (!match7 || !this.regionalCredVerificationUrl) {
          throw new Error('No valid AWS "credential_source" provided');
        } else if (parseInt(match7[2], 10) !== 1) {
          throw new Error(`aws version "${match7[2]}" is not supported in the current build.`);
        }
      }
      /**
       * Triggered when an external subject token is needed to be exchanged for a
       * GCP access token via GCP STS endpoint. This will call the
       * {@link AwsSecurityCredentialsSupplier} to retrieve an AWS region and AWS
       * Security Credentials, then use them to create a signed AWS STS request that
       * can be exchanged for a GCP access token.
       * @return A promise that resolves with the external subject token.
       */
      async retrieveSubjectToken() {
        if (!this.awsRequestSigner) {
          this.region = await this.awsSecurityCredentialsSupplier.getAwsRegion(this.supplierContext);
          this.awsRequestSigner = new awsrequestsigner_1.AwsRequestSigner(async () => {
            return this.awsSecurityCredentialsSupplier.getAwsSecurityCredentials(this.supplierContext);
          }, this.region);
        }
        const options = await this.awsRequestSigner.getRequestOptions({
          ..._a3.RETRY_CONFIG,
          url: this.regionalCredVerificationUrl.replace("{region}", this.region),
          method: "POST"
        });
        const reformattedHeader = [];
        const extendedHeaders = Object.assign({
          // The full, canonical resource name of the workload identity pool
          // provider, with or without the HTTPS prefix.
          // Including this header as part of the signature is recommended to
          // ensure data integrity.
          "x-goog-cloud-target-resource": this.audience
        }, options.headers);
        for (const key in extendedHeaders) {
          reformattedHeader.push({
            key,
            value: extendedHeaders[key]
          });
        }
        return encodeURIComponent(JSON.stringify({
          url: options.url,
          method: options.method,
          headers: reformattedHeader
        }));
      }
    };
    exports.AwsClient = AwsClient;
    _a3 = AwsClient;
    _AwsClient_DEFAULT_AWS_REGIONAL_CREDENTIAL_VERIFICATION_URL = { value: "https://sts.{region}.amazonaws.com?Action=GetCallerIdentity&Version=2011-06-15" };
    AwsClient.AWS_EC2_METADATA_IPV4_ADDRESS = "169.254.169.254";
    AwsClient.AWS_EC2_METADATA_IPV6_ADDRESS = "fd00:ec2::254";
  }
});

// ../node_modules/google-auth-library/build/src/auth/executable-response.js
var require_executable_response = __commonJS({
  "../node_modules/google-auth-library/build/src/auth/executable-response.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidSubjectTokenError = exports.InvalidMessageFieldError = exports.InvalidCodeFieldError = exports.InvalidTokenTypeFieldError = exports.InvalidExpirationTimeFieldError = exports.InvalidSuccessFieldError = exports.InvalidVersionFieldError = exports.ExecutableResponseError = exports.ExecutableResponse = void 0;
    var SAML_SUBJECT_TOKEN_TYPE = "urn:ietf:params:oauth:token-type:saml2";
    var OIDC_SUBJECT_TOKEN_TYPE1 = "urn:ietf:params:oauth:token-type:id_token";
    var OIDC_SUBJECT_TOKEN_TYPE2 = "urn:ietf:params:oauth:token-type:jwt";
    var ExecutableResponse = class {
      /**
       * Instantiates an ExecutableResponse instance using the provided JSON object
       * from the output of the executable.
       * @param responseJson Response from a 3rd party executable, loaded from a
       * run of the executable or a cached output file.
       */
      constructor(responseJson) {
        if (!responseJson.version) {
          throw new InvalidVersionFieldError("Executable response must contain a 'version' field.");
        }
        if (responseJson.success === void 0) {
          throw new InvalidSuccessFieldError("Executable response must contain a 'success' field.");
        }
        this.version = responseJson.version;
        this.success = responseJson.success;
        if (this.success) {
          this.expirationTime = responseJson.expiration_time;
          this.tokenType = responseJson.token_type;
          if (this.tokenType !== SAML_SUBJECT_TOKEN_TYPE && this.tokenType !== OIDC_SUBJECT_TOKEN_TYPE1 && this.tokenType !== OIDC_SUBJECT_TOKEN_TYPE2) {
            throw new InvalidTokenTypeFieldError(`Executable response must contain a 'token_type' field when successful and it must be one of ${OIDC_SUBJECT_TOKEN_TYPE1}, ${OIDC_SUBJECT_TOKEN_TYPE2}, or ${SAML_SUBJECT_TOKEN_TYPE}.`);
          }
          if (this.tokenType === SAML_SUBJECT_TOKEN_TYPE) {
            if (!responseJson.saml_response) {
              throw new InvalidSubjectTokenError(`Executable response must contain a 'saml_response' field when token_type=${SAML_SUBJECT_TOKEN_TYPE}.`);
            }
            this.subjectToken = responseJson.saml_response;
          } else {
            if (!responseJson.id_token) {
              throw new InvalidSubjectTokenError(`Executable response must contain a 'id_token' field when token_type=${OIDC_SUBJECT_TOKEN_TYPE1} or ${OIDC_SUBJECT_TOKEN_TYPE2}.`);
            }
            this.subjectToken = responseJson.id_token;
          }
        } else {
          if (!responseJson.code) {
            throw new InvalidCodeFieldError("Executable response must contain a 'code' field when unsuccessful.");
          }
          if (!responseJson.message) {
            throw new InvalidMessageFieldError("Executable response must contain a 'message' field when unsuccessful.");
          }
          this.errorCode = responseJson.code;
          this.errorMessage = responseJson.message;
        }
      }
      /**
       * @return A boolean representing if the response has a valid token. Returns
       * true when the response was successful and the token is not expired.
       */
      isValid() {
        return !this.isExpired() && this.success;
      }
      /**
       * @return A boolean representing if the response is expired. Returns true if the
       * provided timeout has passed.
       */
      isExpired() {
        return this.expirationTime !== void 0 && this.expirationTime < Math.round(Date.now() / 1e3);
      }
    };
    exports.ExecutableResponse = ExecutableResponse;
    var ExecutableResponseError = class extends Error {
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, new.target.prototype);
      }
    };
    exports.ExecutableResponseError = ExecutableResponseError;
    var InvalidVersionFieldError = class extends ExecutableResponseError {
    };
    exports.InvalidVersionFieldError = InvalidVersionFieldError;
    var InvalidSuccessFieldError = class extends ExecutableResponseError {
    };
    exports.InvalidSuccessFieldError = InvalidSuccessFieldError;
    var InvalidExpirationTimeFieldError = class extends ExecutableResponseError {
    };
    exports.InvalidExpirationTimeFieldError = InvalidExpirationTimeFieldError;
    var InvalidTokenTypeFieldError = class extends ExecutableResponseError {
    };
    exports.InvalidTokenTypeFieldError = InvalidTokenTypeFieldError;
    var InvalidCodeFieldError = class extends ExecutableResponseError {
    };
    exports.InvalidCodeFieldError = InvalidCodeFieldError;
    var InvalidMessageFieldError = class extends ExecutableResponseError {
    };
    exports.InvalidMessageFieldError = InvalidMessageFieldError;
    var InvalidSubjectTokenError = class extends ExecutableResponseError {
    };
    exports.InvalidSubjectTokenError = InvalidSubjectTokenError;
  }
});

// ../node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js
var require_pluggable_auth_handler = __commonJS({
  "../node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PluggableAuthHandler = void 0;
    var pluggable_auth_client_1 = require_pluggable_auth_client();
    var executable_response_1 = require_executable_response();
    var childProcess = __require("child_process");
    var fs3 = __require("fs");
    var PluggableAuthHandler = class _PluggableAuthHandler {
      /**
       * Instantiates a PluggableAuthHandler instance using the provided
       * PluggableAuthHandlerOptions object.
       */
      constructor(options) {
        if (!options.command) {
          throw new Error("No command provided.");
        }
        this.commandComponents = _PluggableAuthHandler.parseCommand(options.command);
        this.timeoutMillis = options.timeoutMillis;
        if (!this.timeoutMillis) {
          throw new Error("No timeoutMillis provided.");
        }
        this.outputFile = options.outputFile;
      }
      /**
       * Calls user provided executable to get a 3rd party subject token and
       * returns the response.
       * @param envMap a Map of additional Environment Variables required for
       *   the executable.
       * @return A promise that resolves with the executable response.
       */
      retrieveResponseFromExecutable(envMap) {
        return new Promise((resolve, reject) => {
          const child = childProcess.spawn(this.commandComponents[0], this.commandComponents.slice(1), {
            env: { ...process.env, ...Object.fromEntries(envMap) }
          });
          let output = "";
          child.stdout.on("data", (data) => {
            output += data;
          });
          child.stderr.on("data", (err) => {
            output += err;
          });
          const timeout = setTimeout(() => {
            child.removeAllListeners();
            child.kill();
            return reject(new Error("The executable failed to finish within the timeout specified."));
          }, this.timeoutMillis);
          child.on("close", (code) => {
            clearTimeout(timeout);
            if (code === 0) {
              try {
                const responseJson = JSON.parse(output);
                const response = new executable_response_1.ExecutableResponse(responseJson);
                return resolve(response);
              } catch (error) {
                if (error instanceof executable_response_1.ExecutableResponseError) {
                  return reject(error);
                }
                return reject(new executable_response_1.ExecutableResponseError(`The executable returned an invalid response: ${output}`));
              }
            } else {
              return reject(new pluggable_auth_client_1.ExecutableError(output, code.toString()));
            }
          });
        });
      }
      /**
       * Checks user provided output file for response from previous run of
       * executable and return the response if it exists, is formatted correctly, and is not expired.
       */
      async retrieveCachedResponse() {
        if (!this.outputFile || this.outputFile.length === 0) {
          return void 0;
        }
        let filePath;
        try {
          filePath = await fs3.promises.realpath(this.outputFile);
        } catch (_a3) {
          return void 0;
        }
        if (!(await fs3.promises.lstat(filePath)).isFile()) {
          return void 0;
        }
        const responseString = await fs3.promises.readFile(filePath, {
          encoding: "utf8"
        });
        if (responseString === "") {
          return void 0;
        }
        try {
          const responseJson = JSON.parse(responseString);
          const response = new executable_response_1.ExecutableResponse(responseJson);
          if (response.isValid()) {
            return new executable_response_1.ExecutableResponse(responseJson);
          }
          return void 0;
        } catch (error) {
          if (error instanceof executable_response_1.ExecutableResponseError) {
            throw error;
          }
          throw new executable_response_1.ExecutableResponseError(`The output file contained an invalid response: ${responseString}`);
        }
      }
      /**
       * Parses given command string into component array, splitting on spaces unless
       * spaces are between quotation marks.
       */
      static parseCommand(command) {
        const components = command.match(/(?:[^\s"]+|"[^"]*")+/g);
        if (!components) {
          throw new Error(`Provided command: "${command}" could not be parsed.`);
        }
        for (let i2 = 0; i2 < components.length; i2++) {
          if (components[i2][0] === '"' && components[i2].slice(-1) === '"') {
            components[i2] = components[i2].slice(1, -1);
          }
        }
        return components;
      }
    };
    exports.PluggableAuthHandler = PluggableAuthHandler;
  }
});

// ../node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js
var require_pluggable_auth_client = __commonJS({
  "../node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PluggableAuthClient = exports.ExecutableError = void 0;
    var baseexternalclient_1 = require_baseexternalclient();
    var executable_response_1 = require_executable_response();
    var pluggable_auth_handler_1 = require_pluggable_auth_handler();
    var ExecutableError = class extends Error {
      constructor(message, code) {
        super(`The executable failed with exit code: ${code} and error message: ${message}.`);
        this.code = code;
        Object.setPrototypeOf(this, new.target.prototype);
      }
    };
    exports.ExecutableError = ExecutableError;
    var DEFAULT_EXECUTABLE_TIMEOUT_MILLIS = 30 * 1e3;
    var MINIMUM_EXECUTABLE_TIMEOUT_MILLIS = 5 * 1e3;
    var MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS = 120 * 1e3;
    var GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES = "GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES";
    var MAXIMUM_EXECUTABLE_VERSION = 1;
    var PluggableAuthClient = class extends baseexternalclient_1.BaseExternalAccountClient {
      /**
       * Instantiates a PluggableAuthClient instance using the provided JSON
       * object loaded from an external account credentials file.
       * An error is thrown if the credential is not a valid pluggable auth credential.
       * @param options The external account options object typically loaded from
       *   the external account JSON credential file.
       * @param additionalOptions **DEPRECATED, all options are available in the
       *   `options` parameter.** Optional additional behavior customization options.
       *   These currently customize expiration threshold time and whether to retry
       *   on 401/403 API request errors.
       */
      constructor(options, additionalOptions) {
        super(options, additionalOptions);
        if (!options.credential_source.executable) {
          throw new Error('No valid Pluggable Auth "credential_source" provided.');
        }
        this.command = options.credential_source.executable.command;
        if (!this.command) {
          throw new Error('No valid Pluggable Auth "credential_source" provided.');
        }
        if (options.credential_source.executable.timeout_millis === void 0) {
          this.timeoutMillis = DEFAULT_EXECUTABLE_TIMEOUT_MILLIS;
        } else {
          this.timeoutMillis = options.credential_source.executable.timeout_millis;
          if (this.timeoutMillis < MINIMUM_EXECUTABLE_TIMEOUT_MILLIS || this.timeoutMillis > MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS) {
            throw new Error(`Timeout must be between ${MINIMUM_EXECUTABLE_TIMEOUT_MILLIS} and ${MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS} milliseconds.`);
          }
        }
        this.outputFile = options.credential_source.executable.output_file;
        this.handler = new pluggable_auth_handler_1.PluggableAuthHandler({
          command: this.command,
          timeoutMillis: this.timeoutMillis,
          outputFile: this.outputFile
        });
        this.credentialSourceType = "executable";
      }
      /**
       * Triggered when an external subject token is needed to be exchanged for a
       * GCP access token via GCP STS endpoint.
       * This uses the `options.credential_source` object to figure out how
       * to retrieve the token using the current environment. In this case,
       * this calls a user provided executable which returns the subject token.
       * The logic is summarized as:
       * 1. Validated that the executable is allowed to run. The
       *    GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment must be set to
       *    1 for security reasons.
       * 2. If an output file is specified by the user, check the file location
       *    for a response. If the file exists and contains a valid response,
       *    return the subject token from the file.
       * 3. Call the provided executable and return response.
       * @return A promise that resolves with the external subject token.
       */
      async retrieveSubjectToken() {
        if (process.env[GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES] !== "1") {
          throw new Error("Pluggable Auth executables need to be explicitly allowed to run by setting the GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment Variable to 1.");
        }
        let executableResponse = void 0;
        if (this.outputFile) {
          executableResponse = await this.handler.retrieveCachedResponse();
        }
        if (!executableResponse) {
          const envMap = /* @__PURE__ */ new Map();
          envMap.set("GOOGLE_EXTERNAL_ACCOUNT_AUDIENCE", this.audience);
          envMap.set("GOOGLE_EXTERNAL_ACCOUNT_TOKEN_TYPE", this.subjectTokenType);
          envMap.set("GOOGLE_EXTERNAL_ACCOUNT_INTERACTIVE", "0");
          if (this.outputFile) {
            envMap.set("GOOGLE_EXTERNAL_ACCOUNT_OUTPUT_FILE", this.outputFile);
          }
          const serviceAccountEmail = this.getServiceAccountEmail();
          if (serviceAccountEmail) {
            envMap.set("GOOGLE_EXTERNAL_ACCOUNT_IMPERSONATED_EMAIL", serviceAccountEmail);
          }
          executableResponse = await this.handler.retrieveResponseFromExecutable(envMap);
        }
        if (executableResponse.version > MAXIMUM_EXECUTABLE_VERSION) {
          throw new Error(`Version of executable is not currently supported, maximum supported version is ${MAXIMUM_EXECUTABLE_VERSION}.`);
        }
        if (!executableResponse.success) {
          throw new ExecutableError(executableResponse.errorMessage, executableResponse.errorCode);
        }
        if (this.outputFile) {
          if (!executableResponse.expirationTime) {
            throw new executable_response_1.InvalidExpirationTimeFieldError("The executable response must contain the `expiration_time` field for successful responses when an output_file has been specified in the configuration.");
          }
        }
        if (executableResponse.isExpired()) {
          throw new Error("Executable response is expired.");
        }
        return executableResponse.subjectToken;
      }
    };
    exports.PluggableAuthClient = PluggableAuthClient;
  }
});

// ../node_modules/google-auth-library/build/src/auth/externalclient.js
var require_externalclient = __commonJS({
  "../node_modules/google-auth-library/build/src/auth/externalclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExternalAccountClient = void 0;
    var baseexternalclient_1 = require_baseexternalclient();
    var identitypoolclient_1 = require_identitypoolclient();
    var awsclient_1 = require_awsclient();
    var pluggable_auth_client_1 = require_pluggable_auth_client();
    var ExternalAccountClient = class {
      constructor() {
        throw new Error("ExternalAccountClients should be initialized via: ExternalAccountClient.fromJSON(), directly via explicit constructors, eg. new AwsClient(options), new IdentityPoolClient(options), newPluggableAuthClientOptions, or via new GoogleAuth(options).getClient()");
      }
      /**
       * This static method will instantiate the
       * corresponding type of external account credential depending on the
       * underlying credential source.
       * @param options The external account options object typically loaded
       *   from the external account JSON credential file.
       * @param additionalOptions **DEPRECATED, all options are available in the
       *   `options` parameter.** Optional additional behavior customization options.
       *   These currently customize expiration threshold time and whether to retry
       *   on 401/403 API request errors.
       * @return A BaseExternalAccountClient instance or null if the options
       *   provided do not correspond to an external account credential.
       */
      static fromJSON(options, additionalOptions) {
        var _a3, _b;
        if (options && options.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {
          if ((_a3 = options.credential_source) === null || _a3 === void 0 ? void 0 : _a3.environment_id) {
            return new awsclient_1.AwsClient(options, additionalOptions);
          } else if ((_b = options.credential_source) === null || _b === void 0 ? void 0 : _b.executable) {
            return new pluggable_auth_client_1.PluggableAuthClient(options, additionalOptions);
          } else {
            return new identitypoolclient_1.IdentityPoolClient(options, additionalOptions);
          }
        } else {
          return null;
        }
      }
    };
    exports.ExternalAccountClient = ExternalAccountClient;
  }
});

// ../node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js
var require_externalAccountAuthorizedUserClient = __commonJS({
  "../node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExternalAccountAuthorizedUserClient = exports.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = void 0;
    var authclient_1 = require_authclient();
    var oauth2common_1 = require_oauth2common();
    var gaxios_1 = require_src2();
    var stream = __require("stream");
    var baseexternalclient_1 = require_baseexternalclient();
    exports.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = "external_account_authorized_user";
    var DEFAULT_TOKEN_URL = "https://sts.{universeDomain}/v1/oauthtoken";
    var ExternalAccountAuthorizedUserHandler = class _ExternalAccountAuthorizedUserHandler extends oauth2common_1.OAuthClientAuthHandler {
      /**
       * Initializes an ExternalAccountAuthorizedUserHandler instance.
       * @param url The URL of the token refresh endpoint.
       * @param transporter The transporter to use for the refresh request.
       * @param clientAuthentication The client authentication credentials to use
       *   for the refresh request.
       */
      constructor(url, transporter, clientAuthentication) {
        super(clientAuthentication);
        this.url = url;
        this.transporter = transporter;
      }
      /**
       * Requests a new access token from the token_url endpoint using the provided
       *   refresh token.
       * @param refreshToken The refresh token to use to generate a new access token.
       * @param additionalHeaders Optional additional headers to pass along the
       *   request.
       * @return A promise that resolves with the token refresh response containing
       *   the requested access token and its expiration time.
       */
      async refreshToken(refreshToken, additionalHeaders) {
        const values = new URLSearchParams({
          grant_type: "refresh_token",
          refresh_token: refreshToken
        });
        const headers = {
          "Content-Type": "application/x-www-form-urlencoded",
          ...additionalHeaders
        };
        const opts = {
          ..._ExternalAccountAuthorizedUserHandler.RETRY_CONFIG,
          url: this.url,
          method: "POST",
          headers,
          data: values.toString(),
          responseType: "json"
        };
        this.applyClientAuthenticationOptions(opts);
        try {
          const response = await this.transporter.request(opts);
          const tokenRefreshResponse = response.data;
          tokenRefreshResponse.res = response;
          return tokenRefreshResponse;
        } catch (error) {
          if (error instanceof gaxios_1.GaxiosError && error.response) {
            throw (0, oauth2common_1.getErrorFromOAuthErrorResponse)(
              error.response.data,
              // Preserve other fields from the original error.
              error
            );
          }
          throw error;
        }
      }
    };
    var ExternalAccountAuthorizedUserClient = class extends authclient_1.AuthClient {
      /**
       * Instantiates an ExternalAccountAuthorizedUserClient instances using the
       * provided JSON object loaded from a credentials files.
       * An error is throws if the credential is not valid.
       * @param options The external account authorized user option object typically
       *   from the external accoutn authorized user JSON credential file.
       * @param additionalOptions **DEPRECATED, all options are available in the
       *   `options` parameter.** Optional additional behavior customization options.
       *   These currently customize expiration threshold time and whether to retry
       *   on 401/403 API request errors.
       */
      constructor(options, additionalOptions) {
        var _a3;
        super({ ...options, ...additionalOptions });
        if (options.universe_domain) {
          this.universeDomain = options.universe_domain;
        }
        this.refreshToken = options.refresh_token;
        const clientAuth = {
          confidentialClientType: "basic",
          clientId: options.client_id,
          clientSecret: options.client_secret
        };
        this.externalAccountAuthorizedUserHandler = new ExternalAccountAuthorizedUserHandler((_a3 = options.token_url) !== null && _a3 !== void 0 ? _a3 : DEFAULT_TOKEN_URL.replace("{universeDomain}", this.universeDomain), this.transporter, clientAuth);
        this.cachedAccessToken = null;
        this.quotaProjectId = options.quota_project_id;
        if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== "number") {
          this.eagerRefreshThresholdMillis = baseexternalclient_1.EXPIRATION_TIME_OFFSET;
        } else {
          this.eagerRefreshThresholdMillis = additionalOptions.eagerRefreshThresholdMillis;
        }
        this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);
      }
      async getAccessToken() {
        if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) {
          await this.refreshAccessTokenAsync();
        }
        return {
          token: this.cachedAccessToken.access_token,
          res: this.cachedAccessToken.res
        };
      }
      async getRequestHeaders() {
        const accessTokenResponse = await this.getAccessToken();
        const headers = {
          Authorization: `Bearer ${accessTokenResponse.token}`
        };
        return this.addSharedMetadataHeaders(headers);
      }
      request(opts, callback) {
        if (callback) {
          this.requestAsync(opts).then((r2) => callback(null, r2), (e2) => {
            return callback(e2, e2.response);
          });
        } else {
          return this.requestAsync(opts);
        }
      }
      /**
       * Authenticates the provided HTTP request, processes it and resolves with the
       * returned response.
       * @param opts The HTTP request options.
       * @param reAuthRetried Whether the current attempt is a retry after a failed attempt due to an auth failure.
       * @return A promise that resolves with the successful response.
       */
      async requestAsync(opts, reAuthRetried = false) {
        let response;
        try {
          const requestHeaders = await this.getRequestHeaders();
          opts.headers = opts.headers || {};
          if (requestHeaders && requestHeaders["x-goog-user-project"]) {
            opts.headers["x-goog-user-project"] = requestHeaders["x-goog-user-project"];
          }
          if (requestHeaders && requestHeaders.Authorization) {
            opts.headers.Authorization = requestHeaders.Authorization;
          }
          response = await this.transporter.request(opts);
        } catch (e2) {
          const res = e2.response;
          if (res) {
            const statusCode = res.status;
            const isReadableStream = res.config.data instanceof stream.Readable;
            const isAuthErr = statusCode === 401 || statusCode === 403;
            if (!reAuthRetried && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {
              await this.refreshAccessTokenAsync();
              return await this.requestAsync(opts, true);
            }
          }
          throw e2;
        }
        return response;
      }
      /**
       * Forces token refresh, even if unexpired tokens are currently cached.
       * @return A promise that resolves with the refreshed credential.
       */
      async refreshAccessTokenAsync() {
        const refreshResponse = await this.externalAccountAuthorizedUserHandler.refreshToken(this.refreshToken);
        this.cachedAccessToken = {
          access_token: refreshResponse.access_token,
          expiry_date: (/* @__PURE__ */ new Date()).getTime() + refreshResponse.expires_in * 1e3,
          res: refreshResponse.res
        };
        if (refreshResponse.refresh_token !== void 0) {
          this.refreshToken = refreshResponse.refresh_token;
        }
        return this.cachedAccessToken;
      }
      /**
       * Returns whether the provided credentials are expired or not.
       * If there is no expiry time, assumes the token is not expired or expiring.
       * @param credentials The credentials to check for expiration.
       * @return Whether the credentials are expired or not.
       */
      isExpired(credentials) {
        const now = (/* @__PURE__ */ new Date()).getTime();
        return credentials.expiry_date ? now >= credentials.expiry_date - this.eagerRefreshThresholdMillis : false;
      }
    };
    exports.ExternalAccountAuthorizedUserClient = ExternalAccountAuthorizedUserClient;
  }
});

// ../node_modules/google-auth-library/build/src/auth/googleauth.js
var require_googleauth = __commonJS({
  "../node_modules/google-auth-library/build/src/auth/googleauth.js"(exports) {
    "use strict";
    var __classPrivateFieldGet11 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind3, f2) {
      if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind3 === "m" ? f2 : kind3 === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
    };
    var __classPrivateFieldSet10 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind3, f2) {
      if (kind3 === "m") throw new TypeError("Private method is not writable");
      if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind3 === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
    };
    var _GoogleAuth_instances;
    var _GoogleAuth_pendingAuthClient;
    var _GoogleAuth_prepareAndCacheClient;
    var _GoogleAuth_determineClient;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GoogleAuth = exports.GoogleAuthExceptionMessages = exports.CLOUD_SDK_CLIENT_ID = void 0;
    var child_process_1 = __require("child_process");
    var fs3 = __require("fs");
    var gcpMetadata = require_src4();
    var os = __require("os");
    var path2 = __require("path");
    var crypto_1 = require_crypto3();
    var transporters_1 = require_transporters();
    var computeclient_1 = require_computeclient();
    var idtokenclient_1 = require_idtokenclient();
    var envDetect_1 = require_envDetect();
    var jwtclient_1 = require_jwtclient();
    var refreshclient_1 = require_refreshclient();
    var impersonated_1 = require_impersonated();
    var externalclient_1 = require_externalclient();
    var baseexternalclient_1 = require_baseexternalclient();
    var authclient_1 = require_authclient();
    var externalAccountAuthorizedUserClient_1 = require_externalAccountAuthorizedUserClient();
    var util_1 = require_util2();
    exports.CLOUD_SDK_CLIENT_ID = "764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com";
    exports.GoogleAuthExceptionMessages = {
      API_KEY_WITH_CREDENTIALS: "API Keys and Credentials are mutually exclusive authentication methods and cannot be used together.",
      NO_PROJECT_ID_FOUND: "Unable to detect a Project Id in the current environment. \nTo learn more about authentication and Google APIs, visit: \nhttps://cloud.google.com/docs/authentication/getting-started",
      NO_CREDENTIALS_FOUND: "Unable to find credentials in current environment. \nTo learn more about authentication and Google APIs, visit: \nhttps://cloud.google.com/docs/authentication/getting-started",
      NO_ADC_FOUND: "Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.",
      NO_UNIVERSE_DOMAIN_FOUND: "Unable to detect a Universe Domain in the current environment.\nTo learn more about Universe Domain retrieval, visit: \nhttps://cloud.google.com/compute/docs/metadata/predefined-metadata-keys"
    };
    var GoogleAuth2 = class {
      // Note:  this properly is only public to satisfy unit tests.
      // https://github.com/Microsoft/TypeScript/issues/5228
      get isGCE() {
        return this.checkIsGCE;
      }
      /**
       * Configuration is resolved in the following order of precedence:
       * - {@link GoogleAuthOptions.credentials `credentials`}
       * - {@link GoogleAuthOptions.keyFilename `keyFilename`}
       * - {@link GoogleAuthOptions.keyFile `keyFile`}
       *
       * {@link GoogleAuthOptions.clientOptions `clientOptions`} are passed to the
       * {@link AuthClient `AuthClient`s}.
       *
       * @param opts
       */
      constructor(opts = {}) {
        _GoogleAuth_instances.add(this);
        this.checkIsGCE = void 0;
        this.jsonContent = null;
        this.cachedCredential = null;
        _GoogleAuth_pendingAuthClient.set(this, null);
        this.clientOptions = {};
        this._cachedProjectId = opts.projectId || null;
        this.cachedCredential = opts.authClient || null;
        this.keyFilename = opts.keyFilename || opts.keyFile;
        this.scopes = opts.scopes;
        this.clientOptions = opts.clientOptions || {};
        this.jsonContent = opts.credentials || null;
        this.apiKey = opts.apiKey || this.clientOptions.apiKey || null;
        if (this.apiKey && (this.jsonContent || this.clientOptions.credentials)) {
          throw new RangeError(exports.GoogleAuthExceptionMessages.API_KEY_WITH_CREDENTIALS);
        }
        if (opts.universeDomain) {
          this.clientOptions.universeDomain = opts.universeDomain;
        }
      }
      // GAPIC client libraries should always use self-signed JWTs. The following
      // variables are set on the JWT client in order to indicate the type of library,
      // and sign the JWT with the correct audience and scopes (if not supplied).
      setGapicJWTValues(client) {
        client.defaultServicePath = this.defaultServicePath;
        client.useJWTAccessWithScope = this.useJWTAccessWithScope;
        client.defaultScopes = this.defaultScopes;
      }
      getProjectId(callback) {
        if (callback) {
          this.getProjectIdAsync().then((r2) => callback(null, r2), callback);
        } else {
          return this.getProjectIdAsync();
        }
      }
      /**
       * A temporary method for internal `getProjectId` usages where `null` is
       * acceptable. In a future major release, `getProjectId` should return `null`
       * (as the `Promise<string | null>` base signature describes) and this private
       * method should be removed.
       *
       * @returns Promise that resolves with project id (or `null`)
       */
      async getProjectIdOptional() {
        try {
          return await this.getProjectId();
        } catch (e2) {
          if (e2 instanceof Error && e2.message === exports.GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND) {
            return null;
          } else {
            throw e2;
          }
        }
      }
      /**
       * A private method for finding and caching a projectId.
       *
       * Supports environments in order of precedence:
       * - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable
       * - GOOGLE_APPLICATION_CREDENTIALS JSON file
       * - Cloud SDK: `gcloud config config-helper --format json`
       * - GCE project ID from metadata server
       *
       * @returns projectId
       */
      async findAndCacheProjectId() {
        let projectId = null;
        projectId || (projectId = await this.getProductionProjectId());
        projectId || (projectId = await this.getFileProjectId());
        projectId || (projectId = await this.getDefaultServiceProjectId());
        projectId || (projectId = await this.getGCEProjectId());
        projectId || (projectId = await this.getExternalAccountClientProjectId());
        if (projectId) {
          this._cachedProjectId = projectId;
          return projectId;
        } else {
          throw new Error(exports.GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND);
        }
      }
      async getProjectIdAsync() {
        if (this._cachedProjectId) {
          return this._cachedProjectId;
        }
        if (!this._findProjectIdPromise) {
          this._findProjectIdPromise = this.findAndCacheProjectId();
        }
        return this._findProjectIdPromise;
      }
      /**
       * Retrieves a universe domain from the metadata server via
       * {@link gcpMetadata.universe}.
       *
       * @returns a universe domain
       */
      async getUniverseDomainFromMetadataServer() {
        var _a3;
        let universeDomain;
        try {
          universeDomain = await gcpMetadata.universe("universe-domain");
          universeDomain || (universeDomain = authclient_1.DEFAULT_UNIVERSE);
        } catch (e2) {
          if (e2 && ((_a3 = e2 === null || e2 === void 0 ? void 0 : e2.response) === null || _a3 === void 0 ? void 0 : _a3.status) === 404) {
            universeDomain = authclient_1.DEFAULT_UNIVERSE;
          } else {
            throw e2;
          }
        }
        return universeDomain;
      }
      /**
       * Retrieves, caches, and returns the universe domain in the following order
       * of precedence:
       * - The universe domain in {@link GoogleAuth.clientOptions}
       * - An existing or ADC {@link AuthClient}'s universe domain
       * - {@link gcpMetadata.universe}, if {@link Compute} client
       *
       * @returns The universe domain
       */
      async getUniverseDomain() {
        let universeDomain = (0, util_1.originalOrCamelOptions)(this.clientOptions).get("universe_domain");
        try {
          universeDomain !== null && universeDomain !== void 0 ? universeDomain : universeDomain = (await this.getClient()).universeDomain;
        } catch (_a3) {
          universeDomain !== null && universeDomain !== void 0 ? universeDomain : universeDomain = authclient_1.DEFAULT_UNIVERSE;
        }
        return universeDomain;
      }
      /**
       * @returns Any scopes (user-specified or default scopes specified by the
       *   client library) that need to be set on the current Auth client.
       */
      getAnyScopes() {
        return this.scopes || this.defaultScopes;
      }
      getApplicationDefault(optionsOrCallback = {}, callback) {
        let options;
        if (typeof optionsOrCallback === "function") {
          callback = optionsOrCallback;
        } else {
          options = optionsOrCallback;
        }
        if (callback) {
          this.getApplicationDefaultAsync(options).then((r2) => callback(null, r2.credential, r2.projectId), callback);
        } else {
          return this.getApplicationDefaultAsync(options);
        }
      }
      async getApplicationDefaultAsync(options = {}) {
        if (this.cachedCredential) {
          return await __classPrivateFieldGet11(this, _GoogleAuth_instances, "m", _GoogleAuth_prepareAndCacheClient).call(this, this.cachedCredential, null);
        }
        let credential;
        credential = await this._tryGetApplicationCredentialsFromEnvironmentVariable(options);
        if (credential) {
          if (credential instanceof jwtclient_1.JWT) {
            credential.scopes = this.scopes;
          } else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {
            credential.scopes = this.getAnyScopes();
          }
          return await __classPrivateFieldGet11(this, _GoogleAuth_instances, "m", _GoogleAuth_prepareAndCacheClient).call(this, credential);
        }
        credential = await this._tryGetApplicationCredentialsFromWellKnownFile(options);
        if (credential) {
          if (credential instanceof jwtclient_1.JWT) {
            credential.scopes = this.scopes;
          } else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {
            credential.scopes = this.getAnyScopes();
          }
          return await __classPrivateFieldGet11(this, _GoogleAuth_instances, "m", _GoogleAuth_prepareAndCacheClient).call(this, credential);
        }
        if (await this._checkIsGCE()) {
          options.scopes = this.getAnyScopes();
          return await __classPrivateFieldGet11(this, _GoogleAuth_instances, "m", _GoogleAuth_prepareAndCacheClient).call(this, new computeclient_1.Compute(options));
        }
        throw new Error(exports.GoogleAuthExceptionMessages.NO_ADC_FOUND);
      }
      /**
       * Determines whether the auth layer is running on Google Compute Engine.
       * Checks for GCP Residency, then fallback to checking if metadata server
       * is available.
       *
       * @returns A promise that resolves with the boolean.
       * @api private
       */
      async _checkIsGCE() {
        if (this.checkIsGCE === void 0) {
          this.checkIsGCE = gcpMetadata.getGCPResidency() || await gcpMetadata.isAvailable();
        }
        return this.checkIsGCE;
      }
      /**
       * Attempts to load default credentials from the environment variable path..
       * @returns Promise that resolves with the OAuth2Client or null.
       * @api private
       */
      async _tryGetApplicationCredentialsFromEnvironmentVariable(options) {
        const credentialsPath = process.env["GOOGLE_APPLICATION_CREDENTIALS"] || process.env["google_application_credentials"];
        if (!credentialsPath || credentialsPath.length === 0) {
          return null;
        }
        try {
          return this._getApplicationCredentialsFromFilePath(credentialsPath, options);
        } catch (e2) {
          if (e2 instanceof Error) {
            e2.message = `Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable: ${e2.message}`;
          }
          throw e2;
        }
      }
      /**
       * Attempts to load default credentials from a well-known file location
       * @return Promise that resolves with the OAuth2Client or null.
       * @api private
       */
      async _tryGetApplicationCredentialsFromWellKnownFile(options) {
        let location = null;
        if (this._isWindows()) {
          location = process.env["APPDATA"];
        } else {
          const home = process.env["HOME"];
          if (home) {
            location = path2.join(home, ".config");
          }
        }
        if (location) {
          location = path2.join(location, "gcloud", "application_default_credentials.json");
          if (!fs3.existsSync(location)) {
            location = null;
          }
        }
        if (!location) {
          return null;
        }
        const client = await this._getApplicationCredentialsFromFilePath(location, options);
        return client;
      }
      /**
       * Attempts to load default credentials from a file at the given path..
       * @param filePath The path to the file to read.
       * @returns Promise that resolves with the OAuth2Client
       * @api private
       */
      async _getApplicationCredentialsFromFilePath(filePath, options = {}) {
        if (!filePath || filePath.length === 0) {
          throw new Error("The file path is invalid.");
        }
        try {
          filePath = fs3.realpathSync(filePath);
          if (!fs3.lstatSync(filePath).isFile()) {
            throw new Error();
          }
        } catch (err) {
          if (err instanceof Error) {
            err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;
          }
          throw err;
        }
        const readStream = fs3.createReadStream(filePath);
        return this.fromStream(readStream, options);
      }
      /**
       * Create a credentials instance using a given impersonated input options.
       * @param json The impersonated input object.
       * @returns JWT or UserRefresh Client with data
       */
      fromImpersonatedJSON(json) {
        var _a3, _b, _c, _d;
        if (!json) {
          throw new Error("Must pass in a JSON object containing an  impersonated refresh token");
        }
        if (json.type !== impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {
          throw new Error(`The incoming JSON object does not have the "${impersonated_1.IMPERSONATED_ACCOUNT_TYPE}" type`);
        }
        if (!json.source_credentials) {
          throw new Error("The incoming JSON object does not contain a source_credentials field");
        }
        if (!json.service_account_impersonation_url) {
          throw new Error("The incoming JSON object does not contain a service_account_impersonation_url field");
        }
        const sourceClient = this.fromJSON(json.source_credentials);
        if (((_a3 = json.service_account_impersonation_url) === null || _a3 === void 0 ? void 0 : _a3.length) > 256) {
          throw new RangeError(`Target principal is too long: ${json.service_account_impersonation_url}`);
        }
        const targetPrincipal = (_c = (_b = /(?<target>[^/]+):(generateAccessToken|generateIdToken)$/.exec(json.service_account_impersonation_url)) === null || _b === void 0 ? void 0 : _b.groups) === null || _c === void 0 ? void 0 : _c.target;
        if (!targetPrincipal) {
          throw new RangeError(`Cannot extract target principal from ${json.service_account_impersonation_url}`);
        }
        const targetScopes = (_d = this.getAnyScopes()) !== null && _d !== void 0 ? _d : [];
        return new impersonated_1.Impersonated({
          ...json,
          sourceClient,
          targetPrincipal,
          targetScopes: Array.isArray(targetScopes) ? targetScopes : [targetScopes]
        });
      }
      /**
       * Create a credentials instance using the given input options.
       * This client is not cached.
       *
       * **Important**: If you accept a credential configuration (credential JSON/File/Stream) from an external source for authentication to Google Cloud, you must validate it before providing it to any Google API or library. Providing an unvalidated credential configuration to Google APIs can compromise the security of your systems and data. For more information, refer to {@link https://cloud.google.com/docs/authentication/external/externally-sourced-credentials Validate credential configurations from external sources}.
       *
       * @param json The input object.
       * @param options The JWT or UserRefresh options for the client
       * @returns JWT or UserRefresh Client with data
       */
      fromJSON(json, options = {}) {
        let client;
        const preferredUniverseDomain = (0, util_1.originalOrCamelOptions)(options).get("universe_domain");
        if (json.type === refreshclient_1.USER_REFRESH_ACCOUNT_TYPE) {
          client = new refreshclient_1.UserRefreshClient(options);
          client.fromJSON(json);
        } else if (json.type === impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {
          client = this.fromImpersonatedJSON(json);
        } else if (json.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {
          client = externalclient_1.ExternalAccountClient.fromJSON(json, options);
          client.scopes = this.getAnyScopes();
        } else if (json.type === externalAccountAuthorizedUserClient_1.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE) {
          client = new externalAccountAuthorizedUserClient_1.ExternalAccountAuthorizedUserClient(json, options);
        } else {
          options.scopes = this.scopes;
          client = new jwtclient_1.JWT(options);
          this.setGapicJWTValues(client);
          client.fromJSON(json);
        }
        if (preferredUniverseDomain) {
          client.universeDomain = preferredUniverseDomain;
        }
        return client;
      }
      /**
       * Return a JWT or UserRefreshClient from JavaScript object, caching both the
       * object used to instantiate and the client.
       * @param json The input object.
       * @param options The JWT or UserRefresh options for the client
       * @returns JWT or UserRefresh Client with data
       */
      _cacheClientFromJSON(json, options) {
        const client = this.fromJSON(json, options);
        this.jsonContent = json;
        this.cachedCredential = client;
        return client;
      }
      fromStream(inputStream, optionsOrCallback = {}, callback) {
        let options = {};
        if (typeof optionsOrCallback === "function") {
          callback = optionsOrCallback;
        } else {
          options = optionsOrCallback;
        }
        if (callback) {
          this.fromStreamAsync(inputStream, options).then((r2) => callback(null, r2), callback);
        } else {
          return this.fromStreamAsync(inputStream, options);
        }
      }
      fromStreamAsync(inputStream, options) {
        return new Promise((resolve, reject) => {
          if (!inputStream) {
            throw new Error("Must pass in a stream containing the Google auth settings.");
          }
          const chunks = [];
          inputStream.setEncoding("utf8").on("error", reject).on("data", (chunk) => chunks.push(chunk)).on("end", () => {
            try {
              try {
                const data = JSON.parse(chunks.join(""));
                const r2 = this._cacheClientFromJSON(data, options);
                return resolve(r2);
              } catch (err) {
                if (!this.keyFilename)
                  throw err;
                const client = new jwtclient_1.JWT({
                  ...this.clientOptions,
                  keyFile: this.keyFilename
                });
                this.cachedCredential = client;
                this.setGapicJWTValues(client);
                return resolve(client);
              }
            } catch (err) {
              return reject(err);
            }
          });
        });
      }
      /**
       * Create a credentials instance using the given API key string.
       * The created client is not cached. In order to create and cache it use the {@link GoogleAuth.getClient `getClient`} method after first providing an {@link GoogleAuth.apiKey `apiKey`}.
       *
       * @param apiKey The API key string
       * @param options An optional options object.
       * @returns A JWT loaded from the key
       */
      fromAPIKey(apiKey, options = {}) {
        return new jwtclient_1.JWT({ ...options, apiKey });
      }
      /**
       * Determines whether the current operating system is Windows.
       * @api private
       */
      _isWindows() {
        const sys = os.platform();
        if (sys && sys.length >= 3) {
          if (sys.substring(0, 3).toLowerCase() === "win") {
            return true;
          }
        }
        return false;
      }
      /**
       * Run the Google Cloud SDK command that prints the default project ID
       */
      async getDefaultServiceProjectId() {
        return new Promise((resolve) => {
          (0, child_process_1.exec)("gcloud config config-helper --format json", (err, stdout) => {
            if (!err && stdout) {
              try {
                const projectId = JSON.parse(stdout).configuration.properties.core.project;
                resolve(projectId);
                return;
              } catch (e2) {
              }
            }
            resolve(null);
          });
        });
      }
      /**
       * Loads the project id from environment variables.
       * @api private
       */
      getProductionProjectId() {
        return process.env["GCLOUD_PROJECT"] || process.env["GOOGLE_CLOUD_PROJECT"] || process.env["gcloud_project"] || process.env["google_cloud_project"];
      }
      /**
       * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.
       * @api private
       */
      async getFileProjectId() {
        if (this.cachedCredential) {
          return this.cachedCredential.projectId;
        }
        if (this.keyFilename) {
          const creds = await this.getClient();
          if (creds && creds.projectId) {
            return creds.projectId;
          }
        }
        const r2 = await this._tryGetApplicationCredentialsFromEnvironmentVariable();
        if (r2) {
          return r2.projectId;
        } else {
          return null;
        }
      }
      /**
       * Gets the project ID from external account client if available.
       */
      async getExternalAccountClientProjectId() {
        if (!this.jsonContent || this.jsonContent.type !== baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {
          return null;
        }
        const creds = await this.getClient();
        return await creds.getProjectId();
      }
      /**
       * Gets the Compute Engine project ID if it can be inferred.
       */
      async getGCEProjectId() {
        try {
          const r2 = await gcpMetadata.project("project-id");
          return r2;
        } catch (e2) {
          return null;
        }
      }
      getCredentials(callback) {
        if (callback) {
          this.getCredentialsAsync().then((r2) => callback(null, r2), callback);
        } else {
          return this.getCredentialsAsync();
        }
      }
      async getCredentialsAsync() {
        const client = await this.getClient();
        if (client instanceof impersonated_1.Impersonated) {
          return { client_email: client.getTargetPrincipal() };
        }
        if (client instanceof baseexternalclient_1.BaseExternalAccountClient) {
          const serviceAccountEmail = client.getServiceAccountEmail();
          if (serviceAccountEmail) {
            return {
              client_email: serviceAccountEmail,
              universe_domain: client.universeDomain
            };
          }
        }
        if (this.jsonContent) {
          return {
            client_email: this.jsonContent.client_email,
            private_key: this.jsonContent.private_key,
            universe_domain: this.jsonContent.universe_domain
          };
        }
        if (await this._checkIsGCE()) {
          const [client_email, universe_domain] = await Promise.all([
            gcpMetadata.instance("service-accounts/default/email"),
            this.getUniverseDomain()
          ]);
          return { client_email, universe_domain };
        }
        throw new Error(exports.GoogleAuthExceptionMessages.NO_CREDENTIALS_FOUND);
      }
      /**
       * Automatically obtain an {@link AuthClient `AuthClient`} based on the
       * provided configuration. If no options were passed, use Application
       * Default Credentials.
       */
      async getClient() {
        if (this.cachedCredential) {
          return this.cachedCredential;
        }
        __classPrivateFieldSet10(this, _GoogleAuth_pendingAuthClient, __classPrivateFieldGet11(this, _GoogleAuth_pendingAuthClient, "f") || __classPrivateFieldGet11(this, _GoogleAuth_instances, "m", _GoogleAuth_determineClient).call(this), "f");
        try {
          return await __classPrivateFieldGet11(this, _GoogleAuth_pendingAuthClient, "f");
        } finally {
          __classPrivateFieldSet10(this, _GoogleAuth_pendingAuthClient, null, "f");
        }
      }
      /**
       * Creates a client which will fetch an ID token for authorization.
       * @param targetAudience the audience for the fetched ID token.
       * @returns IdTokenClient for making HTTP calls authenticated with ID tokens.
       */
      async getIdTokenClient(targetAudience) {
        const client = await this.getClient();
        if (!("fetchIdToken" in client)) {
          throw new Error("Cannot fetch ID token in this environment, use GCE or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to a service account credentials JSON file.");
        }
        return new idtokenclient_1.IdTokenClient({ targetAudience, idTokenProvider: client });
      }
      /**
       * Automatically obtain application default credentials, and return
       * an access token for making requests.
       */
      async getAccessToken() {
        const client = await this.getClient();
        return (await client.getAccessToken()).token;
      }
      /**
       * Obtain the HTTP headers that will provide authorization for a given
       * request.
       */
      async getRequestHeaders(url) {
        const client = await this.getClient();
        return client.getRequestHeaders(url);
      }
      /**
       * Obtain credentials for a request, then attach the appropriate headers to
       * the request options.
       * @param opts Axios or Request options on which to attach the headers
       */
      async authorizeRequest(opts) {
        opts = opts || {};
        const url = opts.url || opts.uri;
        const client = await this.getClient();
        const headers = await client.getRequestHeaders(url);
        opts.headers = Object.assign(opts.headers || {}, headers);
        return opts;
      }
      /**
       * Automatically obtain application default credentials, and make an
       * HTTP request using the given options.
       * @param opts Axios request options for the HTTP request.
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      async request(opts) {
        const client = await this.getClient();
        return client.request(opts);
      }
      /**
       * Determine the compute environment in which the code is running.
       */
      getEnv() {
        return (0, envDetect_1.getEnv)();
      }
      /**
       * Sign the given data with the current private key, or go out
       * to the IAM API to sign it.
       * @param data The data to be signed.
       * @param endpoint A custom endpoint to use.
       *
       * @example
       * ```
       * sign('data', 'https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/');
       * ```
       */
      async sign(data, endpoint) {
        const client = await this.getClient();
        const universe = await this.getUniverseDomain();
        endpoint = endpoint || `https://iamcredentials.${universe}/v1/projects/-/serviceAccounts/`;
        if (client instanceof impersonated_1.Impersonated) {
          const signed = await client.sign(data);
          return signed.signedBlob;
        }
        const crypto6 = (0, crypto_1.createCrypto)();
        if (client instanceof jwtclient_1.JWT && client.key) {
          const sign = await crypto6.sign(client.key, data);
          return sign;
        }
        const creds = await this.getCredentials();
        if (!creds.client_email) {
          throw new Error("Cannot sign data without `client_email`.");
        }
        return this.signBlob(crypto6, creds.client_email, data, endpoint);
      }
      async signBlob(crypto6, emailOrUniqueId, data, endpoint) {
        const url = new URL(endpoint + `${emailOrUniqueId}:signBlob`);
        const res = await this.request({
          method: "POST",
          url: url.href,
          data: {
            payload: crypto6.encodeBase64StringUtf8(data)
          },
          retry: true,
          retryConfig: {
            httpMethodsToRetry: ["POST"]
          }
        });
        return res.data.signedBlob;
      }
    };
    exports.GoogleAuth = GoogleAuth2;
    _GoogleAuth_pendingAuthClient = /* @__PURE__ */ new WeakMap(), _GoogleAuth_instances = /* @__PURE__ */ new WeakSet(), _GoogleAuth_prepareAndCacheClient = async function _GoogleAuth_prepareAndCacheClient2(credential, quotaProjectIdOverride = process.env["GOOGLE_CLOUD_QUOTA_PROJECT"] || null) {
      const projectId = await this.getProjectIdOptional();
      if (quotaProjectIdOverride) {
        credential.quotaProjectId = quotaProjectIdOverride;
      }
      this.cachedCredential = credential;
      return { credential, projectId };
    }, _GoogleAuth_determineClient = async function _GoogleAuth_determineClient2() {
      if (this.jsonContent) {
        return this._cacheClientFromJSON(this.jsonContent, this.clientOptions);
      } else if (this.keyFilename) {
        const filePath = path2.resolve(this.keyFilename);
        const stream = fs3.createReadStream(filePath);
        return await this.fromStreamAsync(stream, this.clientOptions);
      } else if (this.apiKey) {
        const client = await this.fromAPIKey(this.apiKey, this.clientOptions);
        client.scopes = this.scopes;
        const { credential } = await __classPrivateFieldGet11(this, _GoogleAuth_instances, "m", _GoogleAuth_prepareAndCacheClient).call(this, client);
        return credential;
      } else {
        const { credential } = await this.getApplicationDefaultAsync(this.clientOptions);
        return credential;
      }
    };
    GoogleAuth2.DefaultTransporter = transporters_1.DefaultTransporter;
  }
});

// ../node_modules/google-auth-library/build/src/auth/iam.js
var require_iam = __commonJS({
  "../node_modules/google-auth-library/build/src/auth/iam.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IAMAuth = void 0;
    var IAMAuth = class {
      /**
       * IAM credentials.
       *
       * @param selector the iam authority selector
       * @param token the token
       * @constructor
       */
      constructor(selector, token) {
        this.selector = selector;
        this.token = token;
        this.selector = selector;
        this.token = token;
      }
      /**
       * Acquire the HTTP headers required to make an authenticated request.
       */
      getRequestHeaders() {
        return {
          "x-goog-iam-authority-selector": this.selector,
          "x-goog-iam-authorization-token": this.token
        };
      }
    };
    exports.IAMAuth = IAMAuth;
  }
});

// ../node_modules/google-auth-library/build/src/auth/downscopedclient.js
var require_downscopedclient = __commonJS({
  "../node_modules/google-auth-library/build/src/auth/downscopedclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DownscopedClient = exports.EXPIRATION_TIME_OFFSET = exports.MAX_ACCESS_BOUNDARY_RULES_COUNT = void 0;
    var stream = __require("stream");
    var authclient_1 = require_authclient();
    var sts = require_stscredentials();
    var STS_GRANT_TYPE = "urn:ietf:params:oauth:grant-type:token-exchange";
    var STS_REQUEST_TOKEN_TYPE = "urn:ietf:params:oauth:token-type:access_token";
    var STS_SUBJECT_TOKEN_TYPE = "urn:ietf:params:oauth:token-type:access_token";
    exports.MAX_ACCESS_BOUNDARY_RULES_COUNT = 10;
    exports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1e3;
    var DownscopedClient = class extends authclient_1.AuthClient {
      /**
       * Instantiates a downscoped client object using the provided source
       * AuthClient and credential access boundary rules.
       * To downscope permissions of a source AuthClient, a Credential Access
       * Boundary that specifies which resources the new credential can access, as
       * well as an upper bound on the permissions that are available on each
       * resource, has to be defined. A downscoped client can then be instantiated
       * using the source AuthClient and the Credential Access Boundary.
       * @param authClient The source AuthClient to be downscoped based on the
       *   provided Credential Access Boundary rules.
       * @param credentialAccessBoundary The Credential Access Boundary which
       *   contains a list of access boundary rules. Each rule contains information
       *   on the resource that the rule applies to, the upper bound of the
       *   permissions that are available on that resource and an optional
       *   condition to further restrict permissions.
       * @param additionalOptions **DEPRECATED, set this in the provided `authClient`.**
       *   Optional additional behavior customization options.
       * @param quotaProjectId **DEPRECATED, set this in the provided `authClient`.**
       *   Optional quota project id for setting up in the x-goog-user-project header.
       */
      constructor(authClient, credentialAccessBoundary, additionalOptions, quotaProjectId) {
        super({ ...additionalOptions, quotaProjectId });
        this.authClient = authClient;
        this.credentialAccessBoundary = credentialAccessBoundary;
        if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length === 0) {
          throw new Error("At least one access boundary rule needs to be defined.");
        } else if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length > exports.MAX_ACCESS_BOUNDARY_RULES_COUNT) {
          throw new Error(`The provided access boundary has more than ${exports.MAX_ACCESS_BOUNDARY_RULES_COUNT} access boundary rules.`);
        }
        for (const rule of credentialAccessBoundary.accessBoundary.accessBoundaryRules) {
          if (rule.availablePermissions.length === 0) {
            throw new Error("At least one permission should be defined in access boundary rules.");
          }
        }
        this.stsCredential = new sts.StsCredentials(`https://sts.${this.universeDomain}/v1/token`);
        this.cachedDownscopedAccessToken = null;
      }
      /**
       * Provides a mechanism to inject Downscoped access tokens directly.
       * The expiry_date field is required to facilitate determination of the token
       * expiration which would make it easier for the token consumer to handle.
       * @param credentials The Credentials object to set on the current client.
       */
      setCredentials(credentials) {
        if (!credentials.expiry_date) {
          throw new Error("The access token expiry_date field is missing in the provided credentials.");
        }
        super.setCredentials(credentials);
        this.cachedDownscopedAccessToken = credentials;
      }
      async getAccessToken() {
        if (!this.cachedDownscopedAccessToken || this.isExpired(this.cachedDownscopedAccessToken)) {
          await this.refreshAccessTokenAsync();
        }
        return {
          token: this.cachedDownscopedAccessToken.access_token,
          expirationTime: this.cachedDownscopedAccessToken.expiry_date,
          res: this.cachedDownscopedAccessToken.res
        };
      }
      /**
       * The main authentication interface. It takes an optional url which when
       * present is the endpoint being accessed, and returns a Promise which
       * resolves with authorization header fields.
       *
       * The result has the form:
       * { Authorization: 'Bearer <access_token_value>' }
       */
      async getRequestHeaders() {
        const accessTokenResponse = await this.getAccessToken();
        const headers = {
          Authorization: `Bearer ${accessTokenResponse.token}`
        };
        return this.addSharedMetadataHeaders(headers);
      }
      request(opts, callback) {
        if (callback) {
          this.requestAsync(opts).then((r2) => callback(null, r2), (e2) => {
            return callback(e2, e2.response);
          });
        } else {
          return this.requestAsync(opts);
        }
      }
      /**
       * Authenticates the provided HTTP request, processes it and resolves with the
       * returned response.
       * @param opts The HTTP request options.
       * @param reAuthRetried Whether the current attempt is a retry after a failed attempt due to an auth failure
       * @return A promise that resolves with the successful response.
       */
      async requestAsync(opts, reAuthRetried = false) {
        let response;
        try {
          const requestHeaders = await this.getRequestHeaders();
          opts.headers = opts.headers || {};
          if (requestHeaders && requestHeaders["x-goog-user-project"]) {
            opts.headers["x-goog-user-project"] = requestHeaders["x-goog-user-project"];
          }
          if (requestHeaders && requestHeaders.Authorization) {
            opts.headers.Authorization = requestHeaders.Authorization;
          }
          response = await this.transporter.request(opts);
        } catch (e2) {
          const res = e2.response;
          if (res) {
            const statusCode = res.status;
            const isReadableStream = res.config.data instanceof stream.Readable;
            const isAuthErr = statusCode === 401 || statusCode === 403;
            if (!reAuthRetried && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {
              await this.refreshAccessTokenAsync();
              return await this.requestAsync(opts, true);
            }
          }
          throw e2;
        }
        return response;
      }
      /**
       * Forces token refresh, even if unexpired tokens are currently cached.
       * GCP access tokens are retrieved from authclient object/source credential.
       * Then GCP access tokens are exchanged for downscoped access tokens via the
       * token exchange endpoint.
       * @return A promise that resolves with the fresh downscoped access token.
       */
      async refreshAccessTokenAsync() {
        var _a3;
        const subjectToken = (await this.authClient.getAccessToken()).token;
        const stsCredentialsOptions = {
          grantType: STS_GRANT_TYPE,
          requestedTokenType: STS_REQUEST_TOKEN_TYPE,
          subjectToken,
          subjectTokenType: STS_SUBJECT_TOKEN_TYPE
        };
        const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, void 0, this.credentialAccessBoundary);
        const sourceCredExpireDate = ((_a3 = this.authClient.credentials) === null || _a3 === void 0 ? void 0 : _a3.expiry_date) || null;
        const expiryDate = stsResponse.expires_in ? (/* @__PURE__ */ new Date()).getTime() + stsResponse.expires_in * 1e3 : sourceCredExpireDate;
        this.cachedDownscopedAccessToken = {
          access_token: stsResponse.access_token,
          expiry_date: expiryDate,
          res: stsResponse.res
        };
        this.credentials = {};
        Object.assign(this.credentials, this.cachedDownscopedAccessToken);
        delete this.credentials.res;
        this.emit("tokens", {
          refresh_token: null,
          expiry_date: this.cachedDownscopedAccessToken.expiry_date,
          access_token: this.cachedDownscopedAccessToken.access_token,
          token_type: "Bearer",
          id_token: null
        });
        return this.cachedDownscopedAccessToken;
      }
      /**
       * Returns whether the provided credentials are expired or not.
       * If there is no expiry time, assumes the token is not expired or expiring.
       * @param downscopedAccessToken The credentials to check for expiration.
       * @return Whether the credentials are expired or not.
       */
      isExpired(downscopedAccessToken) {
        const now = (/* @__PURE__ */ new Date()).getTime();
        return downscopedAccessToken.expiry_date ? now >= downscopedAccessToken.expiry_date - this.eagerRefreshThresholdMillis : false;
      }
    };
    exports.DownscopedClient = DownscopedClient;
  }
});

// ../node_modules/google-auth-library/build/src/auth/passthrough.js
var require_passthrough = __commonJS({
  "../node_modules/google-auth-library/build/src/auth/passthrough.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PassThroughClient = void 0;
    var authclient_1 = require_authclient();
    var PassThroughClient = class extends authclient_1.AuthClient {
      /**
       * Creates a request without any authentication headers or checks.
       *
       * @remarks
       *
       * In testing environments it may be useful to change the provided
       * {@link AuthClient.transporter} for any desired request overrides/handling.
       *
       * @param opts
       * @returns The response of the request.
       */
      async request(opts) {
        return this.transporter.request(opts);
      }
      /**
       * A required method of the base class.
       * Always will return an empty object.
       *
       * @returns {}
       */
      async getAccessToken() {
        return {};
      }
      /**
       * A required method of the base class.
       * Always will return an empty object.
       *
       * @returns {}
       */
      async getRequestHeaders() {
        return {};
      }
    };
    exports.PassThroughClient = PassThroughClient;
    var a2 = new PassThroughClient();
    a2.getAccessToken();
  }
});

// ../node_modules/google-auth-library/build/src/index.js
var require_src6 = __commonJS({
  "../node_modules/google-auth-library/build/src/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GoogleAuth = exports.auth = exports.DefaultTransporter = exports.PassThroughClient = exports.ExecutableError = exports.PluggableAuthClient = exports.DownscopedClient = exports.BaseExternalAccountClient = exports.ExternalAccountClient = exports.IdentityPoolClient = exports.AwsRequestSigner = exports.AwsClient = exports.UserRefreshClient = exports.LoginTicket = exports.ClientAuthentication = exports.OAuth2Client = exports.CodeChallengeMethod = exports.Impersonated = exports.JWT = exports.JWTAccess = exports.IdTokenClient = exports.IAMAuth = exports.GCPEnv = exports.Compute = exports.DEFAULT_UNIVERSE = exports.AuthClient = exports.gaxios = exports.gcpMetadata = void 0;
    var googleauth_1 = require_googleauth();
    Object.defineProperty(exports, "GoogleAuth", { enumerable: true, get: function() {
      return googleauth_1.GoogleAuth;
    } });
    exports.gcpMetadata = require_src4();
    exports.gaxios = require_src2();
    var authclient_1 = require_authclient();
    Object.defineProperty(exports, "AuthClient", { enumerable: true, get: function() {
      return authclient_1.AuthClient;
    } });
    Object.defineProperty(exports, "DEFAULT_UNIVERSE", { enumerable: true, get: function() {
      return authclient_1.DEFAULT_UNIVERSE;
    } });
    var computeclient_1 = require_computeclient();
    Object.defineProperty(exports, "Compute", { enumerable: true, get: function() {
      return computeclient_1.Compute;
    } });
    var envDetect_1 = require_envDetect();
    Object.defineProperty(exports, "GCPEnv", { enumerable: true, get: function() {
      return envDetect_1.GCPEnv;
    } });
    var iam_1 = require_iam();
    Object.defineProperty(exports, "IAMAuth", { enumerable: true, get: function() {
      return iam_1.IAMAuth;
    } });
    var idtokenclient_1 = require_idtokenclient();
    Object.defineProperty(exports, "IdTokenClient", { enumerable: true, get: function() {
      return idtokenclient_1.IdTokenClient;
    } });
    var jwtaccess_1 = require_jwtaccess();
    Object.defineProperty(exports, "JWTAccess", { enumerable: true, get: function() {
      return jwtaccess_1.JWTAccess;
    } });
    var jwtclient_1 = require_jwtclient();
    Object.defineProperty(exports, "JWT", { enumerable: true, get: function() {
      return jwtclient_1.JWT;
    } });
    var impersonated_1 = require_impersonated();
    Object.defineProperty(exports, "Impersonated", { enumerable: true, get: function() {
      return impersonated_1.Impersonated;
    } });
    var oauth2client_1 = require_oauth2client();
    Object.defineProperty(exports, "CodeChallengeMethod", { enumerable: true, get: function() {
      return oauth2client_1.CodeChallengeMethod;
    } });
    Object.defineProperty(exports, "OAuth2Client", { enumerable: true, get: function() {
      return oauth2client_1.OAuth2Client;
    } });
    Object.defineProperty(exports, "ClientAuthentication", { enumerable: true, get: function() {
      return oauth2client_1.ClientAuthentication;
    } });
    var loginticket_1 = require_loginticket();
    Object.defineProperty(exports, "LoginTicket", { enumerable: true, get: function() {
      return loginticket_1.LoginTicket;
    } });
    var refreshclient_1 = require_refreshclient();
    Object.defineProperty(exports, "UserRefreshClient", { enumerable: true, get: function() {
      return refreshclient_1.UserRefreshClient;
    } });
    var awsclient_1 = require_awsclient();
    Object.defineProperty(exports, "AwsClient", { enumerable: true, get: function() {
      return awsclient_1.AwsClient;
    } });
    var awsrequestsigner_1 = require_awsrequestsigner();
    Object.defineProperty(exports, "AwsRequestSigner", { enumerable: true, get: function() {
      return awsrequestsigner_1.AwsRequestSigner;
    } });
    var identitypoolclient_1 = require_identitypoolclient();
    Object.defineProperty(exports, "IdentityPoolClient", { enumerable: true, get: function() {
      return identitypoolclient_1.IdentityPoolClient;
    } });
    var externalclient_1 = require_externalclient();
    Object.defineProperty(exports, "ExternalAccountClient", { enumerable: true, get: function() {
      return externalclient_1.ExternalAccountClient;
    } });
    var baseexternalclient_1 = require_baseexternalclient();
    Object.defineProperty(exports, "BaseExternalAccountClient", { enumerable: true, get: function() {
      return baseexternalclient_1.BaseExternalAccountClient;
    } });
    var downscopedclient_1 = require_downscopedclient();
    Object.defineProperty(exports, "DownscopedClient", { enumerable: true, get: function() {
      return downscopedclient_1.DownscopedClient;
    } });
    var pluggable_auth_client_1 = require_pluggable_auth_client();
    Object.defineProperty(exports, "PluggableAuthClient", { enumerable: true, get: function() {
      return pluggable_auth_client_1.PluggableAuthClient;
    } });
    Object.defineProperty(exports, "ExecutableError", { enumerable: true, get: function() {
      return pluggable_auth_client_1.ExecutableError;
    } });
    var passthrough_1 = require_passthrough();
    Object.defineProperty(exports, "PassThroughClient", { enumerable: true, get: function() {
      return passthrough_1.PassThroughClient;
    } });
    var transporters_1 = require_transporters();
    Object.defineProperty(exports, "DefaultTransporter", { enumerable: true, get: function() {
      return transporters_1.DefaultTransporter;
    } });
    var auth = new googleauth_1.GoogleAuth();
    exports.auth = auth;
  }
});

// ../node_modules/@google/genai/node_modules/ws/lib/constants.js
var require_constants2 = __commonJS({
  "../node_modules/@google/genai/node_modules/ws/lib/constants.js"(exports, module) {
    "use strict";
    var BINARY_TYPES = ["nodebuffer", "arraybuffer", "fragments"];
    var hasBlob = typeof Blob !== "undefined";
    if (hasBlob) BINARY_TYPES.push("blob");
    module.exports = {
      BINARY_TYPES,
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      hasBlob,
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
  }
});

// ../node_modules/@google/genai/node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "../node_modules/@google/genai/node_modules/ws/lib/buffer-util.js"(exports, module) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants2();
    var FastBuffer = Buffer[Symbol.species];
    function concat(list, totalLength) {
      if (list.length === 0) return EMPTY_BUFFER;
      if (list.length === 1) return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i2 = 0; i2 < list.length; i2++) {
        const buf = list[i2];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength) {
        return new FastBuffer(target.buffer, target.byteOffset, offset);
      }
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i2 = 0; i2 < length; i2++) {
        output[offset + i2] = source[i2] ^ mask[i2 & 3];
      }
    }
    function _unmask(buffer, mask) {
      for (let i2 = 0; i2 < buffer.length; i2++) {
        buffer[i2] ^= mask[i2 & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.length === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data)) return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = new FastBuffer(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    module.exports = {
      concat,
      mask: _mask,
      toArrayBuffer,
      toBuffer,
      unmask: _unmask
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil = __require("bufferutil");
        module.exports.mask = function(source, mask, output, offset, length) {
          if (length < 48) _mask(source, mask, output, offset, length);
          else bufferUtil.mask(source, mask, output, offset, length);
        };
        module.exports.unmask = function(buffer, mask) {
          if (buffer.length < 32) _unmask(buffer, mask);
          else bufferUtil.unmask(buffer, mask);
        };
      } catch (e2) {
      }
    }
  }
});

// ../node_modules/@google/genai/node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "../node_modules/@google/genai/node_modules/ws/lib/limiter.js"(exports, module) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency) return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module.exports = Limiter;
  }
});

// ../node_modules/@google/genai/node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "../node_modules/@google/genai/node_modules/ws/lib/permessage-deflate.js"(exports, module) {
    "use strict";
    var zlib2 = __require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants2();
    var FastBuffer = Buffer[Symbol.species];
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed if context takeover is disabled
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib2.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib2.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin) this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib2.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib2.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib2.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin) {
            data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
          }
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      if (this[kError]) {
        this[kCallback](this[kError]);
        return;
      }
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// ../node_modules/@google/genai/node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "../node_modules/@google/genai/node_modules/ws/lib/validation.js"(exports, module) {
    "use strict";
    var { isUtf8 } = __require("buffer");
    var { hasBlob } = require_constants2();
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i2 = 0;
      while (i2 < len) {
        if ((buf[i2] & 128) === 0) {
          i2++;
        } else if ((buf[i2] & 224) === 192) {
          if (i2 + 1 === len || (buf[i2 + 1] & 192) !== 128 || (buf[i2] & 254) === 192) {
            return false;
          }
          i2 += 2;
        } else if ((buf[i2] & 240) === 224) {
          if (i2 + 2 >= len || (buf[i2 + 1] & 192) !== 128 || (buf[i2 + 2] & 192) !== 128 || buf[i2] === 224 && (buf[i2 + 1] & 224) === 128 || // Overlong
          buf[i2] === 237 && (buf[i2 + 1] & 224) === 160) {
            return false;
          }
          i2 += 3;
        } else if ((buf[i2] & 248) === 240) {
          if (i2 + 3 >= len || (buf[i2 + 1] & 192) !== 128 || (buf[i2 + 2] & 192) !== 128 || (buf[i2 + 3] & 192) !== 128 || buf[i2] === 240 && (buf[i2 + 1] & 240) === 128 || // Overlong
          buf[i2] === 244 && buf[i2 + 1] > 143 || buf[i2] > 244) {
            return false;
          }
          i2 += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    function isBlob3(value) {
      return hasBlob && typeof value === "object" && typeof value.arrayBuffer === "function" && typeof value.type === "string" && typeof value.stream === "function" && (value[Symbol.toStringTag] === "Blob" || value[Symbol.toStringTag] === "File");
    }
    module.exports = {
      isBlob: isBlob3,
      isValidStatusCode,
      isValidUTF8: _isValidUTF8,
      tokenChars
    };
    if (isUtf8) {
      module.exports.isValidUTF8 = function(buf) {
        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
      };
    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF8 = __require("utf-8-validate");
        module.exports.isValidUTF8 = function(buf) {
          return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
        };
      } catch (e2) {
      }
    }
  }
});

// ../node_modules/@google/genai/node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "../node_modules/@google/genai/node_modules/ws/lib/receiver.js"(exports, module) {
    "use strict";
    var { Writable } = __require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants2();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var FastBuffer = Buffer[Symbol.species];
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var DEFER_EVENT = 6;
    var Receiver2 = class extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {Object} [options] Options object
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {String} [options.binaryType=nodebuffer] The type for binary data
       * @param {Object} [options.extensions] An object containing the negotiated
       *     extensions
       * @param {Boolean} [options.isServer=false] Specifies whether to operate in
       *     client or server mode
       * @param {Number} [options.maxPayload=0] The maximum allowed message length
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       */
      constructor(options = {}) {
        super();
        this._allowSynchronousEvents = options.allowSynchronousEvents !== void 0 ? options.allowSynchronousEvents : true;
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._errored = false;
        this._loop = false;
        this._state = GET_INFO;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO) return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n2) {
        this._bufferedBytes -= n2;
        if (n2 === this._buffers[0].length) return this._buffers.shift();
        if (n2 < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = new FastBuffer(
            buf.buffer,
            buf.byteOffset + n2,
            buf.length - n2
          );
          return new FastBuffer(buf.buffer, buf.byteOffset, n2);
        }
        const dst = Buffer.allocUnsafe(n2);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n2;
          if (n2 >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n2), offset);
            this._buffers[0] = new FastBuffer(
              buf.buffer,
              buf.byteOffset + n2,
              buf.length - n2
            );
          }
          n2 -= buf.length;
        } while (n2 > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              this.getInfo(cb);
              break;
            case GET_PAYLOAD_LENGTH_16:
              this.getPayloadLength16(cb);
              break;
            case GET_PAYLOAD_LENGTH_64:
              this.getPayloadLength64(cb);
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              this.getData(cb);
              break;
            case INFLATING:
            case DEFER_EVENT:
              this._loop = false;
              return;
          }
        } while (this._loop);
        if (!this._errored) cb();
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @param {Function} cb Callback
       * @private
       */
      getInfo(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          const error = this.createError(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
          cb(error);
          return;
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          const error = this.createError(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
          cb(error);
          return;
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            const error = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error);
            return;
          }
          if (!this._fragmented) {
            const error = this.createError(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error);
            return;
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            const error = this.createError(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error);
            return;
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            const error = this.createError(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
            cb(error);
            return;
          }
          if (compressed) {
            const error = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error);
            return;
          }
          if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
            const error = this.createError(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
            cb(error);
            return;
          }
        } else {
          const error = this.createError(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
          cb(error);
          return;
        }
        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            const error = this.createError(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
            cb(error);
            return;
          }
        } else if (this._masked) {
          const error = this.createError(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
          cb(error);
          return;
        }
        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
        else this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength16(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength64(cb) {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          const error = this.createError(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
          cb(error);
          return;
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        this.haveLength(cb);
      }
      /**
       * Payload length has been read.
       *
       * @param {Function} cb Callback
       * @private
       */
      haveLength(cb) {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            const error = this.createError(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
            cb(error);
            return;
          }
        }
        if (this._masked) this._state = GET_MASK;
        else this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @private
       */
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7) {
          this.controlMessage(data, cb);
          return;
        }
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        this.dataMessage(cb);
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err) return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              const error = this.createError(
                RangeError,
                "Max payload size exceeded",
                false,
                1009,
                "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
              );
              cb(error);
              return;
            }
            this._fragments.push(buf);
          }
          this.dataMessage(cb);
          if (this._state === GET_INFO) this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @param {Function} cb Callback
       * @private
       */
      dataMessage(cb) {
        if (!this._fin) {
          this._state = GET_INFO;
          return;
        }
        const messageLength = this._messageLength;
        const fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];
        if (this._opcode === 2) {
          let data;
          if (this._binaryType === "nodebuffer") {
            data = concat(fragments, messageLength);
          } else if (this._binaryType === "arraybuffer") {
            data = toArrayBuffer(concat(fragments, messageLength));
          } else if (this._binaryType === "blob") {
            data = new Blob(fragments);
          } else {
            data = fragments;
          }
          if (this._allowSynchronousEvents) {
            this.emit("message", data, true);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", data, true);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        } else {
          const buf = concat(fragments, messageLength);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error = this.createError(
              Error,
              "invalid UTF-8 sequence",
              true,
              1007,
              "WS_ERR_INVALID_UTF8"
            );
            cb(error);
            return;
          }
          if (this._state === INFLATING || this._allowSynchronousEvents) {
            this.emit("message", buf, false);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", buf, false);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        }
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data, cb) {
        if (this._opcode === 8) {
          if (data.length === 0) {
            this._loop = false;
            this.emit("conclude", 1005, EMPTY_BUFFER);
            this.end();
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              const error = this.createError(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
              cb(error);
              return;
            }
            const buf = new FastBuffer(
              data.buffer,
              data.byteOffset + 2,
              data.length - 2
            );
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              const error = this.createError(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
              cb(error);
              return;
            }
            this._loop = false;
            this.emit("conclude", code, buf);
            this.end();
          }
          this._state = GET_INFO;
          return;
        }
        if (this._allowSynchronousEvents) {
          this.emit(this._opcode === 9 ? "ping" : "pong", data);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit(this._opcode === 9 ? "ping" : "pong", data);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
      /**
       * Builds an error object.
       *
       * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
       * @param {String} message The error message
       * @param {Boolean} prefix Specifies whether or not to add a default prefix to
       *     `message`
       * @param {Number} statusCode The status code
       * @param {String} errorCode The exposed error code
       * @return {(Error|RangeError)} The error
       * @private
       */
      createError(ErrorCtor, message, prefix, statusCode, errorCode) {
        this._loop = false;
        this._errored = true;
        const err = new ErrorCtor(
          prefix ? `Invalid WebSocket frame: ${message}` : message
        );
        Error.captureStackTrace(err, this.createError);
        err.code = errorCode;
        err[kStatusCode] = statusCode;
        return err;
      }
    };
    module.exports = Receiver2;
  }
});

// ../node_modules/@google/genai/node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "../node_modules/@google/genai/node_modules/ws/lib/sender.js"(exports, module) {
    "use strict";
    var { Duplex } = __require("stream");
    var { randomFillSync } = __require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER, kWebSocket, NOOP } = require_constants2();
    var { isBlob: isBlob3, isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var kByteLength = Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var RANDOM_POOL_SIZE = 8 * 1024;
    var randomPool;
    var randomPoolPointer = RANDOM_POOL_SIZE;
    var DEFAULT = 0;
    var DEFLATING = 1;
    var GET_BLOB_DATA = 2;
    var Sender2 = class _Sender {
      /**
       * Creates a Sender instance.
       *
       * @param {Duplex} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Function} [generateMask] The function used to generate the masking
       *     key
       */
      constructor(socket, extensions, generateMask) {
        this._extensions = extensions || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._queue = [];
        this._state = DEFAULT;
        this.onerror = NOOP;
        this[kWebSocket] = void 0;
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {(Buffer|String)} data The data to frame
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {(Buffer|String)[]} The framed data
       * @public
       */
      static frame(data, options) {
        let mask;
        let merge = false;
        let offset = 2;
        let skipMasking = false;
        if (options.mask) {
          mask = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask);
          } else {
            if (randomPoolPointer === RANDOM_POOL_SIZE) {
              if (randomPool === void 0) {
                randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
              }
              randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
              randomPoolPointer = 0;
            }
            mask[0] = randomPool[randomPoolPointer++];
            mask[1] = randomPool[randomPoolPointer++];
            mask[2] = randomPool[randomPoolPointer++];
            mask[3] = randomPool[randomPoolPointer++];
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        let dataLength;
        if (typeof data === "string") {
          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
            dataLength = options[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1) target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options.mask) return [target, data];
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking) return [target, data];
        if (merge) {
          applyMask(data, mask, target, offset, dataLength);
          return [target];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [target, data];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data, mask, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data === "string") {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }
        const options = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, buf, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(buf, options), cb);
        }
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob3(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (isBlob3(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options, cb]);
          } else {
            this.getBlobData(data, false, options, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob3(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (isBlob3(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options, cb]);
          } else {
            this.getBlobData(data, false, options, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob3(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin) this._firstFragment = true;
        const opts = {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1
        };
        if (isBlob3(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
          } else {
            this.getBlobData(data, this._compress, opts, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, this._compress, opts, cb]);
        } else {
          this.dispatch(data, this._compress, opts, cb);
        }
      }
      /**
       * Gets the contents of a blob as binary data.
       *
       * @param {Blob} blob The blob
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     the data
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      getBlobData(blob, compress, options, cb) {
        this._bufferedBytes += options[kByteLength];
        this._state = GET_BLOB_DATA;
        blob.arrayBuffer().then((arrayBuffer) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while the blob was being read"
            );
            process.nextTick(callCallbacks, this, err, cb);
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          const data = toBuffer(arrayBuffer);
          if (!compress) {
            this._state = DEFAULT;
            this.sendFrame(_Sender.frame(data, options), cb);
            this.dequeue();
          } else {
            this.dispatch(data, compress, options, cb);
          }
        }).catch((err) => {
          process.nextTick(onError, this, err, cb);
        });
      }
      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(_Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._state = DEFLATING;
        perMessageDeflate.compress(data, options.fin, (_2, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            callCallbacks(this, err, cb);
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          this._state = DEFAULT;
          options.readOnly = false;
          this.sendFrame(_Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (this._state === DEFAULT && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {(Buffer | String)[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module.exports = Sender2;
    function callCallbacks(sender, err, cb) {
      if (typeof cb === "function") cb(err);
      for (let i2 = 0; i2 < sender._queue.length; i2++) {
        const params = sender._queue[i2];
        const callback = params[params.length - 1];
        if (typeof callback === "function") callback(err);
      }
    }
    function onError(sender, err, cb) {
      callCallbacks(sender, err, cb);
      sender.onerror(err);
    }
  }
});

// ../node_modules/@google/genai/node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "../node_modules/@google/genai/node_modules/ws/lib/event-target.js"(exports, module) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants2();
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError = Symbol("kError");
    var kMessage = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @throws {TypeError} If the `type` argument is not specified
       */
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      /**
       * @type {*}
       */
      get target() {
        return this[kTarget];
      }
      /**
       * @type {String}
       */
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event.prototype, "target", { enumerable: true });
    Object.defineProperty(Event.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {Number} [options.code=0] The status code explaining why the
       *     connection was closed
       * @param {String} [options.reason=''] A human-readable string explaining why
       *     the connection was closed
       * @param {Boolean} [options.wasClean=false] Indicates whether or not the
       *     connection was cleanly closed
       */
      constructor(type, options = {}) {
        super(type);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? "" : options.reason;
        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
      }
      /**
       * @type {Number}
       */
      get code() {
        return this[kCode];
      }
      /**
       * @type {String}
       */
      get reason() {
        return this[kReason];
      }
      /**
       * @type {Boolean}
       */
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    var ErrorEvent = class extends Event {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.error=null] The error that generated this event
       * @param {String} [options.message=''] The error message
       */
      constructor(type, options = {}) {
        super(type);
        this[kError] = options.error === void 0 ? null : options.error;
        this[kMessage] = options.message === void 0 ? "" : options.message;
      }
      /**
       * @type {*}
       */
      get error() {
        return this[kError];
      }
      /**
       * @type {String}
       */
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.data=null] The message content
       */
      constructor(type, options = {}) {
        super(type);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      /**
       * @type {*}
       */
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {(Function|Object)} handler The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, handler, options = {}) {
        for (const listener of this.listeners(type)) {
          if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            return;
          }
        }
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data : data.toString()
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "close") {
          wrapper = function onClose(code, message) {
            const event = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "error") {
          wrapper = function onError(error) {
            const event = new ErrorEvent("error", {
              error,
              message: error.message
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event = new Event("open");
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = handler;
        if (options.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {(Function|Object)} handler The listener to remove
       * @public
       */
      removeEventListener(type, handler) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      }
    };
    module.exports = {
      CloseEvent,
      ErrorEvent,
      Event,
      EventTarget,
      MessageEvent
    };
    function callListener(listener, thisArg, event) {
      if (typeof listener === "object" && listener.handleEvent) {
        listener.handleEvent.call(listener, event);
      } else {
        listener.call(thisArg, event);
      }
    }
  }
});

// ../node_modules/@google/genai/node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "../node_modules/@google/genai/node_modules/ws/lib/extension.js"(exports, module) {
    "use strict";
    var { tokenChars } = require_validation();
    function push(dest, name, elem) {
      if (dest[name] === void 0) dest[name] = [elem];
      else dest[name].push(elem);
    }
    function parse2(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code = -1;
      let end = -1;
      let i2 = 0;
      for (; i2 < header.length; i2++) {
        code = header.charCodeAt(i2);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i2;
          } else if (i2 !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start !== -1) end = i2;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (end === -1) end = i2;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i2;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1) end = i2;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (end === -1) end = i2;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i2);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (start === -1) start = i2;
            else if (!mustUnescape) mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1) start = i2;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i2;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
          } else if (code === 34 && header.charCodeAt(i2 - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i2;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1) end = i2;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (end === -1) end = i2;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
        }
      }
      if (start === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1) end = i2;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations)) configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k2) => {
              let values = params[k2];
              if (!Array.isArray(values)) values = [values];
              return values.map((v2) => v2 === true ? k2 : `${k2}=${v2}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module.exports = { format, parse: parse2 };
  }
});

// ../node_modules/@google/genai/node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "../node_modules/@google/genai/node_modules/ws/lib/websocket.js"(exports, module) {
    "use strict";
    var EventEmitter2 = __require("events");
    var https2 = __require("https");
    var http2 = __require("http");
    var net = __require("net");
    var tls = __require("tls");
    var { randomBytes, createHash } = __require("crypto");
    var { Duplex, Readable: Readable5 } = __require("stream");
    var { URL: URL4 } = __require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver2 = require_receiver();
    var Sender2 = require_sender();
    var { isBlob: isBlob3 } = require_validation();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants2();
    var {
      EventTarget: { addEventListener, removeEventListener }
    } = require_event_target();
    var { format, parse: parse2 } = require_extension();
    var { toBuffer } = require_buffer_util();
    var closeTimeout = 30 * 1e3;
    var kAborted = Symbol("kAborted");
    var protocolVersions = [8, 13];
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var WebSocket2 = class _WebSocket extends EventEmitter2 {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._errorEmitted = false;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = _WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._autoPong = options.autoPong;
          this._isServer = true;
        }
      }
      /**
       * For historical reasons, the custom "nodebuffer" type is used by the default
       * instead of "blob".
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type)) return;
        this._binaryType = type;
        if (this._receiver) this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket) return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Boolean}
       */
      get isPaused() {
        return this._paused;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
      setSocket(socket, head, options) {
        const receiver = new Receiver2({
          allowSynchronousEvents: options.allowSynchronousEvents,
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation
        });
        const sender = new Sender2(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._sender = sender;
        this._socket = socket;
        receiver[kWebSocket] = this;
        sender[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        sender.onerror = senderOnError;
        if (socket.setTimeout) socket.setTimeout(0);
        if (socket.setNoDelay) socket.setNoDelay();
        if (head.length > 0) socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = _WebSocket.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = _WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = _WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
      close(code, data) {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this.readyState === _WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = _WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err) return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        setCloseTimer(this);
      }
      /**
       * Pause the socket.
       *
       * @public
       */
      pause() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Resume the socket.
       *
       * @public
       */
      resume() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain) this._socket.resume();
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data, options, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this._socket) {
          this._readyState = _WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket2, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket2.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket2.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== "function") return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket2.prototype.addEventListener = addEventListener;
    WebSocket2.prototype.removeEventListener = removeEventListener;
    module.exports = WebSocket2;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        allowSynchronousEvents: true,
        autoPong: true,
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: "GET",
        host: void 0,
        path: void 0,
        port: void 0
      };
      websocket._autoPong = opts.autoPong;
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL4) {
        parsedUrl = address;
      } else {
        try {
          parsedUrl = new URL4(address);
        } catch (e2) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
      }
      if (parsedUrl.protocol === "http:") {
        parsedUrl.protocol = "ws:";
      } else if (parsedUrl.protocol === "https:") {
        parsedUrl.protocol = "wss:";
      }
      websocket._url = parsedUrl.href;
      const isSecure = parsedUrl.protocol === "wss:";
      const isIpcUrl = parsedUrl.protocol === "ws+unix:";
      let invalidUrlMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
        invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", "http:", "https:", or "ws+unix:"`;
      } else if (isIpcUrl && !parsedUrl.pathname) {
        invalidUrlMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidUrlMessage = "The URL contains a fragment identifier";
      }
      if (invalidUrlMessage) {
        const err = new SyntaxError(invalidUrlMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const request = isSecure ? https2.request : http2.request;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        ...opts.headers,
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket"
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError(
              "An invalid or duplicated subprotocol was specified"
            );
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isIpcUrl) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req;
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalIpc = isIpcUrl;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else if (websocket.listenerCount("redirect") === 0) {
          const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost) delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
        req = websocket._req = request(opts);
        if (websocket._redirects) {
          websocket.emit("redirect", websocket.url, req);
        }
      } else {
        req = websocket._req = request(opts);
      }
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req[kAborted]) return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL4(location, address);
          } catch (e2) {
            const err = new SyntaxError(`Invalid URL: ${location}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket2.CONNECTING) return;
        req = websocket._req = null;
        const upgrade = res.headers.upgrade;
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt) websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse2(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          allowSynchronousEvents: opts.allowSynchronousEvents,
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
      if (opts.finishRequest) {
        opts.finishRequest(req, websocket);
      } else {
        req.end();
      }
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket2.CLOSING;
      websocket._errorEmitted = true;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket2.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream[kAborted] = true;
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        process.nextTick(emitErrorAndClose, websocket, err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = isBlob3(data) ? data.size : toBuffer(data).length;
        if (websocket._socket) websocket._sender._bufferedBytes += length;
        else websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        process.nextTick(cb, err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0) return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005) websocket.close();
      else websocket.close(code, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused) websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      if (!websocket._errorEmitted) {
        websocket._errorEmitted = true;
        websocket.emit("error", err);
      }
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data, isBinary) {
      this[kWebSocket].emit("message", data, isBinary);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
      stream.resume();
    }
    function senderOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket.readyState === WebSocket2.CLOSED) return;
      if (websocket.readyState === WebSocket2.OPEN) {
        websocket._readyState = WebSocket2.CLOSING;
        setCloseTimer(websocket);
      }
      this._socket.end();
      if (!websocket._errorEmitted) {
        websocket._errorEmitted = true;
        websocket.emit("error", err);
      }
    }
    function setCloseTimer(websocket) {
      websocket._closeTimer = setTimeout(
        websocket._socket.destroy.bind(websocket._socket),
        closeTimeout
      );
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket2.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket2.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket2.CLOSING;
        this.destroy();
      }
    }
  }
});

// ../node_modules/@google/genai/node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "../node_modules/@google/genai/node_modules/ws/lib/stream.js"(exports, module) {
    "use strict";
    var WebSocket2 = require_websocket();
    var { Duplex } = __require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream2(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg, isBinary) {
        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data)) ws.pause();
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed) return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed) return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called) callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy) ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open2() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null) return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted) duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused) ws.resume();
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open2() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module.exports = createWebSocketStream2;
  }
});

// ../node_modules/@google/genai/node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
  "../node_modules/@google/genai/node_modules/ws/lib/subprotocol.js"(exports, module) {
    "use strict";
    var { tokenChars } = require_validation();
    function parse2(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start = -1;
      let end = -1;
      let i2 = 0;
      for (i2; i2 < header.length; i2++) {
        const code = header.charCodeAt(i2);
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1) start = i2;
        } else if (i2 !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1) end = i2;
        } else if (code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
          if (end === -1) end = i2;
          const protocol2 = header.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i2}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start, i2);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    module.exports = { parse: parse2 };
  }
});

// ../node_modules/@google/genai/node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "../node_modules/@google/genai/node_modules/ws/lib/websocket-server.js"(exports, module) {
    "use strict";
    var EventEmitter2 = __require("events");
    var http2 = __require("http");
    var { Duplex } = __require("stream");
    var { createHash } = __require("crypto");
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket2 = require_websocket();
    var { GUID, kWebSocket } = require_constants2();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer2 = class extends EventEmitter2 {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Boolean} [options.autoPong=true] Specifies whether or not to
       *     automatically send a pong in response to a ping
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
       *     class to use. It must be the `WebSocket` class or class that extends it
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options, callback) {
        super();
        options = {
          allowSynchronousEvents: true,
          autoPong: true,
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket: WebSocket2,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http2.createServer((req, res) => {
            const body = http2.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true) options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server) return null;
        return this._server.address();
      }
      /**
       * Stop the server from accepting new connections and emit the `'close'` event
       * when all existing connections are closed.
       *
       * @param {Function} [cb] A one-time listener for the `'close'` event
       * @public
       */
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb) this.once("close", cb);
        if (this._state === CLOSING) return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path) return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"];
        const upgrade = req.headers.upgrade;
        const version2 = +req.headers["sec-websocket-version"];
        if (req.method !== "GET") {
          const message = "Invalid HTTP method";
          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
          return;
        }
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          const message = "Invalid Upgrade header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (key === void 0 || !keyRegex.test(key)) {
          const message = "Missing or invalid Sec-WebSocket-Key header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (version2 !== 13 && version2 !== 8) {
          const message = "Missing or invalid Sec-WebSocket-Version header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message, {
            "Sec-WebSocket-Version": "13, 8"
          });
          return;
        }
        if (!this.shouldHandle(req)) {
          abortHandshake(socket, 400);
          return;
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Protocol header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version2 === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(
                extensions,
                key,
                protocols,
                req,
                socket,
                head,
                cb
              );
            });
            return;
          }
          if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {Object} extensions The accepted extensions
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Set} protocols The subprotocols
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable) return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING) return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null, void 0, this.options);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          allowSynchronousEvents: this.options.allowSynchronousEvents,
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module.exports = WebSocketServer2;
    function addListeners(server, map) {
      for (const event of Object.keys(map)) server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      message = message || http2.STATUS_CODES[code];
      headers = {
        Connection: "close",
        "Content-Type": "text/html",
        "Content-Length": Buffer.byteLength(message),
        ...headers
      };
      socket.once("finish", socket.destroy);
      socket.end(
        `HTTP/1.1 ${code} ${http2.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h2) => `${h2}: ${headers[h2]}`).join("\r\n") + "\r\n\r\n" + message
      );
    }
    function abortHandshakeOrEmitwsClientError(server, req, socket, code, message, headers) {
      if (server.listenerCount("wsClientError")) {
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
        server.emit("wsClientError", err, socket, req);
      } else {
        abortHandshake(socket, code, message, headers);
      }
    }
  }
});

// ../node_modules/@mistralai/mistralai/lib/url.js
var require_url = __commonJS({
  "../node_modules/@mistralai/mistralai/lib/url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pathToFunc = pathToFunc;
    var hasOwn3 = Object.prototype.hasOwnProperty;
    function pathToFunc(pathPattern, options) {
      const paramRE = /\{([a-zA-Z0-9_]+?)\}/g;
      return function buildURLPath(params = {}) {
        return pathPattern.replace(paramRE, function(_2, placeholder) {
          if (!hasOwn3.call(params, placeholder)) {
            throw new Error(`Parameter '${placeholder}' is required`);
          }
          const value = params[placeholder];
          if (typeof value !== "string" && typeof value !== "number") {
            throw new Error(`Parameter '${placeholder}' must be a string or number`);
          }
          return options?.charEncoding === "percent" ? encodeURIComponent(`${value}`) : `${value}`;
        });
      };
    }
  }
});

// ../node_modules/@mistralai/mistralai/lib/config.js
var require_config = __commonJS({
  "../node_modules/@mistralai/mistralai/lib/config.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SDK_METADATA = exports.ServerList = exports.ServerEu = void 0;
    exports.serverURLFromOptions = serverURLFromOptions;
    var url_js_1 = require_url();
    exports.ServerEu = "eu";
    exports.ServerList = {
      [exports.ServerEu]: "https://api.mistral.ai"
    };
    function serverURLFromOptions(options) {
      let serverURL = options.serverURL;
      const params = {};
      if (!serverURL) {
        const server = options.server ?? exports.ServerEu;
        serverURL = exports.ServerList[server] || "";
      }
      const u2 = (0, url_js_1.pathToFunc)(serverURL)(params);
      return new URL(u2);
    }
    exports.SDK_METADATA = {
      language: "typescript",
      openapiDocVersion: "1.0.0",
      sdkVersion: "1.7.5",
      genVersion: "2.548.6",
      userAgent: "speakeasy-sdk/typescript 1.7.5 2.548.6 1.0.0 @mistralai/mistralai"
    };
  }
});

// ../node_modules/@mistralai/mistralai/lib/files.js
var require_files = __commonJS({
  "../node_modules/@mistralai/mistralai/lib/files.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readableStreamToArrayBuffer = readableStreamToArrayBuffer;
    async function readableStreamToArrayBuffer(readable) {
      const reader = readable.getReader();
      const chunks = [];
      let totalLength = 0;
      let done = false;
      while (!done) {
        const { value, done: doneReading } = await reader.read();
        if (doneReading) {
          done = true;
        } else {
          chunks.push(value);
          totalLength += value.length;
        }
      }
      const concatenatedChunks = new Uint8Array(totalLength);
      let offset = 0;
      for (const chunk of chunks) {
        concatenatedChunks.set(chunk, offset);
        offset += chunk.length;
      }
      return concatenatedChunks.buffer;
    }
  }
});

// ../node_modules/@mistralai/mistralai/hooks/custom_user_agent.js
var require_custom_user_agent = __commonJS({
  "../node_modules/@mistralai/mistralai/hooks/custom_user_agent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CustomUserAgentHook = void 0;
    var config_1 = require_config();
    var CustomUserAgentHook = class {
      beforeRequest(_2, request) {
        const version2 = config_1.SDK_METADATA.sdkVersion;
        const ua = `mistral-client-typescript/${version2}`;
        request.headers.set("user-agent", ua);
        if (!request.headers.get("user-agent")) {
          request.headers.set("x-mistral-user-agent", ua);
        }
        return request;
      }
    };
    exports.CustomUserAgentHook = CustomUserAgentHook;
  }
});

// ../node_modules/@mistralai/mistralai/hooks/deprecation_warning.js
var require_deprecation_warning = __commonJS({
  "../node_modules/@mistralai/mistralai/hooks/deprecation_warning.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeprecationWarningHook = void 0;
    var HEADER_MODEL_DEPRECATION_TIMESTAMP = "x-model-deprecation-timestamp";
    var DeprecationWarningHook = class {
      afterSuccess(_2, response) {
        if (response.headers.has(HEADER_MODEL_DEPRECATION_TIMESTAMP)) {
          response.clone().json().then((body) => {
            const model = body.model;
            console.warn(`WARNING: The model ${model} is deprecated and will be removed on ${response.headers.get(HEADER_MODEL_DEPRECATION_TIMESTAMP)}. Please refer to https://docs.mistral.ai/getting-started/models/#api-versioning for more information.`);
          });
        }
        return response;
      }
    };
    exports.DeprecationWarningHook = DeprecationWarningHook;
  }
});

// ../node_modules/@mistralai/mistralai/hooks/registration.js
var require_registration = __commonJS({
  "../node_modules/@mistralai/mistralai/hooks/registration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.initHooks = initHooks;
    var custom_user_agent_1 = require_custom_user_agent();
    var deprecation_warning_1 = require_deprecation_warning();
    function initHooks(hooks) {
      const customUserAgentHook = new custom_user_agent_1.CustomUserAgentHook();
      hooks.registerBeforeRequestHook(customUserAgentHook);
      const deprecationWarningHook = new deprecation_warning_1.DeprecationWarningHook();
      hooks.registerAfterSuccessHook(deprecationWarningHook);
    }
  }
});

// ../node_modules/@mistralai/mistralai/hooks/hooks.js
var require_hooks = __commonJS({
  "../node_modules/@mistralai/mistralai/hooks/hooks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SDKHooks = void 0;
    var registration_js_1 = require_registration();
    var SDKHooks = class {
      constructor() {
        this.sdkInitHooks = [];
        this.beforeCreateRequestHooks = [];
        this.beforeRequestHooks = [];
        this.afterSuccessHooks = [];
        this.afterErrorHooks = [];
        const presetHooks = [];
        for (const hook of presetHooks) {
          if ("sdkInit" in hook) {
            this.registerSDKInitHook(hook);
          }
          if ("beforeCreateRequest" in hook) {
            this.registerBeforeCreateRequestHook(hook);
          }
          if ("beforeRequest" in hook) {
            this.registerBeforeRequestHook(hook);
          }
          if ("afterSuccess" in hook) {
            this.registerAfterSuccessHook(hook);
          }
          if ("afterError" in hook) {
            this.registerAfterErrorHook(hook);
          }
        }
        (0, registration_js_1.initHooks)(this);
      }
      registerSDKInitHook(hook) {
        this.sdkInitHooks.push(hook);
      }
      registerBeforeCreateRequestHook(hook) {
        this.beforeCreateRequestHooks.push(hook);
      }
      registerBeforeRequestHook(hook) {
        this.beforeRequestHooks.push(hook);
      }
      registerAfterSuccessHook(hook) {
        this.afterSuccessHooks.push(hook);
      }
      registerAfterErrorHook(hook) {
        this.afterErrorHooks.push(hook);
      }
      sdkInit(opts) {
        return this.sdkInitHooks.reduce((opts2, hook) => hook.sdkInit(opts2), opts);
      }
      beforeCreateRequest(hookCtx, input) {
        let inp = input;
        for (const hook of this.beforeCreateRequestHooks) {
          inp = hook.beforeCreateRequest(hookCtx, inp);
        }
        return inp;
      }
      async beforeRequest(hookCtx, request) {
        let req = request;
        for (const hook of this.beforeRequestHooks) {
          req = await hook.beforeRequest(hookCtx, req);
        }
        return req;
      }
      async afterSuccess(hookCtx, response) {
        let res = response;
        for (const hook of this.afterSuccessHooks) {
          res = await hook.afterSuccess(hookCtx, res);
        }
        return res;
      }
      async afterError(hookCtx, response, error) {
        let res = response;
        let err = error;
        for (const hook of this.afterErrorHooks) {
          const result = await hook.afterError(hookCtx, res, err);
          res = result.response;
          err = result.error;
        }
        return { response: res, error: err };
      }
    };
    exports.SDKHooks = SDKHooks;
  }
});

// ../node_modules/@mistralai/mistralai/models/errors/httpclienterrors.js
var require_httpclienterrors = __commonJS({
  "../node_modules/@mistralai/mistralai/models/errors/httpclienterrors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectionError = exports.RequestTimeoutError = exports.RequestAbortedError = exports.InvalidRequestError = exports.UnexpectedClientError = exports.HTTPClientError = void 0;
    var HTTPClientError = class extends Error {
      constructor(message, opts) {
        let msg = message;
        if (opts?.cause) {
          msg += `: ${opts.cause}`;
        }
        super(msg, opts);
        this.name = "HTTPClientError";
        if (typeof this.cause === "undefined") {
          this.cause = opts?.cause;
        }
      }
    };
    exports.HTTPClientError = HTTPClientError;
    var UnexpectedClientError = class extends HTTPClientError {
      constructor() {
        super(...arguments);
        this.name = "UnexpectedClientError";
      }
    };
    exports.UnexpectedClientError = UnexpectedClientError;
    var InvalidRequestError = class extends HTTPClientError {
      constructor() {
        super(...arguments);
        this.name = "InvalidRequestError";
      }
    };
    exports.InvalidRequestError = InvalidRequestError;
    var RequestAbortedError = class extends HTTPClientError {
      constructor() {
        super(...arguments);
        this.name = "RequestAbortedError";
      }
    };
    exports.RequestAbortedError = RequestAbortedError;
    var RequestTimeoutError = class extends HTTPClientError {
      constructor() {
        super(...arguments);
        this.name = "RequestTimeoutError";
      }
    };
    exports.RequestTimeoutError = RequestTimeoutError;
    var ConnectionError = class extends HTTPClientError {
      constructor() {
        super(...arguments);
        this.name = "ConnectionError";
      }
    };
    exports.ConnectionError = ConnectionError;
  }
});

// ../node_modules/@mistralai/mistralai/types/fp.js
var require_fp = __commonJS({
  "../node_modules/@mistralai/mistralai/types/fp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OK = OK;
    exports.ERR = ERR;
    exports.unwrap = unwrap;
    exports.unwrapAsync = unwrapAsync;
    function OK(value) {
      return { ok: true, value };
    }
    function ERR(error) {
      return { ok: false, error };
    }
    function unwrap(r2) {
      if (!r2.ok) {
        throw r2.error;
      }
      return r2.value;
    }
    async function unwrapAsync(pr2) {
      const r2 = await pr2;
      if (!r2.ok) {
        throw r2.error;
      }
      return r2.value;
    }
  }
});

// ../node_modules/@mistralai/mistralai/lib/base64.js
var require_base64 = __commonJS({
  "../node_modules/@mistralai/mistralai/lib/base64.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zodInbound = exports.zodOutbound = void 0;
    exports.bytesToBase64 = bytesToBase64;
    exports.bytesFromBase64 = bytesFromBase64;
    exports.stringToBytes = stringToBytes2;
    exports.stringFromBytes = stringFromBytes;
    exports.stringToBase64 = stringToBase64;
    exports.stringFromBase64 = stringFromBase64;
    var z4 = __importStar(__require("zod"));
    function bytesToBase64(u8arr) {
      return btoa(String.fromCodePoint(...u8arr));
    }
    function bytesFromBase64(encoded) {
      return Uint8Array.from(atob(encoded), (c2) => c2.charCodeAt(0));
    }
    function stringToBytes2(str) {
      return new TextEncoder().encode(str);
    }
    function stringFromBytes(u8arr) {
      return new TextDecoder().decode(u8arr);
    }
    function stringToBase64(str) {
      return bytesToBase64(stringToBytes2(str));
    }
    function stringFromBase64(b64str) {
      return stringFromBytes(bytesFromBase64(b64str));
    }
    exports.zodOutbound = z4.instanceof(Uint8Array).or(z4.string().transform(stringToBytes2));
    exports.zodInbound = z4.instanceof(Uint8Array).or(z4.string().transform(bytesFromBase64));
  }
});

// ../node_modules/@mistralai/mistralai/lib/is-plain-object.js
var require_is_plain_object = __commonJS({
  "../node_modules/@mistralai/mistralai/lib/is-plain-object.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isPlainObject = isPlainObject3;
    function isPlainObject3(value) {
      if (typeof value !== "object" || value === null) {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
    }
  }
});

// ../node_modules/@mistralai/mistralai/lib/encodings.js
var require_encodings = __commonJS({
  "../node_modules/@mistralai/mistralai/lib/encodings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeDeepObjectQuery = exports.encodePipeDelimitedQuery = exports.encodeSpaceDelimitedQuery = exports.encodeFormQuery = exports.encodeJSONQuery = exports.encodeSimple = exports.encodePipeDelimited = exports.encodeSpaceDelimited = exports.encodeForm = exports.EncodingError = void 0;
    exports.encodeMatrix = encodeMatrix;
    exports.encodeLabel = encodeLabel;
    exports.encodeBodyForm = encodeBodyForm;
    exports.encodeDeepObject = encodeDeepObject;
    exports.encodeDeepObjectObject = encodeDeepObjectObject;
    exports.encodeJSON = encodeJSON;
    exports.queryJoin = queryJoin;
    exports.queryEncoder = queryEncoder;
    exports.appendForm = appendForm;
    var base64_js_1 = require_base64();
    var is_plain_object_js_1 = require_is_plain_object();
    var EncodingError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "EncodingError";
      }
    };
    exports.EncodingError = EncodingError;
    function encodeMatrix(key, value, options) {
      let out = "";
      const pairs = options?.explode ? explode(key, value) : [[key, value]];
      if (pairs.every(([_2, v2]) => v2 == null)) {
        return;
      }
      const encodeString = (v2) => {
        return options?.charEncoding === "percent" ? encodeURIComponent(v2) : v2;
      };
      const encodeValue = (v2) => encodeString(serializeValue(v2));
      pairs.forEach(([pk, pv]) => {
        let tmp = "";
        let encValue = null;
        if (pv == null) {
          return;
        } else if (Array.isArray(pv)) {
          encValue = mapDefined(pv, (v2) => `${encodeValue(v2)}`)?.join(",");
        } else if ((0, is_plain_object_js_1.isPlainObject)(pv)) {
          const mapped = mapDefinedEntries(Object.entries(pv), ([k2, v2]) => {
            return `,${encodeString(k2)},${encodeValue(v2)}`;
          });
          encValue = mapped?.join("").slice(1);
        } else {
          encValue = `${encodeValue(pv)}`;
        }
        if (encValue == null) {
          return;
        }
        const keyPrefix = encodeString(pk);
        tmp = `${keyPrefix}=${encValue}`;
        if (tmp === `${keyPrefix}=`) {
          tmp = tmp.slice(0, -1);
        }
        if (!tmp) {
          return;
        }
        out += `;${tmp}`;
      });
      return out;
    }
    function encodeLabel(key, value, options) {
      let out = "";
      const pairs = options?.explode ? explode(key, value) : [[key, value]];
      if (pairs.every(([_2, v2]) => v2 == null)) {
        return;
      }
      const encodeString = (v2) => {
        return options?.charEncoding === "percent" ? encodeURIComponent(v2) : v2;
      };
      const encodeValue = (v2) => encodeString(serializeValue(v2));
      pairs.forEach(([pk, pv]) => {
        let encValue = "";
        if (pv == null) {
          return;
        } else if (Array.isArray(pv)) {
          encValue = mapDefined(pv, (v2) => `${encodeValue(v2)}`)?.join(".");
        } else if ((0, is_plain_object_js_1.isPlainObject)(pv)) {
          const mapped = mapDefinedEntries(Object.entries(pv), ([k2, v2]) => {
            return `.${encodeString(k2)}.${encodeValue(v2)}`;
          });
          encValue = mapped?.join("").slice(1);
        } else {
          const k2 = options?.explode && (0, is_plain_object_js_1.isPlainObject)(value) ? `${encodeString(pk)}=` : "";
          encValue = `${k2}${encodeValue(pv)}`;
        }
        out += encValue == null ? "" : `.${encValue}`;
      });
      return out;
    }
    function formEncoder(sep2) {
      return (key, value, options) => {
        let out = "";
        const pairs = options?.explode ? explode(key, value) : [[key, value]];
        if (pairs.every(([_2, v2]) => v2 == null)) {
          return;
        }
        const encodeString = (v2) => {
          return options?.charEncoding === "percent" ? encodeURIComponent(v2) : v2;
        };
        const encodeValue = (v2) => encodeString(serializeValue(v2));
        const encodedSep = encodeString(sep2);
        pairs.forEach(([pk, pv]) => {
          let tmp = "";
          let encValue = null;
          if (pv == null) {
            return;
          } else if (Array.isArray(pv)) {
            encValue = mapDefined(pv, (v2) => `${encodeValue(v2)}`)?.join(encodedSep);
          } else if ((0, is_plain_object_js_1.isPlainObject)(pv)) {
            encValue = mapDefinedEntries(Object.entries(pv), ([k2, v2]) => {
              return `${encodeString(k2)}${encodedSep}${encodeValue(v2)}`;
            })?.join(encodedSep);
          } else {
            encValue = `${encodeValue(pv)}`;
          }
          if (encValue == null) {
            return;
          }
          tmp = `${encodeString(pk)}=${encValue}`;
          if (!tmp || tmp === "=") {
            return;
          }
          out += `&${tmp}`;
        });
        return out.slice(1);
      };
    }
    exports.encodeForm = formEncoder(",");
    exports.encodeSpaceDelimited = formEncoder(" ");
    exports.encodePipeDelimited = formEncoder("|");
    function encodeBodyForm(key, value, options) {
      let out = "";
      const pairs = options?.explode ? explode(key, value) : [[key, value]];
      const encodeString = (v2) => {
        return options?.charEncoding === "percent" ? encodeURIComponent(v2) : v2;
      };
      const encodeValue = (v2) => encodeString(serializeValue(v2));
      pairs.forEach(([pk, pv]) => {
        let tmp = "";
        let encValue = "";
        if (pv == null) {
          return;
        } else if (Array.isArray(pv)) {
          encValue = JSON.stringify(pv, jsonReplacer);
        } else if ((0, is_plain_object_js_1.isPlainObject)(pv)) {
          encValue = JSON.stringify(pv, jsonReplacer);
        } else {
          encValue = `${encodeValue(pv)}`;
        }
        tmp = `${encodeString(pk)}=${encValue}`;
        if (!tmp || tmp === "=") {
          return;
        }
        out += `&${tmp}`;
      });
      return out.slice(1);
    }
    function encodeDeepObject(key, value, options) {
      if (value == null) {
        return;
      }
      if (!(0, is_plain_object_js_1.isPlainObject)(value)) {
        throw new EncodingError(`Value of parameter '${key}' which uses deepObject encoding must be an object or null`);
      }
      return encodeDeepObjectObject(key, value, options);
    }
    function encodeDeepObjectObject(key, value, options) {
      if (value == null) {
        return;
      }
      let out = "";
      const encodeString = (v2) => {
        return options?.charEncoding === "percent" ? encodeURIComponent(v2) : v2;
      };
      if (!(0, is_plain_object_js_1.isPlainObject)(value)) {
        throw new EncodingError(`Expected parameter '${key}' to be an object.`);
      }
      Object.entries(value).forEach(([ck, cv]) => {
        if (cv == null) {
          return;
        }
        const pk = `${key}[${ck}]`;
        if ((0, is_plain_object_js_1.isPlainObject)(cv)) {
          const objOut = encodeDeepObjectObject(pk, cv, options);
          out += objOut == null ? "" : `&${objOut}`;
          return;
        }
        const pairs = Array.isArray(cv) ? cv : [cv];
        const encoded = mapDefined(pairs, (v2) => {
          return `${encodeString(pk)}=${encodeString(serializeValue(v2))}`;
        })?.join("&");
        out += encoded == null ? "" : `&${encoded}`;
      });
      return out.slice(1);
    }
    function encodeJSON(key, value, options) {
      if (typeof value === "undefined") {
        return;
      }
      const encodeString = (v2) => {
        return options?.charEncoding === "percent" ? encodeURIComponent(v2) : v2;
      };
      const encVal = encodeString(JSON.stringify(value, jsonReplacer));
      return options?.explode ? encVal : `${encodeString(key)}=${encVal}`;
    }
    var encodeSimple = (key, value, options) => {
      let out = "";
      const pairs = options?.explode ? explode(key, value) : [[key, value]];
      if (pairs.every(([_2, v2]) => v2 == null)) {
        return;
      }
      const encodeString = (v2) => {
        return options?.charEncoding === "percent" ? encodeURIComponent(v2) : v2;
      };
      const encodeValue = (v2) => encodeString(serializeValue(v2));
      pairs.forEach(([pk, pv]) => {
        let tmp = "";
        if (pv == null) {
          return;
        } else if (Array.isArray(pv)) {
          tmp = mapDefined(pv, (v2) => `${encodeValue(v2)}`)?.join(",");
        } else if ((0, is_plain_object_js_1.isPlainObject)(pv)) {
          const mapped = mapDefinedEntries(Object.entries(pv), ([k2, v2]) => {
            return `,${encodeString(k2)},${encodeValue(v2)}`;
          });
          tmp = mapped?.join("").slice(1);
        } else {
          const k2 = options?.explode && (0, is_plain_object_js_1.isPlainObject)(value) ? `${pk}=` : "";
          tmp = `${k2}${encodeValue(pv)}`;
        }
        out += tmp ? `,${tmp}` : "";
      });
      return out.slice(1);
    };
    exports.encodeSimple = encodeSimple;
    function explode(key, value) {
      if (Array.isArray(value)) {
        return value.map((v2) => [key, v2]);
      } else if ((0, is_plain_object_js_1.isPlainObject)(value)) {
        const o2 = value ?? {};
        return Object.entries(o2).map(([k2, v2]) => [k2, v2]);
      } else {
        return [[key, value]];
      }
    }
    function serializeValue(value) {
      if (value == null) {
        return "";
      } else if (value instanceof Date) {
        return value.toISOString();
      } else if (value instanceof Uint8Array) {
        return (0, base64_js_1.bytesToBase64)(value);
      } else if (typeof value === "object") {
        return JSON.stringify(value, jsonReplacer);
      }
      return `${value}`;
    }
    function jsonReplacer(_2, value) {
      if (value instanceof Uint8Array) {
        return (0, base64_js_1.bytesToBase64)(value);
      } else {
        return value;
      }
    }
    function mapDefined(inp, mapper) {
      const res = inp.reduce((acc, v2) => {
        if (v2 == null) {
          return acc;
        }
        const m2 = mapper(v2);
        if (m2 == null) {
          return acc;
        }
        acc.push(m2);
        return acc;
      }, []);
      return res.length ? res : null;
    }
    function mapDefinedEntries(inp, mapper) {
      const acc = [];
      for (const [k2, v2] of inp) {
        if (v2 == null) {
          continue;
        }
        const m2 = mapper([k2, v2]);
        if (m2 == null) {
          continue;
        }
        acc.push(m2);
      }
      return acc.length ? acc : null;
    }
    function queryJoin(...args) {
      return args.filter(Boolean).join("&");
    }
    function queryEncoder(f2) {
      const bulkEncode = function(values, options) {
        const opts = {
          ...options,
          explode: options?.explode ?? true,
          charEncoding: options?.charEncoding ?? "percent"
        };
        const encoded = Object.entries(values).map(([key, value]) => {
          return f2(key, value, opts);
        });
        return queryJoin(...encoded);
      };
      return bulkEncode;
    }
    exports.encodeJSONQuery = queryEncoder(encodeJSON);
    exports.encodeFormQuery = queryEncoder(exports.encodeForm);
    exports.encodeSpaceDelimitedQuery = queryEncoder(exports.encodeSpaceDelimited);
    exports.encodePipeDelimitedQuery = queryEncoder(exports.encodePipeDelimited);
    exports.encodeDeepObjectQuery = queryEncoder(encodeDeepObject);
    function appendForm(fd, key, value, fileName) {
      if (value == null) {
        return;
      } else if (value instanceof Blob && fileName) {
        fd.append(key, value, fileName);
      } else if (value instanceof Blob) {
        fd.append(key, value);
      } else {
        fd.append(key, String(value));
      }
    }
  }
});

// ../node_modules/@mistralai/mistralai/lib/dlv.js
var require_dlv = __commonJS({
  "../node_modules/@mistralai/mistralai/lib/dlv.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dlv = dlv;
    function dlv(obj, key, def, p2, undef) {
      key = Array.isArray(key) ? key : key.split(".");
      for (p2 = 0; p2 < key.length; p2++) {
        const k2 = key[p2];
        obj = k2 != null && obj ? obj[k2] : undef;
      }
      return obj === undef ? def : obj;
    }
  }
});

// ../node_modules/@mistralai/mistralai/lib/env.js
var require_env = __commonJS({
  "../node_modules/@mistralai/mistralai/lib/env.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.envSchema = void 0;
    exports.env = env;
    exports.resetEnv = resetEnv;
    var dlv_js_1 = require_dlv();
    var z4 = __importStar(__require("zod"));
    exports.envSchema = z4.object({
      MISTRAL_API_KEY: z4.string().optional(),
      MISTRAL_DEBUG: z4.coerce.boolean().optional()
    });
    var envMemo = void 0;
    function env() {
      if (envMemo) {
        return envMemo;
      }
      envMemo = exports.envSchema.parse((0, dlv_js_1.dlv)(globalThis, "process.env") ?? (0, dlv_js_1.dlv)(globalThis, "Deno.env") ?? {});
      return envMemo;
    }
    function resetEnv() {
      envMemo = void 0;
    }
  }
});

// ../node_modules/@mistralai/mistralai/lib/http.js
var require_http = __commonJS({
  "../node_modules/@mistralai/mistralai/lib/http.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HTTPClient = void 0;
    exports.matchContentType = matchContentType;
    exports.matchStatusCode = matchStatusCode;
    exports.matchResponse = matchResponse;
    exports.isConnectionError = isConnectionError;
    exports.isTimeoutError = isTimeoutError;
    exports.isAbortError = isAbortError;
    var DEFAULT_FETCHER = (input, init) => {
      if (init == null) {
        return fetch(input);
      } else {
        return fetch(input, init);
      }
    };
    var HTTPClient = class _HTTPClient {
      constructor(options = {}) {
        this.options = options;
        this.requestHooks = [];
        this.requestErrorHooks = [];
        this.responseHooks = [];
        this.fetcher = options.fetcher || DEFAULT_FETCHER;
      }
      async request(request) {
        let req = request;
        for (const hook of this.requestHooks) {
          const nextRequest = await hook(req);
          if (nextRequest) {
            req = nextRequest;
          }
        }
        try {
          const res = await this.fetcher(req);
          for (const hook of this.responseHooks) {
            await hook(res, req);
          }
          return res;
        } catch (err) {
          for (const hook of this.requestErrorHooks) {
            await hook(err, req);
          }
          throw err;
        }
      }
      addHook(...args) {
        if (args[0] === "beforeRequest") {
          this.requestHooks.push(args[1]);
        } else if (args[0] === "requestError") {
          this.requestErrorHooks.push(args[1]);
        } else if (args[0] === "response") {
          this.responseHooks.push(args[1]);
        } else {
          throw new Error(`Invalid hook type: ${args[0]}`);
        }
        return this;
      }
      removeHook(...args) {
        let target;
        if (args[0] === "beforeRequest") {
          target = this.requestHooks;
        } else if (args[0] === "requestError") {
          target = this.requestErrorHooks;
        } else if (args[0] === "response") {
          target = this.responseHooks;
        } else {
          throw new Error(`Invalid hook type: ${args[0]}`);
        }
        const index = target.findIndex((v2) => v2 === args[1]);
        if (index >= 0) {
          target.splice(index, 1);
        }
        return this;
      }
      clone() {
        const child = new _HTTPClient(this.options);
        child.requestHooks = this.requestHooks.slice();
        child.requestErrorHooks = this.requestErrorHooks.slice();
        child.responseHooks = this.responseHooks.slice();
        return child;
      }
    };
    exports.HTTPClient = HTTPClient;
    var mediaParamSeparator = /\s*;\s*/g;
    function matchContentType(response, pattern) {
      if (pattern === "*") {
        return true;
      }
      let contentType = response.headers.get("content-type")?.trim() || "application/octet-stream";
      contentType = contentType.toLowerCase();
      const wantParts = pattern.toLowerCase().trim().split(mediaParamSeparator);
      const [wantType = "", ...wantParams] = wantParts;
      if (wantType.split("/").length !== 2) {
        return false;
      }
      const gotParts = contentType.split(mediaParamSeparator);
      const [gotType = "", ...gotParams] = gotParts;
      const [type = "", subtype = ""] = gotType.split("/");
      if (!type || !subtype) {
        return false;
      }
      if (wantType !== "*/*" && gotType !== wantType && `${type}/*` !== wantType && `*/${subtype}` !== wantType) {
        return false;
      }
      if (gotParams.length < wantParams.length) {
        return false;
      }
      const params = new Set(gotParams);
      for (const wantParam of wantParams) {
        if (!params.has(wantParam)) {
          return false;
        }
      }
      return true;
    }
    var codeRangeRE = new RegExp("^[0-9]xx$", "i");
    function matchStatusCode(response, codes) {
      const actual = `${response.status}`;
      const expectedCodes = Array.isArray(codes) ? codes : [codes];
      if (!expectedCodes.length) {
        return false;
      }
      return expectedCodes.some((ec) => {
        const code = `${ec}`;
        if (code === "default") {
          return true;
        }
        if (!codeRangeRE.test(`${code}`)) {
          return code === actual;
        }
        const expectFamily = code.charAt(0);
        if (!expectFamily) {
          throw new Error("Invalid status code range");
        }
        const actualFamily = actual.charAt(0);
        if (!actualFamily) {
          throw new Error(`Invalid response status code: ${actual}`);
        }
        return actualFamily === expectFamily;
      });
    }
    function matchResponse(response, code, contentTypePattern) {
      return matchStatusCode(response, code) && matchContentType(response, contentTypePattern);
    }
    function isConnectionError(err) {
      if (typeof err !== "object" || err == null) {
        return false;
      }
      const isBrowserErr = err instanceof TypeError && err.message.toLowerCase().startsWith("failed to fetch");
      const isNodeErr = err instanceof TypeError && err.message.toLowerCase().startsWith("fetch failed");
      const isBunErr = "name" in err && err.name === "ConnectionError";
      const isGenericErr = "code" in err && typeof err.code === "string" && err.code.toLowerCase() === "econnreset";
      return isBrowserErr || isNodeErr || isGenericErr || isBunErr;
    }
    function isTimeoutError(err) {
      if (typeof err !== "object" || err == null) {
        return false;
      }
      const isNative = "name" in err && err.name === "TimeoutError";
      const isLegacyNative = "code" in err && err.code === 23;
      const isGenericErr = "code" in err && typeof err.code === "string" && err.code.toLowerCase() === "econnaborted";
      return isNative || isLegacyNative || isGenericErr;
    }
    function isAbortError(err) {
      if (typeof err !== "object" || err == null) {
        return false;
      }
      const isNative = "name" in err && err.name === "AbortError";
      const isLegacyNative = "code" in err && err.code === 20;
      const isGenericErr = "code" in err && typeof err.code === "string" && err.code.toLowerCase() === "econnaborted";
      return isNative || isLegacyNative || isGenericErr;
    }
  }
});

// ../node_modules/@mistralai/mistralai/lib/retries.js
var require_retries = __commonJS({
  "../node_modules/@mistralai/mistralai/lib/retries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TemporaryError = exports.PermanentError = void 0;
    exports.retry = retry;
    var http_js_1 = require_http();
    var defaultBackoff = {
      initialInterval: 500,
      maxInterval: 6e4,
      exponent: 1.5,
      maxElapsedTime: 36e5
    };
    var PermanentError = class _PermanentError extends Error {
      constructor(message, options) {
        let msg = message;
        if (options?.cause) {
          msg += `: ${options.cause}`;
        }
        super(msg, options);
        this.name = "PermanentError";
        if (typeof this.cause === "undefined") {
          this.cause = options?.cause;
        }
        Object.setPrototypeOf(this, _PermanentError.prototype);
      }
    };
    exports.PermanentError = PermanentError;
    var TemporaryError = class _TemporaryError extends Error {
      constructor(message, response) {
        super(message);
        this.response = response;
        this.name = "TemporaryError";
        Object.setPrototypeOf(this, _TemporaryError.prototype);
      }
    };
    exports.TemporaryError = TemporaryError;
    async function retry(fetchFn, options) {
      switch (options.config.strategy) {
        case "backoff":
          return retryBackoff(wrapFetcher(fetchFn, {
            statusCodes: options.statusCodes,
            retryConnectionErrors: !!options.config.retryConnectionErrors
          }), options.config.backoff ?? defaultBackoff);
        default:
          return await fetchFn();
      }
    }
    function wrapFetcher(fn, options) {
      return async () => {
        try {
          const res = await fn();
          if (isRetryableResponse(res, options.statusCodes)) {
            throw new TemporaryError("Response failed with retryable status code", res);
          }
          return res;
        } catch (err) {
          if (err instanceof TemporaryError) {
            throw err;
          }
          if (options.retryConnectionErrors && ((0, http_js_1.isTimeoutError)(err) || (0, http_js_1.isConnectionError)(err))) {
            throw err;
          }
          throw new PermanentError("Permanent error", { cause: err });
        }
      };
    }
    var codeRangeRE = new RegExp("^[0-9]xx$", "i");
    function isRetryableResponse(res, statusCodes) {
      const actual = `${res.status}`;
      return statusCodes.some((code) => {
        if (!codeRangeRE.test(code)) {
          return code === actual;
        }
        const expectFamily = code.charAt(0);
        if (!expectFamily) {
          throw new Error("Invalid status code range");
        }
        const actualFamily = actual.charAt(0);
        if (!actualFamily) {
          throw new Error(`Invalid response status code: ${actual}`);
        }
        return actualFamily === expectFamily;
      });
    }
    async function retryBackoff(fn, strategy) {
      const { maxElapsedTime, initialInterval, exponent, maxInterval } = strategy;
      const start = Date.now();
      let x2 = 0;
      while (true) {
        try {
          const res = await fn();
          return res;
        } catch (err) {
          if (err instanceof PermanentError) {
            throw err.cause;
          }
          const elapsed = Date.now() - start;
          if (elapsed > maxElapsedTime) {
            if (err instanceof TemporaryError) {
              return err.response;
            }
            throw err;
          }
          let retryInterval = 0;
          if (err instanceof TemporaryError) {
            retryInterval = retryIntervalFromResponse(err.response);
          }
          if (retryInterval <= 0) {
            retryInterval = initialInterval * Math.pow(x2, exponent) + Math.random() * 1e3;
          }
          const d2 = Math.min(retryInterval, maxInterval);
          await delay(d2);
          x2++;
        }
      }
    }
    function retryIntervalFromResponse(res) {
      const retryVal = res.headers.get("retry-after") || "";
      if (!retryVal) {
        return 0;
      }
      const parsedNumber = Number(retryVal);
      if (Number.isInteger(parsedNumber)) {
        return parsedNumber * 1e3;
      }
      const parsedDate = Date.parse(retryVal);
      if (Number.isInteger(parsedDate)) {
        const deltaMS = parsedDate - Date.now();
        return deltaMS > 0 ? Math.ceil(deltaMS) : 0;
      }
      return 0;
    }
    async function delay(delay2) {
      return new Promise((resolve) => setTimeout(resolve, delay2));
    }
  }
});

// ../node_modules/@mistralai/mistralai/lib/sdks.js
var require_sdks = __commonJS({
  "../node_modules/@mistralai/mistralai/lib/sdks.js"(exports) {
    "use strict";
    var __classPrivateFieldSet10 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind3, f2) {
      if (kind3 === "m") throw new TypeError("Private method is not writable");
      if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind3 === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet11 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind3, f2) {
      if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind3 === "m" ? f2 : kind3 === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
    };
    var _ClientSDK_httpClient;
    var _ClientSDK_hooks;
    var _ClientSDK_logger;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClientSDK = void 0;
    var hooks_js_1 = require_hooks();
    var httpclienterrors_js_1 = require_httpclienterrors();
    var fp_js_1 = require_fp();
    var base64_js_1 = require_base64();
    var config_js_1 = require_config();
    var encodings_js_1 = require_encodings();
    var env_js_1 = require_env();
    var http_js_1 = require_http();
    var retries_js_1 = require_retries();
    var gt2 = typeof globalThis === "undefined" ? null : globalThis;
    var webWorkerLike = typeof gt2 === "object" && gt2 != null && "importScripts" in gt2 && typeof gt2["importScripts"] === "function";
    var isBrowserLike = webWorkerLike || typeof navigator !== "undefined" && "serviceWorker" in navigator || typeof window === "object" && typeof window.document !== "undefined";
    var ClientSDK = class {
      constructor(options = {}) {
        _ClientSDK_httpClient.set(this, void 0);
        _ClientSDK_hooks.set(this, void 0);
        _ClientSDK_logger.set(this, void 0);
        const opt = options;
        if (typeof opt === "object" && opt != null && "hooks" in opt && opt.hooks instanceof hooks_js_1.SDKHooks) {
          __classPrivateFieldSet10(this, _ClientSDK_hooks, opt.hooks, "f");
        } else {
          __classPrivateFieldSet10(this, _ClientSDK_hooks, new hooks_js_1.SDKHooks(), "f");
        }
        this._options = { ...options, hooks: __classPrivateFieldGet11(this, _ClientSDK_hooks, "f") };
        const url = (0, config_js_1.serverURLFromOptions)(options);
        if (url) {
          url.pathname = url.pathname.replace(/\/+$/, "") + "/";
        }
        const { baseURL, client } = __classPrivateFieldGet11(this, _ClientSDK_hooks, "f").sdkInit({
          baseURL: url,
          client: options.httpClient || new http_js_1.HTTPClient()
        });
        this._baseURL = baseURL;
        __classPrivateFieldSet10(this, _ClientSDK_httpClient, client, "f");
        __classPrivateFieldSet10(this, _ClientSDK_logger, options.debugLogger, "f");
        if (!__classPrivateFieldGet11(this, _ClientSDK_logger, "f") && (0, env_js_1.env)().MISTRAL_DEBUG) {
          __classPrivateFieldSet10(this, _ClientSDK_logger, console, "f");
        }
      }
      _createRequest(context, conf, options) {
        const { method, path: path2, query, headers: opHeaders, security } = conf;
        const base = conf.baseURL ?? this._baseURL;
        if (!base) {
          return (0, fp_js_1.ERR)(new httpclienterrors_js_1.InvalidRequestError("No base URL provided for operation"));
        }
        const reqURL = new URL(base);
        const inputURL = new URL(path2, reqURL);
        if (path2) {
          reqURL.pathname += reqURL.pathname.endsWith("/") ? "" : "/";
          reqURL.pathname += inputURL.pathname.replace(/^\/+/, "");
        }
        let finalQuery = query || "";
        const secQuery = [];
        for (const [k2, v2] of Object.entries(security?.queryParams || {})) {
          const q2 = (0, encodings_js_1.encodeForm)(k2, v2, { charEncoding: "percent" });
          if (typeof q2 !== "undefined") {
            secQuery.push(q2);
          }
        }
        if (secQuery.length) {
          finalQuery += `&${secQuery.join("&")}`;
        }
        if (finalQuery) {
          const q2 = finalQuery.startsWith("&") ? finalQuery.slice(1) : finalQuery;
          reqURL.search = `?${q2}`;
        }
        const headers = new Headers(opHeaders);
        const username = security?.basic.username;
        const password = security?.basic.password;
        if (username != null || password != null) {
          const encoded = (0, base64_js_1.stringToBase64)([username || "", password || ""].join(":"));
          headers.set("Authorization", `Basic ${encoded}`);
        }
        const securityHeaders = new Headers(security?.headers || {});
        for (const [k2, v2] of securityHeaders) {
          headers.set(k2, v2);
        }
        let cookie = headers.get("cookie") || "";
        for (const [k2, v2] of Object.entries(security?.cookies || {})) {
          cookie += `; ${k2}=${v2}`;
        }
        cookie = cookie.startsWith("; ") ? cookie.slice(2) : cookie;
        headers.set("cookie", cookie);
        const userHeaders = new Headers(options?.fetchOptions?.headers);
        for (const [k2, v2] of userHeaders) {
          headers.set(k2, v2);
        }
        if (!isBrowserLike) {
          headers.set(conf.uaHeader ?? "user-agent", config_js_1.SDK_METADATA.userAgent);
        }
        let fetchOptions = options?.fetchOptions;
        if (!fetchOptions?.signal && conf.timeoutMs && conf.timeoutMs > 0) {
          const timeoutSignal = AbortSignal.timeout(conf.timeoutMs);
          if (!fetchOptions) {
            fetchOptions = { signal: timeoutSignal };
          } else {
            fetchOptions.signal = timeoutSignal;
          }
        }
        if (conf.body instanceof ReadableStream) {
          if (!fetchOptions) {
            fetchOptions = {};
          }
          Object.assign(fetchOptions, { duplex: "half" });
        }
        let input;
        try {
          input = __classPrivateFieldGet11(this, _ClientSDK_hooks, "f").beforeCreateRequest(context, {
            url: reqURL,
            options: {
              ...fetchOptions,
              body: conf.body ?? null,
              headers,
              method
            }
          });
        } catch (err) {
          return (0, fp_js_1.ERR)(new httpclienterrors_js_1.UnexpectedClientError("Create request hook failed to execute", {
            cause: err
          }));
        }
        return (0, fp_js_1.OK)(new Request(input.url, input.options));
      }
      async _do(request, options) {
        const { context, errorCodes } = options;
        return (0, retries_js_1.retry)(async () => {
          const req = await __classPrivateFieldGet11(this, _ClientSDK_hooks, "f").beforeRequest(context, request.clone());
          await logRequest(__classPrivateFieldGet11(this, _ClientSDK_logger, "f"), req).catch((e2) => __classPrivateFieldGet11(this, _ClientSDK_logger, "f")?.log("Failed to log request:", e2));
          let response = await __classPrivateFieldGet11(this, _ClientSDK_httpClient, "f").request(req);
          try {
            if ((0, http_js_1.matchStatusCode)(response, errorCodes)) {
              const result = await __classPrivateFieldGet11(this, _ClientSDK_hooks, "f").afterError(context, response, null);
              if (result.error) {
                throw result.error;
              }
              response = result.response || response;
            } else {
              response = await __classPrivateFieldGet11(this, _ClientSDK_hooks, "f").afterSuccess(context, response);
            }
          } finally {
            await logResponse(__classPrivateFieldGet11(this, _ClientSDK_logger, "f"), response, req).catch((e2) => __classPrivateFieldGet11(this, _ClientSDK_logger, "f")?.log("Failed to log response:", e2));
          }
          return response;
        }, { config: options.retryConfig, statusCodes: options.retryCodes }).then((r2) => (0, fp_js_1.OK)(r2), (err) => {
          switch (true) {
            case (0, http_js_1.isAbortError)(err):
              return (0, fp_js_1.ERR)(new httpclienterrors_js_1.RequestAbortedError("Request aborted by client", {
                cause: err
              }));
            case (0, http_js_1.isTimeoutError)(err):
              return (0, fp_js_1.ERR)(new httpclienterrors_js_1.RequestTimeoutError("Request timed out", { cause: err }));
            case (0, http_js_1.isConnectionError)(err):
              return (0, fp_js_1.ERR)(new httpclienterrors_js_1.ConnectionError("Unable to make request", { cause: err }));
            default:
              return (0, fp_js_1.ERR)(new httpclienterrors_js_1.UnexpectedClientError("Unexpected HTTP client error", {
                cause: err
              }));
          }
        });
      }
    };
    exports.ClientSDK = ClientSDK;
    _ClientSDK_httpClient = /* @__PURE__ */ new WeakMap(), _ClientSDK_hooks = /* @__PURE__ */ new WeakMap(), _ClientSDK_logger = /* @__PURE__ */ new WeakMap();
    var jsonLikeContentTypeRE = /^application\/(?:.{0,100}\+)?json/;
    async function logRequest(logger2, req) {
      if (!logger2) {
        return;
      }
      const contentType = req.headers.get("content-type");
      const ct2 = contentType?.split(";")[0] || "";
      logger2.group(`> Request: ${req.method} ${req.url}`);
      logger2.group("Headers:");
      for (const [k2, v2] of req.headers.entries()) {
        logger2.log(`${k2}: ${v2}`);
      }
      logger2.groupEnd();
      logger2.group("Body:");
      switch (true) {
        case jsonLikeContentTypeRE.test(ct2):
          logger2.log(await req.clone().json());
          break;
        case ct2.startsWith("text/"):
          logger2.log(await req.clone().text());
          break;
        case ct2 === "multipart/form-data": {
          const body = await req.clone().formData();
          for (const [k2, v2] of body) {
            const vlabel = v2 instanceof Blob ? "<Blob>" : v2;
            logger2.log(`${k2}: ${vlabel}`);
          }
          break;
        }
        default:
          logger2.log(`<${contentType}>`);
          break;
      }
      logger2.groupEnd();
      logger2.groupEnd();
    }
    async function logResponse(logger2, res, req) {
      if (!logger2) {
        return;
      }
      const contentType = res.headers.get("content-type");
      const ct2 = contentType?.split(";")[0] || "";
      logger2.group(`< Response: ${req.method} ${req.url}`);
      logger2.log("Status Code:", res.status, res.statusText);
      logger2.group("Headers:");
      for (const [k2, v2] of res.headers.entries()) {
        logger2.log(`${k2}: ${v2}`);
      }
      logger2.groupEnd();
      logger2.group("Body:");
      switch (true) {
        case ((0, http_js_1.matchContentType)(res, "application/json") || jsonLikeContentTypeRE.test(ct2)):
          logger2.log(await res.clone().json());
          break;
        case (0, http_js_1.matchContentType)(res, "text/event-stream"):
          logger2.log(`<${contentType}>`);
          break;
        case (0, http_js_1.matchContentType)(res, "text/*"):
          logger2.log(await res.clone().text());
          break;
        case (0, http_js_1.matchContentType)(res, "multipart/form-data"): {
          const body = await res.clone().formData();
          for (const [k2, v2] of body) {
            const vlabel = v2 instanceof Blob ? "<Blob>" : v2;
            logger2.log(`${k2}: ${vlabel}`);
          }
          break;
        }
        default:
          logger2.log(`<${contentType}>`);
          break;
      }
      logger2.groupEnd();
      logger2.groupEnd();
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/errors/sdkerror.js
var require_sdkerror = __commonJS({
  "../node_modules/@mistralai/mistralai/models/errors/sdkerror.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SDKError = void 0;
    var SDKError = class extends Error {
      constructor(message, rawResponse, body = "") {
        const statusCode = rawResponse.status;
        const contentType = rawResponse.headers.get("content-type") || "";
        const bodyString = body.length > 0 ? `
${body}` : "";
        super(`${message}: Status ${statusCode} Content-Type ${contentType} Body ${bodyString}`);
        this.rawResponse = rawResponse;
        this.body = body;
        this.statusCode = statusCode;
        this.contentType = contentType;
        this.name = "SDKError";
      }
    };
    exports.SDKError = SDKError;
  }
});

// ../node_modules/@mistralai/mistralai/lib/event-streams.js
var require_event_streams = __commonJS({
  "../node_modules/@mistralai/mistralai/lib/event-streams.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EventStream = void 0;
    exports.discardSentinel = discardSentinel;
    var LF = 10;
    var CR = 13;
    var NEWLINE_CHARS = /* @__PURE__ */ new Set([LF, CR]);
    var MESSAGE_BOUNDARIES = [
      new Uint8Array([CR, LF, CR, LF]),
      new Uint8Array([CR, CR]),
      new Uint8Array([LF, LF])
    ];
    var EventStream = class {
      constructor(init) {
        this.stream = init.stream;
        this.decoder = init.decoder;
      }
      async *[Symbol.asyncIterator]() {
        const reader = this.stream.getReader();
        let buffer = new Uint8Array([]);
        let position = 0;
        try {
          while (true) {
            const { done, value } = await reader.read();
            if (done) {
              break;
            }
            const newBuffer = new Uint8Array(buffer.length + value.length);
            newBuffer.set(buffer);
            newBuffer.set(value, buffer.length);
            buffer = newBuffer;
            for (let i2 = position; i2 < buffer.length; i2++) {
              const boundary = findBoundary(buffer, i2);
              if (boundary == null) {
                continue;
              }
              const chunk = buffer.slice(position, i2);
              position = i2 + boundary.length;
              const event = parseEvent(chunk, this.decoder);
              if (event != null) {
                yield event;
              }
            }
            if (position > 0) {
              buffer = buffer.slice(position);
              position = 0;
            }
          }
          if (buffer.length > 0) {
            const event = parseEvent(buffer, this.decoder);
            if (event != null) {
              yield event;
            }
          }
        } catch (e2) {
          if (e2 instanceof Error && e2.name === "AbortError") {
            return;
          }
          throw e2;
        } finally {
          reader.releaseLock();
        }
      }
    };
    exports.EventStream = EventStream;
    function findBoundary(buffer, start) {
      const char1 = buffer[start];
      const char2 = buffer[start + 1];
      if (char1 == null || char2 == null || !NEWLINE_CHARS.has(char1) || !NEWLINE_CHARS.has(char2)) {
        return null;
      }
      for (const s2 of MESSAGE_BOUNDARIES) {
        const seq = peekSequence(start, buffer, s2);
        if (seq != null) {
          return seq;
        }
      }
      return null;
    }
    function peekSequence(position, buffer, sequence) {
      if (sequence.length > buffer.length - position) {
        return null;
      }
      for (let i2 = 0; i2 < sequence.length; i2++) {
        if (buffer[position + i2] !== sequence[i2]) {
          return null;
        }
      }
      return sequence;
    }
    function parseEvent(chunk, decoder) {
      if (!chunk.length) {
        return null;
      }
      const td = new TextDecoder();
      const raw = td.decode(chunk);
      const lines = raw.split(/\r?\n|\r/g);
      let publish = false;
      const rawEvent = {};
      for (const line of lines) {
        if (!line) {
          continue;
        }
        const delim = line.indexOf(":");
        if (delim === 0) {
          continue;
        }
        const field = delim > 0 ? line.substring(0, delim) : "";
        let value = delim > 0 ? line.substring(delim + 1) : "";
        if (value.charAt(0) === " ") {
          value = value.substring(1);
        }
        switch (field) {
          case "event": {
            publish = true;
            rawEvent.event = value;
            break;
          }
          case "data": {
            publish = true;
            rawEvent.data ?? (rawEvent.data = "");
            rawEvent.data += value + "\n";
            break;
          }
          case "id": {
            publish = true;
            rawEvent.id = value;
            break;
          }
          case "retry": {
            const r2 = parseInt(value, 10);
            if (!Number.isNaN(r2)) {
              publish = true;
              rawEvent.retry = r2;
            }
            break;
          }
        }
      }
      if (!publish) {
        return null;
      }
      if (rawEvent.data != null) {
        rawEvent.data = rawEvent.data.slice(0, -1);
      }
      return decoder(rawEvent);
    }
    function discardSentinel(stream, sentinel) {
      return new ReadableStream({
        async start(controller) {
          let buffer = new Uint8Array([]);
          let position = 0;
          let done = false;
          let discard = false;
          const rdr = stream.getReader();
          try {
            while (!done) {
              const result = await rdr.read();
              const value = result.value;
              done = done || result.done;
              if (discard) {
                continue;
              }
              if (typeof value === "undefined") {
                continue;
              }
              const newBuffer = new Uint8Array(buffer.length + value.length);
              newBuffer.set(buffer);
              newBuffer.set(value, buffer.length);
              buffer = newBuffer;
              for (let i2 = position; i2 < buffer.length; i2++) {
                const boundary = findBoundary(buffer, i2);
                if (boundary == null) {
                  continue;
                }
                const start = position;
                const chunk = buffer.slice(start, i2);
                position = i2 + boundary.length;
                const event = parseEvent(chunk, id);
                if (event?.data === sentinel) {
                  controller.enqueue(buffer.slice(0, start));
                  discard = true;
                } else {
                  controller.enqueue(buffer.slice(0, position));
                  buffer = buffer.slice(position);
                  position = 0;
                }
              }
            }
          } catch (e2) {
            controller.error(e2);
          } finally {
            controller.close();
            rdr.releaseLock();
          }
        }
      });
    }
    function id(v2) {
      return v2;
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/errors/sdkvalidationerror.js
var require_sdkvalidationerror = __commonJS({
  "../node_modules/@mistralai/mistralai/models/errors/sdkvalidationerror.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SDKValidationError = void 0;
    exports.formatZodError = formatZodError;
    var z4 = __importStar(__require("zod"));
    var SDKValidationError = class extends Error {
      constructor(message, cause, rawValue) {
        super(`${message}: ${cause}`);
        this.name = "SDKValidationError";
        this.cause = cause;
        this.rawValue = rawValue;
        this.rawMessage = message;
      }
      /**
       * Return a pretty-formatted error message if the underlying validation error
       * is a ZodError or some other recognized error type, otherwise return the
       * default error message.
       */
      pretty() {
        if (this.cause instanceof z4.ZodError) {
          return `${this.rawMessage}
${formatZodError(this.cause)}`;
        } else {
          return this.toString();
        }
      }
    };
    exports.SDKValidationError = SDKValidationError;
    function formatZodError(err, level = 0) {
      let pre = "  ".repeat(level);
      pre = level > 0 ? `\u2502${pre}` : pre;
      pre += " ".repeat(level);
      let message = "";
      const append = (str) => message += `
${pre}${str}`;
      const len = err.issues.length;
      const headline = len === 1 ? `${len} issue found` : `${len} issues found`;
      if (len) {
        append(`\u250C ${headline}:`);
      }
      for (const issue of err.issues) {
        let path2 = issue.path.join(".");
        path2 = path2 ? `<root>.${path2}` : "<root>";
        append(`\u2502 \u2022 [${path2}]: ${issue.message} (${issue.code})`);
        switch (issue.code) {
          case "invalid_literal":
          case "invalid_type": {
            append(`\u2502     Want: ${issue.expected}`);
            append(`\u2502      Got: ${issue.received}`);
            break;
          }
          case "unrecognized_keys": {
            append(`\u2502     Keys: ${issue.keys.join(", ")}`);
            break;
          }
          case "invalid_enum_value": {
            append(`\u2502     Allowed: ${issue.options.join(", ")}`);
            append(`\u2502         Got: ${issue.received}`);
            break;
          }
          case "invalid_union_discriminator": {
            append(`\u2502     Allowed: ${issue.options.join(", ")}`);
            break;
          }
          case "invalid_union": {
            const len2 = issue.unionErrors.length;
            append(`\u2502   \u2716\uFE0E Attemped to deserialize into one of ${len2} union members:`);
            issue.unionErrors.forEach((err2, i2) => {
              append(`\u2502   \u2716\uFE0E Member ${i2 + 1} of ${len2}`);
              append(`${formatZodError(err2, level + 1)}`);
            });
          }
        }
      }
      if (err.issues.length) {
        append(`\u2514\u2500*`);
      }
      return message.slice(1);
    }
  }
});

// ../node_modules/@mistralai/mistralai/lib/schemas.js
var require_schemas = __commonJS({
  "../node_modules/@mistralai/mistralai/lib/schemas.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = parse2;
    exports.safeParse = safeParse;
    exports.collectExtraKeys = collectExtraKeys;
    var zod_1 = __require("zod");
    var sdkvalidationerror_js_1 = require_sdkvalidationerror();
    var fp_js_1 = require_fp();
    function parse2(rawValue, fn, errorMessage) {
      try {
        return fn(rawValue);
      } catch (err) {
        if (err instanceof zod_1.ZodError) {
          throw new sdkvalidationerror_js_1.SDKValidationError(errorMessage, err, rawValue);
        }
        throw err;
      }
    }
    function safeParse(rawValue, fn, errorMessage) {
      try {
        return (0, fp_js_1.OK)(fn(rawValue));
      } catch (err) {
        return (0, fp_js_1.ERR)(new sdkvalidationerror_js_1.SDKValidationError(errorMessage, err, rawValue));
      }
    }
    function collectExtraKeys(obj, extrasKey, optional) {
      return obj.transform((val) => {
        const extras = {};
        const { shape } = obj;
        for (const [key] of Object.entries(val)) {
          if (key in shape) {
            continue;
          }
          const v2 = val[key];
          if (typeof v2 === "undefined") {
            continue;
          }
          extras[key] = v2;
          delete val[key];
        }
        if (optional && Object.keys(extras).length === 0) {
          return val;
        }
        return { ...val, [extrasKey]: extras };
      });
    }
  }
});

// ../node_modules/@mistralai/mistralai/lib/matchers.js
var require_matchers = __commonJS({
  "../node_modules/@mistralai/mistralai/lib/matchers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.jsonErr = jsonErr;
    exports.json = json;
    exports.textErr = textErr;
    exports.text = text;
    exports.bytesErr = bytesErr;
    exports.bytes = bytes;
    exports.streamErr = streamErr;
    exports.stream = stream;
    exports.sseErr = sseErr;
    exports.sse = sse;
    exports.nilErr = nilErr;
    exports.nil = nil;
    exports.fail = fail;
    exports.match = match7;
    exports.unpackHeaders = unpackHeaders;
    exports.discardResponseBody = discardResponseBody;
    var sdkerror_js_1 = require_sdkerror();
    var event_streams_js_1 = require_event_streams();
    var http_js_1 = require_http();
    var is_plain_object_js_1 = require_is_plain_object();
    var schemas_js_1 = require_schemas();
    var DEFAULT_CONTENT_TYPES = {
      json: "application/json",
      text: "text/plain",
      bytes: "application/octet-stream",
      stream: "application/octet-stream",
      sse: "text/event-stream",
      nil: "*",
      fail: "*"
    };
    function jsonErr(codes, schema, options) {
      return { ...options, err: true, enc: "json", codes, schema };
    }
    function json(codes, schema, options) {
      return { ...options, enc: "json", codes, schema };
    }
    function textErr(codes, schema, options) {
      return { ...options, err: true, enc: "text", codes, schema };
    }
    function text(codes, schema, options) {
      return { ...options, enc: "text", codes, schema };
    }
    function bytesErr(codes, schema, options) {
      return { ...options, err: true, enc: "bytes", codes, schema };
    }
    function bytes(codes, schema, options) {
      return { ...options, enc: "bytes", codes, schema };
    }
    function streamErr(codes, schema, options) {
      return { ...options, err: true, enc: "stream", codes, schema };
    }
    function stream(codes, schema, options) {
      return { ...options, enc: "stream", codes, schema };
    }
    function sseErr(codes, schema, options) {
      return { ...options, err: true, enc: "sse", codes, schema };
    }
    function sse(codes, schema, options) {
      return { ...options, enc: "sse", codes, schema };
    }
    function nilErr(codes, schema, options) {
      return { ...options, err: true, enc: "nil", codes, schema };
    }
    function nil(codes, schema, options) {
      return { ...options, enc: "nil", codes, schema };
    }
    function fail(codes) {
      return { enc: "fail", codes };
    }
    function match7(...matchers) {
      return async function matchFunc(response, options) {
        let raw;
        let matcher;
        for (const match8 of matchers) {
          const { codes } = match8;
          const ctpattern = "ctype" in match8 ? match8.ctype : DEFAULT_CONTENT_TYPES[match8.enc];
          if (ctpattern && (0, http_js_1.matchResponse)(response, codes, ctpattern)) {
            matcher = match8;
            break;
          } else if (!ctpattern && (0, http_js_1.matchStatusCode)(response, codes)) {
            matcher = match8;
            break;
          }
        }
        if (!matcher) {
          const responseBody = await response.text();
          return [{
            ok: false,
            error: new sdkerror_js_1.SDKError("Unexpected API response status or content-type", response, responseBody)
          }, responseBody];
        }
        const encoding = matcher.enc;
        switch (encoding) {
          case "json":
            raw = await response.json();
            break;
          case "bytes":
            raw = new Uint8Array(await response.arrayBuffer());
            break;
          case "stream":
            raw = response.body;
            break;
          case "text":
            raw = await response.text();
            break;
          case "sse":
            raw = response.body && matcher.sseSentinel ? (0, event_streams_js_1.discardSentinel)(response.body, matcher.sseSentinel) : response.body;
            break;
          case "nil":
            raw = await discardResponseBody(response);
            break;
          case "fail":
            raw = await response.text();
            break;
          default:
            encoding;
            throw new Error(`Unsupported response type: ${encoding}`);
        }
        if (matcher.enc === "fail") {
          return [{
            ok: false,
            error: new sdkerror_js_1.SDKError("API error occurred", response, typeof raw === "string" ? raw : "")
          }, raw];
        }
        const resultKey = matcher.key || options?.resultKey;
        let data;
        if ("err" in matcher) {
          data = {
            ...options?.extraFields,
            ...matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null,
            ...(0, is_plain_object_js_1.isPlainObject)(raw) ? raw : null
          };
        } else if (resultKey) {
          data = {
            ...options?.extraFields,
            ...matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null,
            [resultKey]: raw
          };
        } else if (matcher.hdrs) {
          data = {
            ...options?.extraFields,
            ...matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null,
            ...(0, is_plain_object_js_1.isPlainObject)(raw) ? raw : null
          };
        } else {
          data = raw;
        }
        if ("err" in matcher) {
          const result = (0, schemas_js_1.safeParse)(data, (v2) => matcher.schema.parse(v2), "Response validation failed");
          return [result.ok ? { ok: false, error: result.value } : result, raw];
        } else {
          return [
            (0, schemas_js_1.safeParse)(data, (v2) => matcher.schema.parse(v2), "Response validation failed"),
            raw
          ];
        }
      };
    }
    var headerValRE = /, */;
    function unpackHeaders(headers) {
      const out = {};
      for (const [k2, v2] of headers.entries()) {
        out[k2] = v2.split(headerValRE);
      }
      return out;
    }
    async function discardResponseBody(res) {
      const reader = res.body?.getReader();
      if (reader == null) {
        return;
      }
      try {
        let done = false;
        while (!done) {
          const res2 = await reader.read();
          done = res2.done;
        }
      } finally {
        reader.releaseLock();
      }
    }
  }
});

// ../node_modules/@mistralai/mistralai/lib/primitives.js
var require_primitives = __commonJS({
  "../node_modules/@mistralai/mistralai/lib/primitives.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.invariant = invariant;
    exports.remap = remap;
    exports.combineSignals = combineSignals;
    exports.abortSignalAny = abortSignalAny;
    exports.compactMap = compactMap;
    exports.allRequired = allRequired;
    var InvariantError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "InvariantError";
      }
    };
    function invariant(condition, message) {
      if (!condition) {
        throw new InvariantError(message);
      }
    }
    function remap(inp, mappings) {
      let out = {};
      if (!Object.keys(mappings).length) {
        out = inp;
        return out;
      }
      for (const [k2, v2] of Object.entries(inp)) {
        const j2 = mappings[k2];
        if (j2 === null) {
          continue;
        }
        out[j2 ?? k2] = v2;
      }
      return out;
    }
    function combineSignals(...signals) {
      const filtered = [];
      for (const signal of signals) {
        if (signal) {
          filtered.push(signal);
        }
      }
      switch (filtered.length) {
        case 0:
        case 1:
          return filtered[0] || null;
        default:
          if ("any" in AbortSignal && typeof AbortSignal.any === "function") {
            return AbortSignal.any(filtered);
          }
          return abortSignalAny(filtered);
      }
    }
    function abortSignalAny(signals) {
      const controller = new AbortController();
      const result = controller.signal;
      if (!signals.length) {
        return controller.signal;
      }
      if (signals.length === 1) {
        return signals[0] || controller.signal;
      }
      for (const signal of signals) {
        if (signal.aborted) {
          return signal;
        }
      }
      function abort() {
        controller.abort(this.reason);
        clean();
      }
      const signalRefs = [];
      function clean() {
        for (const signalRef of signalRefs) {
          const signal = signalRef.deref();
          if (signal) {
            signal.removeEventListener("abort", abort);
          }
        }
      }
      for (const signal of signals) {
        signalRefs.push(new WeakRef(signal));
        signal.addEventListener("abort", abort);
      }
      return result;
    }
    function compactMap(values) {
      const out = {};
      for (const [k2, v2] of Object.entries(values)) {
        if (typeof v2 !== "undefined") {
          out[k2] = v2;
        }
      }
      return out;
    }
    function allRequired(v2) {
      if (Object.values(v2).every((x2) => x2 == null)) {
        return void 0;
      }
      return v2;
    }
  }
});

// ../node_modules/@mistralai/mistralai/lib/security.js
var require_security = __commonJS({
  "../node_modules/@mistralai/mistralai/lib/security.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SecurityError = exports.SecurityErrorCode = void 0;
    exports.resolveSecurity = resolveSecurity;
    exports.resolveGlobalSecurity = resolveGlobalSecurity;
    exports.extractSecurity = extractSecurity;
    var env_js_1 = require_env();
    var SecurityErrorCode;
    (function(SecurityErrorCode2) {
      SecurityErrorCode2["Incomplete"] = "incomplete";
      SecurityErrorCode2["UnrecognisedSecurityType"] = "unrecognized_security_type";
    })(SecurityErrorCode || (exports.SecurityErrorCode = SecurityErrorCode = {}));
    var SecurityError = class _SecurityError extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        this.name = "SecurityError";
      }
      static incomplete() {
        return new _SecurityError(SecurityErrorCode.Incomplete, "Security requirements not met in order to perform the operation");
      }
      static unrecognizedType(type) {
        return new _SecurityError(SecurityErrorCode.UnrecognisedSecurityType, `Unrecognised security type: ${type}`);
      }
    };
    exports.SecurityError = SecurityError;
    function resolveSecurity(...options) {
      const state = {
        basic: {},
        headers: {},
        queryParams: {},
        cookies: {},
        oauth2: { type: "none" }
      };
      const option = options.find((opts) => {
        return opts.every((o2) => {
          if (o2.value == null) {
            return false;
          } else if (o2.type === "http:basic") {
            return o2.value.username != null || o2.value.password != null;
          } else if (o2.type === "http:custom") {
            return null;
          } else if (o2.type === "oauth2:password") {
            return typeof o2.value === "string" && !!o2.value;
          } else if (o2.type === "oauth2:client_credentials") {
            return o2.value.clientID != null || o2.value.clientSecret != null;
          } else if (typeof o2.value === "string") {
            return !!o2.value;
          } else {
            throw new Error(`Unrecognized security type: ${o2.type} (value type: ${typeof o2.value})`);
          }
        });
      });
      if (option == null) {
        return null;
      }
      option.forEach((spec) => {
        if (spec.value == null) {
          return;
        }
        const { type } = spec;
        switch (type) {
          case "apiKey:header":
            state.headers[spec.fieldName] = spec.value;
            break;
          case "apiKey:query":
            state.queryParams[spec.fieldName] = spec.value;
            break;
          case "apiKey:cookie":
            state.cookies[spec.fieldName] = spec.value;
            break;
          case "http:basic":
            applyBasic(state, spec);
            break;
          case "http:custom":
            break;
          case "http:bearer":
            applyBearer(state, spec);
            break;
          case "oauth2":
            applyBearer(state, spec);
            break;
          case "oauth2:password":
            applyBearer(state, spec);
            break;
          case "oauth2:client_credentials":
            break;
          case "openIdConnect":
            applyBearer(state, spec);
            break;
          default:
            spec;
            throw SecurityError.unrecognizedType(type);
        }
      });
      return state;
    }
    function applyBasic(state, spec) {
      if (spec.value == null) {
        return;
      }
      state.basic = spec.value;
    }
    function applyBearer(state, spec) {
      if (typeof spec.value !== "string" || !spec.value) {
        return;
      }
      let value = spec.value;
      if (value.slice(0, 7).toLowerCase() !== "bearer ") {
        value = `Bearer ${value}`;
      }
      state.headers[spec.fieldName] = value;
    }
    function resolveGlobalSecurity(security) {
      return resolveSecurity([
        {
          fieldName: "Authorization",
          type: "http:bearer",
          value: security?.apiKey ?? (0, env_js_1.env)().MISTRAL_API_KEY
        }
      ]);
    }
    async function extractSecurity(sec) {
      if (sec == null) {
        return;
      }
      return typeof sec === "function" ? sec() : sec;
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/codeinterpretertool.js
var require_codeinterpretertool = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/codeinterpretertool.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodeInterpreterTool$ = exports.CodeInterpreterTool$outboundSchema = exports.CodeInterpreterTool$inboundSchema = exports.CodeInterpreterToolType$ = exports.CodeInterpreterToolType$outboundSchema = exports.CodeInterpreterToolType$inboundSchema = exports.CodeInterpreterToolType = void 0;
    exports.codeInterpreterToolToJSON = codeInterpreterToolToJSON;
    exports.codeInterpreterToolFromJSON = codeInterpreterToolFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    exports.CodeInterpreterToolType = {
      CodeInterpreter: "code_interpreter"
    };
    exports.CodeInterpreterToolType$inboundSchema = z4.nativeEnum(exports.CodeInterpreterToolType);
    exports.CodeInterpreterToolType$outboundSchema = exports.CodeInterpreterToolType$inboundSchema;
    var CodeInterpreterToolType$;
    (function(CodeInterpreterToolType$2) {
      CodeInterpreterToolType$2.inboundSchema = exports.CodeInterpreterToolType$inboundSchema;
      CodeInterpreterToolType$2.outboundSchema = exports.CodeInterpreterToolType$outboundSchema;
    })(CodeInterpreterToolType$ || (exports.CodeInterpreterToolType$ = CodeInterpreterToolType$ = {}));
    exports.CodeInterpreterTool$inboundSchema = z4.object({
      type: exports.CodeInterpreterToolType$inboundSchema.default("code_interpreter")
    });
    exports.CodeInterpreterTool$outboundSchema = z4.object({
      type: exports.CodeInterpreterToolType$outboundSchema.default("code_interpreter")
    });
    var CodeInterpreterTool$;
    (function(CodeInterpreterTool$2) {
      CodeInterpreterTool$2.inboundSchema = exports.CodeInterpreterTool$inboundSchema;
      CodeInterpreterTool$2.outboundSchema = exports.CodeInterpreterTool$outboundSchema;
    })(CodeInterpreterTool$ || (exports.CodeInterpreterTool$ = CodeInterpreterTool$ = {}));
    function codeInterpreterToolToJSON(codeInterpreterTool) {
      return JSON.stringify(exports.CodeInterpreterTool$outboundSchema.parse(codeInterpreterTool));
    }
    function codeInterpreterToolFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.CodeInterpreterTool$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'CodeInterpreterTool' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/completionargsstop.js
var require_completionargsstop = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/completionargsstop.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompletionArgsStop$ = exports.CompletionArgsStop$outboundSchema = exports.CompletionArgsStop$inboundSchema = void 0;
    exports.completionArgsStopToJSON = completionArgsStopToJSON;
    exports.completionArgsStopFromJSON = completionArgsStopFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    exports.CompletionArgsStop$inboundSchema = z4.union([z4.string(), z4.array(z4.string())]);
    exports.CompletionArgsStop$outboundSchema = z4.union([z4.string(), z4.array(z4.string())]);
    var CompletionArgsStop$;
    (function(CompletionArgsStop$2) {
      CompletionArgsStop$2.inboundSchema = exports.CompletionArgsStop$inboundSchema;
      CompletionArgsStop$2.outboundSchema = exports.CompletionArgsStop$outboundSchema;
    })(CompletionArgsStop$ || (exports.CompletionArgsStop$ = CompletionArgsStop$ = {}));
    function completionArgsStopToJSON(completionArgsStop) {
      return JSON.stringify(exports.CompletionArgsStop$outboundSchema.parse(completionArgsStop));
    }
    function completionArgsStopFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.CompletionArgsStop$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'CompletionArgsStop' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/prediction.js
var require_prediction = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/prediction.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Prediction$ = exports.Prediction$outboundSchema = exports.Prediction$inboundSchema = void 0;
    exports.predictionToJSON = predictionToJSON;
    exports.predictionFromJSON = predictionFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    exports.Prediction$inboundSchema = z4.object({
      type: z4.literal("content").default("content"),
      content: z4.string().default("")
    });
    exports.Prediction$outboundSchema = z4.object({
      type: z4.literal("content").default("content"),
      content: z4.string().default("")
    });
    var Prediction$;
    (function(Prediction$2) {
      Prediction$2.inboundSchema = exports.Prediction$inboundSchema;
      Prediction$2.outboundSchema = exports.Prediction$outboundSchema;
    })(Prediction$ || (exports.Prediction$ = Prediction$ = {}));
    function predictionToJSON(prediction) {
      return JSON.stringify(exports.Prediction$outboundSchema.parse(prediction));
    }
    function predictionFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.Prediction$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'Prediction' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/jsonschema.js
var require_jsonschema = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/jsonschema.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonSchema$ = exports.JsonSchema$outboundSchema = exports.JsonSchema$inboundSchema = void 0;
    exports.jsonSchemaToJSON = jsonSchemaToJSON;
    exports.jsonSchemaFromJSON = jsonSchemaFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.JsonSchema$inboundSchema = z4.object({
      name: z4.string(),
      description: z4.nullable(z4.string()).optional(),
      schema: z4.record(z4.any()),
      strict: z4.boolean().optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "schema": "schemaDefinition"
      });
    });
    exports.JsonSchema$outboundSchema = z4.object({
      name: z4.string(),
      description: z4.nullable(z4.string()).optional(),
      schemaDefinition: z4.record(z4.any()),
      strict: z4.boolean().optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        schemaDefinition: "schema"
      });
    });
    var JsonSchema$;
    (function(JsonSchema$2) {
      JsonSchema$2.inboundSchema = exports.JsonSchema$inboundSchema;
      JsonSchema$2.outboundSchema = exports.JsonSchema$outboundSchema;
    })(JsonSchema$ || (exports.JsonSchema$ = JsonSchema$ = {}));
    function jsonSchemaToJSON(jsonSchema) {
      return JSON.stringify(exports.JsonSchema$outboundSchema.parse(jsonSchema));
    }
    function jsonSchemaFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.JsonSchema$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'JsonSchema' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/responseformats.js
var require_responseformats = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/responseformats.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ResponseFormats$ = exports.ResponseFormats$outboundSchema = exports.ResponseFormats$inboundSchema = exports.ResponseFormats = void 0;
    var z4 = __importStar(__require("zod"));
    exports.ResponseFormats = {
      Text: "text",
      JsonObject: "json_object",
      JsonSchema: "json_schema"
    };
    exports.ResponseFormats$inboundSchema = z4.nativeEnum(exports.ResponseFormats);
    exports.ResponseFormats$outboundSchema = exports.ResponseFormats$inboundSchema;
    var ResponseFormats$;
    (function(ResponseFormats$2) {
      ResponseFormats$2.inboundSchema = exports.ResponseFormats$inboundSchema;
      ResponseFormats$2.outboundSchema = exports.ResponseFormats$outboundSchema;
    })(ResponseFormats$ || (exports.ResponseFormats$ = ResponseFormats$ = {}));
  }
});

// ../node_modules/@mistralai/mistralai/models/components/responseformat.js
var require_responseformat = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/responseformat.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ResponseFormat$ = exports.ResponseFormat$outboundSchema = exports.ResponseFormat$inboundSchema = void 0;
    exports.responseFormatToJSON = responseFormatToJSON;
    exports.responseFormatFromJSON = responseFormatFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var jsonschema_js_1 = require_jsonschema();
    var responseformats_js_1 = require_responseformats();
    exports.ResponseFormat$inboundSchema = z4.object({
      type: responseformats_js_1.ResponseFormats$inboundSchema.optional(),
      json_schema: z4.nullable(jsonschema_js_1.JsonSchema$inboundSchema).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "json_schema": "jsonSchema"
      });
    });
    exports.ResponseFormat$outboundSchema = z4.object({
      type: responseformats_js_1.ResponseFormats$outboundSchema.optional(),
      jsonSchema: z4.nullable(jsonschema_js_1.JsonSchema$outboundSchema).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        jsonSchema: "json_schema"
      });
    });
    var ResponseFormat$;
    (function(ResponseFormat$2) {
      ResponseFormat$2.inboundSchema = exports.ResponseFormat$inboundSchema;
      ResponseFormat$2.outboundSchema = exports.ResponseFormat$outboundSchema;
    })(ResponseFormat$ || (exports.ResponseFormat$ = ResponseFormat$ = {}));
    function responseFormatToJSON(responseFormat) {
      return JSON.stringify(exports.ResponseFormat$outboundSchema.parse(responseFormat));
    }
    function responseFormatFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ResponseFormat$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ResponseFormat' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/toolchoiceenum.js
var require_toolchoiceenum = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/toolchoiceenum.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ToolChoiceEnum$ = exports.ToolChoiceEnum$outboundSchema = exports.ToolChoiceEnum$inboundSchema = exports.ToolChoiceEnum = void 0;
    var z4 = __importStar(__require("zod"));
    exports.ToolChoiceEnum = {
      Auto: "auto",
      None: "none",
      Any: "any",
      Required: "required"
    };
    exports.ToolChoiceEnum$inboundSchema = z4.nativeEnum(exports.ToolChoiceEnum);
    exports.ToolChoiceEnum$outboundSchema = exports.ToolChoiceEnum$inboundSchema;
    var ToolChoiceEnum$;
    (function(ToolChoiceEnum$2) {
      ToolChoiceEnum$2.inboundSchema = exports.ToolChoiceEnum$inboundSchema;
      ToolChoiceEnum$2.outboundSchema = exports.ToolChoiceEnum$outboundSchema;
    })(ToolChoiceEnum$ || (exports.ToolChoiceEnum$ = ToolChoiceEnum$ = {}));
  }
});

// ../node_modules/@mistralai/mistralai/models/components/completionargs.js
var require_completionargs = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/completionargs.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompletionArgs$ = exports.CompletionArgs$outboundSchema = exports.CompletionArgs$inboundSchema = void 0;
    exports.completionArgsToJSON = completionArgsToJSON;
    exports.completionArgsFromJSON = completionArgsFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var completionargsstop_js_1 = require_completionargsstop();
    var prediction_js_1 = require_prediction();
    var responseformat_js_1 = require_responseformat();
    var toolchoiceenum_js_1 = require_toolchoiceenum();
    exports.CompletionArgs$inboundSchema = z4.object({
      stop: z4.nullable(completionargsstop_js_1.CompletionArgsStop$inboundSchema).optional(),
      presence_penalty: z4.nullable(z4.number()).optional(),
      frequency_penalty: z4.nullable(z4.number()).optional(),
      temperature: z4.nullable(z4.number()).optional(),
      top_p: z4.nullable(z4.number()).optional(),
      max_tokens: z4.nullable(z4.number().int()).optional(),
      random_seed: z4.nullable(z4.number().int()).optional(),
      prediction: z4.nullable(prediction_js_1.Prediction$inboundSchema).optional(),
      response_format: z4.nullable(responseformat_js_1.ResponseFormat$inboundSchema).optional(),
      tool_choice: toolchoiceenum_js_1.ToolChoiceEnum$inboundSchema.optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "presence_penalty": "presencePenalty",
        "frequency_penalty": "frequencyPenalty",
        "top_p": "topP",
        "max_tokens": "maxTokens",
        "random_seed": "randomSeed",
        "response_format": "responseFormat",
        "tool_choice": "toolChoice"
      });
    });
    exports.CompletionArgs$outboundSchema = z4.object({
      stop: z4.nullable(completionargsstop_js_1.CompletionArgsStop$outboundSchema).optional(),
      presencePenalty: z4.nullable(z4.number()).optional(),
      frequencyPenalty: z4.nullable(z4.number()).optional(),
      temperature: z4.nullable(z4.number()).optional(),
      topP: z4.nullable(z4.number()).optional(),
      maxTokens: z4.nullable(z4.number().int()).optional(),
      randomSeed: z4.nullable(z4.number().int()).optional(),
      prediction: z4.nullable(prediction_js_1.Prediction$outboundSchema).optional(),
      responseFormat: z4.nullable(responseformat_js_1.ResponseFormat$outboundSchema).optional(),
      toolChoice: toolchoiceenum_js_1.ToolChoiceEnum$outboundSchema.optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        presencePenalty: "presence_penalty",
        frequencyPenalty: "frequency_penalty",
        topP: "top_p",
        maxTokens: "max_tokens",
        randomSeed: "random_seed",
        responseFormat: "response_format",
        toolChoice: "tool_choice"
      });
    });
    var CompletionArgs$;
    (function(CompletionArgs$2) {
      CompletionArgs$2.inboundSchema = exports.CompletionArgs$inboundSchema;
      CompletionArgs$2.outboundSchema = exports.CompletionArgs$outboundSchema;
    })(CompletionArgs$ || (exports.CompletionArgs$ = CompletionArgs$ = {}));
    function completionArgsToJSON(completionArgs) {
      return JSON.stringify(exports.CompletionArgs$outboundSchema.parse(completionArgs));
    }
    function completionArgsFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.CompletionArgs$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'CompletionArgs' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/documentlibrarytool.js
var require_documentlibrarytool = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/documentlibrarytool.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DocumentLibraryTool$ = exports.DocumentLibraryTool$outboundSchema = exports.DocumentLibraryTool$inboundSchema = exports.DocumentLibraryToolType$ = exports.DocumentLibraryToolType$outboundSchema = exports.DocumentLibraryToolType$inboundSchema = exports.DocumentLibraryToolType = void 0;
    exports.documentLibraryToolToJSON = documentLibraryToolToJSON;
    exports.documentLibraryToolFromJSON = documentLibraryToolFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.DocumentLibraryToolType = {
      DocumentLibrary: "document_library"
    };
    exports.DocumentLibraryToolType$inboundSchema = z4.nativeEnum(exports.DocumentLibraryToolType);
    exports.DocumentLibraryToolType$outboundSchema = exports.DocumentLibraryToolType$inboundSchema;
    var DocumentLibraryToolType$;
    (function(DocumentLibraryToolType$2) {
      DocumentLibraryToolType$2.inboundSchema = exports.DocumentLibraryToolType$inboundSchema;
      DocumentLibraryToolType$2.outboundSchema = exports.DocumentLibraryToolType$outboundSchema;
    })(DocumentLibraryToolType$ || (exports.DocumentLibraryToolType$ = DocumentLibraryToolType$ = {}));
    exports.DocumentLibraryTool$inboundSchema = z4.object({
      type: exports.DocumentLibraryToolType$inboundSchema.default("document_library"),
      library_ids: z4.array(z4.string())
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "library_ids": "libraryIds"
      });
    });
    exports.DocumentLibraryTool$outboundSchema = z4.object({
      type: exports.DocumentLibraryToolType$outboundSchema.default("document_library"),
      libraryIds: z4.array(z4.string())
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        libraryIds: "library_ids"
      });
    });
    var DocumentLibraryTool$;
    (function(DocumentLibraryTool$2) {
      DocumentLibraryTool$2.inboundSchema = exports.DocumentLibraryTool$inboundSchema;
      DocumentLibraryTool$2.outboundSchema = exports.DocumentLibraryTool$outboundSchema;
    })(DocumentLibraryTool$ || (exports.DocumentLibraryTool$ = DocumentLibraryTool$ = {}));
    function documentLibraryToolToJSON(documentLibraryTool) {
      return JSON.stringify(exports.DocumentLibraryTool$outboundSchema.parse(documentLibraryTool));
    }
    function documentLibraryToolFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.DocumentLibraryTool$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'DocumentLibraryTool' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/function.js
var require_function = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/function.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FunctionT$ = exports.FunctionT$outboundSchema = exports.FunctionT$inboundSchema = void 0;
    exports.functionToJSON = functionToJSON;
    exports.functionFromJSON = functionFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    exports.FunctionT$inboundSchema = z4.object({
      name: z4.string(),
      description: z4.string().optional(),
      strict: z4.boolean().optional(),
      parameters: z4.record(z4.any())
    });
    exports.FunctionT$outboundSchema = z4.object({
      name: z4.string(),
      description: z4.string().optional(),
      strict: z4.boolean().optional(),
      parameters: z4.record(z4.any())
    });
    var FunctionT$;
    (function(FunctionT$2) {
      FunctionT$2.inboundSchema = exports.FunctionT$inboundSchema;
      FunctionT$2.outboundSchema = exports.FunctionT$outboundSchema;
    })(FunctionT$ || (exports.FunctionT$ = FunctionT$ = {}));
    function functionToJSON(functionT) {
      return JSON.stringify(exports.FunctionT$outboundSchema.parse(functionT));
    }
    function functionFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.FunctionT$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'FunctionT' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/functiontool.js
var require_functiontool = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/functiontool.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FunctionTool$ = exports.FunctionTool$outboundSchema = exports.FunctionTool$inboundSchema = exports.FunctionToolType$ = exports.FunctionToolType$outboundSchema = exports.FunctionToolType$inboundSchema = exports.FunctionToolType = void 0;
    exports.functionToolToJSON = functionToolToJSON;
    exports.functionToolFromJSON = functionToolFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var function_js_1 = require_function();
    exports.FunctionToolType = {
      Function: "function"
    };
    exports.FunctionToolType$inboundSchema = z4.nativeEnum(exports.FunctionToolType);
    exports.FunctionToolType$outboundSchema = exports.FunctionToolType$inboundSchema;
    var FunctionToolType$;
    (function(FunctionToolType$2) {
      FunctionToolType$2.inboundSchema = exports.FunctionToolType$inboundSchema;
      FunctionToolType$2.outboundSchema = exports.FunctionToolType$outboundSchema;
    })(FunctionToolType$ || (exports.FunctionToolType$ = FunctionToolType$ = {}));
    exports.FunctionTool$inboundSchema = z4.object({
      type: exports.FunctionToolType$inboundSchema.default("function"),
      function: function_js_1.FunctionT$inboundSchema
    });
    exports.FunctionTool$outboundSchema = z4.object({
      type: exports.FunctionToolType$outboundSchema.default("function"),
      function: function_js_1.FunctionT$outboundSchema
    });
    var FunctionTool$;
    (function(FunctionTool$2) {
      FunctionTool$2.inboundSchema = exports.FunctionTool$inboundSchema;
      FunctionTool$2.outboundSchema = exports.FunctionTool$outboundSchema;
    })(FunctionTool$ || (exports.FunctionTool$ = FunctionTool$ = {}));
    function functionToolToJSON(functionTool) {
      return JSON.stringify(exports.FunctionTool$outboundSchema.parse(functionTool));
    }
    function functionToolFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.FunctionTool$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'FunctionTool' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/imagegenerationtool.js
var require_imagegenerationtool = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/imagegenerationtool.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImageGenerationTool$ = exports.ImageGenerationTool$outboundSchema = exports.ImageGenerationTool$inboundSchema = exports.ImageGenerationToolType$ = exports.ImageGenerationToolType$outboundSchema = exports.ImageGenerationToolType$inboundSchema = exports.ImageGenerationToolType = void 0;
    exports.imageGenerationToolToJSON = imageGenerationToolToJSON;
    exports.imageGenerationToolFromJSON = imageGenerationToolFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    exports.ImageGenerationToolType = {
      ImageGeneration: "image_generation"
    };
    exports.ImageGenerationToolType$inboundSchema = z4.nativeEnum(exports.ImageGenerationToolType);
    exports.ImageGenerationToolType$outboundSchema = exports.ImageGenerationToolType$inboundSchema;
    var ImageGenerationToolType$;
    (function(ImageGenerationToolType$2) {
      ImageGenerationToolType$2.inboundSchema = exports.ImageGenerationToolType$inboundSchema;
      ImageGenerationToolType$2.outboundSchema = exports.ImageGenerationToolType$outboundSchema;
    })(ImageGenerationToolType$ || (exports.ImageGenerationToolType$ = ImageGenerationToolType$ = {}));
    exports.ImageGenerationTool$inboundSchema = z4.object({
      type: exports.ImageGenerationToolType$inboundSchema.default("image_generation")
    });
    exports.ImageGenerationTool$outboundSchema = z4.object({
      type: exports.ImageGenerationToolType$outboundSchema.default("image_generation")
    });
    var ImageGenerationTool$;
    (function(ImageGenerationTool$2) {
      ImageGenerationTool$2.inboundSchema = exports.ImageGenerationTool$inboundSchema;
      ImageGenerationTool$2.outboundSchema = exports.ImageGenerationTool$outboundSchema;
    })(ImageGenerationTool$ || (exports.ImageGenerationTool$ = ImageGenerationTool$ = {}));
    function imageGenerationToolToJSON(imageGenerationTool) {
      return JSON.stringify(exports.ImageGenerationTool$outboundSchema.parse(imageGenerationTool));
    }
    function imageGenerationToolFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ImageGenerationTool$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ImageGenerationTool' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/websearchpremiumtool.js
var require_websearchpremiumtool = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/websearchpremiumtool.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSearchPremiumTool$ = exports.WebSearchPremiumTool$outboundSchema = exports.WebSearchPremiumTool$inboundSchema = exports.WebSearchPremiumToolType$ = exports.WebSearchPremiumToolType$outboundSchema = exports.WebSearchPremiumToolType$inboundSchema = exports.WebSearchPremiumToolType = void 0;
    exports.webSearchPremiumToolToJSON = webSearchPremiumToolToJSON;
    exports.webSearchPremiumToolFromJSON = webSearchPremiumToolFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    exports.WebSearchPremiumToolType = {
      WebSearchPremium: "web_search_premium"
    };
    exports.WebSearchPremiumToolType$inboundSchema = z4.nativeEnum(exports.WebSearchPremiumToolType);
    exports.WebSearchPremiumToolType$outboundSchema = exports.WebSearchPremiumToolType$inboundSchema;
    var WebSearchPremiumToolType$;
    (function(WebSearchPremiumToolType$2) {
      WebSearchPremiumToolType$2.inboundSchema = exports.WebSearchPremiumToolType$inboundSchema;
      WebSearchPremiumToolType$2.outboundSchema = exports.WebSearchPremiumToolType$outboundSchema;
    })(WebSearchPremiumToolType$ || (exports.WebSearchPremiumToolType$ = WebSearchPremiumToolType$ = {}));
    exports.WebSearchPremiumTool$inboundSchema = z4.object({
      type: exports.WebSearchPremiumToolType$inboundSchema.default("web_search_premium")
    });
    exports.WebSearchPremiumTool$outboundSchema = z4.object({
      type: exports.WebSearchPremiumToolType$outboundSchema.default("web_search_premium")
    });
    var WebSearchPremiumTool$;
    (function(WebSearchPremiumTool$2) {
      WebSearchPremiumTool$2.inboundSchema = exports.WebSearchPremiumTool$inboundSchema;
      WebSearchPremiumTool$2.outboundSchema = exports.WebSearchPremiumTool$outboundSchema;
    })(WebSearchPremiumTool$ || (exports.WebSearchPremiumTool$ = WebSearchPremiumTool$ = {}));
    function webSearchPremiumToolToJSON(webSearchPremiumTool) {
      return JSON.stringify(exports.WebSearchPremiumTool$outboundSchema.parse(webSearchPremiumTool));
    }
    function webSearchPremiumToolFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.WebSearchPremiumTool$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebSearchPremiumTool' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/websearchtool.js
var require_websearchtool = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/websearchtool.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSearchTool$ = exports.WebSearchTool$outboundSchema = exports.WebSearchTool$inboundSchema = exports.WebSearchToolType$ = exports.WebSearchToolType$outboundSchema = exports.WebSearchToolType$inboundSchema = exports.WebSearchToolType = void 0;
    exports.webSearchToolToJSON = webSearchToolToJSON;
    exports.webSearchToolFromJSON = webSearchToolFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    exports.WebSearchToolType = {
      WebSearch: "web_search"
    };
    exports.WebSearchToolType$inboundSchema = z4.nativeEnum(exports.WebSearchToolType);
    exports.WebSearchToolType$outboundSchema = exports.WebSearchToolType$inboundSchema;
    var WebSearchToolType$;
    (function(WebSearchToolType$2) {
      WebSearchToolType$2.inboundSchema = exports.WebSearchToolType$inboundSchema;
      WebSearchToolType$2.outboundSchema = exports.WebSearchToolType$outboundSchema;
    })(WebSearchToolType$ || (exports.WebSearchToolType$ = WebSearchToolType$ = {}));
    exports.WebSearchTool$inboundSchema = z4.object({
      type: exports.WebSearchToolType$inboundSchema.default("web_search")
    });
    exports.WebSearchTool$outboundSchema = z4.object({
      type: exports.WebSearchToolType$outboundSchema.default("web_search")
    });
    var WebSearchTool$;
    (function(WebSearchTool$2) {
      WebSearchTool$2.inboundSchema = exports.WebSearchTool$inboundSchema;
      WebSearchTool$2.outboundSchema = exports.WebSearchTool$outboundSchema;
    })(WebSearchTool$ || (exports.WebSearchTool$ = WebSearchTool$ = {}));
    function webSearchToolToJSON(webSearchTool) {
      return JSON.stringify(exports.WebSearchTool$outboundSchema.parse(webSearchTool));
    }
    function webSearchToolFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.WebSearchTool$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WebSearchTool' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/agent.js
var require_agent2 = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/agent.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Agent$ = exports.Agent$outboundSchema = exports.Agent$inboundSchema = exports.AgentObject$ = exports.AgentObject$outboundSchema = exports.AgentObject$inboundSchema = exports.AgentTools$ = exports.AgentTools$outboundSchema = exports.AgentTools$inboundSchema = exports.AgentObject = void 0;
    exports.agentToolsToJSON = agentToolsToJSON;
    exports.agentToolsFromJSON = agentToolsFromJSON;
    exports.agentToJSON = agentToJSON;
    exports.agentFromJSON = agentFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var codeinterpretertool_js_1 = require_codeinterpretertool();
    var completionargs_js_1 = require_completionargs();
    var documentlibrarytool_js_1 = require_documentlibrarytool();
    var functiontool_js_1 = require_functiontool();
    var imagegenerationtool_js_1 = require_imagegenerationtool();
    var websearchpremiumtool_js_1 = require_websearchpremiumtool();
    var websearchtool_js_1 = require_websearchtool();
    exports.AgentObject = {
      Agent: "agent"
    };
    exports.AgentTools$inboundSchema = z4.union([
      codeinterpretertool_js_1.CodeInterpreterTool$inboundSchema.and(z4.object({ type: z4.literal("code_interpreter") }).transform((v2) => ({
        type: v2.type
      }))),
      imagegenerationtool_js_1.ImageGenerationTool$inboundSchema.and(z4.object({ type: z4.literal("image_generation") }).transform((v2) => ({
        type: v2.type
      }))),
      websearchtool_js_1.WebSearchTool$inboundSchema.and(z4.object({ type: z4.literal("web_search") }).transform((v2) => ({
        type: v2.type
      }))),
      websearchpremiumtool_js_1.WebSearchPremiumTool$inboundSchema.and(z4.object({ type: z4.literal("web_search_premium") }).transform((v2) => ({
        type: v2.type
      }))),
      documentlibrarytool_js_1.DocumentLibraryTool$inboundSchema.and(z4.object({ type: z4.literal("document_library") }).transform((v2) => ({
        type: v2.type
      }))),
      functiontool_js_1.FunctionTool$inboundSchema.and(z4.object({ type: z4.literal("function") }).transform((v2) => ({
        type: v2.type
      })))
    ]);
    exports.AgentTools$outboundSchema = z4.union([
      codeinterpretertool_js_1.CodeInterpreterTool$outboundSchema.and(z4.object({ type: z4.literal("code_interpreter") }).transform((v2) => ({
        type: v2.type
      }))),
      imagegenerationtool_js_1.ImageGenerationTool$outboundSchema.and(z4.object({ type: z4.literal("image_generation") }).transform((v2) => ({
        type: v2.type
      }))),
      websearchtool_js_1.WebSearchTool$outboundSchema.and(z4.object({ type: z4.literal("web_search") }).transform((v2) => ({
        type: v2.type
      }))),
      websearchpremiumtool_js_1.WebSearchPremiumTool$outboundSchema.and(z4.object({ type: z4.literal("web_search_premium") }).transform((v2) => ({
        type: v2.type
      }))),
      documentlibrarytool_js_1.DocumentLibraryTool$outboundSchema.and(z4.object({ type: z4.literal("document_library") }).transform((v2) => ({
        type: v2.type
      }))),
      functiontool_js_1.FunctionTool$outboundSchema.and(z4.object({ type: z4.literal("function") }).transform((v2) => ({
        type: v2.type
      })))
    ]);
    var AgentTools$;
    (function(AgentTools$2) {
      AgentTools$2.inboundSchema = exports.AgentTools$inboundSchema;
      AgentTools$2.outboundSchema = exports.AgentTools$outboundSchema;
    })(AgentTools$ || (exports.AgentTools$ = AgentTools$ = {}));
    function agentToolsToJSON(agentTools) {
      return JSON.stringify(exports.AgentTools$outboundSchema.parse(agentTools));
    }
    function agentToolsFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AgentTools$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AgentTools' from JSON`);
    }
    exports.AgentObject$inboundSchema = z4.nativeEnum(exports.AgentObject);
    exports.AgentObject$outboundSchema = exports.AgentObject$inboundSchema;
    var AgentObject$;
    (function(AgentObject$2) {
      AgentObject$2.inboundSchema = exports.AgentObject$inboundSchema;
      AgentObject$2.outboundSchema = exports.AgentObject$outboundSchema;
    })(AgentObject$ || (exports.AgentObject$ = AgentObject$ = {}));
    exports.Agent$inboundSchema = z4.object({
      instructions: z4.nullable(z4.string()).optional(),
      tools: z4.array(z4.union([
        codeinterpretertool_js_1.CodeInterpreterTool$inboundSchema.and(z4.object({ type: z4.literal("code_interpreter") }).transform((v2) => ({
          type: v2.type
        }))),
        imagegenerationtool_js_1.ImageGenerationTool$inboundSchema.and(z4.object({ type: z4.literal("image_generation") }).transform((v2) => ({
          type: v2.type
        }))),
        websearchtool_js_1.WebSearchTool$inboundSchema.and(z4.object({ type: z4.literal("web_search") }).transform((v2) => ({
          type: v2.type
        }))),
        websearchpremiumtool_js_1.WebSearchPremiumTool$inboundSchema.and(z4.object({ type: z4.literal("web_search_premium") }).transform((v2) => ({ type: v2.type }))),
        documentlibrarytool_js_1.DocumentLibraryTool$inboundSchema.and(z4.object({ type: z4.literal("document_library") }).transform((v2) => ({
          type: v2.type
        }))),
        functiontool_js_1.FunctionTool$inboundSchema.and(z4.object({ type: z4.literal("function") }).transform((v2) => ({
          type: v2.type
        })))
      ])).optional(),
      completion_args: completionargs_js_1.CompletionArgs$inboundSchema.optional(),
      model: z4.string(),
      name: z4.string(),
      description: z4.nullable(z4.string()).optional(),
      handoffs: z4.nullable(z4.array(z4.string())).optional(),
      object: exports.AgentObject$inboundSchema.default("agent"),
      id: z4.string(),
      version: z4.number().int(),
      created_at: z4.string().datetime({ offset: true }).transform((v2) => new Date(v2)),
      updated_at: z4.string().datetime({ offset: true }).transform((v2) => new Date(v2))
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "completion_args": "completionArgs",
        "created_at": "createdAt",
        "updated_at": "updatedAt"
      });
    });
    exports.Agent$outboundSchema = z4.object({
      instructions: z4.nullable(z4.string()).optional(),
      tools: z4.array(z4.union([
        codeinterpretertool_js_1.CodeInterpreterTool$outboundSchema.and(z4.object({ type: z4.literal("code_interpreter") }).transform((v2) => ({
          type: v2.type
        }))),
        imagegenerationtool_js_1.ImageGenerationTool$outboundSchema.and(z4.object({ type: z4.literal("image_generation") }).transform((v2) => ({
          type: v2.type
        }))),
        websearchtool_js_1.WebSearchTool$outboundSchema.and(z4.object({ type: z4.literal("web_search") }).transform((v2) => ({
          type: v2.type
        }))),
        websearchpremiumtool_js_1.WebSearchPremiumTool$outboundSchema.and(z4.object({ type: z4.literal("web_search_premium") }).transform((v2) => ({
          type: v2.type
        }))),
        documentlibrarytool_js_1.DocumentLibraryTool$outboundSchema.and(z4.object({ type: z4.literal("document_library") }).transform((v2) => ({
          type: v2.type
        }))),
        functiontool_js_1.FunctionTool$outboundSchema.and(z4.object({ type: z4.literal("function") }).transform((v2) => ({
          type: v2.type
        })))
      ])).optional(),
      completionArgs: completionargs_js_1.CompletionArgs$outboundSchema.optional(),
      model: z4.string(),
      name: z4.string(),
      description: z4.nullable(z4.string()).optional(),
      handoffs: z4.nullable(z4.array(z4.string())).optional(),
      object: exports.AgentObject$outboundSchema.default("agent"),
      id: z4.string(),
      version: z4.number().int(),
      createdAt: z4.date().transform((v2) => v2.toISOString()),
      updatedAt: z4.date().transform((v2) => v2.toISOString())
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        completionArgs: "completion_args",
        createdAt: "created_at",
        updatedAt: "updated_at"
      });
    });
    var Agent$;
    (function(Agent$2) {
      Agent$2.inboundSchema = exports.Agent$inboundSchema;
      Agent$2.outboundSchema = exports.Agent$outboundSchema;
    })(Agent$ || (exports.Agent$ = Agent$ = {}));
    function agentToJSON(agent) {
      return JSON.stringify(exports.Agent$outboundSchema.parse(agent));
    }
    function agentFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.Agent$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'Agent' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/agentconversation.js
var require_agentconversation = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/agentconversation.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AgentConversation$ = exports.AgentConversation$outboundSchema = exports.AgentConversation$inboundSchema = exports.AgentConversationObject$ = exports.AgentConversationObject$outboundSchema = exports.AgentConversationObject$inboundSchema = exports.AgentConversationObject = void 0;
    exports.agentConversationToJSON = agentConversationToJSON;
    exports.agentConversationFromJSON = agentConversationFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.AgentConversationObject = {
      Conversation: "conversation"
    };
    exports.AgentConversationObject$inboundSchema = z4.nativeEnum(exports.AgentConversationObject);
    exports.AgentConversationObject$outboundSchema = exports.AgentConversationObject$inboundSchema;
    var AgentConversationObject$;
    (function(AgentConversationObject$2) {
      AgentConversationObject$2.inboundSchema = exports.AgentConversationObject$inboundSchema;
      AgentConversationObject$2.outboundSchema = exports.AgentConversationObject$outboundSchema;
    })(AgentConversationObject$ || (exports.AgentConversationObject$ = AgentConversationObject$ = {}));
    exports.AgentConversation$inboundSchema = z4.object({
      name: z4.nullable(z4.string()).optional(),
      description: z4.nullable(z4.string()).optional(),
      object: exports.AgentConversationObject$inboundSchema.default("conversation"),
      id: z4.string(),
      created_at: z4.string().datetime({ offset: true }).transform((v2) => new Date(v2)),
      updated_at: z4.string().datetime({ offset: true }).transform((v2) => new Date(v2)),
      agent_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "created_at": "createdAt",
        "updated_at": "updatedAt",
        "agent_id": "agentId"
      });
    });
    exports.AgentConversation$outboundSchema = z4.object({
      name: z4.nullable(z4.string()).optional(),
      description: z4.nullable(z4.string()).optional(),
      object: exports.AgentConversationObject$outboundSchema.default("conversation"),
      id: z4.string(),
      createdAt: z4.date().transform((v2) => v2.toISOString()),
      updatedAt: z4.date().transform((v2) => v2.toISOString()),
      agentId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        createdAt: "created_at",
        updatedAt: "updated_at",
        agentId: "agent_id"
      });
    });
    var AgentConversation$;
    (function(AgentConversation$2) {
      AgentConversation$2.inboundSchema = exports.AgentConversation$inboundSchema;
      AgentConversation$2.outboundSchema = exports.AgentConversation$outboundSchema;
    })(AgentConversation$ || (exports.AgentConversation$ = AgentConversation$ = {}));
    function agentConversationToJSON(agentConversation) {
      return JSON.stringify(exports.AgentConversation$outboundSchema.parse(agentConversation));
    }
    function agentConversationFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AgentConversation$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AgentConversation' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/agentcreationrequest.js
var require_agentcreationrequest = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/agentcreationrequest.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AgentCreationRequest$ = exports.AgentCreationRequest$outboundSchema = exports.AgentCreationRequest$inboundSchema = exports.AgentCreationRequestTools$ = exports.AgentCreationRequestTools$outboundSchema = exports.AgentCreationRequestTools$inboundSchema = void 0;
    exports.agentCreationRequestToolsToJSON = agentCreationRequestToolsToJSON;
    exports.agentCreationRequestToolsFromJSON = agentCreationRequestToolsFromJSON;
    exports.agentCreationRequestToJSON = agentCreationRequestToJSON;
    exports.agentCreationRequestFromJSON = agentCreationRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var codeinterpretertool_js_1 = require_codeinterpretertool();
    var completionargs_js_1 = require_completionargs();
    var documentlibrarytool_js_1 = require_documentlibrarytool();
    var functiontool_js_1 = require_functiontool();
    var imagegenerationtool_js_1 = require_imagegenerationtool();
    var websearchpremiumtool_js_1 = require_websearchpremiumtool();
    var websearchtool_js_1 = require_websearchtool();
    exports.AgentCreationRequestTools$inboundSchema = z4.union([
      codeinterpretertool_js_1.CodeInterpreterTool$inboundSchema.and(z4.object({ type: z4.literal("code_interpreter") }).transform((v2) => ({
        type: v2.type
      }))),
      imagegenerationtool_js_1.ImageGenerationTool$inboundSchema.and(z4.object({ type: z4.literal("image_generation") }).transform((v2) => ({
        type: v2.type
      }))),
      websearchtool_js_1.WebSearchTool$inboundSchema.and(z4.object({ type: z4.literal("web_search") }).transform((v2) => ({
        type: v2.type
      }))),
      websearchpremiumtool_js_1.WebSearchPremiumTool$inboundSchema.and(z4.object({ type: z4.literal("web_search_premium") }).transform((v2) => ({
        type: v2.type
      }))),
      documentlibrarytool_js_1.DocumentLibraryTool$inboundSchema.and(z4.object({ type: z4.literal("document_library") }).transform((v2) => ({
        type: v2.type
      }))),
      functiontool_js_1.FunctionTool$inboundSchema.and(z4.object({ type: z4.literal("function") }).transform((v2) => ({
        type: v2.type
      })))
    ]);
    exports.AgentCreationRequestTools$outboundSchema = z4.union([
      codeinterpretertool_js_1.CodeInterpreterTool$outboundSchema.and(z4.object({ type: z4.literal("code_interpreter") }).transform((v2) => ({
        type: v2.type
      }))),
      imagegenerationtool_js_1.ImageGenerationTool$outboundSchema.and(z4.object({ type: z4.literal("image_generation") }).transform((v2) => ({
        type: v2.type
      }))),
      websearchtool_js_1.WebSearchTool$outboundSchema.and(z4.object({ type: z4.literal("web_search") }).transform((v2) => ({
        type: v2.type
      }))),
      websearchpremiumtool_js_1.WebSearchPremiumTool$outboundSchema.and(z4.object({ type: z4.literal("web_search_premium") }).transform((v2) => ({
        type: v2.type
      }))),
      documentlibrarytool_js_1.DocumentLibraryTool$outboundSchema.and(z4.object({ type: z4.literal("document_library") }).transform((v2) => ({
        type: v2.type
      }))),
      functiontool_js_1.FunctionTool$outboundSchema.and(z4.object({ type: z4.literal("function") }).transform((v2) => ({
        type: v2.type
      })))
    ]);
    var AgentCreationRequestTools$;
    (function(AgentCreationRequestTools$2) {
      AgentCreationRequestTools$2.inboundSchema = exports.AgentCreationRequestTools$inboundSchema;
      AgentCreationRequestTools$2.outboundSchema = exports.AgentCreationRequestTools$outboundSchema;
    })(AgentCreationRequestTools$ || (exports.AgentCreationRequestTools$ = AgentCreationRequestTools$ = {}));
    function agentCreationRequestToolsToJSON(agentCreationRequestTools) {
      return JSON.stringify(exports.AgentCreationRequestTools$outboundSchema.parse(agentCreationRequestTools));
    }
    function agentCreationRequestToolsFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AgentCreationRequestTools$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AgentCreationRequestTools' from JSON`);
    }
    exports.AgentCreationRequest$inboundSchema = z4.object({
      instructions: z4.nullable(z4.string()).optional(),
      tools: z4.array(z4.union([
        codeinterpretertool_js_1.CodeInterpreterTool$inboundSchema.and(z4.object({ type: z4.literal("code_interpreter") }).transform((v2) => ({
          type: v2.type
        }))),
        imagegenerationtool_js_1.ImageGenerationTool$inboundSchema.and(z4.object({ type: z4.literal("image_generation") }).transform((v2) => ({
          type: v2.type
        }))),
        websearchtool_js_1.WebSearchTool$inboundSchema.and(z4.object({ type: z4.literal("web_search") }).transform((v2) => ({
          type: v2.type
        }))),
        websearchpremiumtool_js_1.WebSearchPremiumTool$inboundSchema.and(z4.object({ type: z4.literal("web_search_premium") }).transform((v2) => ({
          type: v2.type
        }))),
        documentlibrarytool_js_1.DocumentLibraryTool$inboundSchema.and(z4.object({ type: z4.literal("document_library") }).transform((v2) => ({
          type: v2.type
        }))),
        functiontool_js_1.FunctionTool$inboundSchema.and(z4.object({ type: z4.literal("function") }).transform((v2) => ({
          type: v2.type
        })))
      ])).optional(),
      completion_args: completionargs_js_1.CompletionArgs$inboundSchema.optional(),
      model: z4.string(),
      name: z4.string(),
      description: z4.nullable(z4.string()).optional(),
      handoffs: z4.nullable(z4.array(z4.string())).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "completion_args": "completionArgs"
      });
    });
    exports.AgentCreationRequest$outboundSchema = z4.object({
      instructions: z4.nullable(z4.string()).optional(),
      tools: z4.array(z4.union([
        codeinterpretertool_js_1.CodeInterpreterTool$outboundSchema.and(z4.object({ type: z4.literal("code_interpreter") }).transform((v2) => ({
          type: v2.type
        }))),
        imagegenerationtool_js_1.ImageGenerationTool$outboundSchema.and(z4.object({ type: z4.literal("image_generation") }).transform((v2) => ({
          type: v2.type
        }))),
        websearchtool_js_1.WebSearchTool$outboundSchema.and(z4.object({ type: z4.literal("web_search") }).transform((v2) => ({
          type: v2.type
        }))),
        websearchpremiumtool_js_1.WebSearchPremiumTool$outboundSchema.and(z4.object({ type: z4.literal("web_search_premium") }).transform((v2) => ({
          type: v2.type
        }))),
        documentlibrarytool_js_1.DocumentLibraryTool$outboundSchema.and(z4.object({ type: z4.literal("document_library") }).transform((v2) => ({
          type: v2.type
        }))),
        functiontool_js_1.FunctionTool$outboundSchema.and(z4.object({ type: z4.literal("function") }).transform((v2) => ({
          type: v2.type
        })))
      ])).optional(),
      completionArgs: completionargs_js_1.CompletionArgs$outboundSchema.optional(),
      model: z4.string(),
      name: z4.string(),
      description: z4.nullable(z4.string()).optional(),
      handoffs: z4.nullable(z4.array(z4.string())).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        completionArgs: "completion_args"
      });
    });
    var AgentCreationRequest$;
    (function(AgentCreationRequest$2) {
      AgentCreationRequest$2.inboundSchema = exports.AgentCreationRequest$inboundSchema;
      AgentCreationRequest$2.outboundSchema = exports.AgentCreationRequest$outboundSchema;
    })(AgentCreationRequest$ || (exports.AgentCreationRequest$ = AgentCreationRequest$ = {}));
    function agentCreationRequestToJSON(agentCreationRequest) {
      return JSON.stringify(exports.AgentCreationRequest$outboundSchema.parse(agentCreationRequest));
    }
    function agentCreationRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AgentCreationRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AgentCreationRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/agenthandoffdoneevent.js
var require_agenthandoffdoneevent = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/agenthandoffdoneevent.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AgentHandoffDoneEvent$ = exports.AgentHandoffDoneEvent$outboundSchema = exports.AgentHandoffDoneEvent$inboundSchema = exports.AgentHandoffDoneEventType$ = exports.AgentHandoffDoneEventType$outboundSchema = exports.AgentHandoffDoneEventType$inboundSchema = exports.AgentHandoffDoneEventType = void 0;
    exports.agentHandoffDoneEventToJSON = agentHandoffDoneEventToJSON;
    exports.agentHandoffDoneEventFromJSON = agentHandoffDoneEventFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.AgentHandoffDoneEventType = {
      AgentHandoffDone: "agent.handoff.done"
    };
    exports.AgentHandoffDoneEventType$inboundSchema = z4.nativeEnum(exports.AgentHandoffDoneEventType);
    exports.AgentHandoffDoneEventType$outboundSchema = exports.AgentHandoffDoneEventType$inboundSchema;
    var AgentHandoffDoneEventType$;
    (function(AgentHandoffDoneEventType$2) {
      AgentHandoffDoneEventType$2.inboundSchema = exports.AgentHandoffDoneEventType$inboundSchema;
      AgentHandoffDoneEventType$2.outboundSchema = exports.AgentHandoffDoneEventType$outboundSchema;
    })(AgentHandoffDoneEventType$ || (exports.AgentHandoffDoneEventType$ = AgentHandoffDoneEventType$ = {}));
    exports.AgentHandoffDoneEvent$inboundSchema = z4.object({
      type: exports.AgentHandoffDoneEventType$inboundSchema.default("agent.handoff.done"),
      created_at: z4.string().datetime({ offset: true }).transform((v2) => new Date(v2)).optional(),
      output_index: z4.number().int().default(0),
      id: z4.string(),
      next_agent_id: z4.string(),
      next_agent_name: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "created_at": "createdAt",
        "output_index": "outputIndex",
        "next_agent_id": "nextAgentId",
        "next_agent_name": "nextAgentName"
      });
    });
    exports.AgentHandoffDoneEvent$outboundSchema = z4.object({
      type: exports.AgentHandoffDoneEventType$outboundSchema.default("agent.handoff.done"),
      createdAt: z4.date().transform((v2) => v2.toISOString()).optional(),
      outputIndex: z4.number().int().default(0),
      id: z4.string(),
      nextAgentId: z4.string(),
      nextAgentName: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        createdAt: "created_at",
        outputIndex: "output_index",
        nextAgentId: "next_agent_id",
        nextAgentName: "next_agent_name"
      });
    });
    var AgentHandoffDoneEvent$;
    (function(AgentHandoffDoneEvent$2) {
      AgentHandoffDoneEvent$2.inboundSchema = exports.AgentHandoffDoneEvent$inboundSchema;
      AgentHandoffDoneEvent$2.outboundSchema = exports.AgentHandoffDoneEvent$outboundSchema;
    })(AgentHandoffDoneEvent$ || (exports.AgentHandoffDoneEvent$ = AgentHandoffDoneEvent$ = {}));
    function agentHandoffDoneEventToJSON(agentHandoffDoneEvent) {
      return JSON.stringify(exports.AgentHandoffDoneEvent$outboundSchema.parse(agentHandoffDoneEvent));
    }
    function agentHandoffDoneEventFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AgentHandoffDoneEvent$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AgentHandoffDoneEvent' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/agenthandoffentry.js
var require_agenthandoffentry = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/agenthandoffentry.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AgentHandoffEntry$ = exports.AgentHandoffEntry$outboundSchema = exports.AgentHandoffEntry$inboundSchema = exports.AgentHandoffEntryType$ = exports.AgentHandoffEntryType$outboundSchema = exports.AgentHandoffEntryType$inboundSchema = exports.AgentHandoffEntryObject$ = exports.AgentHandoffEntryObject$outboundSchema = exports.AgentHandoffEntryObject$inboundSchema = exports.AgentHandoffEntryType = exports.AgentHandoffEntryObject = void 0;
    exports.agentHandoffEntryToJSON = agentHandoffEntryToJSON;
    exports.agentHandoffEntryFromJSON = agentHandoffEntryFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.AgentHandoffEntryObject = {
      Entry: "entry"
    };
    exports.AgentHandoffEntryType = {
      AgentHandoff: "agent.handoff"
    };
    exports.AgentHandoffEntryObject$inboundSchema = z4.nativeEnum(exports.AgentHandoffEntryObject);
    exports.AgentHandoffEntryObject$outboundSchema = exports.AgentHandoffEntryObject$inboundSchema;
    var AgentHandoffEntryObject$;
    (function(AgentHandoffEntryObject$2) {
      AgentHandoffEntryObject$2.inboundSchema = exports.AgentHandoffEntryObject$inboundSchema;
      AgentHandoffEntryObject$2.outboundSchema = exports.AgentHandoffEntryObject$outboundSchema;
    })(AgentHandoffEntryObject$ || (exports.AgentHandoffEntryObject$ = AgentHandoffEntryObject$ = {}));
    exports.AgentHandoffEntryType$inboundSchema = z4.nativeEnum(exports.AgentHandoffEntryType);
    exports.AgentHandoffEntryType$outboundSchema = exports.AgentHandoffEntryType$inboundSchema;
    var AgentHandoffEntryType$;
    (function(AgentHandoffEntryType$2) {
      AgentHandoffEntryType$2.inboundSchema = exports.AgentHandoffEntryType$inboundSchema;
      AgentHandoffEntryType$2.outboundSchema = exports.AgentHandoffEntryType$outboundSchema;
    })(AgentHandoffEntryType$ || (exports.AgentHandoffEntryType$ = AgentHandoffEntryType$ = {}));
    exports.AgentHandoffEntry$inboundSchema = z4.object({
      object: exports.AgentHandoffEntryObject$inboundSchema.default("entry"),
      type: exports.AgentHandoffEntryType$inboundSchema.default("agent.handoff"),
      created_at: z4.string().datetime({ offset: true }).transform((v2) => new Date(v2)).optional(),
      completed_at: z4.nullable(z4.string().datetime({ offset: true }).transform((v2) => new Date(v2))).optional(),
      id: z4.string().optional(),
      previous_agent_id: z4.string(),
      previous_agent_name: z4.string(),
      next_agent_id: z4.string(),
      next_agent_name: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "created_at": "createdAt",
        "completed_at": "completedAt",
        "previous_agent_id": "previousAgentId",
        "previous_agent_name": "previousAgentName",
        "next_agent_id": "nextAgentId",
        "next_agent_name": "nextAgentName"
      });
    });
    exports.AgentHandoffEntry$outboundSchema = z4.object({
      object: exports.AgentHandoffEntryObject$outboundSchema.default("entry"),
      type: exports.AgentHandoffEntryType$outboundSchema.default("agent.handoff"),
      createdAt: z4.date().transform((v2) => v2.toISOString()).optional(),
      completedAt: z4.nullable(z4.date().transform((v2) => v2.toISOString())).optional(),
      id: z4.string().optional(),
      previousAgentId: z4.string(),
      previousAgentName: z4.string(),
      nextAgentId: z4.string(),
      nextAgentName: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        createdAt: "created_at",
        completedAt: "completed_at",
        previousAgentId: "previous_agent_id",
        previousAgentName: "previous_agent_name",
        nextAgentId: "next_agent_id",
        nextAgentName: "next_agent_name"
      });
    });
    var AgentHandoffEntry$;
    (function(AgentHandoffEntry$2) {
      AgentHandoffEntry$2.inboundSchema = exports.AgentHandoffEntry$inboundSchema;
      AgentHandoffEntry$2.outboundSchema = exports.AgentHandoffEntry$outboundSchema;
    })(AgentHandoffEntry$ || (exports.AgentHandoffEntry$ = AgentHandoffEntry$ = {}));
    function agentHandoffEntryToJSON(agentHandoffEntry) {
      return JSON.stringify(exports.AgentHandoffEntry$outboundSchema.parse(agentHandoffEntry));
    }
    function agentHandoffEntryFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AgentHandoffEntry$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AgentHandoffEntry' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/agenthandoffstartedevent.js
var require_agenthandoffstartedevent = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/agenthandoffstartedevent.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AgentHandoffStartedEvent$ = exports.AgentHandoffStartedEvent$outboundSchema = exports.AgentHandoffStartedEvent$inboundSchema = exports.AgentHandoffStartedEventType$ = exports.AgentHandoffStartedEventType$outboundSchema = exports.AgentHandoffStartedEventType$inboundSchema = exports.AgentHandoffStartedEventType = void 0;
    exports.agentHandoffStartedEventToJSON = agentHandoffStartedEventToJSON;
    exports.agentHandoffStartedEventFromJSON = agentHandoffStartedEventFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.AgentHandoffStartedEventType = {
      AgentHandoffStarted: "agent.handoff.started"
    };
    exports.AgentHandoffStartedEventType$inboundSchema = z4.nativeEnum(exports.AgentHandoffStartedEventType);
    exports.AgentHandoffStartedEventType$outboundSchema = exports.AgentHandoffStartedEventType$inboundSchema;
    var AgentHandoffStartedEventType$;
    (function(AgentHandoffStartedEventType$2) {
      AgentHandoffStartedEventType$2.inboundSchema = exports.AgentHandoffStartedEventType$inboundSchema;
      AgentHandoffStartedEventType$2.outboundSchema = exports.AgentHandoffStartedEventType$outboundSchema;
    })(AgentHandoffStartedEventType$ || (exports.AgentHandoffStartedEventType$ = AgentHandoffStartedEventType$ = {}));
    exports.AgentHandoffStartedEvent$inboundSchema = z4.object({
      type: exports.AgentHandoffStartedEventType$inboundSchema.default("agent.handoff.started"),
      created_at: z4.string().datetime({ offset: true }).transform((v2) => new Date(v2)).optional(),
      output_index: z4.number().int().default(0),
      id: z4.string(),
      previous_agent_id: z4.string(),
      previous_agent_name: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "created_at": "createdAt",
        "output_index": "outputIndex",
        "previous_agent_id": "previousAgentId",
        "previous_agent_name": "previousAgentName"
      });
    });
    exports.AgentHandoffStartedEvent$outboundSchema = z4.object({
      type: exports.AgentHandoffStartedEventType$outboundSchema.default("agent.handoff.started"),
      createdAt: z4.date().transform((v2) => v2.toISOString()).optional(),
      outputIndex: z4.number().int().default(0),
      id: z4.string(),
      previousAgentId: z4.string(),
      previousAgentName: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        createdAt: "created_at",
        outputIndex: "output_index",
        previousAgentId: "previous_agent_id",
        previousAgentName: "previous_agent_name"
      });
    });
    var AgentHandoffStartedEvent$;
    (function(AgentHandoffStartedEvent$2) {
      AgentHandoffStartedEvent$2.inboundSchema = exports.AgentHandoffStartedEvent$inboundSchema;
      AgentHandoffStartedEvent$2.outboundSchema = exports.AgentHandoffStartedEvent$outboundSchema;
    })(AgentHandoffStartedEvent$ || (exports.AgentHandoffStartedEvent$ = AgentHandoffStartedEvent$ = {}));
    function agentHandoffStartedEventToJSON(agentHandoffStartedEvent) {
      return JSON.stringify(exports.AgentHandoffStartedEvent$outboundSchema.parse(agentHandoffStartedEvent));
    }
    function agentHandoffStartedEventFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AgentHandoffStartedEvent$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AgentHandoffStartedEvent' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/audiochunk.js
var require_audiochunk = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/audiochunk.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AudioChunk$ = exports.AudioChunk$outboundSchema = exports.AudioChunk$inboundSchema = exports.AudioChunkType$ = exports.AudioChunkType$outboundSchema = exports.AudioChunkType$inboundSchema = exports.AudioChunkType = void 0;
    exports.audioChunkToJSON = audioChunkToJSON;
    exports.audioChunkFromJSON = audioChunkFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.AudioChunkType = {
      InputAudio: "input_audio"
    };
    exports.AudioChunkType$inboundSchema = z4.nativeEnum(exports.AudioChunkType);
    exports.AudioChunkType$outboundSchema = exports.AudioChunkType$inboundSchema;
    var AudioChunkType$;
    (function(AudioChunkType$2) {
      AudioChunkType$2.inboundSchema = exports.AudioChunkType$inboundSchema;
      AudioChunkType$2.outboundSchema = exports.AudioChunkType$outboundSchema;
    })(AudioChunkType$ || (exports.AudioChunkType$ = AudioChunkType$ = {}));
    exports.AudioChunk$inboundSchema = z4.object({
      input_audio: z4.string(),
      type: exports.AudioChunkType$inboundSchema.default("input_audio")
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "input_audio": "inputAudio"
      });
    });
    exports.AudioChunk$outboundSchema = z4.object({
      inputAudio: z4.string(),
      type: exports.AudioChunkType$outboundSchema.default("input_audio")
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        inputAudio: "input_audio"
      });
    });
    var AudioChunk$;
    (function(AudioChunk$2) {
      AudioChunk$2.inboundSchema = exports.AudioChunk$inboundSchema;
      AudioChunk$2.outboundSchema = exports.AudioChunk$outboundSchema;
    })(AudioChunk$ || (exports.AudioChunk$ = AudioChunk$ = {}));
    function audioChunkToJSON(audioChunk) {
      return JSON.stringify(exports.AudioChunk$outboundSchema.parse(audioChunk));
    }
    function audioChunkFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AudioChunk$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AudioChunk' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/documenturlchunk.js
var require_documenturlchunk = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/documenturlchunk.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DocumentURLChunk$ = exports.DocumentURLChunk$outboundSchema = exports.DocumentURLChunk$inboundSchema = exports.DocumentURLChunkType$ = exports.DocumentURLChunkType$outboundSchema = exports.DocumentURLChunkType$inboundSchema = exports.DocumentURLChunkType = void 0;
    exports.documentURLChunkToJSON = documentURLChunkToJSON;
    exports.documentURLChunkFromJSON = documentURLChunkFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.DocumentURLChunkType = {
      DocumentUrl: "document_url"
    };
    exports.DocumentURLChunkType$inboundSchema = z4.nativeEnum(exports.DocumentURLChunkType);
    exports.DocumentURLChunkType$outboundSchema = exports.DocumentURLChunkType$inboundSchema;
    var DocumentURLChunkType$;
    (function(DocumentURLChunkType$2) {
      DocumentURLChunkType$2.inboundSchema = exports.DocumentURLChunkType$inboundSchema;
      DocumentURLChunkType$2.outboundSchema = exports.DocumentURLChunkType$outboundSchema;
    })(DocumentURLChunkType$ || (exports.DocumentURLChunkType$ = DocumentURLChunkType$ = {}));
    exports.DocumentURLChunk$inboundSchema = z4.object({
      document_url: z4.string(),
      document_name: z4.nullable(z4.string()).optional(),
      type: exports.DocumentURLChunkType$inboundSchema.default("document_url")
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "document_url": "documentUrl",
        "document_name": "documentName"
      });
    });
    exports.DocumentURLChunk$outboundSchema = z4.object({
      documentUrl: z4.string(),
      documentName: z4.nullable(z4.string()).optional(),
      type: exports.DocumentURLChunkType$outboundSchema.default("document_url")
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        documentUrl: "document_url",
        documentName: "document_name"
      });
    });
    var DocumentURLChunk$;
    (function(DocumentURLChunk$2) {
      DocumentURLChunk$2.inboundSchema = exports.DocumentURLChunk$inboundSchema;
      DocumentURLChunk$2.outboundSchema = exports.DocumentURLChunk$outboundSchema;
    })(DocumentURLChunk$ || (exports.DocumentURLChunk$ = DocumentURLChunk$ = {}));
    function documentURLChunkToJSON(documentURLChunk) {
      return JSON.stringify(exports.DocumentURLChunk$outboundSchema.parse(documentURLChunk));
    }
    function documentURLChunkFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.DocumentURLChunk$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'DocumentURLChunk' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/filechunk.js
var require_filechunk = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/filechunk.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FileChunk$ = exports.FileChunk$outboundSchema = exports.FileChunk$inboundSchema = void 0;
    exports.fileChunkToJSON = fileChunkToJSON;
    exports.fileChunkFromJSON = fileChunkFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.FileChunk$inboundSchema = z4.object({
      type: z4.literal("file").default("file"),
      file_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "file_id": "fileId"
      });
    });
    exports.FileChunk$outboundSchema = z4.object({
      type: z4.literal("file").default("file"),
      fileId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        fileId: "file_id"
      });
    });
    var FileChunk$;
    (function(FileChunk$2) {
      FileChunk$2.inboundSchema = exports.FileChunk$inboundSchema;
      FileChunk$2.outboundSchema = exports.FileChunk$outboundSchema;
    })(FileChunk$ || (exports.FileChunk$ = FileChunk$ = {}));
    function fileChunkToJSON(fileChunk) {
      return JSON.stringify(exports.FileChunk$outboundSchema.parse(fileChunk));
    }
    function fileChunkFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.FileChunk$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'FileChunk' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/imageurl.js
var require_imageurl = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/imageurl.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImageURL$ = exports.ImageURL$outboundSchema = exports.ImageURL$inboundSchema = void 0;
    exports.imageURLToJSON = imageURLToJSON;
    exports.imageURLFromJSON = imageURLFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    exports.ImageURL$inboundSchema = z4.object({
      url: z4.string(),
      detail: z4.nullable(z4.string()).optional()
    });
    exports.ImageURL$outboundSchema = z4.object({
      url: z4.string(),
      detail: z4.nullable(z4.string()).optional()
    });
    var ImageURL$;
    (function(ImageURL$2) {
      ImageURL$2.inboundSchema = exports.ImageURL$inboundSchema;
      ImageURL$2.outboundSchema = exports.ImageURL$outboundSchema;
    })(ImageURL$ || (exports.ImageURL$ = ImageURL$ = {}));
    function imageURLToJSON(imageURL) {
      return JSON.stringify(exports.ImageURL$outboundSchema.parse(imageURL));
    }
    function imageURLFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ImageURL$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ImageURL' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/imageurlchunk.js
var require_imageurlchunk = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/imageurlchunk.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImageURLChunk$ = exports.ImageURLChunk$outboundSchema = exports.ImageURLChunk$inboundSchema = exports.ImageURLChunkType$ = exports.ImageURLChunkType$outboundSchema = exports.ImageURLChunkType$inboundSchema = exports.ImageURLChunkImageURL$ = exports.ImageURLChunkImageURL$outboundSchema = exports.ImageURLChunkImageURL$inboundSchema = exports.ImageURLChunkType = void 0;
    exports.imageURLChunkImageURLToJSON = imageURLChunkImageURLToJSON;
    exports.imageURLChunkImageURLFromJSON = imageURLChunkImageURLFromJSON;
    exports.imageURLChunkToJSON = imageURLChunkToJSON;
    exports.imageURLChunkFromJSON = imageURLChunkFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var imageurl_js_1 = require_imageurl();
    exports.ImageURLChunkType = {
      ImageUrl: "image_url"
    };
    exports.ImageURLChunkImageURL$inboundSchema = z4.union([imageurl_js_1.ImageURL$inboundSchema, z4.string()]);
    exports.ImageURLChunkImageURL$outboundSchema = z4.union([imageurl_js_1.ImageURL$outboundSchema, z4.string()]);
    var ImageURLChunkImageURL$;
    (function(ImageURLChunkImageURL$2) {
      ImageURLChunkImageURL$2.inboundSchema = exports.ImageURLChunkImageURL$inboundSchema;
      ImageURLChunkImageURL$2.outboundSchema = exports.ImageURLChunkImageURL$outboundSchema;
    })(ImageURLChunkImageURL$ || (exports.ImageURLChunkImageURL$ = ImageURLChunkImageURL$ = {}));
    function imageURLChunkImageURLToJSON(imageURLChunkImageURL) {
      return JSON.stringify(exports.ImageURLChunkImageURL$outboundSchema.parse(imageURLChunkImageURL));
    }
    function imageURLChunkImageURLFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ImageURLChunkImageURL$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ImageURLChunkImageURL' from JSON`);
    }
    exports.ImageURLChunkType$inboundSchema = z4.nativeEnum(exports.ImageURLChunkType);
    exports.ImageURLChunkType$outboundSchema = exports.ImageURLChunkType$inboundSchema;
    var ImageURLChunkType$;
    (function(ImageURLChunkType$2) {
      ImageURLChunkType$2.inboundSchema = exports.ImageURLChunkType$inboundSchema;
      ImageURLChunkType$2.outboundSchema = exports.ImageURLChunkType$outboundSchema;
    })(ImageURLChunkType$ || (exports.ImageURLChunkType$ = ImageURLChunkType$ = {}));
    exports.ImageURLChunk$inboundSchema = z4.object({
      image_url: z4.union([imageurl_js_1.ImageURL$inboundSchema, z4.string()]),
      type: exports.ImageURLChunkType$inboundSchema.default("image_url")
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "image_url": "imageUrl"
      });
    });
    exports.ImageURLChunk$outboundSchema = z4.object({
      imageUrl: z4.union([imageurl_js_1.ImageURL$outboundSchema, z4.string()]),
      type: exports.ImageURLChunkType$outboundSchema.default("image_url")
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        imageUrl: "image_url"
      });
    });
    var ImageURLChunk$;
    (function(ImageURLChunk$2) {
      ImageURLChunk$2.inboundSchema = exports.ImageURLChunk$inboundSchema;
      ImageURLChunk$2.outboundSchema = exports.ImageURLChunk$outboundSchema;
    })(ImageURLChunk$ || (exports.ImageURLChunk$ = ImageURLChunk$ = {}));
    function imageURLChunkToJSON(imageURLChunk) {
      return JSON.stringify(exports.ImageURLChunk$outboundSchema.parse(imageURLChunk));
    }
    function imageURLChunkFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ImageURLChunk$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ImageURLChunk' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/referencechunk.js
var require_referencechunk = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/referencechunk.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReferenceChunk$ = exports.ReferenceChunk$outboundSchema = exports.ReferenceChunk$inboundSchema = exports.ReferenceChunkType$ = exports.ReferenceChunkType$outboundSchema = exports.ReferenceChunkType$inboundSchema = exports.ReferenceChunkType = void 0;
    exports.referenceChunkToJSON = referenceChunkToJSON;
    exports.referenceChunkFromJSON = referenceChunkFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.ReferenceChunkType = {
      Reference: "reference"
    };
    exports.ReferenceChunkType$inboundSchema = z4.nativeEnum(exports.ReferenceChunkType);
    exports.ReferenceChunkType$outboundSchema = exports.ReferenceChunkType$inboundSchema;
    var ReferenceChunkType$;
    (function(ReferenceChunkType$2) {
      ReferenceChunkType$2.inboundSchema = exports.ReferenceChunkType$inboundSchema;
      ReferenceChunkType$2.outboundSchema = exports.ReferenceChunkType$outboundSchema;
    })(ReferenceChunkType$ || (exports.ReferenceChunkType$ = ReferenceChunkType$ = {}));
    exports.ReferenceChunk$inboundSchema = z4.object({
      reference_ids: z4.array(z4.number().int()),
      type: exports.ReferenceChunkType$inboundSchema.default("reference")
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "reference_ids": "referenceIds"
      });
    });
    exports.ReferenceChunk$outboundSchema = z4.object({
      referenceIds: z4.array(z4.number().int()),
      type: exports.ReferenceChunkType$outboundSchema.default("reference")
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        referenceIds: "reference_ids"
      });
    });
    var ReferenceChunk$;
    (function(ReferenceChunk$2) {
      ReferenceChunk$2.inboundSchema = exports.ReferenceChunk$inboundSchema;
      ReferenceChunk$2.outboundSchema = exports.ReferenceChunk$outboundSchema;
    })(ReferenceChunk$ || (exports.ReferenceChunk$ = ReferenceChunk$ = {}));
    function referenceChunkToJSON(referenceChunk) {
      return JSON.stringify(exports.ReferenceChunk$outboundSchema.parse(referenceChunk));
    }
    function referenceChunkFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ReferenceChunk$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ReferenceChunk' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/textchunk.js
var require_textchunk = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/textchunk.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TextChunk$ = exports.TextChunk$outboundSchema = exports.TextChunk$inboundSchema = exports.TextChunkType$ = exports.TextChunkType$outboundSchema = exports.TextChunkType$inboundSchema = exports.TextChunkType = void 0;
    exports.textChunkToJSON = textChunkToJSON;
    exports.textChunkFromJSON = textChunkFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    exports.TextChunkType = {
      Text: "text"
    };
    exports.TextChunkType$inboundSchema = z4.nativeEnum(exports.TextChunkType);
    exports.TextChunkType$outboundSchema = exports.TextChunkType$inboundSchema;
    var TextChunkType$;
    (function(TextChunkType$2) {
      TextChunkType$2.inboundSchema = exports.TextChunkType$inboundSchema;
      TextChunkType$2.outboundSchema = exports.TextChunkType$outboundSchema;
    })(TextChunkType$ || (exports.TextChunkType$ = TextChunkType$ = {}));
    exports.TextChunk$inboundSchema = z4.object({
      text: z4.string(),
      type: exports.TextChunkType$inboundSchema.default("text")
    });
    exports.TextChunk$outboundSchema = z4.object({
      text: z4.string(),
      type: exports.TextChunkType$outboundSchema.default("text")
    });
    var TextChunk$;
    (function(TextChunk$2) {
      TextChunk$2.inboundSchema = exports.TextChunk$inboundSchema;
      TextChunk$2.outboundSchema = exports.TextChunk$outboundSchema;
    })(TextChunk$ || (exports.TextChunk$ = TextChunk$ = {}));
    function textChunkToJSON(textChunk) {
      return JSON.stringify(exports.TextChunk$outboundSchema.parse(textChunk));
    }
    function textChunkFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.TextChunk$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'TextChunk' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/thinkchunk.js
var require_thinkchunk = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/thinkchunk.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ThinkChunk$ = exports.ThinkChunk$outboundSchema = exports.ThinkChunk$inboundSchema = exports.ThinkChunkType$ = exports.ThinkChunkType$outboundSchema = exports.ThinkChunkType$inboundSchema = exports.Thinking$ = exports.Thinking$outboundSchema = exports.Thinking$inboundSchema = exports.ThinkChunkType = void 0;
    exports.thinkingToJSON = thinkingToJSON;
    exports.thinkingFromJSON = thinkingFromJSON;
    exports.thinkChunkToJSON = thinkChunkToJSON;
    exports.thinkChunkFromJSON = thinkChunkFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var referencechunk_js_1 = require_referencechunk();
    var textchunk_js_1 = require_textchunk();
    exports.ThinkChunkType = {
      Thinking: "thinking"
    };
    exports.Thinking$inboundSchema = z4.union([referencechunk_js_1.ReferenceChunk$inboundSchema, textchunk_js_1.TextChunk$inboundSchema]);
    exports.Thinking$outboundSchema = z4.union([referencechunk_js_1.ReferenceChunk$outboundSchema, textchunk_js_1.TextChunk$outboundSchema]);
    var Thinking$;
    (function(Thinking$2) {
      Thinking$2.inboundSchema = exports.Thinking$inboundSchema;
      Thinking$2.outboundSchema = exports.Thinking$outboundSchema;
    })(Thinking$ || (exports.Thinking$ = Thinking$ = {}));
    function thinkingToJSON(thinking) {
      return JSON.stringify(exports.Thinking$outboundSchema.parse(thinking));
    }
    function thinkingFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.Thinking$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'Thinking' from JSON`);
    }
    exports.ThinkChunkType$inboundSchema = z4.nativeEnum(exports.ThinkChunkType);
    exports.ThinkChunkType$outboundSchema = exports.ThinkChunkType$inboundSchema;
    var ThinkChunkType$;
    (function(ThinkChunkType$2) {
      ThinkChunkType$2.inboundSchema = exports.ThinkChunkType$inboundSchema;
      ThinkChunkType$2.outboundSchema = exports.ThinkChunkType$outboundSchema;
    })(ThinkChunkType$ || (exports.ThinkChunkType$ = ThinkChunkType$ = {}));
    exports.ThinkChunk$inboundSchema = z4.object({
      thinking: z4.array(z4.union([referencechunk_js_1.ReferenceChunk$inboundSchema, textchunk_js_1.TextChunk$inboundSchema])),
      closed: z4.boolean().optional(),
      type: exports.ThinkChunkType$inboundSchema.default("thinking")
    });
    exports.ThinkChunk$outboundSchema = z4.object({
      thinking: z4.array(z4.union([referencechunk_js_1.ReferenceChunk$outboundSchema, textchunk_js_1.TextChunk$outboundSchema])),
      closed: z4.boolean().optional(),
      type: exports.ThinkChunkType$outboundSchema.default("thinking")
    });
    var ThinkChunk$;
    (function(ThinkChunk$2) {
      ThinkChunk$2.inboundSchema = exports.ThinkChunk$inboundSchema;
      ThinkChunk$2.outboundSchema = exports.ThinkChunk$outboundSchema;
    })(ThinkChunk$ || (exports.ThinkChunk$ = ThinkChunk$ = {}));
    function thinkChunkToJSON(thinkChunk) {
      return JSON.stringify(exports.ThinkChunk$outboundSchema.parse(thinkChunk));
    }
    function thinkChunkFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ThinkChunk$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ThinkChunk' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/contentchunk.js
var require_contentchunk = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/contentchunk.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContentChunk$ = exports.ContentChunk$outboundSchema = exports.ContentChunk$inboundSchema = void 0;
    exports.contentChunkToJSON = contentChunkToJSON;
    exports.contentChunkFromJSON = contentChunkFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var audiochunk_js_1 = require_audiochunk();
    var documenturlchunk_js_1 = require_documenturlchunk();
    var filechunk_js_1 = require_filechunk();
    var imageurlchunk_js_1 = require_imageurlchunk();
    var referencechunk_js_1 = require_referencechunk();
    var textchunk_js_1 = require_textchunk();
    var thinkchunk_js_1 = require_thinkchunk();
    exports.ContentChunk$inboundSchema = z4.union([
      imageurlchunk_js_1.ImageURLChunk$inboundSchema.and(z4.object({ type: z4.literal("image_url") }).transform((v2) => ({
        type: v2.type
      }))),
      textchunk_js_1.TextChunk$inboundSchema.and(z4.object({ type: z4.literal("text") }).transform((v2) => ({ type: v2.type }))),
      referencechunk_js_1.ReferenceChunk$inboundSchema.and(z4.object({ type: z4.literal("reference") }).transform((v2) => ({
        type: v2.type
      }))),
      filechunk_js_1.FileChunk$inboundSchema.and(z4.object({ type: z4.literal("file") }).transform((v2) => ({ type: v2.type }))),
      audiochunk_js_1.AudioChunk$inboundSchema.and(z4.object({ type: z4.literal("input_audio") }).transform((v2) => ({
        type: v2.type
      }))),
      documenturlchunk_js_1.DocumentURLChunk$inboundSchema.and(z4.object({ type: z4.literal("document_url") }).transform((v2) => ({
        type: v2.type
      }))),
      thinkchunk_js_1.ThinkChunk$inboundSchema.and(z4.object({ type: z4.literal("thinking") }).transform((v2) => ({
        type: v2.type
      })))
    ]);
    exports.ContentChunk$outboundSchema = z4.union([
      imageurlchunk_js_1.ImageURLChunk$outboundSchema.and(z4.object({ type: z4.literal("image_url") }).transform((v2) => ({
        type: v2.type
      }))),
      textchunk_js_1.TextChunk$outboundSchema.and(z4.object({ type: z4.literal("text") }).transform((v2) => ({ type: v2.type }))),
      referencechunk_js_1.ReferenceChunk$outboundSchema.and(z4.object({ type: z4.literal("reference") }).transform((v2) => ({
        type: v2.type
      }))),
      filechunk_js_1.FileChunk$outboundSchema.and(z4.object({ type: z4.literal("file") }).transform((v2) => ({ type: v2.type }))),
      audiochunk_js_1.AudioChunk$outboundSchema.and(z4.object({ type: z4.literal("input_audio") }).transform((v2) => ({
        type: v2.type
      }))),
      documenturlchunk_js_1.DocumentURLChunk$outboundSchema.and(z4.object({ type: z4.literal("document_url") }).transform((v2) => ({
        type: v2.type
      }))),
      thinkchunk_js_1.ThinkChunk$outboundSchema.and(z4.object({ type: z4.literal("thinking") }).transform((v2) => ({
        type: v2.type
      })))
    ]);
    var ContentChunk$;
    (function(ContentChunk$2) {
      ContentChunk$2.inboundSchema = exports.ContentChunk$inboundSchema;
      ContentChunk$2.outboundSchema = exports.ContentChunk$outboundSchema;
    })(ContentChunk$ || (exports.ContentChunk$ = ContentChunk$ = {}));
    function contentChunkToJSON(contentChunk) {
      return JSON.stringify(exports.ContentChunk$outboundSchema.parse(contentChunk));
    }
    function contentChunkFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ContentChunk$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ContentChunk' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/functioncall.js
var require_functioncall = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/functioncall.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FunctionCall$ = exports.FunctionCall$outboundSchema = exports.FunctionCall$inboundSchema = exports.Arguments$ = exports.Arguments$outboundSchema = exports.Arguments$inboundSchema = void 0;
    exports.argumentsToJSON = argumentsToJSON;
    exports.argumentsFromJSON = argumentsFromJSON;
    exports.functionCallToJSON = functionCallToJSON;
    exports.functionCallFromJSON = functionCallFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    exports.Arguments$inboundSchema = z4.union([z4.record(z4.any()), z4.string()]);
    exports.Arguments$outboundSchema = z4.union([z4.record(z4.any()), z4.string()]);
    var Arguments$;
    (function(Arguments$2) {
      Arguments$2.inboundSchema = exports.Arguments$inboundSchema;
      Arguments$2.outboundSchema = exports.Arguments$outboundSchema;
    })(Arguments$ || (exports.Arguments$ = Arguments$ = {}));
    function argumentsToJSON(value) {
      return JSON.stringify(exports.Arguments$outboundSchema.parse(value));
    }
    function argumentsFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.Arguments$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'Arguments' from JSON`);
    }
    exports.FunctionCall$inboundSchema = z4.object({
      name: z4.string(),
      arguments: z4.union([z4.record(z4.any()), z4.string()])
    });
    exports.FunctionCall$outboundSchema = z4.object({
      name: z4.string(),
      arguments: z4.union([z4.record(z4.any()), z4.string()])
    });
    var FunctionCall$;
    (function(FunctionCall$2) {
      FunctionCall$2.inboundSchema = exports.FunctionCall$inboundSchema;
      FunctionCall$2.outboundSchema = exports.FunctionCall$outboundSchema;
    })(FunctionCall$ || (exports.FunctionCall$ = FunctionCall$ = {}));
    function functionCallToJSON(functionCall) {
      return JSON.stringify(exports.FunctionCall$outboundSchema.parse(functionCall));
    }
    function functionCallFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.FunctionCall$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'FunctionCall' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/types/enums.js
var require_enums = __commonJS({
  "../node_modules/@mistralai/mistralai/types/enums.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.catchUnrecognizedEnum = catchUnrecognizedEnum;
    function catchUnrecognizedEnum(value) {
      return value;
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/tooltypes.js
var require_tooltypes = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/tooltypes.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ToolTypes$ = exports.ToolTypes$outboundSchema = exports.ToolTypes$inboundSchema = exports.ToolTypes = void 0;
    var z4 = __importStar(__require("zod"));
    var enums_js_1 = require_enums();
    exports.ToolTypes = {
      Function: "function"
    };
    exports.ToolTypes$inboundSchema = z4.union([
      z4.nativeEnum(exports.ToolTypes),
      z4.string().transform(enums_js_1.catchUnrecognizedEnum)
    ]);
    exports.ToolTypes$outboundSchema = z4.union([
      z4.nativeEnum(exports.ToolTypes),
      z4.string().and(z4.custom())
    ]);
    var ToolTypes$;
    (function(ToolTypes$2) {
      ToolTypes$2.inboundSchema = exports.ToolTypes$inboundSchema;
      ToolTypes$2.outboundSchema = exports.ToolTypes$outboundSchema;
    })(ToolTypes$ || (exports.ToolTypes$ = ToolTypes$ = {}));
  }
});

// ../node_modules/@mistralai/mistralai/models/components/toolcall.js
var require_toolcall = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/toolcall.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ToolCall$ = exports.ToolCall$outboundSchema = exports.ToolCall$inboundSchema = exports.Metadata$ = exports.Metadata$outboundSchema = exports.Metadata$inboundSchema = void 0;
    exports.metadataToJSON = metadataToJSON;
    exports.metadataFromJSON = metadataFromJSON;
    exports.toolCallToJSON = toolCallToJSON;
    exports.toolCallFromJSON = toolCallFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var functioncall_js_1 = require_functioncall();
    var tooltypes_js_1 = require_tooltypes();
    exports.Metadata$inboundSchema = z4.object({});
    exports.Metadata$outboundSchema = z4.object({});
    var Metadata$;
    (function(Metadata$2) {
      Metadata$2.inboundSchema = exports.Metadata$inboundSchema;
      Metadata$2.outboundSchema = exports.Metadata$outboundSchema;
    })(Metadata$ || (exports.Metadata$ = Metadata$ = {}));
    function metadataToJSON(metadata) {
      return JSON.stringify(exports.Metadata$outboundSchema.parse(metadata));
    }
    function metadataFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.Metadata$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'Metadata' from JSON`);
    }
    exports.ToolCall$inboundSchema = z4.object({
      id: z4.string().default("null"),
      type: tooltypes_js_1.ToolTypes$inboundSchema.optional(),
      function: functioncall_js_1.FunctionCall$inboundSchema,
      index: z4.number().int().default(0),
      metadata: z4.nullable(z4.lazy(() => exports.Metadata$inboundSchema)).optional()
    });
    exports.ToolCall$outboundSchema = z4.object({
      id: z4.string().default("null"),
      type: tooltypes_js_1.ToolTypes$outboundSchema.optional(),
      function: functioncall_js_1.FunctionCall$outboundSchema,
      index: z4.number().int().default(0),
      metadata: z4.nullable(z4.lazy(() => exports.Metadata$outboundSchema)).optional()
    });
    var ToolCall$;
    (function(ToolCall$2) {
      ToolCall$2.inboundSchema = exports.ToolCall$inboundSchema;
      ToolCall$2.outboundSchema = exports.ToolCall$outboundSchema;
    })(ToolCall$ || (exports.ToolCall$ = ToolCall$ = {}));
    function toolCallToJSON(toolCall) {
      return JSON.stringify(exports.ToolCall$outboundSchema.parse(toolCall));
    }
    function toolCallFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ToolCall$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ToolCall' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/assistantmessage.js
var require_assistantmessage = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/assistantmessage.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AssistantMessage$ = exports.AssistantMessage$outboundSchema = exports.AssistantMessage$inboundSchema = exports.AssistantMessageRole$ = exports.AssistantMessageRole$outboundSchema = exports.AssistantMessageRole$inboundSchema = exports.AssistantMessageContent$ = exports.AssistantMessageContent$outboundSchema = exports.AssistantMessageContent$inboundSchema = exports.AssistantMessageRole = void 0;
    exports.assistantMessageContentToJSON = assistantMessageContentToJSON;
    exports.assistantMessageContentFromJSON = assistantMessageContentFromJSON;
    exports.assistantMessageToJSON = assistantMessageToJSON;
    exports.assistantMessageFromJSON = assistantMessageFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var contentchunk_js_1 = require_contentchunk();
    var toolcall_js_1 = require_toolcall();
    exports.AssistantMessageRole = {
      Assistant: "assistant"
    };
    exports.AssistantMessageContent$inboundSchema = z4.union([z4.string(), z4.array(contentchunk_js_1.ContentChunk$inboundSchema)]);
    exports.AssistantMessageContent$outboundSchema = z4.union([z4.string(), z4.array(contentchunk_js_1.ContentChunk$outboundSchema)]);
    var AssistantMessageContent$;
    (function(AssistantMessageContent$2) {
      AssistantMessageContent$2.inboundSchema = exports.AssistantMessageContent$inboundSchema;
      AssistantMessageContent$2.outboundSchema = exports.AssistantMessageContent$outboundSchema;
    })(AssistantMessageContent$ || (exports.AssistantMessageContent$ = AssistantMessageContent$ = {}));
    function assistantMessageContentToJSON(assistantMessageContent) {
      return JSON.stringify(exports.AssistantMessageContent$outboundSchema.parse(assistantMessageContent));
    }
    function assistantMessageContentFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AssistantMessageContent$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AssistantMessageContent' from JSON`);
    }
    exports.AssistantMessageRole$inboundSchema = z4.nativeEnum(exports.AssistantMessageRole);
    exports.AssistantMessageRole$outboundSchema = exports.AssistantMessageRole$inboundSchema;
    var AssistantMessageRole$;
    (function(AssistantMessageRole$2) {
      AssistantMessageRole$2.inboundSchema = exports.AssistantMessageRole$inboundSchema;
      AssistantMessageRole$2.outboundSchema = exports.AssistantMessageRole$outboundSchema;
    })(AssistantMessageRole$ || (exports.AssistantMessageRole$ = AssistantMessageRole$ = {}));
    exports.AssistantMessage$inboundSchema = z4.object({
      content: z4.nullable(z4.union([z4.string(), z4.array(contentchunk_js_1.ContentChunk$inboundSchema)])).optional(),
      tool_calls: z4.nullable(z4.array(toolcall_js_1.ToolCall$inboundSchema)).optional(),
      prefix: z4.boolean().default(false),
      role: exports.AssistantMessageRole$inboundSchema.default("assistant")
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "tool_calls": "toolCalls"
      });
    });
    exports.AssistantMessage$outboundSchema = z4.object({
      content: z4.nullable(z4.union([z4.string(), z4.array(contentchunk_js_1.ContentChunk$outboundSchema)])).optional(),
      toolCalls: z4.nullable(z4.array(toolcall_js_1.ToolCall$outboundSchema)).optional(),
      prefix: z4.boolean().default(false),
      role: exports.AssistantMessageRole$outboundSchema.default("assistant")
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        toolCalls: "tool_calls"
      });
    });
    var AssistantMessage$;
    (function(AssistantMessage$2) {
      AssistantMessage$2.inboundSchema = exports.AssistantMessage$inboundSchema;
      AssistantMessage$2.outboundSchema = exports.AssistantMessage$outboundSchema;
    })(AssistantMessage$ || (exports.AssistantMessage$ = AssistantMessage$ = {}));
    function assistantMessageToJSON(assistantMessage) {
      return JSON.stringify(exports.AssistantMessage$outboundSchema.parse(assistantMessage));
    }
    function assistantMessageFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AssistantMessage$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AssistantMessage' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/mistralpromptmode.js
var require_mistralpromptmode = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/mistralpromptmode.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MistralPromptMode$ = exports.MistralPromptMode$outboundSchema = exports.MistralPromptMode$inboundSchema = exports.MistralPromptMode = void 0;
    var z4 = __importStar(__require("zod"));
    var enums_js_1 = require_enums();
    exports.MistralPromptMode = {
      Reasoning: "reasoning"
    };
    exports.MistralPromptMode$inboundSchema = z4.union([
      z4.nativeEnum(exports.MistralPromptMode),
      z4.string().transform(enums_js_1.catchUnrecognizedEnum)
    ]);
    exports.MistralPromptMode$outboundSchema = z4.union([
      z4.nativeEnum(exports.MistralPromptMode),
      z4.string().and(z4.custom())
    ]);
    var MistralPromptMode$;
    (function(MistralPromptMode$2) {
      MistralPromptMode$2.inboundSchema = exports.MistralPromptMode$inboundSchema;
      MistralPromptMode$2.outboundSchema = exports.MistralPromptMode$outboundSchema;
    })(MistralPromptMode$ || (exports.MistralPromptMode$ = MistralPromptMode$ = {}));
  }
});

// ../node_modules/@mistralai/mistralai/models/components/systemmessage.js
var require_systemmessage = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/systemmessage.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SystemMessage$ = exports.SystemMessage$outboundSchema = exports.SystemMessage$inboundSchema = exports.Role$ = exports.Role$outboundSchema = exports.Role$inboundSchema = exports.SystemMessageContent$ = exports.SystemMessageContent$outboundSchema = exports.SystemMessageContent$inboundSchema = exports.Role = void 0;
    exports.systemMessageContentToJSON = systemMessageContentToJSON;
    exports.systemMessageContentFromJSON = systemMessageContentFromJSON;
    exports.systemMessageToJSON = systemMessageToJSON;
    exports.systemMessageFromJSON = systemMessageFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var textchunk_js_1 = require_textchunk();
    exports.Role = {
      System: "system"
    };
    exports.SystemMessageContent$inboundSchema = z4.union([z4.string(), z4.array(textchunk_js_1.TextChunk$inboundSchema)]);
    exports.SystemMessageContent$outboundSchema = z4.union([z4.string(), z4.array(textchunk_js_1.TextChunk$outboundSchema)]);
    var SystemMessageContent$;
    (function(SystemMessageContent$2) {
      SystemMessageContent$2.inboundSchema = exports.SystemMessageContent$inboundSchema;
      SystemMessageContent$2.outboundSchema = exports.SystemMessageContent$outboundSchema;
    })(SystemMessageContent$ || (exports.SystemMessageContent$ = SystemMessageContent$ = {}));
    function systemMessageContentToJSON(systemMessageContent) {
      return JSON.stringify(exports.SystemMessageContent$outboundSchema.parse(systemMessageContent));
    }
    function systemMessageContentFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.SystemMessageContent$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'SystemMessageContent' from JSON`);
    }
    exports.Role$inboundSchema = z4.nativeEnum(exports.Role);
    exports.Role$outboundSchema = exports.Role$inboundSchema;
    var Role$;
    (function(Role$2) {
      Role$2.inboundSchema = exports.Role$inboundSchema;
      Role$2.outboundSchema = exports.Role$outboundSchema;
    })(Role$ || (exports.Role$ = Role$ = {}));
    exports.SystemMessage$inboundSchema = z4.object({
      content: z4.union([z4.string(), z4.array(textchunk_js_1.TextChunk$inboundSchema)]),
      role: exports.Role$inboundSchema.default("system")
    });
    exports.SystemMessage$outboundSchema = z4.object({
      content: z4.union([z4.string(), z4.array(textchunk_js_1.TextChunk$outboundSchema)]),
      role: exports.Role$outboundSchema.default("system")
    });
    var SystemMessage$;
    (function(SystemMessage$2) {
      SystemMessage$2.inboundSchema = exports.SystemMessage$inboundSchema;
      SystemMessage$2.outboundSchema = exports.SystemMessage$outboundSchema;
    })(SystemMessage$ || (exports.SystemMessage$ = SystemMessage$ = {}));
    function systemMessageToJSON(systemMessage) {
      return JSON.stringify(exports.SystemMessage$outboundSchema.parse(systemMessage));
    }
    function systemMessageFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.SystemMessage$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'SystemMessage' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/tool.js
var require_tool = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/tool.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tool$ = exports.Tool$outboundSchema = exports.Tool$inboundSchema = void 0;
    exports.toolToJSON = toolToJSON;
    exports.toolFromJSON = toolFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var function_js_1 = require_function();
    var tooltypes_js_1 = require_tooltypes();
    exports.Tool$inboundSchema = z4.object({
      type: tooltypes_js_1.ToolTypes$inboundSchema.optional(),
      function: function_js_1.FunctionT$inboundSchema
    });
    exports.Tool$outboundSchema = z4.object({
      type: tooltypes_js_1.ToolTypes$outboundSchema.optional(),
      function: function_js_1.FunctionT$outboundSchema
    });
    var Tool$;
    (function(Tool$2) {
      Tool$2.inboundSchema = exports.Tool$inboundSchema;
      Tool$2.outboundSchema = exports.Tool$outboundSchema;
    })(Tool$ || (exports.Tool$ = Tool$ = {}));
    function toolToJSON(tool) {
      return JSON.stringify(exports.Tool$outboundSchema.parse(tool));
    }
    function toolFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.Tool$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'Tool' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/functionname.js
var require_functionname = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/functionname.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FunctionName$ = exports.FunctionName$outboundSchema = exports.FunctionName$inboundSchema = void 0;
    exports.functionNameToJSON = functionNameToJSON;
    exports.functionNameFromJSON = functionNameFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    exports.FunctionName$inboundSchema = z4.object({
      name: z4.string()
    });
    exports.FunctionName$outboundSchema = z4.object({
      name: z4.string()
    });
    var FunctionName$;
    (function(FunctionName$2) {
      FunctionName$2.inboundSchema = exports.FunctionName$inboundSchema;
      FunctionName$2.outboundSchema = exports.FunctionName$outboundSchema;
    })(FunctionName$ || (exports.FunctionName$ = FunctionName$ = {}));
    function functionNameToJSON(functionName) {
      return JSON.stringify(exports.FunctionName$outboundSchema.parse(functionName));
    }
    function functionNameFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.FunctionName$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'FunctionName' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/toolchoice.js
var require_toolchoice = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/toolchoice.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ToolChoice$ = exports.ToolChoice$outboundSchema = exports.ToolChoice$inboundSchema = void 0;
    exports.toolChoiceToJSON = toolChoiceToJSON;
    exports.toolChoiceFromJSON = toolChoiceFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var functionname_js_1 = require_functionname();
    var tooltypes_js_1 = require_tooltypes();
    exports.ToolChoice$inboundSchema = z4.object({
      type: tooltypes_js_1.ToolTypes$inboundSchema.optional(),
      function: functionname_js_1.FunctionName$inboundSchema
    });
    exports.ToolChoice$outboundSchema = z4.object({
      type: tooltypes_js_1.ToolTypes$outboundSchema.optional(),
      function: functionname_js_1.FunctionName$outboundSchema
    });
    var ToolChoice$;
    (function(ToolChoice$2) {
      ToolChoice$2.inboundSchema = exports.ToolChoice$inboundSchema;
      ToolChoice$2.outboundSchema = exports.ToolChoice$outboundSchema;
    })(ToolChoice$ || (exports.ToolChoice$ = ToolChoice$ = {}));
    function toolChoiceToJSON(toolChoice) {
      return JSON.stringify(exports.ToolChoice$outboundSchema.parse(toolChoice));
    }
    function toolChoiceFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ToolChoice$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ToolChoice' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/toolmessage.js
var require_toolmessage = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/toolmessage.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ToolMessage$ = exports.ToolMessage$outboundSchema = exports.ToolMessage$inboundSchema = exports.ToolMessageRole$ = exports.ToolMessageRole$outboundSchema = exports.ToolMessageRole$inboundSchema = exports.ToolMessageContent$ = exports.ToolMessageContent$outboundSchema = exports.ToolMessageContent$inboundSchema = exports.ToolMessageRole = void 0;
    exports.toolMessageContentToJSON = toolMessageContentToJSON;
    exports.toolMessageContentFromJSON = toolMessageContentFromJSON;
    exports.toolMessageToJSON = toolMessageToJSON;
    exports.toolMessageFromJSON = toolMessageFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var contentchunk_js_1 = require_contentchunk();
    exports.ToolMessageRole = {
      Tool: "tool"
    };
    exports.ToolMessageContent$inboundSchema = z4.union([z4.string(), z4.array(contentchunk_js_1.ContentChunk$inboundSchema)]);
    exports.ToolMessageContent$outboundSchema = z4.union([z4.string(), z4.array(contentchunk_js_1.ContentChunk$outboundSchema)]);
    var ToolMessageContent$;
    (function(ToolMessageContent$2) {
      ToolMessageContent$2.inboundSchema = exports.ToolMessageContent$inboundSchema;
      ToolMessageContent$2.outboundSchema = exports.ToolMessageContent$outboundSchema;
    })(ToolMessageContent$ || (exports.ToolMessageContent$ = ToolMessageContent$ = {}));
    function toolMessageContentToJSON(toolMessageContent) {
      return JSON.stringify(exports.ToolMessageContent$outboundSchema.parse(toolMessageContent));
    }
    function toolMessageContentFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ToolMessageContent$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ToolMessageContent' from JSON`);
    }
    exports.ToolMessageRole$inboundSchema = z4.nativeEnum(exports.ToolMessageRole);
    exports.ToolMessageRole$outboundSchema = exports.ToolMessageRole$inboundSchema;
    var ToolMessageRole$;
    (function(ToolMessageRole$2) {
      ToolMessageRole$2.inboundSchema = exports.ToolMessageRole$inboundSchema;
      ToolMessageRole$2.outboundSchema = exports.ToolMessageRole$outboundSchema;
    })(ToolMessageRole$ || (exports.ToolMessageRole$ = ToolMessageRole$ = {}));
    exports.ToolMessage$inboundSchema = z4.object({
      content: z4.nullable(z4.union([z4.string(), z4.array(contentchunk_js_1.ContentChunk$inboundSchema)])),
      tool_call_id: z4.nullable(z4.string()).optional(),
      name: z4.nullable(z4.string()).optional(),
      role: exports.ToolMessageRole$inboundSchema.default("tool")
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "tool_call_id": "toolCallId"
      });
    });
    exports.ToolMessage$outboundSchema = z4.object({
      content: z4.nullable(z4.union([z4.string(), z4.array(contentchunk_js_1.ContentChunk$outboundSchema)])),
      toolCallId: z4.nullable(z4.string()).optional(),
      name: z4.nullable(z4.string()).optional(),
      role: exports.ToolMessageRole$outboundSchema.default("tool")
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        toolCallId: "tool_call_id"
      });
    });
    var ToolMessage$;
    (function(ToolMessage$2) {
      ToolMessage$2.inboundSchema = exports.ToolMessage$inboundSchema;
      ToolMessage$2.outboundSchema = exports.ToolMessage$outboundSchema;
    })(ToolMessage$ || (exports.ToolMessage$ = ToolMessage$ = {}));
    function toolMessageToJSON(toolMessage) {
      return JSON.stringify(exports.ToolMessage$outboundSchema.parse(toolMessage));
    }
    function toolMessageFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ToolMessage$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ToolMessage' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/usermessage.js
var require_usermessage = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/usermessage.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UserMessage$ = exports.UserMessage$outboundSchema = exports.UserMessage$inboundSchema = exports.UserMessageRole$ = exports.UserMessageRole$outboundSchema = exports.UserMessageRole$inboundSchema = exports.UserMessageContent$ = exports.UserMessageContent$outboundSchema = exports.UserMessageContent$inboundSchema = exports.UserMessageRole = void 0;
    exports.userMessageContentToJSON = userMessageContentToJSON;
    exports.userMessageContentFromJSON = userMessageContentFromJSON;
    exports.userMessageToJSON = userMessageToJSON;
    exports.userMessageFromJSON = userMessageFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var contentchunk_js_1 = require_contentchunk();
    exports.UserMessageRole = {
      User: "user"
    };
    exports.UserMessageContent$inboundSchema = z4.union([z4.string(), z4.array(contentchunk_js_1.ContentChunk$inboundSchema)]);
    exports.UserMessageContent$outboundSchema = z4.union([z4.string(), z4.array(contentchunk_js_1.ContentChunk$outboundSchema)]);
    var UserMessageContent$;
    (function(UserMessageContent$2) {
      UserMessageContent$2.inboundSchema = exports.UserMessageContent$inboundSchema;
      UserMessageContent$2.outboundSchema = exports.UserMessageContent$outboundSchema;
    })(UserMessageContent$ || (exports.UserMessageContent$ = UserMessageContent$ = {}));
    function userMessageContentToJSON(userMessageContent) {
      return JSON.stringify(exports.UserMessageContent$outboundSchema.parse(userMessageContent));
    }
    function userMessageContentFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.UserMessageContent$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'UserMessageContent' from JSON`);
    }
    exports.UserMessageRole$inboundSchema = z4.nativeEnum(exports.UserMessageRole);
    exports.UserMessageRole$outboundSchema = exports.UserMessageRole$inboundSchema;
    var UserMessageRole$;
    (function(UserMessageRole$2) {
      UserMessageRole$2.inboundSchema = exports.UserMessageRole$inboundSchema;
      UserMessageRole$2.outboundSchema = exports.UserMessageRole$outboundSchema;
    })(UserMessageRole$ || (exports.UserMessageRole$ = UserMessageRole$ = {}));
    exports.UserMessage$inboundSchema = z4.object({
      content: z4.nullable(z4.union([z4.string(), z4.array(contentchunk_js_1.ContentChunk$inboundSchema)])),
      role: exports.UserMessageRole$inboundSchema.default("user")
    });
    exports.UserMessage$outboundSchema = z4.object({
      content: z4.nullable(z4.union([z4.string(), z4.array(contentchunk_js_1.ContentChunk$outboundSchema)])),
      role: exports.UserMessageRole$outboundSchema.default("user")
    });
    var UserMessage$;
    (function(UserMessage$2) {
      UserMessage$2.inboundSchema = exports.UserMessage$inboundSchema;
      UserMessage$2.outboundSchema = exports.UserMessage$outboundSchema;
    })(UserMessage$ || (exports.UserMessage$ = UserMessage$ = {}));
    function userMessageToJSON(userMessage) {
      return JSON.stringify(exports.UserMessage$outboundSchema.parse(userMessage));
    }
    function userMessageFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.UserMessage$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'UserMessage' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/agentscompletionrequest.js
var require_agentscompletionrequest = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/agentscompletionrequest.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AgentsCompletionRequest$ = exports.AgentsCompletionRequest$outboundSchema = exports.AgentsCompletionRequest$inboundSchema = exports.AgentsCompletionRequestToolChoice$ = exports.AgentsCompletionRequestToolChoice$outboundSchema = exports.AgentsCompletionRequestToolChoice$inboundSchema = exports.AgentsCompletionRequestMessages$ = exports.AgentsCompletionRequestMessages$outboundSchema = exports.AgentsCompletionRequestMessages$inboundSchema = exports.AgentsCompletionRequestStop$ = exports.AgentsCompletionRequestStop$outboundSchema = exports.AgentsCompletionRequestStop$inboundSchema = void 0;
    exports.agentsCompletionRequestStopToJSON = agentsCompletionRequestStopToJSON;
    exports.agentsCompletionRequestStopFromJSON = agentsCompletionRequestStopFromJSON;
    exports.agentsCompletionRequestMessagesToJSON = agentsCompletionRequestMessagesToJSON;
    exports.agentsCompletionRequestMessagesFromJSON = agentsCompletionRequestMessagesFromJSON;
    exports.agentsCompletionRequestToolChoiceToJSON = agentsCompletionRequestToolChoiceToJSON;
    exports.agentsCompletionRequestToolChoiceFromJSON = agentsCompletionRequestToolChoiceFromJSON;
    exports.agentsCompletionRequestToJSON = agentsCompletionRequestToJSON;
    exports.agentsCompletionRequestFromJSON = agentsCompletionRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var assistantmessage_js_1 = require_assistantmessage();
    var mistralpromptmode_js_1 = require_mistralpromptmode();
    var prediction_js_1 = require_prediction();
    var responseformat_js_1 = require_responseformat();
    var systemmessage_js_1 = require_systemmessage();
    var tool_js_1 = require_tool();
    var toolchoice_js_1 = require_toolchoice();
    var toolchoiceenum_js_1 = require_toolchoiceenum();
    var toolmessage_js_1 = require_toolmessage();
    var usermessage_js_1 = require_usermessage();
    exports.AgentsCompletionRequestStop$inboundSchema = z4.union([z4.string(), z4.array(z4.string())]);
    exports.AgentsCompletionRequestStop$outboundSchema = z4.union([z4.string(), z4.array(z4.string())]);
    var AgentsCompletionRequestStop$;
    (function(AgentsCompletionRequestStop$2) {
      AgentsCompletionRequestStop$2.inboundSchema = exports.AgentsCompletionRequestStop$inboundSchema;
      AgentsCompletionRequestStop$2.outboundSchema = exports.AgentsCompletionRequestStop$outboundSchema;
    })(AgentsCompletionRequestStop$ || (exports.AgentsCompletionRequestStop$ = AgentsCompletionRequestStop$ = {}));
    function agentsCompletionRequestStopToJSON(agentsCompletionRequestStop) {
      return JSON.stringify(exports.AgentsCompletionRequestStop$outboundSchema.parse(agentsCompletionRequestStop));
    }
    function agentsCompletionRequestStopFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AgentsCompletionRequestStop$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AgentsCompletionRequestStop' from JSON`);
    }
    exports.AgentsCompletionRequestMessages$inboundSchema = z4.union([
      systemmessage_js_1.SystemMessage$inboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
        role: v2.role
      }))),
      usermessage_js_1.UserMessage$inboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({ role: v2.role }))),
      assistantmessage_js_1.AssistantMessage$inboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
        role: v2.role
      }))),
      toolmessage_js_1.ToolMessage$inboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({ role: v2.role })))
    ]);
    exports.AgentsCompletionRequestMessages$outboundSchema = z4.union([
      systemmessage_js_1.SystemMessage$outboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
        role: v2.role
      }))),
      usermessage_js_1.UserMessage$outboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({ role: v2.role }))),
      assistantmessage_js_1.AssistantMessage$outboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
        role: v2.role
      }))),
      toolmessage_js_1.ToolMessage$outboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({ role: v2.role })))
    ]);
    var AgentsCompletionRequestMessages$;
    (function(AgentsCompletionRequestMessages$2) {
      AgentsCompletionRequestMessages$2.inboundSchema = exports.AgentsCompletionRequestMessages$inboundSchema;
      AgentsCompletionRequestMessages$2.outboundSchema = exports.AgentsCompletionRequestMessages$outboundSchema;
    })(AgentsCompletionRequestMessages$ || (exports.AgentsCompletionRequestMessages$ = AgentsCompletionRequestMessages$ = {}));
    function agentsCompletionRequestMessagesToJSON(agentsCompletionRequestMessages) {
      return JSON.stringify(exports.AgentsCompletionRequestMessages$outboundSchema.parse(agentsCompletionRequestMessages));
    }
    function agentsCompletionRequestMessagesFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AgentsCompletionRequestMessages$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AgentsCompletionRequestMessages' from JSON`);
    }
    exports.AgentsCompletionRequestToolChoice$inboundSchema = z4.union([toolchoice_js_1.ToolChoice$inboundSchema, toolchoiceenum_js_1.ToolChoiceEnum$inboundSchema]);
    exports.AgentsCompletionRequestToolChoice$outboundSchema = z4.union([toolchoice_js_1.ToolChoice$outboundSchema, toolchoiceenum_js_1.ToolChoiceEnum$outboundSchema]);
    var AgentsCompletionRequestToolChoice$;
    (function(AgentsCompletionRequestToolChoice$2) {
      AgentsCompletionRequestToolChoice$2.inboundSchema = exports.AgentsCompletionRequestToolChoice$inboundSchema;
      AgentsCompletionRequestToolChoice$2.outboundSchema = exports.AgentsCompletionRequestToolChoice$outboundSchema;
    })(AgentsCompletionRequestToolChoice$ || (exports.AgentsCompletionRequestToolChoice$ = AgentsCompletionRequestToolChoice$ = {}));
    function agentsCompletionRequestToolChoiceToJSON(agentsCompletionRequestToolChoice) {
      return JSON.stringify(exports.AgentsCompletionRequestToolChoice$outboundSchema.parse(agentsCompletionRequestToolChoice));
    }
    function agentsCompletionRequestToolChoiceFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AgentsCompletionRequestToolChoice$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AgentsCompletionRequestToolChoice' from JSON`);
    }
    exports.AgentsCompletionRequest$inboundSchema = z4.object({
      max_tokens: z4.nullable(z4.number().int()).optional(),
      stream: z4.boolean().default(false),
      stop: z4.union([z4.string(), z4.array(z4.string())]).optional(),
      random_seed: z4.nullable(z4.number().int()).optional(),
      messages: z4.array(z4.union([
        systemmessage_js_1.SystemMessage$inboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
          role: v2.role
        }))),
        usermessage_js_1.UserMessage$inboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({
          role: v2.role
        }))),
        assistantmessage_js_1.AssistantMessage$inboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
          role: v2.role
        }))),
        toolmessage_js_1.ToolMessage$inboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({
          role: v2.role
        })))
      ])),
      response_format: responseformat_js_1.ResponseFormat$inboundSchema.optional(),
      tools: z4.nullable(z4.array(tool_js_1.Tool$inboundSchema)).optional(),
      tool_choice: z4.union([toolchoice_js_1.ToolChoice$inboundSchema, toolchoiceenum_js_1.ToolChoiceEnum$inboundSchema]).optional(),
      presence_penalty: z4.number().optional(),
      frequency_penalty: z4.number().optional(),
      n: z4.nullable(z4.number().int()).optional(),
      prediction: prediction_js_1.Prediction$inboundSchema.optional(),
      parallel_tool_calls: z4.boolean().optional(),
      prompt_mode: z4.nullable(mistralpromptmode_js_1.MistralPromptMode$inboundSchema).optional(),
      agent_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "max_tokens": "maxTokens",
        "random_seed": "randomSeed",
        "response_format": "responseFormat",
        "tool_choice": "toolChoice",
        "presence_penalty": "presencePenalty",
        "frequency_penalty": "frequencyPenalty",
        "parallel_tool_calls": "parallelToolCalls",
        "prompt_mode": "promptMode",
        "agent_id": "agentId"
      });
    });
    exports.AgentsCompletionRequest$outboundSchema = z4.object({
      maxTokens: z4.nullable(z4.number().int()).optional(),
      stream: z4.boolean().default(false),
      stop: z4.union([z4.string(), z4.array(z4.string())]).optional(),
      randomSeed: z4.nullable(z4.number().int()).optional(),
      messages: z4.array(z4.union([
        systemmessage_js_1.SystemMessage$outboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
          role: v2.role
        }))),
        usermessage_js_1.UserMessage$outboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({
          role: v2.role
        }))),
        assistantmessage_js_1.AssistantMessage$outboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
          role: v2.role
        }))),
        toolmessage_js_1.ToolMessage$outboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({
          role: v2.role
        })))
      ])),
      responseFormat: responseformat_js_1.ResponseFormat$outboundSchema.optional(),
      tools: z4.nullable(z4.array(tool_js_1.Tool$outboundSchema)).optional(),
      toolChoice: z4.union([
        toolchoice_js_1.ToolChoice$outboundSchema,
        toolchoiceenum_js_1.ToolChoiceEnum$outboundSchema
      ]).optional(),
      presencePenalty: z4.number().optional(),
      frequencyPenalty: z4.number().optional(),
      n: z4.nullable(z4.number().int()).optional(),
      prediction: prediction_js_1.Prediction$outboundSchema.optional(),
      parallelToolCalls: z4.boolean().optional(),
      promptMode: z4.nullable(mistralpromptmode_js_1.MistralPromptMode$outboundSchema).optional(),
      agentId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        maxTokens: "max_tokens",
        randomSeed: "random_seed",
        responseFormat: "response_format",
        toolChoice: "tool_choice",
        presencePenalty: "presence_penalty",
        frequencyPenalty: "frequency_penalty",
        parallelToolCalls: "parallel_tool_calls",
        promptMode: "prompt_mode",
        agentId: "agent_id"
      });
    });
    var AgentsCompletionRequest$;
    (function(AgentsCompletionRequest$2) {
      AgentsCompletionRequest$2.inboundSchema = exports.AgentsCompletionRequest$inboundSchema;
      AgentsCompletionRequest$2.outboundSchema = exports.AgentsCompletionRequest$outboundSchema;
    })(AgentsCompletionRequest$ || (exports.AgentsCompletionRequest$ = AgentsCompletionRequest$ = {}));
    function agentsCompletionRequestToJSON(agentsCompletionRequest) {
      return JSON.stringify(exports.AgentsCompletionRequest$outboundSchema.parse(agentsCompletionRequest));
    }
    function agentsCompletionRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AgentsCompletionRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AgentsCompletionRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/agentscompletionstreamrequest.js
var require_agentscompletionstreamrequest = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/agentscompletionstreamrequest.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AgentsCompletionStreamRequest$ = exports.AgentsCompletionStreamRequest$outboundSchema = exports.AgentsCompletionStreamRequest$inboundSchema = exports.AgentsCompletionStreamRequestToolChoice$ = exports.AgentsCompletionStreamRequestToolChoice$outboundSchema = exports.AgentsCompletionStreamRequestToolChoice$inboundSchema = exports.AgentsCompletionStreamRequestMessages$ = exports.AgentsCompletionStreamRequestMessages$outboundSchema = exports.AgentsCompletionStreamRequestMessages$inboundSchema = exports.AgentsCompletionStreamRequestStop$ = exports.AgentsCompletionStreamRequestStop$outboundSchema = exports.AgentsCompletionStreamRequestStop$inboundSchema = void 0;
    exports.agentsCompletionStreamRequestStopToJSON = agentsCompletionStreamRequestStopToJSON;
    exports.agentsCompletionStreamRequestStopFromJSON = agentsCompletionStreamRequestStopFromJSON;
    exports.agentsCompletionStreamRequestMessagesToJSON = agentsCompletionStreamRequestMessagesToJSON;
    exports.agentsCompletionStreamRequestMessagesFromJSON = agentsCompletionStreamRequestMessagesFromJSON;
    exports.agentsCompletionStreamRequestToolChoiceToJSON = agentsCompletionStreamRequestToolChoiceToJSON;
    exports.agentsCompletionStreamRequestToolChoiceFromJSON = agentsCompletionStreamRequestToolChoiceFromJSON;
    exports.agentsCompletionStreamRequestToJSON = agentsCompletionStreamRequestToJSON;
    exports.agentsCompletionStreamRequestFromJSON = agentsCompletionStreamRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var assistantmessage_js_1 = require_assistantmessage();
    var mistralpromptmode_js_1 = require_mistralpromptmode();
    var prediction_js_1 = require_prediction();
    var responseformat_js_1 = require_responseformat();
    var systemmessage_js_1 = require_systemmessage();
    var tool_js_1 = require_tool();
    var toolchoice_js_1 = require_toolchoice();
    var toolchoiceenum_js_1 = require_toolchoiceenum();
    var toolmessage_js_1 = require_toolmessage();
    var usermessage_js_1 = require_usermessage();
    exports.AgentsCompletionStreamRequestStop$inboundSchema = z4.union([z4.string(), z4.array(z4.string())]);
    exports.AgentsCompletionStreamRequestStop$outboundSchema = z4.union([z4.string(), z4.array(z4.string())]);
    var AgentsCompletionStreamRequestStop$;
    (function(AgentsCompletionStreamRequestStop$2) {
      AgentsCompletionStreamRequestStop$2.inboundSchema = exports.AgentsCompletionStreamRequestStop$inboundSchema;
      AgentsCompletionStreamRequestStop$2.outboundSchema = exports.AgentsCompletionStreamRequestStop$outboundSchema;
    })(AgentsCompletionStreamRequestStop$ || (exports.AgentsCompletionStreamRequestStop$ = AgentsCompletionStreamRequestStop$ = {}));
    function agentsCompletionStreamRequestStopToJSON(agentsCompletionStreamRequestStop) {
      return JSON.stringify(exports.AgentsCompletionStreamRequestStop$outboundSchema.parse(agentsCompletionStreamRequestStop));
    }
    function agentsCompletionStreamRequestStopFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AgentsCompletionStreamRequestStop$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AgentsCompletionStreamRequestStop' from JSON`);
    }
    exports.AgentsCompletionStreamRequestMessages$inboundSchema = z4.union([
      systemmessage_js_1.SystemMessage$inboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
        role: v2.role
      }))),
      usermessage_js_1.UserMessage$inboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({ role: v2.role }))),
      assistantmessage_js_1.AssistantMessage$inboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
        role: v2.role
      }))),
      toolmessage_js_1.ToolMessage$inboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({ role: v2.role })))
    ]);
    exports.AgentsCompletionStreamRequestMessages$outboundSchema = z4.union([
      systemmessage_js_1.SystemMessage$outboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
        role: v2.role
      }))),
      usermessage_js_1.UserMessage$outboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({ role: v2.role }))),
      assistantmessage_js_1.AssistantMessage$outboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
        role: v2.role
      }))),
      toolmessage_js_1.ToolMessage$outboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({ role: v2.role })))
    ]);
    var AgentsCompletionStreamRequestMessages$;
    (function(AgentsCompletionStreamRequestMessages$2) {
      AgentsCompletionStreamRequestMessages$2.inboundSchema = exports.AgentsCompletionStreamRequestMessages$inboundSchema;
      AgentsCompletionStreamRequestMessages$2.outboundSchema = exports.AgentsCompletionStreamRequestMessages$outboundSchema;
    })(AgentsCompletionStreamRequestMessages$ || (exports.AgentsCompletionStreamRequestMessages$ = AgentsCompletionStreamRequestMessages$ = {}));
    function agentsCompletionStreamRequestMessagesToJSON(agentsCompletionStreamRequestMessages) {
      return JSON.stringify(exports.AgentsCompletionStreamRequestMessages$outboundSchema.parse(agentsCompletionStreamRequestMessages));
    }
    function agentsCompletionStreamRequestMessagesFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AgentsCompletionStreamRequestMessages$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AgentsCompletionStreamRequestMessages' from JSON`);
    }
    exports.AgentsCompletionStreamRequestToolChoice$inboundSchema = z4.union([toolchoice_js_1.ToolChoice$inboundSchema, toolchoiceenum_js_1.ToolChoiceEnum$inboundSchema]);
    exports.AgentsCompletionStreamRequestToolChoice$outboundSchema = z4.union([toolchoice_js_1.ToolChoice$outboundSchema, toolchoiceenum_js_1.ToolChoiceEnum$outboundSchema]);
    var AgentsCompletionStreamRequestToolChoice$;
    (function(AgentsCompletionStreamRequestToolChoice$2) {
      AgentsCompletionStreamRequestToolChoice$2.inboundSchema = exports.AgentsCompletionStreamRequestToolChoice$inboundSchema;
      AgentsCompletionStreamRequestToolChoice$2.outboundSchema = exports.AgentsCompletionStreamRequestToolChoice$outboundSchema;
    })(AgentsCompletionStreamRequestToolChoice$ || (exports.AgentsCompletionStreamRequestToolChoice$ = AgentsCompletionStreamRequestToolChoice$ = {}));
    function agentsCompletionStreamRequestToolChoiceToJSON(agentsCompletionStreamRequestToolChoice) {
      return JSON.stringify(exports.AgentsCompletionStreamRequestToolChoice$outboundSchema.parse(agentsCompletionStreamRequestToolChoice));
    }
    function agentsCompletionStreamRequestToolChoiceFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AgentsCompletionStreamRequestToolChoice$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AgentsCompletionStreamRequestToolChoice' from JSON`);
    }
    exports.AgentsCompletionStreamRequest$inboundSchema = z4.object({
      max_tokens: z4.nullable(z4.number().int()).optional(),
      stream: z4.boolean().default(true),
      stop: z4.union([z4.string(), z4.array(z4.string())]).optional(),
      random_seed: z4.nullable(z4.number().int()).optional(),
      messages: z4.array(z4.union([
        systemmessage_js_1.SystemMessage$inboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
          role: v2.role
        }))),
        usermessage_js_1.UserMessage$inboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({
          role: v2.role
        }))),
        assistantmessage_js_1.AssistantMessage$inboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
          role: v2.role
        }))),
        toolmessage_js_1.ToolMessage$inboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({
          role: v2.role
        })))
      ])),
      response_format: responseformat_js_1.ResponseFormat$inboundSchema.optional(),
      tools: z4.nullable(z4.array(tool_js_1.Tool$inboundSchema)).optional(),
      tool_choice: z4.union([toolchoice_js_1.ToolChoice$inboundSchema, toolchoiceenum_js_1.ToolChoiceEnum$inboundSchema]).optional(),
      presence_penalty: z4.number().optional(),
      frequency_penalty: z4.number().optional(),
      n: z4.nullable(z4.number().int()).optional(),
      prediction: prediction_js_1.Prediction$inboundSchema.optional(),
      parallel_tool_calls: z4.boolean().optional(),
      prompt_mode: z4.nullable(mistralpromptmode_js_1.MistralPromptMode$inboundSchema).optional(),
      agent_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "max_tokens": "maxTokens",
        "random_seed": "randomSeed",
        "response_format": "responseFormat",
        "tool_choice": "toolChoice",
        "presence_penalty": "presencePenalty",
        "frequency_penalty": "frequencyPenalty",
        "parallel_tool_calls": "parallelToolCalls",
        "prompt_mode": "promptMode",
        "agent_id": "agentId"
      });
    });
    exports.AgentsCompletionStreamRequest$outboundSchema = z4.object({
      maxTokens: z4.nullable(z4.number().int()).optional(),
      stream: z4.boolean().default(true),
      stop: z4.union([z4.string(), z4.array(z4.string())]).optional(),
      randomSeed: z4.nullable(z4.number().int()).optional(),
      messages: z4.array(z4.union([
        systemmessage_js_1.SystemMessage$outboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
          role: v2.role
        }))),
        usermessage_js_1.UserMessage$outboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({
          role: v2.role
        }))),
        assistantmessage_js_1.AssistantMessage$outboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
          role: v2.role
        }))),
        toolmessage_js_1.ToolMessage$outboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({
          role: v2.role
        })))
      ])),
      responseFormat: responseformat_js_1.ResponseFormat$outboundSchema.optional(),
      tools: z4.nullable(z4.array(tool_js_1.Tool$outboundSchema)).optional(),
      toolChoice: z4.union([
        toolchoice_js_1.ToolChoice$outboundSchema,
        toolchoiceenum_js_1.ToolChoiceEnum$outboundSchema
      ]).optional(),
      presencePenalty: z4.number().optional(),
      frequencyPenalty: z4.number().optional(),
      n: z4.nullable(z4.number().int()).optional(),
      prediction: prediction_js_1.Prediction$outboundSchema.optional(),
      parallelToolCalls: z4.boolean().optional(),
      promptMode: z4.nullable(mistralpromptmode_js_1.MistralPromptMode$outboundSchema).optional(),
      agentId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        maxTokens: "max_tokens",
        randomSeed: "random_seed",
        responseFormat: "response_format",
        toolChoice: "tool_choice",
        presencePenalty: "presence_penalty",
        frequencyPenalty: "frequency_penalty",
        parallelToolCalls: "parallel_tool_calls",
        promptMode: "prompt_mode",
        agentId: "agent_id"
      });
    });
    var AgentsCompletionStreamRequest$;
    (function(AgentsCompletionStreamRequest$2) {
      AgentsCompletionStreamRequest$2.inboundSchema = exports.AgentsCompletionStreamRequest$inboundSchema;
      AgentsCompletionStreamRequest$2.outboundSchema = exports.AgentsCompletionStreamRequest$outboundSchema;
    })(AgentsCompletionStreamRequest$ || (exports.AgentsCompletionStreamRequest$ = AgentsCompletionStreamRequest$ = {}));
    function agentsCompletionStreamRequestToJSON(agentsCompletionStreamRequest) {
      return JSON.stringify(exports.AgentsCompletionStreamRequest$outboundSchema.parse(agentsCompletionStreamRequest));
    }
    function agentsCompletionStreamRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AgentsCompletionStreamRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AgentsCompletionStreamRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/agentupdaterequest.js
var require_agentupdaterequest = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/agentupdaterequest.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AgentUpdateRequest$ = exports.AgentUpdateRequest$outboundSchema = exports.AgentUpdateRequest$inboundSchema = exports.AgentUpdateRequestTools$ = exports.AgentUpdateRequestTools$outboundSchema = exports.AgentUpdateRequestTools$inboundSchema = void 0;
    exports.agentUpdateRequestToolsToJSON = agentUpdateRequestToolsToJSON;
    exports.agentUpdateRequestToolsFromJSON = agentUpdateRequestToolsFromJSON;
    exports.agentUpdateRequestToJSON = agentUpdateRequestToJSON;
    exports.agentUpdateRequestFromJSON = agentUpdateRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var codeinterpretertool_js_1 = require_codeinterpretertool();
    var completionargs_js_1 = require_completionargs();
    var documentlibrarytool_js_1 = require_documentlibrarytool();
    var functiontool_js_1 = require_functiontool();
    var imagegenerationtool_js_1 = require_imagegenerationtool();
    var websearchpremiumtool_js_1 = require_websearchpremiumtool();
    var websearchtool_js_1 = require_websearchtool();
    exports.AgentUpdateRequestTools$inboundSchema = z4.union([
      codeinterpretertool_js_1.CodeInterpreterTool$inboundSchema.and(z4.object({ type: z4.literal("code_interpreter") }).transform((v2) => ({
        type: v2.type
      }))),
      imagegenerationtool_js_1.ImageGenerationTool$inboundSchema.and(z4.object({ type: z4.literal("image_generation") }).transform((v2) => ({
        type: v2.type
      }))),
      websearchtool_js_1.WebSearchTool$inboundSchema.and(z4.object({ type: z4.literal("web_search") }).transform((v2) => ({
        type: v2.type
      }))),
      websearchpremiumtool_js_1.WebSearchPremiumTool$inboundSchema.and(z4.object({ type: z4.literal("web_search_premium") }).transform((v2) => ({
        type: v2.type
      }))),
      documentlibrarytool_js_1.DocumentLibraryTool$inboundSchema.and(z4.object({ type: z4.literal("document_library") }).transform((v2) => ({
        type: v2.type
      }))),
      functiontool_js_1.FunctionTool$inboundSchema.and(z4.object({ type: z4.literal("function") }).transform((v2) => ({
        type: v2.type
      })))
    ]);
    exports.AgentUpdateRequestTools$outboundSchema = z4.union([
      codeinterpretertool_js_1.CodeInterpreterTool$outboundSchema.and(z4.object({ type: z4.literal("code_interpreter") }).transform((v2) => ({
        type: v2.type
      }))),
      imagegenerationtool_js_1.ImageGenerationTool$outboundSchema.and(z4.object({ type: z4.literal("image_generation") }).transform((v2) => ({
        type: v2.type
      }))),
      websearchtool_js_1.WebSearchTool$outboundSchema.and(z4.object({ type: z4.literal("web_search") }).transform((v2) => ({
        type: v2.type
      }))),
      websearchpremiumtool_js_1.WebSearchPremiumTool$outboundSchema.and(z4.object({ type: z4.literal("web_search_premium") }).transform((v2) => ({
        type: v2.type
      }))),
      documentlibrarytool_js_1.DocumentLibraryTool$outboundSchema.and(z4.object({ type: z4.literal("document_library") }).transform((v2) => ({
        type: v2.type
      }))),
      functiontool_js_1.FunctionTool$outboundSchema.and(z4.object({ type: z4.literal("function") }).transform((v2) => ({
        type: v2.type
      })))
    ]);
    var AgentUpdateRequestTools$;
    (function(AgentUpdateRequestTools$2) {
      AgentUpdateRequestTools$2.inboundSchema = exports.AgentUpdateRequestTools$inboundSchema;
      AgentUpdateRequestTools$2.outboundSchema = exports.AgentUpdateRequestTools$outboundSchema;
    })(AgentUpdateRequestTools$ || (exports.AgentUpdateRequestTools$ = AgentUpdateRequestTools$ = {}));
    function agentUpdateRequestToolsToJSON(agentUpdateRequestTools) {
      return JSON.stringify(exports.AgentUpdateRequestTools$outboundSchema.parse(agentUpdateRequestTools));
    }
    function agentUpdateRequestToolsFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AgentUpdateRequestTools$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AgentUpdateRequestTools' from JSON`);
    }
    exports.AgentUpdateRequest$inboundSchema = z4.object({
      instructions: z4.nullable(z4.string()).optional(),
      tools: z4.array(z4.union([
        codeinterpretertool_js_1.CodeInterpreterTool$inboundSchema.and(z4.object({ type: z4.literal("code_interpreter") }).transform((v2) => ({
          type: v2.type
        }))),
        imagegenerationtool_js_1.ImageGenerationTool$inboundSchema.and(z4.object({ type: z4.literal("image_generation") }).transform((v2) => ({
          type: v2.type
        }))),
        websearchtool_js_1.WebSearchTool$inboundSchema.and(z4.object({ type: z4.literal("web_search") }).transform((v2) => ({
          type: v2.type
        }))),
        websearchpremiumtool_js_1.WebSearchPremiumTool$inboundSchema.and(z4.object({ type: z4.literal("web_search_premium") }).transform((v2) => ({
          type: v2.type
        }))),
        documentlibrarytool_js_1.DocumentLibraryTool$inboundSchema.and(z4.object({ type: z4.literal("document_library") }).transform((v2) => ({
          type: v2.type
        }))),
        functiontool_js_1.FunctionTool$inboundSchema.and(z4.object({ type: z4.literal("function") }).transform((v2) => ({
          type: v2.type
        })))
      ])).optional(),
      completion_args: completionargs_js_1.CompletionArgs$inboundSchema.optional(),
      model: z4.nullable(z4.string()).optional(),
      name: z4.nullable(z4.string()).optional(),
      description: z4.nullable(z4.string()).optional(),
      handoffs: z4.nullable(z4.array(z4.string())).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "completion_args": "completionArgs"
      });
    });
    exports.AgentUpdateRequest$outboundSchema = z4.object({
      instructions: z4.nullable(z4.string()).optional(),
      tools: z4.array(z4.union([
        codeinterpretertool_js_1.CodeInterpreterTool$outboundSchema.and(z4.object({ type: z4.literal("code_interpreter") }).transform((v2) => ({
          type: v2.type
        }))),
        imagegenerationtool_js_1.ImageGenerationTool$outboundSchema.and(z4.object({ type: z4.literal("image_generation") }).transform((v2) => ({
          type: v2.type
        }))),
        websearchtool_js_1.WebSearchTool$outboundSchema.and(z4.object({ type: z4.literal("web_search") }).transform((v2) => ({
          type: v2.type
        }))),
        websearchpremiumtool_js_1.WebSearchPremiumTool$outboundSchema.and(z4.object({ type: z4.literal("web_search_premium") }).transform((v2) => ({
          type: v2.type
        }))),
        documentlibrarytool_js_1.DocumentLibraryTool$outboundSchema.and(z4.object({ type: z4.literal("document_library") }).transform((v2) => ({
          type: v2.type
        }))),
        functiontool_js_1.FunctionTool$outboundSchema.and(z4.object({ type: z4.literal("function") }).transform((v2) => ({
          type: v2.type
        })))
      ])).optional(),
      completionArgs: completionargs_js_1.CompletionArgs$outboundSchema.optional(),
      model: z4.nullable(z4.string()).optional(),
      name: z4.nullable(z4.string()).optional(),
      description: z4.nullable(z4.string()).optional(),
      handoffs: z4.nullable(z4.array(z4.string())).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        completionArgs: "completion_args"
      });
    });
    var AgentUpdateRequest$;
    (function(AgentUpdateRequest$2) {
      AgentUpdateRequest$2.inboundSchema = exports.AgentUpdateRequest$inboundSchema;
      AgentUpdateRequest$2.outboundSchema = exports.AgentUpdateRequest$outboundSchema;
    })(AgentUpdateRequest$ || (exports.AgentUpdateRequest$ = AgentUpdateRequest$ = {}));
    function agentUpdateRequestToJSON(agentUpdateRequest) {
      return JSON.stringify(exports.AgentUpdateRequest$outboundSchema.parse(agentUpdateRequest));
    }
    function agentUpdateRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AgentUpdateRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AgentUpdateRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/apiendpoint.js
var require_apiendpoint = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/apiendpoint.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ApiEndpoint$ = exports.ApiEndpoint$outboundSchema = exports.ApiEndpoint$inboundSchema = exports.ApiEndpoint = void 0;
    var z4 = __importStar(__require("zod"));
    var enums_js_1 = require_enums();
    exports.ApiEndpoint = {
      RootV1ChatCompletions: "/v1/chat/completions",
      RootV1Embeddings: "/v1/embeddings",
      RootV1FimCompletions: "/v1/fim/completions",
      RootV1Moderations: "/v1/moderations",
      RootV1ChatModerations: "/v1/chat/moderations"
    };
    exports.ApiEndpoint$inboundSchema = z4.union([
      z4.nativeEnum(exports.ApiEndpoint),
      z4.string().transform(enums_js_1.catchUnrecognizedEnum)
    ]);
    exports.ApiEndpoint$outboundSchema = z4.union([
      z4.nativeEnum(exports.ApiEndpoint),
      z4.string().and(z4.custom())
    ]);
    var ApiEndpoint$;
    (function(ApiEndpoint$2) {
      ApiEndpoint$2.inboundSchema = exports.ApiEndpoint$inboundSchema;
      ApiEndpoint$2.outboundSchema = exports.ApiEndpoint$outboundSchema;
    })(ApiEndpoint$ || (exports.ApiEndpoint$ = ApiEndpoint$ = {}));
  }
});

// ../node_modules/@mistralai/mistralai/models/components/archiveftmodelout.js
var require_archiveftmodelout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/archiveftmodelout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArchiveFTModelOut$ = exports.ArchiveFTModelOut$outboundSchema = exports.ArchiveFTModelOut$inboundSchema = exports.ArchiveFTModelOutObject$ = exports.ArchiveFTModelOutObject$outboundSchema = exports.ArchiveFTModelOutObject$inboundSchema = exports.ArchiveFTModelOutObject = void 0;
    exports.archiveFTModelOutToJSON = archiveFTModelOutToJSON;
    exports.archiveFTModelOutFromJSON = archiveFTModelOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    exports.ArchiveFTModelOutObject = {
      Model: "model"
    };
    exports.ArchiveFTModelOutObject$inboundSchema = z4.nativeEnum(exports.ArchiveFTModelOutObject);
    exports.ArchiveFTModelOutObject$outboundSchema = exports.ArchiveFTModelOutObject$inboundSchema;
    var ArchiveFTModelOutObject$;
    (function(ArchiveFTModelOutObject$2) {
      ArchiveFTModelOutObject$2.inboundSchema = exports.ArchiveFTModelOutObject$inboundSchema;
      ArchiveFTModelOutObject$2.outboundSchema = exports.ArchiveFTModelOutObject$outboundSchema;
    })(ArchiveFTModelOutObject$ || (exports.ArchiveFTModelOutObject$ = ArchiveFTModelOutObject$ = {}));
    exports.ArchiveFTModelOut$inboundSchema = z4.object({
      id: z4.string(),
      object: exports.ArchiveFTModelOutObject$inboundSchema.default("model"),
      archived: z4.boolean().default(true)
    });
    exports.ArchiveFTModelOut$outboundSchema = z4.object({
      id: z4.string(),
      object: exports.ArchiveFTModelOutObject$outboundSchema.default("model"),
      archived: z4.boolean().default(true)
    });
    var ArchiveFTModelOut$;
    (function(ArchiveFTModelOut$2) {
      ArchiveFTModelOut$2.inboundSchema = exports.ArchiveFTModelOut$inboundSchema;
      ArchiveFTModelOut$2.outboundSchema = exports.ArchiveFTModelOut$outboundSchema;
    })(ArchiveFTModelOut$ || (exports.ArchiveFTModelOut$ = ArchiveFTModelOut$ = {}));
    function archiveFTModelOutToJSON(archiveFTModelOut) {
      return JSON.stringify(exports.ArchiveFTModelOut$outboundSchema.parse(archiveFTModelOut));
    }
    function archiveFTModelOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ArchiveFTModelOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ArchiveFTModelOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/types/blobs.js
var require_blobs = __commonJS({
  "../node_modules/@mistralai/mistralai/types/blobs.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.blobLikeSchema = void 0;
    exports.isBlobLike = isBlobLike3;
    var z4 = __importStar(__require("zod"));
    exports.blobLikeSchema = z4.custom(isBlobLike3, {
      message: "expected a Blob, File or Blob-like object",
      fatal: true
    });
    function isBlobLike3(val) {
      if (val instanceof Blob) {
        return true;
      }
      if (typeof val !== "object" || val == null || !(Symbol.toStringTag in val)) {
        return false;
      }
      const name = val[Symbol.toStringTag];
      if (typeof name !== "string") {
        return false;
      }
      if (name !== "Blob" && name !== "File") {
        return false;
      }
      return "stream" in val && typeof val.stream === "function";
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/file.js
var require_file = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/file.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FileT$ = exports.FileT$outboundSchema = exports.FileT$inboundSchema = void 0;
    exports.fileToJSON = fileToJSON;
    exports.fileFromJSON = fileFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    exports.FileT$inboundSchema = z4.object({
      fileName: z4.string(),
      content: z4.union([
        z4.instanceof(ReadableStream),
        z4.instanceof(Blob),
        z4.instanceof(ArrayBuffer),
        z4.instanceof(Uint8Array)
      ])
    });
    exports.FileT$outboundSchema = z4.object({
      fileName: z4.string(),
      content: z4.union([
        z4.instanceof(ReadableStream),
        z4.instanceof(Blob),
        z4.instanceof(ArrayBuffer),
        z4.instanceof(Uint8Array)
      ])
    });
    var FileT$;
    (function(FileT$2) {
      FileT$2.inboundSchema = exports.FileT$inboundSchema;
      FileT$2.outboundSchema = exports.FileT$outboundSchema;
    })(FileT$ || (exports.FileT$ = FileT$ = {}));
    function fileToJSON(fileT) {
      return JSON.stringify(exports.FileT$outboundSchema.parse(fileT));
    }
    function fileFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.FileT$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'FileT' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/timestampgranularity.js
var require_timestampgranularity = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/timestampgranularity.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TimestampGranularity$ = exports.TimestampGranularity$outboundSchema = exports.TimestampGranularity$inboundSchema = exports.TimestampGranularity = void 0;
    var z4 = __importStar(__require("zod"));
    exports.TimestampGranularity = {
      Segment: "segment"
    };
    exports.TimestampGranularity$inboundSchema = z4.nativeEnum(exports.TimestampGranularity);
    exports.TimestampGranularity$outboundSchema = exports.TimestampGranularity$inboundSchema;
    var TimestampGranularity$;
    (function(TimestampGranularity$2) {
      TimestampGranularity$2.inboundSchema = exports.TimestampGranularity$inboundSchema;
      TimestampGranularity$2.outboundSchema = exports.TimestampGranularity$outboundSchema;
    })(TimestampGranularity$ || (exports.TimestampGranularity$ = TimestampGranularity$ = {}));
  }
});

// ../node_modules/@mistralai/mistralai/models/components/audiotranscriptionrequest.js
var require_audiotranscriptionrequest = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/audiotranscriptionrequest.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AudioTranscriptionRequest$ = exports.AudioTranscriptionRequest$outboundSchema = exports.AudioTranscriptionRequest$inboundSchema = void 0;
    exports.audioTranscriptionRequestToJSON = audioTranscriptionRequestToJSON;
    exports.audioTranscriptionRequestFromJSON = audioTranscriptionRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var blobs_js_1 = require_blobs();
    var file_js_1 = require_file();
    var timestampgranularity_js_1 = require_timestampgranularity();
    exports.AudioTranscriptionRequest$inboundSchema = z4.object({
      model: z4.string(),
      file: file_js_1.FileT$inboundSchema.optional(),
      file_id: z4.nullable(z4.string()).optional(),
      file_url: z4.nullable(z4.string()).optional(),
      language: z4.nullable(z4.string()).optional(),
      stream: z4.literal(false).default(false),
      temperature: z4.nullable(z4.number()).optional(),
      timestamp_granularities: z4.array(timestampgranularity_js_1.TimestampGranularity$inboundSchema).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "file_id": "fileId",
        "file_url": "fileUrl",
        "timestamp_granularities": "timestampGranularities"
      });
    });
    exports.AudioTranscriptionRequest$outboundSchema = z4.object({
      model: z4.string(),
      file: file_js_1.FileT$outboundSchema.or(blobs_js_1.blobLikeSchema).optional(),
      fileId: z4.nullable(z4.string()).optional(),
      fileUrl: z4.nullable(z4.string()).optional(),
      language: z4.nullable(z4.string()).optional(),
      stream: z4.literal(false).default(false),
      temperature: z4.nullable(z4.number()).optional(),
      timestampGranularities: z4.array(timestampgranularity_js_1.TimestampGranularity$outboundSchema).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        fileId: "file_id",
        fileUrl: "file_url",
        timestampGranularities: "timestamp_granularities"
      });
    });
    var AudioTranscriptionRequest$;
    (function(AudioTranscriptionRequest$2) {
      AudioTranscriptionRequest$2.inboundSchema = exports.AudioTranscriptionRequest$inboundSchema;
      AudioTranscriptionRequest$2.outboundSchema = exports.AudioTranscriptionRequest$outboundSchema;
    })(AudioTranscriptionRequest$ || (exports.AudioTranscriptionRequest$ = AudioTranscriptionRequest$ = {}));
    function audioTranscriptionRequestToJSON(audioTranscriptionRequest) {
      return JSON.stringify(exports.AudioTranscriptionRequest$outboundSchema.parse(audioTranscriptionRequest));
    }
    function audioTranscriptionRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AudioTranscriptionRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AudioTranscriptionRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/audiotranscriptionrequeststream.js
var require_audiotranscriptionrequeststream = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/audiotranscriptionrequeststream.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AudioTranscriptionRequestStream$ = exports.AudioTranscriptionRequestStream$outboundSchema = exports.AudioTranscriptionRequestStream$inboundSchema = void 0;
    exports.audioTranscriptionRequestStreamToJSON = audioTranscriptionRequestStreamToJSON;
    exports.audioTranscriptionRequestStreamFromJSON = audioTranscriptionRequestStreamFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var blobs_js_1 = require_blobs();
    var file_js_1 = require_file();
    var timestampgranularity_js_1 = require_timestampgranularity();
    exports.AudioTranscriptionRequestStream$inboundSchema = z4.object({
      model: z4.string(),
      file: file_js_1.FileT$inboundSchema.optional(),
      file_id: z4.nullable(z4.string()).optional(),
      file_url: z4.nullable(z4.string()).optional(),
      language: z4.nullable(z4.string()).optional(),
      stream: z4.literal(true).default(true),
      temperature: z4.nullable(z4.number()).optional(),
      timestamp_granularities: z4.array(timestampgranularity_js_1.TimestampGranularity$inboundSchema).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "file_id": "fileId",
        "file_url": "fileUrl",
        "timestamp_granularities": "timestampGranularities"
      });
    });
    exports.AudioTranscriptionRequestStream$outboundSchema = z4.object({
      model: z4.string(),
      file: file_js_1.FileT$outboundSchema.or(blobs_js_1.blobLikeSchema).optional(),
      fileId: z4.nullable(z4.string()).optional(),
      fileUrl: z4.nullable(z4.string()).optional(),
      language: z4.nullable(z4.string()).optional(),
      stream: z4.literal(true).default(true),
      temperature: z4.nullable(z4.number()).optional(),
      timestampGranularities: z4.array(timestampgranularity_js_1.TimestampGranularity$outboundSchema).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        fileId: "file_id",
        fileUrl: "file_url",
        timestampGranularities: "timestamp_granularities"
      });
    });
    var AudioTranscriptionRequestStream$;
    (function(AudioTranscriptionRequestStream$2) {
      AudioTranscriptionRequestStream$2.inboundSchema = exports.AudioTranscriptionRequestStream$inboundSchema;
      AudioTranscriptionRequestStream$2.outboundSchema = exports.AudioTranscriptionRequestStream$outboundSchema;
    })(AudioTranscriptionRequestStream$ || (exports.AudioTranscriptionRequestStream$ = AudioTranscriptionRequestStream$ = {}));
    function audioTranscriptionRequestStreamToJSON(audioTranscriptionRequestStream) {
      return JSON.stringify(exports.AudioTranscriptionRequestStream$outboundSchema.parse(audioTranscriptionRequestStream));
    }
    function audioTranscriptionRequestStreamFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AudioTranscriptionRequestStream$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AudioTranscriptionRequestStream' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/modelcapabilities.js
var require_modelcapabilities = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/modelcapabilities.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ModelCapabilities$ = exports.ModelCapabilities$outboundSchema = exports.ModelCapabilities$inboundSchema = void 0;
    exports.modelCapabilitiesToJSON = modelCapabilitiesToJSON;
    exports.modelCapabilitiesFromJSON = modelCapabilitiesFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.ModelCapabilities$inboundSchema = z4.object({
      completion_chat: z4.boolean().default(true),
      completion_fim: z4.boolean().default(false),
      function_calling: z4.boolean().default(true),
      fine_tuning: z4.boolean().default(false),
      vision: z4.boolean().default(false),
      classification: z4.boolean().default(false)
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "completion_chat": "completionChat",
        "completion_fim": "completionFim",
        "function_calling": "functionCalling",
        "fine_tuning": "fineTuning"
      });
    });
    exports.ModelCapabilities$outboundSchema = z4.object({
      completionChat: z4.boolean().default(true),
      completionFim: z4.boolean().default(false),
      functionCalling: z4.boolean().default(true),
      fineTuning: z4.boolean().default(false),
      vision: z4.boolean().default(false),
      classification: z4.boolean().default(false)
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        completionChat: "completion_chat",
        completionFim: "completion_fim",
        functionCalling: "function_calling",
        fineTuning: "fine_tuning"
      });
    });
    var ModelCapabilities$;
    (function(ModelCapabilities$2) {
      ModelCapabilities$2.inboundSchema = exports.ModelCapabilities$inboundSchema;
      ModelCapabilities$2.outboundSchema = exports.ModelCapabilities$outboundSchema;
    })(ModelCapabilities$ || (exports.ModelCapabilities$ = ModelCapabilities$ = {}));
    function modelCapabilitiesToJSON(modelCapabilities) {
      return JSON.stringify(exports.ModelCapabilities$outboundSchema.parse(modelCapabilities));
    }
    function modelCapabilitiesFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ModelCapabilities$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ModelCapabilities' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/basemodelcard.js
var require_basemodelcard = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/basemodelcard.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseModelCard$ = exports.BaseModelCard$outboundSchema = exports.BaseModelCard$inboundSchema = exports.BaseModelCardType$ = exports.BaseModelCardType$outboundSchema = exports.BaseModelCardType$inboundSchema = exports.BaseModelCardType = void 0;
    exports.baseModelCardToJSON = baseModelCardToJSON;
    exports.baseModelCardFromJSON = baseModelCardFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var modelcapabilities_js_1 = require_modelcapabilities();
    exports.BaseModelCardType = {
      Base: "base"
    };
    exports.BaseModelCardType$inboundSchema = z4.nativeEnum(exports.BaseModelCardType);
    exports.BaseModelCardType$outboundSchema = exports.BaseModelCardType$inboundSchema;
    var BaseModelCardType$;
    (function(BaseModelCardType$2) {
      BaseModelCardType$2.inboundSchema = exports.BaseModelCardType$inboundSchema;
      BaseModelCardType$2.outboundSchema = exports.BaseModelCardType$outboundSchema;
    })(BaseModelCardType$ || (exports.BaseModelCardType$ = BaseModelCardType$ = {}));
    exports.BaseModelCard$inboundSchema = z4.object({
      id: z4.string(),
      object: z4.string().default("model"),
      created: z4.number().int().optional(),
      owned_by: z4.string().default("mistralai"),
      capabilities: modelcapabilities_js_1.ModelCapabilities$inboundSchema,
      name: z4.nullable(z4.string()).optional(),
      description: z4.nullable(z4.string()).optional(),
      max_context_length: z4.number().int().default(32768),
      aliases: z4.array(z4.string()).optional(),
      deprecation: z4.nullable(z4.string().datetime({ offset: true }).transform((v2) => new Date(v2))).optional(),
      deprecation_replacement_model: z4.nullable(z4.string()).optional(),
      default_model_temperature: z4.nullable(z4.number()).optional(),
      type: z4.literal("base").default("base")
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "owned_by": "ownedBy",
        "max_context_length": "maxContextLength",
        "deprecation_replacement_model": "deprecationReplacementModel",
        "default_model_temperature": "defaultModelTemperature"
      });
    });
    exports.BaseModelCard$outboundSchema = z4.object({
      id: z4.string(),
      object: z4.string().default("model"),
      created: z4.number().int().optional(),
      ownedBy: z4.string().default("mistralai"),
      capabilities: modelcapabilities_js_1.ModelCapabilities$outboundSchema,
      name: z4.nullable(z4.string()).optional(),
      description: z4.nullable(z4.string()).optional(),
      maxContextLength: z4.number().int().default(32768),
      aliases: z4.array(z4.string()).optional(),
      deprecation: z4.nullable(z4.date().transform((v2) => v2.toISOString())).optional(),
      deprecationReplacementModel: z4.nullable(z4.string()).optional(),
      defaultModelTemperature: z4.nullable(z4.number()).optional(),
      type: z4.literal("base").default("base")
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        ownedBy: "owned_by",
        maxContextLength: "max_context_length",
        deprecationReplacementModel: "deprecation_replacement_model",
        defaultModelTemperature: "default_model_temperature"
      });
    });
    var BaseModelCard$;
    (function(BaseModelCard$2) {
      BaseModelCard$2.inboundSchema = exports.BaseModelCard$inboundSchema;
      BaseModelCard$2.outboundSchema = exports.BaseModelCard$outboundSchema;
    })(BaseModelCard$ || (exports.BaseModelCard$ = BaseModelCard$ = {}));
    function baseModelCardToJSON(baseModelCard) {
      return JSON.stringify(exports.BaseModelCard$outboundSchema.parse(baseModelCard));
    }
    function baseModelCardFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.BaseModelCard$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'BaseModelCard' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/batcherror.js
var require_batcherror = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/batcherror.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BatchError$ = exports.BatchError$outboundSchema = exports.BatchError$inboundSchema = void 0;
    exports.batchErrorToJSON = batchErrorToJSON;
    exports.batchErrorFromJSON = batchErrorFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    exports.BatchError$inboundSchema = z4.object({
      message: z4.string(),
      count: z4.number().int().default(1)
    });
    exports.BatchError$outboundSchema = z4.object({
      message: z4.string(),
      count: z4.number().int().default(1)
    });
    var BatchError$;
    (function(BatchError$2) {
      BatchError$2.inboundSchema = exports.BatchError$inboundSchema;
      BatchError$2.outboundSchema = exports.BatchError$outboundSchema;
    })(BatchError$ || (exports.BatchError$ = BatchError$ = {}));
    function batchErrorToJSON(batchError) {
      return JSON.stringify(exports.BatchError$outboundSchema.parse(batchError));
    }
    function batchErrorFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.BatchError$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'BatchError' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/batchjobin.js
var require_batchjobin = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/batchjobin.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BatchJobIn$ = exports.BatchJobIn$outboundSchema = exports.BatchJobIn$inboundSchema = void 0;
    exports.batchJobInToJSON = batchJobInToJSON;
    exports.batchJobInFromJSON = batchJobInFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var apiendpoint_js_1 = require_apiendpoint();
    exports.BatchJobIn$inboundSchema = z4.object({
      input_files: z4.array(z4.string()),
      endpoint: apiendpoint_js_1.ApiEndpoint$inboundSchema,
      model: z4.nullable(z4.string()).optional(),
      agent_id: z4.nullable(z4.string()).optional(),
      metadata: z4.nullable(z4.record(z4.string())).optional(),
      timeout_hours: z4.number().int().default(24)
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "input_files": "inputFiles",
        "agent_id": "agentId",
        "timeout_hours": "timeoutHours"
      });
    });
    exports.BatchJobIn$outboundSchema = z4.object({
      inputFiles: z4.array(z4.string()),
      endpoint: apiendpoint_js_1.ApiEndpoint$outboundSchema,
      model: z4.nullable(z4.string()).optional(),
      agentId: z4.nullable(z4.string()).optional(),
      metadata: z4.nullable(z4.record(z4.string())).optional(),
      timeoutHours: z4.number().int().default(24)
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        inputFiles: "input_files",
        agentId: "agent_id",
        timeoutHours: "timeout_hours"
      });
    });
    var BatchJobIn$;
    (function(BatchJobIn$2) {
      BatchJobIn$2.inboundSchema = exports.BatchJobIn$inboundSchema;
      BatchJobIn$2.outboundSchema = exports.BatchJobIn$outboundSchema;
    })(BatchJobIn$ || (exports.BatchJobIn$ = BatchJobIn$ = {}));
    function batchJobInToJSON(batchJobIn) {
      return JSON.stringify(exports.BatchJobIn$outboundSchema.parse(batchJobIn));
    }
    function batchJobInFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.BatchJobIn$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'BatchJobIn' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/batchjobstatus.js
var require_batchjobstatus = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/batchjobstatus.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BatchJobStatus$ = exports.BatchJobStatus$outboundSchema = exports.BatchJobStatus$inboundSchema = exports.BatchJobStatus = void 0;
    var z4 = __importStar(__require("zod"));
    exports.BatchJobStatus = {
      Queued: "QUEUED",
      Running: "RUNNING",
      Success: "SUCCESS",
      Failed: "FAILED",
      TimeoutExceeded: "TIMEOUT_EXCEEDED",
      CancellationRequested: "CANCELLATION_REQUESTED",
      Cancelled: "CANCELLED"
    };
    exports.BatchJobStatus$inboundSchema = z4.nativeEnum(exports.BatchJobStatus);
    exports.BatchJobStatus$outboundSchema = exports.BatchJobStatus$inboundSchema;
    var BatchJobStatus$;
    (function(BatchJobStatus$2) {
      BatchJobStatus$2.inboundSchema = exports.BatchJobStatus$inboundSchema;
      BatchJobStatus$2.outboundSchema = exports.BatchJobStatus$outboundSchema;
    })(BatchJobStatus$ || (exports.BatchJobStatus$ = BatchJobStatus$ = {}));
  }
});

// ../node_modules/@mistralai/mistralai/models/components/batchjobout.js
var require_batchjobout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/batchjobout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BatchJobOut$ = exports.BatchJobOut$outboundSchema = exports.BatchJobOut$inboundSchema = exports.BatchJobOutObject$ = exports.BatchJobOutObject$outboundSchema = exports.BatchJobOutObject$inboundSchema = exports.BatchJobOutObject = void 0;
    exports.batchJobOutToJSON = batchJobOutToJSON;
    exports.batchJobOutFromJSON = batchJobOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var batcherror_js_1 = require_batcherror();
    var batchjobstatus_js_1 = require_batchjobstatus();
    exports.BatchJobOutObject = {
      Batch: "batch"
    };
    exports.BatchJobOutObject$inboundSchema = z4.nativeEnum(exports.BatchJobOutObject);
    exports.BatchJobOutObject$outboundSchema = exports.BatchJobOutObject$inboundSchema;
    var BatchJobOutObject$;
    (function(BatchJobOutObject$2) {
      BatchJobOutObject$2.inboundSchema = exports.BatchJobOutObject$inboundSchema;
      BatchJobOutObject$2.outboundSchema = exports.BatchJobOutObject$outboundSchema;
    })(BatchJobOutObject$ || (exports.BatchJobOutObject$ = BatchJobOutObject$ = {}));
    exports.BatchJobOut$inboundSchema = z4.object({
      id: z4.string(),
      object: exports.BatchJobOutObject$inboundSchema.default("batch"),
      input_files: z4.array(z4.string()),
      metadata: z4.nullable(z4.record(z4.any())).optional(),
      endpoint: z4.string(),
      model: z4.nullable(z4.string()).optional(),
      agent_id: z4.nullable(z4.string()).optional(),
      output_file: z4.nullable(z4.string()).optional(),
      error_file: z4.nullable(z4.string()).optional(),
      errors: z4.array(batcherror_js_1.BatchError$inboundSchema),
      status: batchjobstatus_js_1.BatchJobStatus$inboundSchema,
      created_at: z4.number().int(),
      total_requests: z4.number().int(),
      completed_requests: z4.number().int(),
      succeeded_requests: z4.number().int(),
      failed_requests: z4.number().int(),
      started_at: z4.nullable(z4.number().int()).optional(),
      completed_at: z4.nullable(z4.number().int()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "input_files": "inputFiles",
        "agent_id": "agentId",
        "output_file": "outputFile",
        "error_file": "errorFile",
        "created_at": "createdAt",
        "total_requests": "totalRequests",
        "completed_requests": "completedRequests",
        "succeeded_requests": "succeededRequests",
        "failed_requests": "failedRequests",
        "started_at": "startedAt",
        "completed_at": "completedAt"
      });
    });
    exports.BatchJobOut$outboundSchema = z4.object({
      id: z4.string(),
      object: exports.BatchJobOutObject$outboundSchema.default("batch"),
      inputFiles: z4.array(z4.string()),
      metadata: z4.nullable(z4.record(z4.any())).optional(),
      endpoint: z4.string(),
      model: z4.nullable(z4.string()).optional(),
      agentId: z4.nullable(z4.string()).optional(),
      outputFile: z4.nullable(z4.string()).optional(),
      errorFile: z4.nullable(z4.string()).optional(),
      errors: z4.array(batcherror_js_1.BatchError$outboundSchema),
      status: batchjobstatus_js_1.BatchJobStatus$outboundSchema,
      createdAt: z4.number().int(),
      totalRequests: z4.number().int(),
      completedRequests: z4.number().int(),
      succeededRequests: z4.number().int(),
      failedRequests: z4.number().int(),
      startedAt: z4.nullable(z4.number().int()).optional(),
      completedAt: z4.nullable(z4.number().int()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        inputFiles: "input_files",
        agentId: "agent_id",
        outputFile: "output_file",
        errorFile: "error_file",
        createdAt: "created_at",
        totalRequests: "total_requests",
        completedRequests: "completed_requests",
        succeededRequests: "succeeded_requests",
        failedRequests: "failed_requests",
        startedAt: "started_at",
        completedAt: "completed_at"
      });
    });
    var BatchJobOut$;
    (function(BatchJobOut$2) {
      BatchJobOut$2.inboundSchema = exports.BatchJobOut$inboundSchema;
      BatchJobOut$2.outboundSchema = exports.BatchJobOut$outboundSchema;
    })(BatchJobOut$ || (exports.BatchJobOut$ = BatchJobOut$ = {}));
    function batchJobOutToJSON(batchJobOut) {
      return JSON.stringify(exports.BatchJobOut$outboundSchema.parse(batchJobOut));
    }
    function batchJobOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.BatchJobOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'BatchJobOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/batchjobsout.js
var require_batchjobsout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/batchjobsout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BatchJobsOut$ = exports.BatchJobsOut$outboundSchema = exports.BatchJobsOut$inboundSchema = exports.BatchJobsOutObject$ = exports.BatchJobsOutObject$outboundSchema = exports.BatchJobsOutObject$inboundSchema = exports.BatchJobsOutObject = void 0;
    exports.batchJobsOutToJSON = batchJobsOutToJSON;
    exports.batchJobsOutFromJSON = batchJobsOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var batchjobout_js_1 = require_batchjobout();
    exports.BatchJobsOutObject = {
      List: "list"
    };
    exports.BatchJobsOutObject$inboundSchema = z4.nativeEnum(exports.BatchJobsOutObject);
    exports.BatchJobsOutObject$outboundSchema = exports.BatchJobsOutObject$inboundSchema;
    var BatchJobsOutObject$;
    (function(BatchJobsOutObject$2) {
      BatchJobsOutObject$2.inboundSchema = exports.BatchJobsOutObject$inboundSchema;
      BatchJobsOutObject$2.outboundSchema = exports.BatchJobsOutObject$outboundSchema;
    })(BatchJobsOutObject$ || (exports.BatchJobsOutObject$ = BatchJobsOutObject$ = {}));
    exports.BatchJobsOut$inboundSchema = z4.object({
      data: z4.array(batchjobout_js_1.BatchJobOut$inboundSchema).optional(),
      object: exports.BatchJobsOutObject$inboundSchema.default("list"),
      total: z4.number().int()
    });
    exports.BatchJobsOut$outboundSchema = z4.object({
      data: z4.array(batchjobout_js_1.BatchJobOut$outboundSchema).optional(),
      object: exports.BatchJobsOutObject$outboundSchema.default("list"),
      total: z4.number().int()
    });
    var BatchJobsOut$;
    (function(BatchJobsOut$2) {
      BatchJobsOut$2.inboundSchema = exports.BatchJobsOut$inboundSchema;
      BatchJobsOut$2.outboundSchema = exports.BatchJobsOut$outboundSchema;
    })(BatchJobsOut$ || (exports.BatchJobsOut$ = BatchJobsOut$ = {}));
    function batchJobsOutToJSON(batchJobsOut) {
      return JSON.stringify(exports.BatchJobsOut$outboundSchema.parse(batchJobsOut));
    }
    function batchJobsOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.BatchJobsOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'BatchJobsOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/builtinconnectors.js
var require_builtinconnectors = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/builtinconnectors.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BuiltInConnectors$ = exports.BuiltInConnectors$outboundSchema = exports.BuiltInConnectors$inboundSchema = exports.BuiltInConnectors = void 0;
    var z4 = __importStar(__require("zod"));
    exports.BuiltInConnectors = {
      WebSearch: "web_search",
      WebSearchPremium: "web_search_premium",
      CodeInterpreter: "code_interpreter",
      ImageGeneration: "image_generation",
      DocumentLibrary: "document_library"
    };
    exports.BuiltInConnectors$inboundSchema = z4.nativeEnum(exports.BuiltInConnectors);
    exports.BuiltInConnectors$outboundSchema = exports.BuiltInConnectors$inboundSchema;
    var BuiltInConnectors$;
    (function(BuiltInConnectors$2) {
      BuiltInConnectors$2.inboundSchema = exports.BuiltInConnectors$inboundSchema;
      BuiltInConnectors$2.outboundSchema = exports.BuiltInConnectors$outboundSchema;
    })(BuiltInConnectors$ || (exports.BuiltInConnectors$ = BuiltInConnectors$ = {}));
  }
});

// ../node_modules/@mistralai/mistralai/models/components/instructrequest.js
var require_instructrequest = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/instructrequest.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InstructRequest$ = exports.InstructRequest$outboundSchema = exports.InstructRequest$inboundSchema = exports.InstructRequestMessages$ = exports.InstructRequestMessages$outboundSchema = exports.InstructRequestMessages$inboundSchema = void 0;
    exports.instructRequestMessagesToJSON = instructRequestMessagesToJSON;
    exports.instructRequestMessagesFromJSON = instructRequestMessagesFromJSON;
    exports.instructRequestToJSON = instructRequestToJSON;
    exports.instructRequestFromJSON = instructRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var assistantmessage_js_1 = require_assistantmessage();
    var systemmessage_js_1 = require_systemmessage();
    var toolmessage_js_1 = require_toolmessage();
    var usermessage_js_1 = require_usermessage();
    exports.InstructRequestMessages$inboundSchema = z4.union([
      systemmessage_js_1.SystemMessage$inboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
        role: v2.role
      }))),
      usermessage_js_1.UserMessage$inboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({ role: v2.role }))),
      assistantmessage_js_1.AssistantMessage$inboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
        role: v2.role
      }))),
      toolmessage_js_1.ToolMessage$inboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({ role: v2.role })))
    ]);
    exports.InstructRequestMessages$outboundSchema = z4.union([
      systemmessage_js_1.SystemMessage$outboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
        role: v2.role
      }))),
      usermessage_js_1.UserMessage$outboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({ role: v2.role }))),
      assistantmessage_js_1.AssistantMessage$outboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
        role: v2.role
      }))),
      toolmessage_js_1.ToolMessage$outboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({ role: v2.role })))
    ]);
    var InstructRequestMessages$;
    (function(InstructRequestMessages$2) {
      InstructRequestMessages$2.inboundSchema = exports.InstructRequestMessages$inboundSchema;
      InstructRequestMessages$2.outboundSchema = exports.InstructRequestMessages$outboundSchema;
    })(InstructRequestMessages$ || (exports.InstructRequestMessages$ = InstructRequestMessages$ = {}));
    function instructRequestMessagesToJSON(instructRequestMessages) {
      return JSON.stringify(exports.InstructRequestMessages$outboundSchema.parse(instructRequestMessages));
    }
    function instructRequestMessagesFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.InstructRequestMessages$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'InstructRequestMessages' from JSON`);
    }
    exports.InstructRequest$inboundSchema = z4.object({
      messages: z4.array(z4.union([
        systemmessage_js_1.SystemMessage$inboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
          role: v2.role
        }))),
        usermessage_js_1.UserMessage$inboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({
          role: v2.role
        }))),
        assistantmessage_js_1.AssistantMessage$inboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
          role: v2.role
        }))),
        toolmessage_js_1.ToolMessage$inboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({
          role: v2.role
        })))
      ]))
    });
    exports.InstructRequest$outboundSchema = z4.object({
      messages: z4.array(z4.union([
        systemmessage_js_1.SystemMessage$outboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
          role: v2.role
        }))),
        usermessage_js_1.UserMessage$outboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({
          role: v2.role
        }))),
        assistantmessage_js_1.AssistantMessage$outboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
          role: v2.role
        }))),
        toolmessage_js_1.ToolMessage$outboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({
          role: v2.role
        })))
      ]))
    });
    var InstructRequest$;
    (function(InstructRequest$2) {
      InstructRequest$2.inboundSchema = exports.InstructRequest$inboundSchema;
      InstructRequest$2.outboundSchema = exports.InstructRequest$outboundSchema;
    })(InstructRequest$ || (exports.InstructRequest$ = InstructRequest$ = {}));
    function instructRequestToJSON(instructRequest) {
      return JSON.stringify(exports.InstructRequest$outboundSchema.parse(instructRequest));
    }
    function instructRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.InstructRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'InstructRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/inputs.js
var require_inputs = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/inputs.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Inputs$ = exports.Inputs$outboundSchema = exports.Inputs$inboundSchema = exports.InstructRequestInputs$ = exports.InstructRequestInputs$outboundSchema = exports.InstructRequestInputs$inboundSchema = exports.InstructRequestInputsMessages$ = exports.InstructRequestInputsMessages$outboundSchema = exports.InstructRequestInputsMessages$inboundSchema = void 0;
    exports.instructRequestInputsMessagesToJSON = instructRequestInputsMessagesToJSON;
    exports.instructRequestInputsMessagesFromJSON = instructRequestInputsMessagesFromJSON;
    exports.instructRequestInputsToJSON = instructRequestInputsToJSON;
    exports.instructRequestInputsFromJSON = instructRequestInputsFromJSON;
    exports.inputsToJSON = inputsToJSON;
    exports.inputsFromJSON = inputsFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var assistantmessage_js_1 = require_assistantmessage();
    var instructrequest_js_1 = require_instructrequest();
    var systemmessage_js_1 = require_systemmessage();
    var toolmessage_js_1 = require_toolmessage();
    var usermessage_js_1 = require_usermessage();
    exports.InstructRequestInputsMessages$inboundSchema = z4.union([
      systemmessage_js_1.SystemMessage$inboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
        role: v2.role
      }))),
      usermessage_js_1.UserMessage$inboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({ role: v2.role }))),
      assistantmessage_js_1.AssistantMessage$inboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
        role: v2.role
      }))),
      toolmessage_js_1.ToolMessage$inboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({ role: v2.role })))
    ]);
    exports.InstructRequestInputsMessages$outboundSchema = z4.union([
      systemmessage_js_1.SystemMessage$outboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
        role: v2.role
      }))),
      usermessage_js_1.UserMessage$outboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({ role: v2.role }))),
      assistantmessage_js_1.AssistantMessage$outboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
        role: v2.role
      }))),
      toolmessage_js_1.ToolMessage$outboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({ role: v2.role })))
    ]);
    var InstructRequestInputsMessages$;
    (function(InstructRequestInputsMessages$2) {
      InstructRequestInputsMessages$2.inboundSchema = exports.InstructRequestInputsMessages$inboundSchema;
      InstructRequestInputsMessages$2.outboundSchema = exports.InstructRequestInputsMessages$outboundSchema;
    })(InstructRequestInputsMessages$ || (exports.InstructRequestInputsMessages$ = InstructRequestInputsMessages$ = {}));
    function instructRequestInputsMessagesToJSON(instructRequestInputsMessages) {
      return JSON.stringify(exports.InstructRequestInputsMessages$outboundSchema.parse(instructRequestInputsMessages));
    }
    function instructRequestInputsMessagesFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.InstructRequestInputsMessages$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'InstructRequestInputsMessages' from JSON`);
    }
    exports.InstructRequestInputs$inboundSchema = z4.object({
      messages: z4.array(z4.union([
        systemmessage_js_1.SystemMessage$inboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
          role: v2.role
        }))),
        usermessage_js_1.UserMessage$inboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({
          role: v2.role
        }))),
        assistantmessage_js_1.AssistantMessage$inboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
          role: v2.role
        }))),
        toolmessage_js_1.ToolMessage$inboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({
          role: v2.role
        })))
      ]))
    });
    exports.InstructRequestInputs$outboundSchema = z4.object({
      messages: z4.array(z4.union([
        systemmessage_js_1.SystemMessage$outboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
          role: v2.role
        }))),
        usermessage_js_1.UserMessage$outboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({
          role: v2.role
        }))),
        assistantmessage_js_1.AssistantMessage$outboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
          role: v2.role
        }))),
        toolmessage_js_1.ToolMessage$outboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({
          role: v2.role
        })))
      ]))
    });
    var InstructRequestInputs$;
    (function(InstructRequestInputs$2) {
      InstructRequestInputs$2.inboundSchema = exports.InstructRequestInputs$inboundSchema;
      InstructRequestInputs$2.outboundSchema = exports.InstructRequestInputs$outboundSchema;
    })(InstructRequestInputs$ || (exports.InstructRequestInputs$ = InstructRequestInputs$ = {}));
    function instructRequestInputsToJSON(instructRequestInputs) {
      return JSON.stringify(exports.InstructRequestInputs$outboundSchema.parse(instructRequestInputs));
    }
    function instructRequestInputsFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.InstructRequestInputs$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'InstructRequestInputs' from JSON`);
    }
    exports.Inputs$inboundSchema = z4.union([
      z4.lazy(() => exports.InstructRequestInputs$inboundSchema),
      z4.array(instructrequest_js_1.InstructRequest$inboundSchema)
    ]);
    exports.Inputs$outboundSchema = z4.union([
      z4.lazy(() => exports.InstructRequestInputs$outboundSchema),
      z4.array(instructrequest_js_1.InstructRequest$outboundSchema)
    ]);
    var Inputs$;
    (function(Inputs$2) {
      Inputs$2.inboundSchema = exports.Inputs$inboundSchema;
      Inputs$2.outboundSchema = exports.Inputs$outboundSchema;
    })(Inputs$ || (exports.Inputs$ = Inputs$ = {}));
    function inputsToJSON(inputs) {
      return JSON.stringify(exports.Inputs$outboundSchema.parse(inputs));
    }
    function inputsFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.Inputs$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'Inputs' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/chatclassificationrequest.js
var require_chatclassificationrequest = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/chatclassificationrequest.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ChatClassificationRequest$ = exports.ChatClassificationRequest$outboundSchema = exports.ChatClassificationRequest$inboundSchema = void 0;
    exports.chatClassificationRequestToJSON = chatClassificationRequestToJSON;
    exports.chatClassificationRequestFromJSON = chatClassificationRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var inputs_js_1 = require_inputs();
    exports.ChatClassificationRequest$inboundSchema = z4.object({
      model: z4.string(),
      input: inputs_js_1.Inputs$inboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "input": "inputs"
      });
    });
    exports.ChatClassificationRequest$outboundSchema = z4.object({
      model: z4.string(),
      inputs: inputs_js_1.Inputs$outboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        inputs: "input"
      });
    });
    var ChatClassificationRequest$;
    (function(ChatClassificationRequest$2) {
      ChatClassificationRequest$2.inboundSchema = exports.ChatClassificationRequest$inboundSchema;
      ChatClassificationRequest$2.outboundSchema = exports.ChatClassificationRequest$outboundSchema;
    })(ChatClassificationRequest$ || (exports.ChatClassificationRequest$ = ChatClassificationRequest$ = {}));
    function chatClassificationRequestToJSON(chatClassificationRequest) {
      return JSON.stringify(exports.ChatClassificationRequest$outboundSchema.parse(chatClassificationRequest));
    }
    function chatClassificationRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ChatClassificationRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ChatClassificationRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/chatcompletionchoice.js
var require_chatcompletionchoice = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/chatcompletionchoice.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ChatCompletionChoice$ = exports.ChatCompletionChoice$outboundSchema = exports.ChatCompletionChoice$inboundSchema = exports.FinishReason$ = exports.FinishReason$outboundSchema = exports.FinishReason$inboundSchema = exports.FinishReason = void 0;
    exports.chatCompletionChoiceToJSON = chatCompletionChoiceToJSON;
    exports.chatCompletionChoiceFromJSON = chatCompletionChoiceFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var enums_js_1 = require_enums();
    var assistantmessage_js_1 = require_assistantmessage();
    exports.FinishReason = {
      Stop: "stop",
      Length: "length",
      ModelLength: "model_length",
      Error: "error",
      ToolCalls: "tool_calls"
    };
    exports.FinishReason$inboundSchema = z4.union([
      z4.nativeEnum(exports.FinishReason),
      z4.string().transform(enums_js_1.catchUnrecognizedEnum)
    ]);
    exports.FinishReason$outboundSchema = z4.union([
      z4.nativeEnum(exports.FinishReason),
      z4.string().and(z4.custom())
    ]);
    var FinishReason$;
    (function(FinishReason$2) {
      FinishReason$2.inboundSchema = exports.FinishReason$inboundSchema;
      FinishReason$2.outboundSchema = exports.FinishReason$outboundSchema;
    })(FinishReason$ || (exports.FinishReason$ = FinishReason$ = {}));
    exports.ChatCompletionChoice$inboundSchema = z4.object({
      index: z4.number().int(),
      message: assistantmessage_js_1.AssistantMessage$inboundSchema,
      finish_reason: exports.FinishReason$inboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "finish_reason": "finishReason"
      });
    });
    exports.ChatCompletionChoice$outboundSchema = z4.object({
      index: z4.number().int(),
      message: assistantmessage_js_1.AssistantMessage$outboundSchema,
      finishReason: exports.FinishReason$outboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        finishReason: "finish_reason"
      });
    });
    var ChatCompletionChoice$;
    (function(ChatCompletionChoice$2) {
      ChatCompletionChoice$2.inboundSchema = exports.ChatCompletionChoice$inboundSchema;
      ChatCompletionChoice$2.outboundSchema = exports.ChatCompletionChoice$outboundSchema;
    })(ChatCompletionChoice$ || (exports.ChatCompletionChoice$ = ChatCompletionChoice$ = {}));
    function chatCompletionChoiceToJSON(chatCompletionChoice) {
      return JSON.stringify(exports.ChatCompletionChoice$outboundSchema.parse(chatCompletionChoice));
    }
    function chatCompletionChoiceFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ChatCompletionChoice$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ChatCompletionChoice' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/chatcompletionrequest.js
var require_chatcompletionrequest = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/chatcompletionrequest.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ChatCompletionRequest$ = exports.ChatCompletionRequest$outboundSchema = exports.ChatCompletionRequest$inboundSchema = exports.ChatCompletionRequestToolChoice$ = exports.ChatCompletionRequestToolChoice$outboundSchema = exports.ChatCompletionRequestToolChoice$inboundSchema = exports.Messages$ = exports.Messages$outboundSchema = exports.Messages$inboundSchema = exports.Stop$ = exports.Stop$outboundSchema = exports.Stop$inboundSchema = void 0;
    exports.stopToJSON = stopToJSON;
    exports.stopFromJSON = stopFromJSON;
    exports.messagesToJSON = messagesToJSON;
    exports.messagesFromJSON = messagesFromJSON;
    exports.chatCompletionRequestToolChoiceToJSON = chatCompletionRequestToolChoiceToJSON;
    exports.chatCompletionRequestToolChoiceFromJSON = chatCompletionRequestToolChoiceFromJSON;
    exports.chatCompletionRequestToJSON = chatCompletionRequestToJSON;
    exports.chatCompletionRequestFromJSON = chatCompletionRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var assistantmessage_js_1 = require_assistantmessage();
    var mistralpromptmode_js_1 = require_mistralpromptmode();
    var prediction_js_1 = require_prediction();
    var responseformat_js_1 = require_responseformat();
    var systemmessage_js_1 = require_systemmessage();
    var tool_js_1 = require_tool();
    var toolchoice_js_1 = require_toolchoice();
    var toolchoiceenum_js_1 = require_toolchoiceenum();
    var toolmessage_js_1 = require_toolmessage();
    var usermessage_js_1 = require_usermessage();
    exports.Stop$inboundSchema = z4.union([z4.string(), z4.array(z4.string())]);
    exports.Stop$outboundSchema = z4.union([z4.string(), z4.array(z4.string())]);
    var Stop$;
    (function(Stop$2) {
      Stop$2.inboundSchema = exports.Stop$inboundSchema;
      Stop$2.outboundSchema = exports.Stop$outboundSchema;
    })(Stop$ || (exports.Stop$ = Stop$ = {}));
    function stopToJSON(stop) {
      return JSON.stringify(exports.Stop$outboundSchema.parse(stop));
    }
    function stopFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.Stop$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'Stop' from JSON`);
    }
    exports.Messages$inboundSchema = z4.union([
      systemmessage_js_1.SystemMessage$inboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
        role: v2.role
      }))),
      usermessage_js_1.UserMessage$inboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({ role: v2.role }))),
      assistantmessage_js_1.AssistantMessage$inboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
        role: v2.role
      }))),
      toolmessage_js_1.ToolMessage$inboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({ role: v2.role })))
    ]);
    exports.Messages$outboundSchema = z4.union([
      systemmessage_js_1.SystemMessage$outboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
        role: v2.role
      }))),
      usermessage_js_1.UserMessage$outboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({ role: v2.role }))),
      assistantmessage_js_1.AssistantMessage$outboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
        role: v2.role
      }))),
      toolmessage_js_1.ToolMessage$outboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({ role: v2.role })))
    ]);
    var Messages$;
    (function(Messages$2) {
      Messages$2.inboundSchema = exports.Messages$inboundSchema;
      Messages$2.outboundSchema = exports.Messages$outboundSchema;
    })(Messages$ || (exports.Messages$ = Messages$ = {}));
    function messagesToJSON(messages) {
      return JSON.stringify(exports.Messages$outboundSchema.parse(messages));
    }
    function messagesFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.Messages$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'Messages' from JSON`);
    }
    exports.ChatCompletionRequestToolChoice$inboundSchema = z4.union([toolchoice_js_1.ToolChoice$inboundSchema, toolchoiceenum_js_1.ToolChoiceEnum$inboundSchema]);
    exports.ChatCompletionRequestToolChoice$outboundSchema = z4.union([toolchoice_js_1.ToolChoice$outboundSchema, toolchoiceenum_js_1.ToolChoiceEnum$outboundSchema]);
    var ChatCompletionRequestToolChoice$;
    (function(ChatCompletionRequestToolChoice$2) {
      ChatCompletionRequestToolChoice$2.inboundSchema = exports.ChatCompletionRequestToolChoice$inboundSchema;
      ChatCompletionRequestToolChoice$2.outboundSchema = exports.ChatCompletionRequestToolChoice$outboundSchema;
    })(ChatCompletionRequestToolChoice$ || (exports.ChatCompletionRequestToolChoice$ = ChatCompletionRequestToolChoice$ = {}));
    function chatCompletionRequestToolChoiceToJSON(chatCompletionRequestToolChoice) {
      return JSON.stringify(exports.ChatCompletionRequestToolChoice$outboundSchema.parse(chatCompletionRequestToolChoice));
    }
    function chatCompletionRequestToolChoiceFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ChatCompletionRequestToolChoice$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ChatCompletionRequestToolChoice' from JSON`);
    }
    exports.ChatCompletionRequest$inboundSchema = z4.object({
      model: z4.string(),
      temperature: z4.nullable(z4.number()).optional(),
      top_p: z4.number().optional(),
      max_tokens: z4.nullable(z4.number().int()).optional(),
      stream: z4.boolean().default(false),
      stop: z4.union([z4.string(), z4.array(z4.string())]).optional(),
      random_seed: z4.nullable(z4.number().int()).optional(),
      messages: z4.array(z4.union([
        systemmessage_js_1.SystemMessage$inboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
          role: v2.role
        }))),
        usermessage_js_1.UserMessage$inboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({
          role: v2.role
        }))),
        assistantmessage_js_1.AssistantMessage$inboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
          role: v2.role
        }))),
        toolmessage_js_1.ToolMessage$inboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({
          role: v2.role
        })))
      ])),
      response_format: responseformat_js_1.ResponseFormat$inboundSchema.optional(),
      tools: z4.nullable(z4.array(tool_js_1.Tool$inboundSchema)).optional(),
      tool_choice: z4.union([toolchoice_js_1.ToolChoice$inboundSchema, toolchoiceenum_js_1.ToolChoiceEnum$inboundSchema]).optional(),
      presence_penalty: z4.number().optional(),
      frequency_penalty: z4.number().optional(),
      n: z4.nullable(z4.number().int()).optional(),
      prediction: prediction_js_1.Prediction$inboundSchema.optional(),
      parallel_tool_calls: z4.boolean().optional(),
      prompt_mode: z4.nullable(mistralpromptmode_js_1.MistralPromptMode$inboundSchema).optional(),
      safe_prompt: z4.boolean().optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "top_p": "topP",
        "max_tokens": "maxTokens",
        "random_seed": "randomSeed",
        "response_format": "responseFormat",
        "tool_choice": "toolChoice",
        "presence_penalty": "presencePenalty",
        "frequency_penalty": "frequencyPenalty",
        "parallel_tool_calls": "parallelToolCalls",
        "prompt_mode": "promptMode",
        "safe_prompt": "safePrompt"
      });
    });
    exports.ChatCompletionRequest$outboundSchema = z4.object({
      model: z4.string(),
      temperature: z4.nullable(z4.number()).optional(),
      topP: z4.number().optional(),
      maxTokens: z4.nullable(z4.number().int()).optional(),
      stream: z4.boolean().default(false),
      stop: z4.union([z4.string(), z4.array(z4.string())]).optional(),
      randomSeed: z4.nullable(z4.number().int()).optional(),
      messages: z4.array(z4.union([
        systemmessage_js_1.SystemMessage$outboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
          role: v2.role
        }))),
        usermessage_js_1.UserMessage$outboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({
          role: v2.role
        }))),
        assistantmessage_js_1.AssistantMessage$outboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
          role: v2.role
        }))),
        toolmessage_js_1.ToolMessage$outboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({
          role: v2.role
        })))
      ])),
      responseFormat: responseformat_js_1.ResponseFormat$outboundSchema.optional(),
      tools: z4.nullable(z4.array(tool_js_1.Tool$outboundSchema)).optional(),
      toolChoice: z4.union([
        toolchoice_js_1.ToolChoice$outboundSchema,
        toolchoiceenum_js_1.ToolChoiceEnum$outboundSchema
      ]).optional(),
      presencePenalty: z4.number().optional(),
      frequencyPenalty: z4.number().optional(),
      n: z4.nullable(z4.number().int()).optional(),
      prediction: prediction_js_1.Prediction$outboundSchema.optional(),
      parallelToolCalls: z4.boolean().optional(),
      promptMode: z4.nullable(mistralpromptmode_js_1.MistralPromptMode$outboundSchema).optional(),
      safePrompt: z4.boolean().optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        topP: "top_p",
        maxTokens: "max_tokens",
        randomSeed: "random_seed",
        responseFormat: "response_format",
        toolChoice: "tool_choice",
        presencePenalty: "presence_penalty",
        frequencyPenalty: "frequency_penalty",
        parallelToolCalls: "parallel_tool_calls",
        promptMode: "prompt_mode",
        safePrompt: "safe_prompt"
      });
    });
    var ChatCompletionRequest$;
    (function(ChatCompletionRequest$2) {
      ChatCompletionRequest$2.inboundSchema = exports.ChatCompletionRequest$inboundSchema;
      ChatCompletionRequest$2.outboundSchema = exports.ChatCompletionRequest$outboundSchema;
    })(ChatCompletionRequest$ || (exports.ChatCompletionRequest$ = ChatCompletionRequest$ = {}));
    function chatCompletionRequestToJSON(chatCompletionRequest) {
      return JSON.stringify(exports.ChatCompletionRequest$outboundSchema.parse(chatCompletionRequest));
    }
    function chatCompletionRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ChatCompletionRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ChatCompletionRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/usageinfo.js
var require_usageinfo = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/usageinfo.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UsageInfo$ = exports.UsageInfo$outboundSchema = exports.UsageInfo$inboundSchema = void 0;
    exports.usageInfoToJSON = usageInfoToJSON;
    exports.usageInfoFromJSON = usageInfoFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.UsageInfo$inboundSchema = (0, schemas_js_1.collectExtraKeys)(z4.object({
      prompt_tokens: z4.number().int().default(0),
      completion_tokens: z4.number().int().default(0),
      total_tokens: z4.number().int().default(0),
      prompt_audio_seconds: z4.nullable(z4.number().int()).optional()
    }).catchall(z4.any()), "additionalProperties", true).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "prompt_tokens": "promptTokens",
        "completion_tokens": "completionTokens",
        "total_tokens": "totalTokens",
        "prompt_audio_seconds": "promptAudioSeconds"
      });
    });
    exports.UsageInfo$outboundSchema = z4.object({
      promptTokens: z4.number().int().default(0),
      completionTokens: z4.number().int().default(0),
      totalTokens: z4.number().int().default(0),
      promptAudioSeconds: z4.nullable(z4.number().int()).optional(),
      additionalProperties: z4.record(z4.any())
    }).transform((v2) => {
      return {
        ...v2.additionalProperties,
        ...(0, primitives_js_1.remap)(v2, {
          promptTokens: "prompt_tokens",
          completionTokens: "completion_tokens",
          totalTokens: "total_tokens",
          promptAudioSeconds: "prompt_audio_seconds",
          additionalProperties: null
        })
      };
    });
    var UsageInfo$;
    (function(UsageInfo$2) {
      UsageInfo$2.inboundSchema = exports.UsageInfo$inboundSchema;
      UsageInfo$2.outboundSchema = exports.UsageInfo$outboundSchema;
    })(UsageInfo$ || (exports.UsageInfo$ = UsageInfo$ = {}));
    function usageInfoToJSON(usageInfo) {
      return JSON.stringify(exports.UsageInfo$outboundSchema.parse(usageInfo));
    }
    function usageInfoFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.UsageInfo$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'UsageInfo' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/chatcompletionresponse.js
var require_chatcompletionresponse = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/chatcompletionresponse.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ChatCompletionResponse$ = exports.ChatCompletionResponse$outboundSchema = exports.ChatCompletionResponse$inboundSchema = void 0;
    exports.chatCompletionResponseToJSON = chatCompletionResponseToJSON;
    exports.chatCompletionResponseFromJSON = chatCompletionResponseFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var chatcompletionchoice_js_1 = require_chatcompletionchoice();
    var usageinfo_js_1 = require_usageinfo();
    exports.ChatCompletionResponse$inboundSchema = z4.object({
      id: z4.string(),
      object: z4.string(),
      model: z4.string(),
      usage: usageinfo_js_1.UsageInfo$inboundSchema,
      created: z4.number().int(),
      choices: z4.array(chatcompletionchoice_js_1.ChatCompletionChoice$inboundSchema)
    });
    exports.ChatCompletionResponse$outboundSchema = z4.object({
      id: z4.string(),
      object: z4.string(),
      model: z4.string(),
      usage: usageinfo_js_1.UsageInfo$outboundSchema,
      created: z4.number().int(),
      choices: z4.array(chatcompletionchoice_js_1.ChatCompletionChoice$outboundSchema)
    });
    var ChatCompletionResponse$;
    (function(ChatCompletionResponse$2) {
      ChatCompletionResponse$2.inboundSchema = exports.ChatCompletionResponse$inboundSchema;
      ChatCompletionResponse$2.outboundSchema = exports.ChatCompletionResponse$outboundSchema;
    })(ChatCompletionResponse$ || (exports.ChatCompletionResponse$ = ChatCompletionResponse$ = {}));
    function chatCompletionResponseToJSON(chatCompletionResponse) {
      return JSON.stringify(exports.ChatCompletionResponse$outboundSchema.parse(chatCompletionResponse));
    }
    function chatCompletionResponseFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ChatCompletionResponse$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ChatCompletionResponse' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/chatcompletionstreamrequest.js
var require_chatcompletionstreamrequest = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/chatcompletionstreamrequest.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ChatCompletionStreamRequest$ = exports.ChatCompletionStreamRequest$outboundSchema = exports.ChatCompletionStreamRequest$inboundSchema = exports.ChatCompletionStreamRequestToolChoice$ = exports.ChatCompletionStreamRequestToolChoice$outboundSchema = exports.ChatCompletionStreamRequestToolChoice$inboundSchema = exports.ChatCompletionStreamRequestMessages$ = exports.ChatCompletionStreamRequestMessages$outboundSchema = exports.ChatCompletionStreamRequestMessages$inboundSchema = exports.ChatCompletionStreamRequestStop$ = exports.ChatCompletionStreamRequestStop$outboundSchema = exports.ChatCompletionStreamRequestStop$inboundSchema = void 0;
    exports.chatCompletionStreamRequestStopToJSON = chatCompletionStreamRequestStopToJSON;
    exports.chatCompletionStreamRequestStopFromJSON = chatCompletionStreamRequestStopFromJSON;
    exports.chatCompletionStreamRequestMessagesToJSON = chatCompletionStreamRequestMessagesToJSON;
    exports.chatCompletionStreamRequestMessagesFromJSON = chatCompletionStreamRequestMessagesFromJSON;
    exports.chatCompletionStreamRequestToolChoiceToJSON = chatCompletionStreamRequestToolChoiceToJSON;
    exports.chatCompletionStreamRequestToolChoiceFromJSON = chatCompletionStreamRequestToolChoiceFromJSON;
    exports.chatCompletionStreamRequestToJSON = chatCompletionStreamRequestToJSON;
    exports.chatCompletionStreamRequestFromJSON = chatCompletionStreamRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var assistantmessage_js_1 = require_assistantmessage();
    var mistralpromptmode_js_1 = require_mistralpromptmode();
    var prediction_js_1 = require_prediction();
    var responseformat_js_1 = require_responseformat();
    var systemmessage_js_1 = require_systemmessage();
    var tool_js_1 = require_tool();
    var toolchoice_js_1 = require_toolchoice();
    var toolchoiceenum_js_1 = require_toolchoiceenum();
    var toolmessage_js_1 = require_toolmessage();
    var usermessage_js_1 = require_usermessage();
    exports.ChatCompletionStreamRequestStop$inboundSchema = z4.union([z4.string(), z4.array(z4.string())]);
    exports.ChatCompletionStreamRequestStop$outboundSchema = z4.union([z4.string(), z4.array(z4.string())]);
    var ChatCompletionStreamRequestStop$;
    (function(ChatCompletionStreamRequestStop$2) {
      ChatCompletionStreamRequestStop$2.inboundSchema = exports.ChatCompletionStreamRequestStop$inboundSchema;
      ChatCompletionStreamRequestStop$2.outboundSchema = exports.ChatCompletionStreamRequestStop$outboundSchema;
    })(ChatCompletionStreamRequestStop$ || (exports.ChatCompletionStreamRequestStop$ = ChatCompletionStreamRequestStop$ = {}));
    function chatCompletionStreamRequestStopToJSON(chatCompletionStreamRequestStop) {
      return JSON.stringify(exports.ChatCompletionStreamRequestStop$outboundSchema.parse(chatCompletionStreamRequestStop));
    }
    function chatCompletionStreamRequestStopFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ChatCompletionStreamRequestStop$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ChatCompletionStreamRequestStop' from JSON`);
    }
    exports.ChatCompletionStreamRequestMessages$inboundSchema = z4.union([
      systemmessage_js_1.SystemMessage$inboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
        role: v2.role
      }))),
      usermessage_js_1.UserMessage$inboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({ role: v2.role }))),
      assistantmessage_js_1.AssistantMessage$inboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
        role: v2.role
      }))),
      toolmessage_js_1.ToolMessage$inboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({ role: v2.role })))
    ]);
    exports.ChatCompletionStreamRequestMessages$outboundSchema = z4.union([
      systemmessage_js_1.SystemMessage$outboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
        role: v2.role
      }))),
      usermessage_js_1.UserMessage$outboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({ role: v2.role }))),
      assistantmessage_js_1.AssistantMessage$outboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
        role: v2.role
      }))),
      toolmessage_js_1.ToolMessage$outboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({ role: v2.role })))
    ]);
    var ChatCompletionStreamRequestMessages$;
    (function(ChatCompletionStreamRequestMessages$2) {
      ChatCompletionStreamRequestMessages$2.inboundSchema = exports.ChatCompletionStreamRequestMessages$inboundSchema;
      ChatCompletionStreamRequestMessages$2.outboundSchema = exports.ChatCompletionStreamRequestMessages$outboundSchema;
    })(ChatCompletionStreamRequestMessages$ || (exports.ChatCompletionStreamRequestMessages$ = ChatCompletionStreamRequestMessages$ = {}));
    function chatCompletionStreamRequestMessagesToJSON(chatCompletionStreamRequestMessages) {
      return JSON.stringify(exports.ChatCompletionStreamRequestMessages$outboundSchema.parse(chatCompletionStreamRequestMessages));
    }
    function chatCompletionStreamRequestMessagesFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ChatCompletionStreamRequestMessages$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ChatCompletionStreamRequestMessages' from JSON`);
    }
    exports.ChatCompletionStreamRequestToolChoice$inboundSchema = z4.union([toolchoice_js_1.ToolChoice$inboundSchema, toolchoiceenum_js_1.ToolChoiceEnum$inboundSchema]);
    exports.ChatCompletionStreamRequestToolChoice$outboundSchema = z4.union([toolchoice_js_1.ToolChoice$outboundSchema, toolchoiceenum_js_1.ToolChoiceEnum$outboundSchema]);
    var ChatCompletionStreamRequestToolChoice$;
    (function(ChatCompletionStreamRequestToolChoice$2) {
      ChatCompletionStreamRequestToolChoice$2.inboundSchema = exports.ChatCompletionStreamRequestToolChoice$inboundSchema;
      ChatCompletionStreamRequestToolChoice$2.outboundSchema = exports.ChatCompletionStreamRequestToolChoice$outboundSchema;
    })(ChatCompletionStreamRequestToolChoice$ || (exports.ChatCompletionStreamRequestToolChoice$ = ChatCompletionStreamRequestToolChoice$ = {}));
    function chatCompletionStreamRequestToolChoiceToJSON(chatCompletionStreamRequestToolChoice) {
      return JSON.stringify(exports.ChatCompletionStreamRequestToolChoice$outboundSchema.parse(chatCompletionStreamRequestToolChoice));
    }
    function chatCompletionStreamRequestToolChoiceFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ChatCompletionStreamRequestToolChoice$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ChatCompletionStreamRequestToolChoice' from JSON`);
    }
    exports.ChatCompletionStreamRequest$inboundSchema = z4.object({
      model: z4.string(),
      temperature: z4.nullable(z4.number()).optional(),
      top_p: z4.number().optional(),
      max_tokens: z4.nullable(z4.number().int()).optional(),
      stream: z4.boolean().default(true),
      stop: z4.union([z4.string(), z4.array(z4.string())]).optional(),
      random_seed: z4.nullable(z4.number().int()).optional(),
      messages: z4.array(z4.union([
        systemmessage_js_1.SystemMessage$inboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
          role: v2.role
        }))),
        usermessage_js_1.UserMessage$inboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({
          role: v2.role
        }))),
        assistantmessage_js_1.AssistantMessage$inboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
          role: v2.role
        }))),
        toolmessage_js_1.ToolMessage$inboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({
          role: v2.role
        })))
      ])),
      response_format: responseformat_js_1.ResponseFormat$inboundSchema.optional(),
      tools: z4.nullable(z4.array(tool_js_1.Tool$inboundSchema)).optional(),
      tool_choice: z4.union([toolchoice_js_1.ToolChoice$inboundSchema, toolchoiceenum_js_1.ToolChoiceEnum$inboundSchema]).optional(),
      presence_penalty: z4.number().optional(),
      frequency_penalty: z4.number().optional(),
      n: z4.nullable(z4.number().int()).optional(),
      prediction: prediction_js_1.Prediction$inboundSchema.optional(),
      parallel_tool_calls: z4.boolean().optional(),
      prompt_mode: z4.nullable(mistralpromptmode_js_1.MistralPromptMode$inboundSchema).optional(),
      safe_prompt: z4.boolean().optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "top_p": "topP",
        "max_tokens": "maxTokens",
        "random_seed": "randomSeed",
        "response_format": "responseFormat",
        "tool_choice": "toolChoice",
        "presence_penalty": "presencePenalty",
        "frequency_penalty": "frequencyPenalty",
        "parallel_tool_calls": "parallelToolCalls",
        "prompt_mode": "promptMode",
        "safe_prompt": "safePrompt"
      });
    });
    exports.ChatCompletionStreamRequest$outboundSchema = z4.object({
      model: z4.string(),
      temperature: z4.nullable(z4.number()).optional(),
      topP: z4.number().optional(),
      maxTokens: z4.nullable(z4.number().int()).optional(),
      stream: z4.boolean().default(true),
      stop: z4.union([z4.string(), z4.array(z4.string())]).optional(),
      randomSeed: z4.nullable(z4.number().int()).optional(),
      messages: z4.array(z4.union([
        systemmessage_js_1.SystemMessage$outboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
          role: v2.role
        }))),
        usermessage_js_1.UserMessage$outboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({
          role: v2.role
        }))),
        assistantmessage_js_1.AssistantMessage$outboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
          role: v2.role
        }))),
        toolmessage_js_1.ToolMessage$outboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({
          role: v2.role
        })))
      ])),
      responseFormat: responseformat_js_1.ResponseFormat$outboundSchema.optional(),
      tools: z4.nullable(z4.array(tool_js_1.Tool$outboundSchema)).optional(),
      toolChoice: z4.union([
        toolchoice_js_1.ToolChoice$outboundSchema,
        toolchoiceenum_js_1.ToolChoiceEnum$outboundSchema
      ]).optional(),
      presencePenalty: z4.number().optional(),
      frequencyPenalty: z4.number().optional(),
      n: z4.nullable(z4.number().int()).optional(),
      prediction: prediction_js_1.Prediction$outboundSchema.optional(),
      parallelToolCalls: z4.boolean().optional(),
      promptMode: z4.nullable(mistralpromptmode_js_1.MistralPromptMode$outboundSchema).optional(),
      safePrompt: z4.boolean().optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        topP: "top_p",
        maxTokens: "max_tokens",
        randomSeed: "random_seed",
        responseFormat: "response_format",
        toolChoice: "tool_choice",
        presencePenalty: "presence_penalty",
        frequencyPenalty: "frequency_penalty",
        parallelToolCalls: "parallel_tool_calls",
        promptMode: "prompt_mode",
        safePrompt: "safe_prompt"
      });
    });
    var ChatCompletionStreamRequest$;
    (function(ChatCompletionStreamRequest$2) {
      ChatCompletionStreamRequest$2.inboundSchema = exports.ChatCompletionStreamRequest$inboundSchema;
      ChatCompletionStreamRequest$2.outboundSchema = exports.ChatCompletionStreamRequest$outboundSchema;
    })(ChatCompletionStreamRequest$ || (exports.ChatCompletionStreamRequest$ = ChatCompletionStreamRequest$ = {}));
    function chatCompletionStreamRequestToJSON(chatCompletionStreamRequest) {
      return JSON.stringify(exports.ChatCompletionStreamRequest$outboundSchema.parse(chatCompletionStreamRequest));
    }
    function chatCompletionStreamRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ChatCompletionStreamRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ChatCompletionStreamRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/chatmoderationrequest.js
var require_chatmoderationrequest = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/chatmoderationrequest.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ChatModerationRequest$ = exports.ChatModerationRequest$outboundSchema = exports.ChatModerationRequest$inboundSchema = exports.ChatModerationRequestInputs$ = exports.ChatModerationRequestInputs$outboundSchema = exports.ChatModerationRequestInputs$inboundSchema = exports.One$ = exports.One$outboundSchema = exports.One$inboundSchema = exports.Two$ = exports.Two$outboundSchema = exports.Two$inboundSchema = void 0;
    exports.twoToJSON = twoToJSON;
    exports.twoFromJSON = twoFromJSON;
    exports.oneToJSON = oneToJSON;
    exports.oneFromJSON = oneFromJSON;
    exports.chatModerationRequestInputsToJSON = chatModerationRequestInputsToJSON;
    exports.chatModerationRequestInputsFromJSON = chatModerationRequestInputsFromJSON;
    exports.chatModerationRequestToJSON = chatModerationRequestToJSON;
    exports.chatModerationRequestFromJSON = chatModerationRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var assistantmessage_js_1 = require_assistantmessage();
    var systemmessage_js_1 = require_systemmessage();
    var toolmessage_js_1 = require_toolmessage();
    var usermessage_js_1 = require_usermessage();
    exports.Two$inboundSchema = z4.union([
      systemmessage_js_1.SystemMessage$inboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
        role: v2.role
      }))),
      usermessage_js_1.UserMessage$inboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({
        role: v2.role
      }))),
      assistantmessage_js_1.AssistantMessage$inboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
        role: v2.role
      }))),
      toolmessage_js_1.ToolMessage$inboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({
        role: v2.role
      })))
    ]);
    exports.Two$outboundSchema = z4.union([
      systemmessage_js_1.SystemMessage$outboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
        role: v2.role
      }))),
      usermessage_js_1.UserMessage$outboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({
        role: v2.role
      }))),
      assistantmessage_js_1.AssistantMessage$outboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
        role: v2.role
      }))),
      toolmessage_js_1.ToolMessage$outboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({
        role: v2.role
      })))
    ]);
    var Two$;
    (function(Two$2) {
      Two$2.inboundSchema = exports.Two$inboundSchema;
      Two$2.outboundSchema = exports.Two$outboundSchema;
    })(Two$ || (exports.Two$ = Two$ = {}));
    function twoToJSON(two) {
      return JSON.stringify(exports.Two$outboundSchema.parse(two));
    }
    function twoFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.Two$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'Two' from JSON`);
    }
    exports.One$inboundSchema = z4.union([
      systemmessage_js_1.SystemMessage$inboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
        role: v2.role
      }))),
      usermessage_js_1.UserMessage$inboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({
        role: v2.role
      }))),
      assistantmessage_js_1.AssistantMessage$inboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
        role: v2.role
      }))),
      toolmessage_js_1.ToolMessage$inboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({
        role: v2.role
      })))
    ]);
    exports.One$outboundSchema = z4.union([
      systemmessage_js_1.SystemMessage$outboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
        role: v2.role
      }))),
      usermessage_js_1.UserMessage$outboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({
        role: v2.role
      }))),
      assistantmessage_js_1.AssistantMessage$outboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
        role: v2.role
      }))),
      toolmessage_js_1.ToolMessage$outboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({
        role: v2.role
      })))
    ]);
    var One$;
    (function(One$2) {
      One$2.inboundSchema = exports.One$inboundSchema;
      One$2.outboundSchema = exports.One$outboundSchema;
    })(One$ || (exports.One$ = One$ = {}));
    function oneToJSON(one) {
      return JSON.stringify(exports.One$outboundSchema.parse(one));
    }
    function oneFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.One$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'One' from JSON`);
    }
    exports.ChatModerationRequestInputs$inboundSchema = z4.union([
      z4.array(z4.union([
        systemmessage_js_1.SystemMessage$inboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
          role: v2.role
        }))),
        usermessage_js_1.UserMessage$inboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({
          role: v2.role
        }))),
        assistantmessage_js_1.AssistantMessage$inboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
          role: v2.role
        }))),
        toolmessage_js_1.ToolMessage$inboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({
          role: v2.role
        })))
      ])),
      z4.array(z4.array(z4.union([
        systemmessage_js_1.SystemMessage$inboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
          role: v2.role
        }))),
        usermessage_js_1.UserMessage$inboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({
          role: v2.role
        }))),
        assistantmessage_js_1.AssistantMessage$inboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
          role: v2.role
        }))),
        toolmessage_js_1.ToolMessage$inboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({
          role: v2.role
        })))
      ])))
    ]);
    exports.ChatModerationRequestInputs$outboundSchema = z4.union([
      z4.array(z4.union([
        systemmessage_js_1.SystemMessage$outboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
          role: v2.role
        }))),
        usermessage_js_1.UserMessage$outboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({
          role: v2.role
        }))),
        assistantmessage_js_1.AssistantMessage$outboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
          role: v2.role
        }))),
        toolmessage_js_1.ToolMessage$outboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({
          role: v2.role
        })))
      ])),
      z4.array(z4.array(z4.union([
        systemmessage_js_1.SystemMessage$outboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
          role: v2.role
        }))),
        usermessage_js_1.UserMessage$outboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({
          role: v2.role
        }))),
        assistantmessage_js_1.AssistantMessage$outboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
          role: v2.role
        }))),
        toolmessage_js_1.ToolMessage$outboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({
          role: v2.role
        })))
      ])))
    ]);
    var ChatModerationRequestInputs$;
    (function(ChatModerationRequestInputs$2) {
      ChatModerationRequestInputs$2.inboundSchema = exports.ChatModerationRequestInputs$inboundSchema;
      ChatModerationRequestInputs$2.outboundSchema = exports.ChatModerationRequestInputs$outboundSchema;
    })(ChatModerationRequestInputs$ || (exports.ChatModerationRequestInputs$ = ChatModerationRequestInputs$ = {}));
    function chatModerationRequestInputsToJSON(chatModerationRequestInputs) {
      return JSON.stringify(exports.ChatModerationRequestInputs$outboundSchema.parse(chatModerationRequestInputs));
    }
    function chatModerationRequestInputsFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ChatModerationRequestInputs$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ChatModerationRequestInputs' from JSON`);
    }
    exports.ChatModerationRequest$inboundSchema = z4.object({
      input: z4.union([
        z4.array(z4.union([
          systemmessage_js_1.SystemMessage$inboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
            role: v2.role
          }))),
          usermessage_js_1.UserMessage$inboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({
            role: v2.role
          }))),
          assistantmessage_js_1.AssistantMessage$inboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
            role: v2.role
          }))),
          toolmessage_js_1.ToolMessage$inboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({
            role: v2.role
          })))
        ])),
        z4.array(z4.array(z4.union([
          systemmessage_js_1.SystemMessage$inboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
            role: v2.role
          }))),
          usermessage_js_1.UserMessage$inboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({
            role: v2.role
          }))),
          assistantmessage_js_1.AssistantMessage$inboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
            role: v2.role
          }))),
          toolmessage_js_1.ToolMessage$inboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({
            role: v2.role
          })))
        ])))
      ]),
      model: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "input": "inputs"
      });
    });
    exports.ChatModerationRequest$outboundSchema = z4.object({
      inputs: z4.union([
        z4.array(z4.union([
          systemmessage_js_1.SystemMessage$outboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
            role: v2.role
          }))),
          usermessage_js_1.UserMessage$outboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({
            role: v2.role
          }))),
          assistantmessage_js_1.AssistantMessage$outboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
            role: v2.role
          }))),
          toolmessage_js_1.ToolMessage$outboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({
            role: v2.role
          })))
        ])),
        z4.array(z4.array(z4.union([
          systemmessage_js_1.SystemMessage$outboundSchema.and(z4.object({ role: z4.literal("system") }).transform((v2) => ({
            role: v2.role
          }))),
          usermessage_js_1.UserMessage$outboundSchema.and(z4.object({ role: z4.literal("user") }).transform((v2) => ({
            role: v2.role
          }))),
          assistantmessage_js_1.AssistantMessage$outboundSchema.and(z4.object({ role: z4.literal("assistant") }).transform((v2) => ({
            role: v2.role
          }))),
          toolmessage_js_1.ToolMessage$outboundSchema.and(z4.object({ role: z4.literal("tool") }).transform((v2) => ({
            role: v2.role
          })))
        ])))
      ]),
      model: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        inputs: "input"
      });
    });
    var ChatModerationRequest$;
    (function(ChatModerationRequest$2) {
      ChatModerationRequest$2.inboundSchema = exports.ChatModerationRequest$inboundSchema;
      ChatModerationRequest$2.outboundSchema = exports.ChatModerationRequest$outboundSchema;
    })(ChatModerationRequest$ || (exports.ChatModerationRequest$ = ChatModerationRequest$ = {}));
    function chatModerationRequestToJSON(chatModerationRequest) {
      return JSON.stringify(exports.ChatModerationRequest$outboundSchema.parse(chatModerationRequest));
    }
    function chatModerationRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ChatModerationRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ChatModerationRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/metricout.js
var require_metricout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/metricout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MetricOut$ = exports.MetricOut$outboundSchema = exports.MetricOut$inboundSchema = void 0;
    exports.metricOutToJSON = metricOutToJSON;
    exports.metricOutFromJSON = metricOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.MetricOut$inboundSchema = z4.object({
      train_loss: z4.nullable(z4.number()).optional(),
      valid_loss: z4.nullable(z4.number()).optional(),
      valid_mean_token_accuracy: z4.nullable(z4.number()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "train_loss": "trainLoss",
        "valid_loss": "validLoss",
        "valid_mean_token_accuracy": "validMeanTokenAccuracy"
      });
    });
    exports.MetricOut$outboundSchema = z4.object({
      trainLoss: z4.nullable(z4.number()).optional(),
      validLoss: z4.nullable(z4.number()).optional(),
      validMeanTokenAccuracy: z4.nullable(z4.number()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        trainLoss: "train_loss",
        validLoss: "valid_loss",
        validMeanTokenAccuracy: "valid_mean_token_accuracy"
      });
    });
    var MetricOut$;
    (function(MetricOut$2) {
      MetricOut$2.inboundSchema = exports.MetricOut$inboundSchema;
      MetricOut$2.outboundSchema = exports.MetricOut$outboundSchema;
    })(MetricOut$ || (exports.MetricOut$ = MetricOut$ = {}));
    function metricOutToJSON(metricOut) {
      return JSON.stringify(exports.MetricOut$outboundSchema.parse(metricOut));
    }
    function metricOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.MetricOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'MetricOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/checkpointout.js
var require_checkpointout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/checkpointout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CheckpointOut$ = exports.CheckpointOut$outboundSchema = exports.CheckpointOut$inboundSchema = void 0;
    exports.checkpointOutToJSON = checkpointOutToJSON;
    exports.checkpointOutFromJSON = checkpointOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var metricout_js_1 = require_metricout();
    exports.CheckpointOut$inboundSchema = z4.object({
      metrics: metricout_js_1.MetricOut$inboundSchema,
      step_number: z4.number().int(),
      created_at: z4.number().int()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "step_number": "stepNumber",
        "created_at": "createdAt"
      });
    });
    exports.CheckpointOut$outboundSchema = z4.object({
      metrics: metricout_js_1.MetricOut$outboundSchema,
      stepNumber: z4.number().int(),
      createdAt: z4.number().int()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        stepNumber: "step_number",
        createdAt: "created_at"
      });
    });
    var CheckpointOut$;
    (function(CheckpointOut$2) {
      CheckpointOut$2.inboundSchema = exports.CheckpointOut$inboundSchema;
      CheckpointOut$2.outboundSchema = exports.CheckpointOut$outboundSchema;
    })(CheckpointOut$ || (exports.CheckpointOut$ = CheckpointOut$ = {}));
    function checkpointOutToJSON(checkpointOut) {
      return JSON.stringify(exports.CheckpointOut$outboundSchema.parse(checkpointOut));
    }
    function checkpointOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.CheckpointOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'CheckpointOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/classificationrequest.js
var require_classificationrequest = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/classificationrequest.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClassificationRequest$ = exports.ClassificationRequest$outboundSchema = exports.ClassificationRequest$inboundSchema = exports.ClassificationRequestInputs$ = exports.ClassificationRequestInputs$outboundSchema = exports.ClassificationRequestInputs$inboundSchema = void 0;
    exports.classificationRequestInputsToJSON = classificationRequestInputsToJSON;
    exports.classificationRequestInputsFromJSON = classificationRequestInputsFromJSON;
    exports.classificationRequestToJSON = classificationRequestToJSON;
    exports.classificationRequestFromJSON = classificationRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.ClassificationRequestInputs$inboundSchema = z4.union([z4.string(), z4.array(z4.string())]);
    exports.ClassificationRequestInputs$outboundSchema = z4.union([z4.string(), z4.array(z4.string())]);
    var ClassificationRequestInputs$;
    (function(ClassificationRequestInputs$2) {
      ClassificationRequestInputs$2.inboundSchema = exports.ClassificationRequestInputs$inboundSchema;
      ClassificationRequestInputs$2.outboundSchema = exports.ClassificationRequestInputs$outboundSchema;
    })(ClassificationRequestInputs$ || (exports.ClassificationRequestInputs$ = ClassificationRequestInputs$ = {}));
    function classificationRequestInputsToJSON(classificationRequestInputs) {
      return JSON.stringify(exports.ClassificationRequestInputs$outboundSchema.parse(classificationRequestInputs));
    }
    function classificationRequestInputsFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ClassificationRequestInputs$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ClassificationRequestInputs' from JSON`);
    }
    exports.ClassificationRequest$inboundSchema = z4.object({
      model: z4.string(),
      input: z4.union([z4.string(), z4.array(z4.string())])
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "input": "inputs"
      });
    });
    exports.ClassificationRequest$outboundSchema = z4.object({
      model: z4.string(),
      inputs: z4.union([z4.string(), z4.array(z4.string())])
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        inputs: "input"
      });
    });
    var ClassificationRequest$;
    (function(ClassificationRequest$2) {
      ClassificationRequest$2.inboundSchema = exports.ClassificationRequest$inboundSchema;
      ClassificationRequest$2.outboundSchema = exports.ClassificationRequest$outboundSchema;
    })(ClassificationRequest$ || (exports.ClassificationRequest$ = ClassificationRequest$ = {}));
    function classificationRequestToJSON(classificationRequest) {
      return JSON.stringify(exports.ClassificationRequest$outboundSchema.parse(classificationRequest));
    }
    function classificationRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ClassificationRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ClassificationRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/classificationtargetresult.js
var require_classificationtargetresult = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/classificationtargetresult.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClassificationTargetResult$ = exports.ClassificationTargetResult$outboundSchema = exports.ClassificationTargetResult$inboundSchema = void 0;
    exports.classificationTargetResultToJSON = classificationTargetResultToJSON;
    exports.classificationTargetResultFromJSON = classificationTargetResultFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    exports.ClassificationTargetResult$inboundSchema = z4.object({
      scores: z4.record(z4.number())
    });
    exports.ClassificationTargetResult$outboundSchema = z4.object({
      scores: z4.record(z4.number())
    });
    var ClassificationTargetResult$;
    (function(ClassificationTargetResult$2) {
      ClassificationTargetResult$2.inboundSchema = exports.ClassificationTargetResult$inboundSchema;
      ClassificationTargetResult$2.outboundSchema = exports.ClassificationTargetResult$outboundSchema;
    })(ClassificationTargetResult$ || (exports.ClassificationTargetResult$ = ClassificationTargetResult$ = {}));
    function classificationTargetResultToJSON(classificationTargetResult) {
      return JSON.stringify(exports.ClassificationTargetResult$outboundSchema.parse(classificationTargetResult));
    }
    function classificationTargetResultFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ClassificationTargetResult$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ClassificationTargetResult' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/classificationresponse.js
var require_classificationresponse = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/classificationresponse.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClassificationResponse$ = exports.ClassificationResponse$outboundSchema = exports.ClassificationResponse$inboundSchema = void 0;
    exports.classificationResponseToJSON = classificationResponseToJSON;
    exports.classificationResponseFromJSON = classificationResponseFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var classificationtargetresult_js_1 = require_classificationtargetresult();
    exports.ClassificationResponse$inboundSchema = z4.object({
      id: z4.string(),
      model: z4.string(),
      results: z4.array(z4.record(classificationtargetresult_js_1.ClassificationTargetResult$inboundSchema))
    });
    exports.ClassificationResponse$outboundSchema = z4.object({
      id: z4.string(),
      model: z4.string(),
      results: z4.array(z4.record(classificationtargetresult_js_1.ClassificationTargetResult$outboundSchema))
    });
    var ClassificationResponse$;
    (function(ClassificationResponse$2) {
      ClassificationResponse$2.inboundSchema = exports.ClassificationResponse$inboundSchema;
      ClassificationResponse$2.outboundSchema = exports.ClassificationResponse$outboundSchema;
    })(ClassificationResponse$ || (exports.ClassificationResponse$ = ClassificationResponse$ = {}));
    function classificationResponseToJSON(classificationResponse) {
      return JSON.stringify(exports.ClassificationResponse$outboundSchema.parse(classificationResponse));
    }
    function classificationResponseFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ClassificationResponse$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ClassificationResponse' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/ftclassifierlossfunction.js
var require_ftclassifierlossfunction = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/ftclassifierlossfunction.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FTClassifierLossFunction$ = exports.FTClassifierLossFunction$outboundSchema = exports.FTClassifierLossFunction$inboundSchema = exports.FTClassifierLossFunction = void 0;
    var z4 = __importStar(__require("zod"));
    exports.FTClassifierLossFunction = {
      SingleClass: "single_class",
      MultiClass: "multi_class"
    };
    exports.FTClassifierLossFunction$inboundSchema = z4.nativeEnum(exports.FTClassifierLossFunction);
    exports.FTClassifierLossFunction$outboundSchema = exports.FTClassifierLossFunction$inboundSchema;
    var FTClassifierLossFunction$;
    (function(FTClassifierLossFunction$2) {
      FTClassifierLossFunction$2.inboundSchema = exports.FTClassifierLossFunction$inboundSchema;
      FTClassifierLossFunction$2.outboundSchema = exports.FTClassifierLossFunction$outboundSchema;
    })(FTClassifierLossFunction$ || (exports.FTClassifierLossFunction$ = FTClassifierLossFunction$ = {}));
  }
});

// ../node_modules/@mistralai/mistralai/models/components/classifiertargetout.js
var require_classifiertargetout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/classifiertargetout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClassifierTargetOut$ = exports.ClassifierTargetOut$outboundSchema = exports.ClassifierTargetOut$inboundSchema = void 0;
    exports.classifierTargetOutToJSON = classifierTargetOutToJSON;
    exports.classifierTargetOutFromJSON = classifierTargetOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var ftclassifierlossfunction_js_1 = require_ftclassifierlossfunction();
    exports.ClassifierTargetOut$inboundSchema = z4.object({
      name: z4.string(),
      labels: z4.array(z4.string()),
      weight: z4.number(),
      loss_function: ftclassifierlossfunction_js_1.FTClassifierLossFunction$inboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "loss_function": "lossFunction"
      });
    });
    exports.ClassifierTargetOut$outboundSchema = z4.object({
      name: z4.string(),
      labels: z4.array(z4.string()),
      weight: z4.number(),
      lossFunction: ftclassifierlossfunction_js_1.FTClassifierLossFunction$outboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        lossFunction: "loss_function"
      });
    });
    var ClassifierTargetOut$;
    (function(ClassifierTargetOut$2) {
      ClassifierTargetOut$2.inboundSchema = exports.ClassifierTargetOut$inboundSchema;
      ClassifierTargetOut$2.outboundSchema = exports.ClassifierTargetOut$outboundSchema;
    })(ClassifierTargetOut$ || (exports.ClassifierTargetOut$ = ClassifierTargetOut$ = {}));
    function classifierTargetOutToJSON(classifierTargetOut) {
      return JSON.stringify(exports.ClassifierTargetOut$outboundSchema.parse(classifierTargetOut));
    }
    function classifierTargetOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ClassifierTargetOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ClassifierTargetOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/classifiertrainingparameters.js
var require_classifiertrainingparameters = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/classifiertrainingparameters.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClassifierTrainingParameters$ = exports.ClassifierTrainingParameters$outboundSchema = exports.ClassifierTrainingParameters$inboundSchema = void 0;
    exports.classifierTrainingParametersToJSON = classifierTrainingParametersToJSON;
    exports.classifierTrainingParametersFromJSON = classifierTrainingParametersFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.ClassifierTrainingParameters$inboundSchema = z4.object({
      training_steps: z4.nullable(z4.number().int()).optional(),
      learning_rate: z4.number().default(1e-4),
      weight_decay: z4.nullable(z4.number()).optional(),
      warmup_fraction: z4.nullable(z4.number()).optional(),
      epochs: z4.nullable(z4.number()).optional(),
      seq_len: z4.nullable(z4.number().int()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "training_steps": "trainingSteps",
        "learning_rate": "learningRate",
        "weight_decay": "weightDecay",
        "warmup_fraction": "warmupFraction",
        "seq_len": "seqLen"
      });
    });
    exports.ClassifierTrainingParameters$outboundSchema = z4.object({
      trainingSteps: z4.nullable(z4.number().int()).optional(),
      learningRate: z4.number().default(1e-4),
      weightDecay: z4.nullable(z4.number()).optional(),
      warmupFraction: z4.nullable(z4.number()).optional(),
      epochs: z4.nullable(z4.number()).optional(),
      seqLen: z4.nullable(z4.number().int()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        trainingSteps: "training_steps",
        learningRate: "learning_rate",
        weightDecay: "weight_decay",
        warmupFraction: "warmup_fraction",
        seqLen: "seq_len"
      });
    });
    var ClassifierTrainingParameters$;
    (function(ClassifierTrainingParameters$2) {
      ClassifierTrainingParameters$2.inboundSchema = exports.ClassifierTrainingParameters$inboundSchema;
      ClassifierTrainingParameters$2.outboundSchema = exports.ClassifierTrainingParameters$outboundSchema;
    })(ClassifierTrainingParameters$ || (exports.ClassifierTrainingParameters$ = ClassifierTrainingParameters$ = {}));
    function classifierTrainingParametersToJSON(classifierTrainingParameters) {
      return JSON.stringify(exports.ClassifierTrainingParameters$outboundSchema.parse(classifierTrainingParameters));
    }
    function classifierTrainingParametersFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ClassifierTrainingParameters$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ClassifierTrainingParameters' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/eventout.js
var require_eventout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/eventout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EventOut$ = exports.EventOut$outboundSchema = exports.EventOut$inboundSchema = void 0;
    exports.eventOutToJSON = eventOutToJSON;
    exports.eventOutFromJSON = eventOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.EventOut$inboundSchema = z4.object({
      name: z4.string(),
      data: z4.nullable(z4.record(z4.any())).optional(),
      created_at: z4.number().int()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "created_at": "createdAt"
      });
    });
    exports.EventOut$outboundSchema = z4.object({
      name: z4.string(),
      data: z4.nullable(z4.record(z4.any())).optional(),
      createdAt: z4.number().int()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        createdAt: "created_at"
      });
    });
    var EventOut$;
    (function(EventOut$2) {
      EventOut$2.inboundSchema = exports.EventOut$inboundSchema;
      EventOut$2.outboundSchema = exports.EventOut$outboundSchema;
    })(EventOut$ || (exports.EventOut$ = EventOut$ = {}));
    function eventOutToJSON(eventOut) {
      return JSON.stringify(exports.EventOut$outboundSchema.parse(eventOut));
    }
    function eventOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.EventOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'EventOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/jobmetadataout.js
var require_jobmetadataout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/jobmetadataout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JobMetadataOut$ = exports.JobMetadataOut$outboundSchema = exports.JobMetadataOut$inboundSchema = void 0;
    exports.jobMetadataOutToJSON = jobMetadataOutToJSON;
    exports.jobMetadataOutFromJSON = jobMetadataOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.JobMetadataOut$inboundSchema = z4.object({
      expected_duration_seconds: z4.nullable(z4.number().int()).optional(),
      cost: z4.nullable(z4.number()).optional(),
      cost_currency: z4.nullable(z4.string()).optional(),
      train_tokens_per_step: z4.nullable(z4.number().int()).optional(),
      train_tokens: z4.nullable(z4.number().int()).optional(),
      data_tokens: z4.nullable(z4.number().int()).optional(),
      estimated_start_time: z4.nullable(z4.number().int()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "expected_duration_seconds": "expectedDurationSeconds",
        "cost_currency": "costCurrency",
        "train_tokens_per_step": "trainTokensPerStep",
        "train_tokens": "trainTokens",
        "data_tokens": "dataTokens",
        "estimated_start_time": "estimatedStartTime"
      });
    });
    exports.JobMetadataOut$outboundSchema = z4.object({
      expectedDurationSeconds: z4.nullable(z4.number().int()).optional(),
      cost: z4.nullable(z4.number()).optional(),
      costCurrency: z4.nullable(z4.string()).optional(),
      trainTokensPerStep: z4.nullable(z4.number().int()).optional(),
      trainTokens: z4.nullable(z4.number().int()).optional(),
      dataTokens: z4.nullable(z4.number().int()).optional(),
      estimatedStartTime: z4.nullable(z4.number().int()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        expectedDurationSeconds: "expected_duration_seconds",
        costCurrency: "cost_currency",
        trainTokensPerStep: "train_tokens_per_step",
        trainTokens: "train_tokens",
        dataTokens: "data_tokens",
        estimatedStartTime: "estimated_start_time"
      });
    });
    var JobMetadataOut$;
    (function(JobMetadataOut$2) {
      JobMetadataOut$2.inboundSchema = exports.JobMetadataOut$inboundSchema;
      JobMetadataOut$2.outboundSchema = exports.JobMetadataOut$outboundSchema;
    })(JobMetadataOut$ || (exports.JobMetadataOut$ = JobMetadataOut$ = {}));
    function jobMetadataOutToJSON(jobMetadataOut) {
      return JSON.stringify(exports.JobMetadataOut$outboundSchema.parse(jobMetadataOut));
    }
    function jobMetadataOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.JobMetadataOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'JobMetadataOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/wandbintegrationout.js
var require_wandbintegrationout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/wandbintegrationout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WandbIntegrationOut$ = exports.WandbIntegrationOut$outboundSchema = exports.WandbIntegrationOut$inboundSchema = exports.WandbIntegrationOutType$ = exports.WandbIntegrationOutType$outboundSchema = exports.WandbIntegrationOutType$inboundSchema = exports.WandbIntegrationOutType = void 0;
    exports.wandbIntegrationOutToJSON = wandbIntegrationOutToJSON;
    exports.wandbIntegrationOutFromJSON = wandbIntegrationOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.WandbIntegrationOutType = {
      Wandb: "wandb"
    };
    exports.WandbIntegrationOutType$inboundSchema = z4.nativeEnum(exports.WandbIntegrationOutType);
    exports.WandbIntegrationOutType$outboundSchema = exports.WandbIntegrationOutType$inboundSchema;
    var WandbIntegrationOutType$;
    (function(WandbIntegrationOutType$2) {
      WandbIntegrationOutType$2.inboundSchema = exports.WandbIntegrationOutType$inboundSchema;
      WandbIntegrationOutType$2.outboundSchema = exports.WandbIntegrationOutType$outboundSchema;
    })(WandbIntegrationOutType$ || (exports.WandbIntegrationOutType$ = WandbIntegrationOutType$ = {}));
    exports.WandbIntegrationOut$inboundSchema = z4.object({
      type: exports.WandbIntegrationOutType$inboundSchema.default("wandb"),
      project: z4.string(),
      name: z4.nullable(z4.string()).optional(),
      run_name: z4.nullable(z4.string()).optional(),
      url: z4.nullable(z4.string()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "run_name": "runName"
      });
    });
    exports.WandbIntegrationOut$outboundSchema = z4.object({
      type: exports.WandbIntegrationOutType$outboundSchema.default("wandb"),
      project: z4.string(),
      name: z4.nullable(z4.string()).optional(),
      runName: z4.nullable(z4.string()).optional(),
      url: z4.nullable(z4.string()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        runName: "run_name"
      });
    });
    var WandbIntegrationOut$;
    (function(WandbIntegrationOut$2) {
      WandbIntegrationOut$2.inboundSchema = exports.WandbIntegrationOut$inboundSchema;
      WandbIntegrationOut$2.outboundSchema = exports.WandbIntegrationOut$outboundSchema;
    })(WandbIntegrationOut$ || (exports.WandbIntegrationOut$ = WandbIntegrationOut$ = {}));
    function wandbIntegrationOutToJSON(wandbIntegrationOut) {
      return JSON.stringify(exports.WandbIntegrationOut$outboundSchema.parse(wandbIntegrationOut));
    }
    function wandbIntegrationOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.WandbIntegrationOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WandbIntegrationOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/classifierdetailedjobout.js
var require_classifierdetailedjobout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/classifierdetailedjobout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClassifierDetailedJobOut$ = exports.ClassifierDetailedJobOut$outboundSchema = exports.ClassifierDetailedJobOut$inboundSchema = exports.ClassifierDetailedJobOutJobType$ = exports.ClassifierDetailedJobOutJobType$outboundSchema = exports.ClassifierDetailedJobOutJobType$inboundSchema = exports.ClassifierDetailedJobOutIntegrations$ = exports.ClassifierDetailedJobOutIntegrations$outboundSchema = exports.ClassifierDetailedJobOutIntegrations$inboundSchema = exports.ClassifierDetailedJobOutObject$ = exports.ClassifierDetailedJobOutObject$outboundSchema = exports.ClassifierDetailedJobOutObject$inboundSchema = exports.ClassifierDetailedJobOutStatus$ = exports.ClassifierDetailedJobOutStatus$outboundSchema = exports.ClassifierDetailedJobOutStatus$inboundSchema = exports.ClassifierDetailedJobOutJobType = exports.ClassifierDetailedJobOutObject = exports.ClassifierDetailedJobOutStatus = void 0;
    exports.classifierDetailedJobOutIntegrationsToJSON = classifierDetailedJobOutIntegrationsToJSON;
    exports.classifierDetailedJobOutIntegrationsFromJSON = classifierDetailedJobOutIntegrationsFromJSON;
    exports.classifierDetailedJobOutToJSON = classifierDetailedJobOutToJSON;
    exports.classifierDetailedJobOutFromJSON = classifierDetailedJobOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var checkpointout_js_1 = require_checkpointout();
    var classifiertargetout_js_1 = require_classifiertargetout();
    var classifiertrainingparameters_js_1 = require_classifiertrainingparameters();
    var eventout_js_1 = require_eventout();
    var jobmetadataout_js_1 = require_jobmetadataout();
    var wandbintegrationout_js_1 = require_wandbintegrationout();
    exports.ClassifierDetailedJobOutStatus = {
      Queued: "QUEUED",
      Started: "STARTED",
      Validating: "VALIDATING",
      Validated: "VALIDATED",
      Running: "RUNNING",
      FailedValidation: "FAILED_VALIDATION",
      Failed: "FAILED",
      Success: "SUCCESS",
      Cancelled: "CANCELLED",
      CancellationRequested: "CANCELLATION_REQUESTED"
    };
    exports.ClassifierDetailedJobOutObject = {
      Job: "job"
    };
    exports.ClassifierDetailedJobOutJobType = {
      Classifier: "classifier"
    };
    exports.ClassifierDetailedJobOutStatus$inboundSchema = z4.nativeEnum(exports.ClassifierDetailedJobOutStatus);
    exports.ClassifierDetailedJobOutStatus$outboundSchema = exports.ClassifierDetailedJobOutStatus$inboundSchema;
    var ClassifierDetailedJobOutStatus$;
    (function(ClassifierDetailedJobOutStatus$2) {
      ClassifierDetailedJobOutStatus$2.inboundSchema = exports.ClassifierDetailedJobOutStatus$inboundSchema;
      ClassifierDetailedJobOutStatus$2.outboundSchema = exports.ClassifierDetailedJobOutStatus$outboundSchema;
    })(ClassifierDetailedJobOutStatus$ || (exports.ClassifierDetailedJobOutStatus$ = ClassifierDetailedJobOutStatus$ = {}));
    exports.ClassifierDetailedJobOutObject$inboundSchema = z4.nativeEnum(exports.ClassifierDetailedJobOutObject);
    exports.ClassifierDetailedJobOutObject$outboundSchema = exports.ClassifierDetailedJobOutObject$inboundSchema;
    var ClassifierDetailedJobOutObject$;
    (function(ClassifierDetailedJobOutObject$2) {
      ClassifierDetailedJobOutObject$2.inboundSchema = exports.ClassifierDetailedJobOutObject$inboundSchema;
      ClassifierDetailedJobOutObject$2.outboundSchema = exports.ClassifierDetailedJobOutObject$outboundSchema;
    })(ClassifierDetailedJobOutObject$ || (exports.ClassifierDetailedJobOutObject$ = ClassifierDetailedJobOutObject$ = {}));
    exports.ClassifierDetailedJobOutIntegrations$inboundSchema = wandbintegrationout_js_1.WandbIntegrationOut$inboundSchema;
    exports.ClassifierDetailedJobOutIntegrations$outboundSchema = wandbintegrationout_js_1.WandbIntegrationOut$outboundSchema;
    var ClassifierDetailedJobOutIntegrations$;
    (function(ClassifierDetailedJobOutIntegrations$2) {
      ClassifierDetailedJobOutIntegrations$2.inboundSchema = exports.ClassifierDetailedJobOutIntegrations$inboundSchema;
      ClassifierDetailedJobOutIntegrations$2.outboundSchema = exports.ClassifierDetailedJobOutIntegrations$outboundSchema;
    })(ClassifierDetailedJobOutIntegrations$ || (exports.ClassifierDetailedJobOutIntegrations$ = ClassifierDetailedJobOutIntegrations$ = {}));
    function classifierDetailedJobOutIntegrationsToJSON(classifierDetailedJobOutIntegrations) {
      return JSON.stringify(exports.ClassifierDetailedJobOutIntegrations$outboundSchema.parse(classifierDetailedJobOutIntegrations));
    }
    function classifierDetailedJobOutIntegrationsFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ClassifierDetailedJobOutIntegrations$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ClassifierDetailedJobOutIntegrations' from JSON`);
    }
    exports.ClassifierDetailedJobOutJobType$inboundSchema = z4.nativeEnum(exports.ClassifierDetailedJobOutJobType);
    exports.ClassifierDetailedJobOutJobType$outboundSchema = exports.ClassifierDetailedJobOutJobType$inboundSchema;
    var ClassifierDetailedJobOutJobType$;
    (function(ClassifierDetailedJobOutJobType$2) {
      ClassifierDetailedJobOutJobType$2.inboundSchema = exports.ClassifierDetailedJobOutJobType$inboundSchema;
      ClassifierDetailedJobOutJobType$2.outboundSchema = exports.ClassifierDetailedJobOutJobType$outboundSchema;
    })(ClassifierDetailedJobOutJobType$ || (exports.ClassifierDetailedJobOutJobType$ = ClassifierDetailedJobOutJobType$ = {}));
    exports.ClassifierDetailedJobOut$inboundSchema = z4.object({
      id: z4.string(),
      auto_start: z4.boolean(),
      model: z4.string(),
      status: exports.ClassifierDetailedJobOutStatus$inboundSchema,
      created_at: z4.number().int(),
      modified_at: z4.number().int(),
      training_files: z4.array(z4.string()),
      validation_files: z4.nullable(z4.array(z4.string())).optional(),
      object: exports.ClassifierDetailedJobOutObject$inboundSchema.default("job"),
      fine_tuned_model: z4.nullable(z4.string()).optional(),
      suffix: z4.nullable(z4.string()).optional(),
      integrations: z4.nullable(z4.array(wandbintegrationout_js_1.WandbIntegrationOut$inboundSchema)).optional(),
      trained_tokens: z4.nullable(z4.number().int()).optional(),
      metadata: z4.nullable(jobmetadataout_js_1.JobMetadataOut$inboundSchema).optional(),
      job_type: exports.ClassifierDetailedJobOutJobType$inboundSchema.default("classifier"),
      hyperparameters: classifiertrainingparameters_js_1.ClassifierTrainingParameters$inboundSchema,
      events: z4.array(eventout_js_1.EventOut$inboundSchema).optional(),
      checkpoints: z4.array(checkpointout_js_1.CheckpointOut$inboundSchema).optional(),
      classifier_targets: z4.array(classifiertargetout_js_1.ClassifierTargetOut$inboundSchema)
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "auto_start": "autoStart",
        "created_at": "createdAt",
        "modified_at": "modifiedAt",
        "training_files": "trainingFiles",
        "validation_files": "validationFiles",
        "fine_tuned_model": "fineTunedModel",
        "trained_tokens": "trainedTokens",
        "job_type": "jobType",
        "classifier_targets": "classifierTargets"
      });
    });
    exports.ClassifierDetailedJobOut$outboundSchema = z4.object({
      id: z4.string(),
      autoStart: z4.boolean(),
      model: z4.string(),
      status: exports.ClassifierDetailedJobOutStatus$outboundSchema,
      createdAt: z4.number().int(),
      modifiedAt: z4.number().int(),
      trainingFiles: z4.array(z4.string()),
      validationFiles: z4.nullable(z4.array(z4.string())).optional(),
      object: exports.ClassifierDetailedJobOutObject$outboundSchema.default("job"),
      fineTunedModel: z4.nullable(z4.string()).optional(),
      suffix: z4.nullable(z4.string()).optional(),
      integrations: z4.nullable(z4.array(wandbintegrationout_js_1.WandbIntegrationOut$outboundSchema)).optional(),
      trainedTokens: z4.nullable(z4.number().int()).optional(),
      metadata: z4.nullable(jobmetadataout_js_1.JobMetadataOut$outboundSchema).optional(),
      jobType: exports.ClassifierDetailedJobOutJobType$outboundSchema.default("classifier"),
      hyperparameters: classifiertrainingparameters_js_1.ClassifierTrainingParameters$outboundSchema,
      events: z4.array(eventout_js_1.EventOut$outboundSchema).optional(),
      checkpoints: z4.array(checkpointout_js_1.CheckpointOut$outboundSchema).optional(),
      classifierTargets: z4.array(classifiertargetout_js_1.ClassifierTargetOut$outboundSchema)
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        autoStart: "auto_start",
        createdAt: "created_at",
        modifiedAt: "modified_at",
        trainingFiles: "training_files",
        validationFiles: "validation_files",
        fineTunedModel: "fine_tuned_model",
        trainedTokens: "trained_tokens",
        jobType: "job_type",
        classifierTargets: "classifier_targets"
      });
    });
    var ClassifierDetailedJobOut$;
    (function(ClassifierDetailedJobOut$2) {
      ClassifierDetailedJobOut$2.inboundSchema = exports.ClassifierDetailedJobOut$inboundSchema;
      ClassifierDetailedJobOut$2.outboundSchema = exports.ClassifierDetailedJobOut$outboundSchema;
    })(ClassifierDetailedJobOut$ || (exports.ClassifierDetailedJobOut$ = ClassifierDetailedJobOut$ = {}));
    function classifierDetailedJobOutToJSON(classifierDetailedJobOut) {
      return JSON.stringify(exports.ClassifierDetailedJobOut$outboundSchema.parse(classifierDetailedJobOut));
    }
    function classifierDetailedJobOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ClassifierDetailedJobOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ClassifierDetailedJobOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/ftmodelcapabilitiesout.js
var require_ftmodelcapabilitiesout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/ftmodelcapabilitiesout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FTModelCapabilitiesOut$ = exports.FTModelCapabilitiesOut$outboundSchema = exports.FTModelCapabilitiesOut$inboundSchema = void 0;
    exports.ftModelCapabilitiesOutToJSON = ftModelCapabilitiesOutToJSON;
    exports.ftModelCapabilitiesOutFromJSON = ftModelCapabilitiesOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.FTModelCapabilitiesOut$inboundSchema = z4.object({
      completion_chat: z4.boolean().default(true),
      completion_fim: z4.boolean().default(false),
      function_calling: z4.boolean().default(false),
      fine_tuning: z4.boolean().default(false),
      classification: z4.boolean().default(false)
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "completion_chat": "completionChat",
        "completion_fim": "completionFim",
        "function_calling": "functionCalling",
        "fine_tuning": "fineTuning"
      });
    });
    exports.FTModelCapabilitiesOut$outboundSchema = z4.object({
      completionChat: z4.boolean().default(true),
      completionFim: z4.boolean().default(false),
      functionCalling: z4.boolean().default(false),
      fineTuning: z4.boolean().default(false),
      classification: z4.boolean().default(false)
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        completionChat: "completion_chat",
        completionFim: "completion_fim",
        functionCalling: "function_calling",
        fineTuning: "fine_tuning"
      });
    });
    var FTModelCapabilitiesOut$;
    (function(FTModelCapabilitiesOut$2) {
      FTModelCapabilitiesOut$2.inboundSchema = exports.FTModelCapabilitiesOut$inboundSchema;
      FTModelCapabilitiesOut$2.outboundSchema = exports.FTModelCapabilitiesOut$outboundSchema;
    })(FTModelCapabilitiesOut$ || (exports.FTModelCapabilitiesOut$ = FTModelCapabilitiesOut$ = {}));
    function ftModelCapabilitiesOutToJSON(ftModelCapabilitiesOut) {
      return JSON.stringify(exports.FTModelCapabilitiesOut$outboundSchema.parse(ftModelCapabilitiesOut));
    }
    function ftModelCapabilitiesOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.FTModelCapabilitiesOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'FTModelCapabilitiesOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/classifierftmodelout.js
var require_classifierftmodelout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/classifierftmodelout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClassifierFTModelOut$ = exports.ClassifierFTModelOut$outboundSchema = exports.ClassifierFTModelOut$inboundSchema = exports.ClassifierFTModelOutModelType$ = exports.ClassifierFTModelOutModelType$outboundSchema = exports.ClassifierFTModelOutModelType$inboundSchema = exports.ClassifierFTModelOutObject$ = exports.ClassifierFTModelOutObject$outboundSchema = exports.ClassifierFTModelOutObject$inboundSchema = exports.ClassifierFTModelOutModelType = exports.ClassifierFTModelOutObject = void 0;
    exports.classifierFTModelOutToJSON = classifierFTModelOutToJSON;
    exports.classifierFTModelOutFromJSON = classifierFTModelOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var classifiertargetout_js_1 = require_classifiertargetout();
    var ftmodelcapabilitiesout_js_1 = require_ftmodelcapabilitiesout();
    exports.ClassifierFTModelOutObject = {
      Model: "model"
    };
    exports.ClassifierFTModelOutModelType = {
      Classifier: "classifier"
    };
    exports.ClassifierFTModelOutObject$inboundSchema = z4.nativeEnum(exports.ClassifierFTModelOutObject);
    exports.ClassifierFTModelOutObject$outboundSchema = exports.ClassifierFTModelOutObject$inboundSchema;
    var ClassifierFTModelOutObject$;
    (function(ClassifierFTModelOutObject$2) {
      ClassifierFTModelOutObject$2.inboundSchema = exports.ClassifierFTModelOutObject$inboundSchema;
      ClassifierFTModelOutObject$2.outboundSchema = exports.ClassifierFTModelOutObject$outboundSchema;
    })(ClassifierFTModelOutObject$ || (exports.ClassifierFTModelOutObject$ = ClassifierFTModelOutObject$ = {}));
    exports.ClassifierFTModelOutModelType$inboundSchema = z4.nativeEnum(exports.ClassifierFTModelOutModelType);
    exports.ClassifierFTModelOutModelType$outboundSchema = exports.ClassifierFTModelOutModelType$inboundSchema;
    var ClassifierFTModelOutModelType$;
    (function(ClassifierFTModelOutModelType$2) {
      ClassifierFTModelOutModelType$2.inboundSchema = exports.ClassifierFTModelOutModelType$inboundSchema;
      ClassifierFTModelOutModelType$2.outboundSchema = exports.ClassifierFTModelOutModelType$outboundSchema;
    })(ClassifierFTModelOutModelType$ || (exports.ClassifierFTModelOutModelType$ = ClassifierFTModelOutModelType$ = {}));
    exports.ClassifierFTModelOut$inboundSchema = z4.object({
      id: z4.string(),
      object: exports.ClassifierFTModelOutObject$inboundSchema.default("model"),
      created: z4.number().int(),
      owned_by: z4.string(),
      workspace_id: z4.string(),
      root: z4.string(),
      root_version: z4.string(),
      archived: z4.boolean(),
      name: z4.nullable(z4.string()).optional(),
      description: z4.nullable(z4.string()).optional(),
      capabilities: ftmodelcapabilitiesout_js_1.FTModelCapabilitiesOut$inboundSchema,
      max_context_length: z4.number().int().default(32768),
      aliases: z4.array(z4.string()).optional(),
      job: z4.string(),
      classifier_targets: z4.array(classifiertargetout_js_1.ClassifierTargetOut$inboundSchema),
      model_type: exports.ClassifierFTModelOutModelType$inboundSchema.default("classifier")
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "owned_by": "ownedBy",
        "workspace_id": "workspaceId",
        "root_version": "rootVersion",
        "max_context_length": "maxContextLength",
        "classifier_targets": "classifierTargets",
        "model_type": "modelType"
      });
    });
    exports.ClassifierFTModelOut$outboundSchema = z4.object({
      id: z4.string(),
      object: exports.ClassifierFTModelOutObject$outboundSchema.default("model"),
      created: z4.number().int(),
      ownedBy: z4.string(),
      workspaceId: z4.string(),
      root: z4.string(),
      rootVersion: z4.string(),
      archived: z4.boolean(),
      name: z4.nullable(z4.string()).optional(),
      description: z4.nullable(z4.string()).optional(),
      capabilities: ftmodelcapabilitiesout_js_1.FTModelCapabilitiesOut$outboundSchema,
      maxContextLength: z4.number().int().default(32768),
      aliases: z4.array(z4.string()).optional(),
      job: z4.string(),
      classifierTargets: z4.array(classifiertargetout_js_1.ClassifierTargetOut$outboundSchema),
      modelType: exports.ClassifierFTModelOutModelType$outboundSchema.default("classifier")
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        ownedBy: "owned_by",
        workspaceId: "workspace_id",
        rootVersion: "root_version",
        maxContextLength: "max_context_length",
        classifierTargets: "classifier_targets",
        modelType: "model_type"
      });
    });
    var ClassifierFTModelOut$;
    (function(ClassifierFTModelOut$2) {
      ClassifierFTModelOut$2.inboundSchema = exports.ClassifierFTModelOut$inboundSchema;
      ClassifierFTModelOut$2.outboundSchema = exports.ClassifierFTModelOut$outboundSchema;
    })(ClassifierFTModelOut$ || (exports.ClassifierFTModelOut$ = ClassifierFTModelOut$ = {}));
    function classifierFTModelOutToJSON(classifierFTModelOut) {
      return JSON.stringify(exports.ClassifierFTModelOut$outboundSchema.parse(classifierFTModelOut));
    }
    function classifierFTModelOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ClassifierFTModelOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ClassifierFTModelOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/classifierjobout.js
var require_classifierjobout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/classifierjobout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClassifierJobOut$ = exports.ClassifierJobOut$outboundSchema = exports.ClassifierJobOut$inboundSchema = exports.ClassifierJobOutJobType$ = exports.ClassifierJobOutJobType$outboundSchema = exports.ClassifierJobOutJobType$inboundSchema = exports.ClassifierJobOutIntegrations$ = exports.ClassifierJobOutIntegrations$outboundSchema = exports.ClassifierJobOutIntegrations$inboundSchema = exports.ClassifierJobOutObject$ = exports.ClassifierJobOutObject$outboundSchema = exports.ClassifierJobOutObject$inboundSchema = exports.ClassifierJobOutStatus$ = exports.ClassifierJobOutStatus$outboundSchema = exports.ClassifierJobOutStatus$inboundSchema = exports.ClassifierJobOutJobType = exports.ClassifierJobOutObject = exports.ClassifierJobOutStatus = void 0;
    exports.classifierJobOutIntegrationsToJSON = classifierJobOutIntegrationsToJSON;
    exports.classifierJobOutIntegrationsFromJSON = classifierJobOutIntegrationsFromJSON;
    exports.classifierJobOutToJSON = classifierJobOutToJSON;
    exports.classifierJobOutFromJSON = classifierJobOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var classifiertrainingparameters_js_1 = require_classifiertrainingparameters();
    var jobmetadataout_js_1 = require_jobmetadataout();
    var wandbintegrationout_js_1 = require_wandbintegrationout();
    exports.ClassifierJobOutStatus = {
      Queued: "QUEUED",
      Started: "STARTED",
      Validating: "VALIDATING",
      Validated: "VALIDATED",
      Running: "RUNNING",
      FailedValidation: "FAILED_VALIDATION",
      Failed: "FAILED",
      Success: "SUCCESS",
      Cancelled: "CANCELLED",
      CancellationRequested: "CANCELLATION_REQUESTED"
    };
    exports.ClassifierJobOutObject = {
      Job: "job"
    };
    exports.ClassifierJobOutJobType = {
      Classifier: "classifier"
    };
    exports.ClassifierJobOutStatus$inboundSchema = z4.nativeEnum(exports.ClassifierJobOutStatus);
    exports.ClassifierJobOutStatus$outboundSchema = exports.ClassifierJobOutStatus$inboundSchema;
    var ClassifierJobOutStatus$;
    (function(ClassifierJobOutStatus$2) {
      ClassifierJobOutStatus$2.inboundSchema = exports.ClassifierJobOutStatus$inboundSchema;
      ClassifierJobOutStatus$2.outboundSchema = exports.ClassifierJobOutStatus$outboundSchema;
    })(ClassifierJobOutStatus$ || (exports.ClassifierJobOutStatus$ = ClassifierJobOutStatus$ = {}));
    exports.ClassifierJobOutObject$inboundSchema = z4.nativeEnum(exports.ClassifierJobOutObject);
    exports.ClassifierJobOutObject$outboundSchema = exports.ClassifierJobOutObject$inboundSchema;
    var ClassifierJobOutObject$;
    (function(ClassifierJobOutObject$2) {
      ClassifierJobOutObject$2.inboundSchema = exports.ClassifierJobOutObject$inboundSchema;
      ClassifierJobOutObject$2.outboundSchema = exports.ClassifierJobOutObject$outboundSchema;
    })(ClassifierJobOutObject$ || (exports.ClassifierJobOutObject$ = ClassifierJobOutObject$ = {}));
    exports.ClassifierJobOutIntegrations$inboundSchema = wandbintegrationout_js_1.WandbIntegrationOut$inboundSchema;
    exports.ClassifierJobOutIntegrations$outboundSchema = wandbintegrationout_js_1.WandbIntegrationOut$outboundSchema;
    var ClassifierJobOutIntegrations$;
    (function(ClassifierJobOutIntegrations$2) {
      ClassifierJobOutIntegrations$2.inboundSchema = exports.ClassifierJobOutIntegrations$inboundSchema;
      ClassifierJobOutIntegrations$2.outboundSchema = exports.ClassifierJobOutIntegrations$outboundSchema;
    })(ClassifierJobOutIntegrations$ || (exports.ClassifierJobOutIntegrations$ = ClassifierJobOutIntegrations$ = {}));
    function classifierJobOutIntegrationsToJSON(classifierJobOutIntegrations) {
      return JSON.stringify(exports.ClassifierJobOutIntegrations$outboundSchema.parse(classifierJobOutIntegrations));
    }
    function classifierJobOutIntegrationsFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ClassifierJobOutIntegrations$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ClassifierJobOutIntegrations' from JSON`);
    }
    exports.ClassifierJobOutJobType$inboundSchema = z4.nativeEnum(exports.ClassifierJobOutJobType);
    exports.ClassifierJobOutJobType$outboundSchema = exports.ClassifierJobOutJobType$inboundSchema;
    var ClassifierJobOutJobType$;
    (function(ClassifierJobOutJobType$2) {
      ClassifierJobOutJobType$2.inboundSchema = exports.ClassifierJobOutJobType$inboundSchema;
      ClassifierJobOutJobType$2.outboundSchema = exports.ClassifierJobOutJobType$outboundSchema;
    })(ClassifierJobOutJobType$ || (exports.ClassifierJobOutJobType$ = ClassifierJobOutJobType$ = {}));
    exports.ClassifierJobOut$inboundSchema = z4.object({
      id: z4.string(),
      auto_start: z4.boolean(),
      model: z4.string(),
      status: exports.ClassifierJobOutStatus$inboundSchema,
      created_at: z4.number().int(),
      modified_at: z4.number().int(),
      training_files: z4.array(z4.string()),
      validation_files: z4.nullable(z4.array(z4.string())).optional(),
      object: exports.ClassifierJobOutObject$inboundSchema.default("job"),
      fine_tuned_model: z4.nullable(z4.string()).optional(),
      suffix: z4.nullable(z4.string()).optional(),
      integrations: z4.nullable(z4.array(wandbintegrationout_js_1.WandbIntegrationOut$inboundSchema)).optional(),
      trained_tokens: z4.nullable(z4.number().int()).optional(),
      metadata: z4.nullable(jobmetadataout_js_1.JobMetadataOut$inboundSchema).optional(),
      job_type: exports.ClassifierJobOutJobType$inboundSchema.default("classifier"),
      hyperparameters: classifiertrainingparameters_js_1.ClassifierTrainingParameters$inboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "auto_start": "autoStart",
        "created_at": "createdAt",
        "modified_at": "modifiedAt",
        "training_files": "trainingFiles",
        "validation_files": "validationFiles",
        "fine_tuned_model": "fineTunedModel",
        "trained_tokens": "trainedTokens",
        "job_type": "jobType"
      });
    });
    exports.ClassifierJobOut$outboundSchema = z4.object({
      id: z4.string(),
      autoStart: z4.boolean(),
      model: z4.string(),
      status: exports.ClassifierJobOutStatus$outboundSchema,
      createdAt: z4.number().int(),
      modifiedAt: z4.number().int(),
      trainingFiles: z4.array(z4.string()),
      validationFiles: z4.nullable(z4.array(z4.string())).optional(),
      object: exports.ClassifierJobOutObject$outboundSchema.default("job"),
      fineTunedModel: z4.nullable(z4.string()).optional(),
      suffix: z4.nullable(z4.string()).optional(),
      integrations: z4.nullable(z4.array(wandbintegrationout_js_1.WandbIntegrationOut$outboundSchema)).optional(),
      trainedTokens: z4.nullable(z4.number().int()).optional(),
      metadata: z4.nullable(jobmetadataout_js_1.JobMetadataOut$outboundSchema).optional(),
      jobType: exports.ClassifierJobOutJobType$outboundSchema.default("classifier"),
      hyperparameters: classifiertrainingparameters_js_1.ClassifierTrainingParameters$outboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        autoStart: "auto_start",
        createdAt: "created_at",
        modifiedAt: "modified_at",
        trainingFiles: "training_files",
        validationFiles: "validation_files",
        fineTunedModel: "fine_tuned_model",
        trainedTokens: "trained_tokens",
        jobType: "job_type"
      });
    });
    var ClassifierJobOut$;
    (function(ClassifierJobOut$2) {
      ClassifierJobOut$2.inboundSchema = exports.ClassifierJobOut$inboundSchema;
      ClassifierJobOut$2.outboundSchema = exports.ClassifierJobOut$outboundSchema;
    })(ClassifierJobOut$ || (exports.ClassifierJobOut$ = ClassifierJobOut$ = {}));
    function classifierJobOutToJSON(classifierJobOut) {
      return JSON.stringify(exports.ClassifierJobOut$outboundSchema.parse(classifierJobOut));
    }
    function classifierJobOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ClassifierJobOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ClassifierJobOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/classifiertargetin.js
var require_classifiertargetin = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/classifiertargetin.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClassifierTargetIn$ = exports.ClassifierTargetIn$outboundSchema = exports.ClassifierTargetIn$inboundSchema = void 0;
    exports.classifierTargetInToJSON = classifierTargetInToJSON;
    exports.classifierTargetInFromJSON = classifierTargetInFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var ftclassifierlossfunction_js_1 = require_ftclassifierlossfunction();
    exports.ClassifierTargetIn$inboundSchema = z4.object({
      name: z4.string(),
      labels: z4.array(z4.string()),
      weight: z4.number().default(1),
      loss_function: z4.nullable(ftclassifierlossfunction_js_1.FTClassifierLossFunction$inboundSchema).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "loss_function": "lossFunction"
      });
    });
    exports.ClassifierTargetIn$outboundSchema = z4.object({
      name: z4.string(),
      labels: z4.array(z4.string()),
      weight: z4.number().default(1),
      lossFunction: z4.nullable(ftclassifierlossfunction_js_1.FTClassifierLossFunction$outboundSchema).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        lossFunction: "loss_function"
      });
    });
    var ClassifierTargetIn$;
    (function(ClassifierTargetIn$2) {
      ClassifierTargetIn$2.inboundSchema = exports.ClassifierTargetIn$inboundSchema;
      ClassifierTargetIn$2.outboundSchema = exports.ClassifierTargetIn$outboundSchema;
    })(ClassifierTargetIn$ || (exports.ClassifierTargetIn$ = ClassifierTargetIn$ = {}));
    function classifierTargetInToJSON(classifierTargetIn) {
      return JSON.stringify(exports.ClassifierTargetIn$outboundSchema.parse(classifierTargetIn));
    }
    function classifierTargetInFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ClassifierTargetIn$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ClassifierTargetIn' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/classifiertrainingparametersin.js
var require_classifiertrainingparametersin = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/classifiertrainingparametersin.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClassifierTrainingParametersIn$ = exports.ClassifierTrainingParametersIn$outboundSchema = exports.ClassifierTrainingParametersIn$inboundSchema = void 0;
    exports.classifierTrainingParametersInToJSON = classifierTrainingParametersInToJSON;
    exports.classifierTrainingParametersInFromJSON = classifierTrainingParametersInFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.ClassifierTrainingParametersIn$inboundSchema = z4.object({
      training_steps: z4.nullable(z4.number().int()).optional(),
      learning_rate: z4.number().default(1e-4),
      weight_decay: z4.nullable(z4.number()).optional(),
      warmup_fraction: z4.nullable(z4.number()).optional(),
      epochs: z4.nullable(z4.number()).optional(),
      seq_len: z4.nullable(z4.number().int()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "training_steps": "trainingSteps",
        "learning_rate": "learningRate",
        "weight_decay": "weightDecay",
        "warmup_fraction": "warmupFraction",
        "seq_len": "seqLen"
      });
    });
    exports.ClassifierTrainingParametersIn$outboundSchema = z4.object({
      trainingSteps: z4.nullable(z4.number().int()).optional(),
      learningRate: z4.number().default(1e-4),
      weightDecay: z4.nullable(z4.number()).optional(),
      warmupFraction: z4.nullable(z4.number()).optional(),
      epochs: z4.nullable(z4.number()).optional(),
      seqLen: z4.nullable(z4.number().int()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        trainingSteps: "training_steps",
        learningRate: "learning_rate",
        weightDecay: "weight_decay",
        warmupFraction: "warmup_fraction",
        seqLen: "seq_len"
      });
    });
    var ClassifierTrainingParametersIn$;
    (function(ClassifierTrainingParametersIn$2) {
      ClassifierTrainingParametersIn$2.inboundSchema = exports.ClassifierTrainingParametersIn$inboundSchema;
      ClassifierTrainingParametersIn$2.outboundSchema = exports.ClassifierTrainingParametersIn$outboundSchema;
    })(ClassifierTrainingParametersIn$ || (exports.ClassifierTrainingParametersIn$ = ClassifierTrainingParametersIn$ = {}));
    function classifierTrainingParametersInToJSON(classifierTrainingParametersIn) {
      return JSON.stringify(exports.ClassifierTrainingParametersIn$outboundSchema.parse(classifierTrainingParametersIn));
    }
    function classifierTrainingParametersInFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ClassifierTrainingParametersIn$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ClassifierTrainingParametersIn' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/deltamessage.js
var require_deltamessage = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/deltamessage.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeltaMessage$ = exports.DeltaMessage$outboundSchema = exports.DeltaMessage$inboundSchema = exports.Content$ = exports.Content$outboundSchema = exports.Content$inboundSchema = void 0;
    exports.contentToJSON = contentToJSON;
    exports.contentFromJSON = contentFromJSON;
    exports.deltaMessageToJSON = deltaMessageToJSON;
    exports.deltaMessageFromJSON = deltaMessageFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var contentchunk_js_1 = require_contentchunk();
    var toolcall_js_1 = require_toolcall();
    exports.Content$inboundSchema = z4.union([z4.string(), z4.array(contentchunk_js_1.ContentChunk$inboundSchema)]);
    exports.Content$outboundSchema = z4.union([z4.string(), z4.array(contentchunk_js_1.ContentChunk$outboundSchema)]);
    var Content$;
    (function(Content$2) {
      Content$2.inboundSchema = exports.Content$inboundSchema;
      Content$2.outboundSchema = exports.Content$outboundSchema;
    })(Content$ || (exports.Content$ = Content$ = {}));
    function contentToJSON(content) {
      return JSON.stringify(exports.Content$outboundSchema.parse(content));
    }
    function contentFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.Content$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'Content' from JSON`);
    }
    exports.DeltaMessage$inboundSchema = z4.object({
      role: z4.nullable(z4.string()).optional(),
      content: z4.nullable(z4.union([z4.string(), z4.array(contentchunk_js_1.ContentChunk$inboundSchema)])).optional(),
      tool_calls: z4.nullable(z4.array(toolcall_js_1.ToolCall$inboundSchema)).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "tool_calls": "toolCalls"
      });
    });
    exports.DeltaMessage$outboundSchema = z4.object({
      role: z4.nullable(z4.string()).optional(),
      content: z4.nullable(z4.union([z4.string(), z4.array(contentchunk_js_1.ContentChunk$outboundSchema)])).optional(),
      toolCalls: z4.nullable(z4.array(toolcall_js_1.ToolCall$outboundSchema)).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        toolCalls: "tool_calls"
      });
    });
    var DeltaMessage$;
    (function(DeltaMessage$2) {
      DeltaMessage$2.inboundSchema = exports.DeltaMessage$inboundSchema;
      DeltaMessage$2.outboundSchema = exports.DeltaMessage$outboundSchema;
    })(DeltaMessage$ || (exports.DeltaMessage$ = DeltaMessage$ = {}));
    function deltaMessageToJSON(deltaMessage) {
      return JSON.stringify(exports.DeltaMessage$outboundSchema.parse(deltaMessage));
    }
    function deltaMessageFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.DeltaMessage$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'DeltaMessage' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/completionresponsestreamchoice.js
var require_completionresponsestreamchoice = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/completionresponsestreamchoice.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompletionResponseStreamChoice$ = exports.CompletionResponseStreamChoice$outboundSchema = exports.CompletionResponseStreamChoice$inboundSchema = exports.CompletionResponseStreamChoiceFinishReason$ = exports.CompletionResponseStreamChoiceFinishReason$outboundSchema = exports.CompletionResponseStreamChoiceFinishReason$inboundSchema = exports.CompletionResponseStreamChoiceFinishReason = void 0;
    exports.completionResponseStreamChoiceToJSON = completionResponseStreamChoiceToJSON;
    exports.completionResponseStreamChoiceFromJSON = completionResponseStreamChoiceFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var enums_js_1 = require_enums();
    var deltamessage_js_1 = require_deltamessage();
    exports.CompletionResponseStreamChoiceFinishReason = {
      Stop: "stop",
      Length: "length",
      Error: "error",
      ToolCalls: "tool_calls"
    };
    exports.CompletionResponseStreamChoiceFinishReason$inboundSchema = z4.union([
      z4.nativeEnum(exports.CompletionResponseStreamChoiceFinishReason),
      z4.string().transform(enums_js_1.catchUnrecognizedEnum)
    ]);
    exports.CompletionResponseStreamChoiceFinishReason$outboundSchema = z4.union([
      z4.nativeEnum(exports.CompletionResponseStreamChoiceFinishReason),
      z4.string().and(z4.custom())
    ]);
    var CompletionResponseStreamChoiceFinishReason$;
    (function(CompletionResponseStreamChoiceFinishReason$2) {
      CompletionResponseStreamChoiceFinishReason$2.inboundSchema = exports.CompletionResponseStreamChoiceFinishReason$inboundSchema;
      CompletionResponseStreamChoiceFinishReason$2.outboundSchema = exports.CompletionResponseStreamChoiceFinishReason$outboundSchema;
    })(CompletionResponseStreamChoiceFinishReason$ || (exports.CompletionResponseStreamChoiceFinishReason$ = CompletionResponseStreamChoiceFinishReason$ = {}));
    exports.CompletionResponseStreamChoice$inboundSchema = z4.object({
      index: z4.number().int(),
      delta: deltamessage_js_1.DeltaMessage$inboundSchema,
      finish_reason: z4.nullable(exports.CompletionResponseStreamChoiceFinishReason$inboundSchema)
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "finish_reason": "finishReason"
      });
    });
    exports.CompletionResponseStreamChoice$outboundSchema = z4.object({
      index: z4.number().int(),
      delta: deltamessage_js_1.DeltaMessage$outboundSchema,
      finishReason: z4.nullable(exports.CompletionResponseStreamChoiceFinishReason$outboundSchema)
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        finishReason: "finish_reason"
      });
    });
    var CompletionResponseStreamChoice$;
    (function(CompletionResponseStreamChoice$2) {
      CompletionResponseStreamChoice$2.inboundSchema = exports.CompletionResponseStreamChoice$inboundSchema;
      CompletionResponseStreamChoice$2.outboundSchema = exports.CompletionResponseStreamChoice$outboundSchema;
    })(CompletionResponseStreamChoice$ || (exports.CompletionResponseStreamChoice$ = CompletionResponseStreamChoice$ = {}));
    function completionResponseStreamChoiceToJSON(completionResponseStreamChoice) {
      return JSON.stringify(exports.CompletionResponseStreamChoice$outboundSchema.parse(completionResponseStreamChoice));
    }
    function completionResponseStreamChoiceFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.CompletionResponseStreamChoice$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'CompletionResponseStreamChoice' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/completionchunk.js
var require_completionchunk = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/completionchunk.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompletionChunk$ = exports.CompletionChunk$outboundSchema = exports.CompletionChunk$inboundSchema = void 0;
    exports.completionChunkToJSON = completionChunkToJSON;
    exports.completionChunkFromJSON = completionChunkFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var completionresponsestreamchoice_js_1 = require_completionresponsestreamchoice();
    var usageinfo_js_1 = require_usageinfo();
    exports.CompletionChunk$inboundSchema = z4.object({
      id: z4.string(),
      object: z4.string().optional(),
      created: z4.number().int().optional(),
      model: z4.string(),
      usage: usageinfo_js_1.UsageInfo$inboundSchema.optional(),
      choices: z4.array(completionresponsestreamchoice_js_1.CompletionResponseStreamChoice$inboundSchema)
    });
    exports.CompletionChunk$outboundSchema = z4.object({
      id: z4.string(),
      object: z4.string().optional(),
      created: z4.number().int().optional(),
      model: z4.string(),
      usage: usageinfo_js_1.UsageInfo$outboundSchema.optional(),
      choices: z4.array(completionresponsestreamchoice_js_1.CompletionResponseStreamChoice$outboundSchema)
    });
    var CompletionChunk$;
    (function(CompletionChunk$2) {
      CompletionChunk$2.inboundSchema = exports.CompletionChunk$inboundSchema;
      CompletionChunk$2.outboundSchema = exports.CompletionChunk$outboundSchema;
    })(CompletionChunk$ || (exports.CompletionChunk$ = CompletionChunk$ = {}));
    function completionChunkToJSON(completionChunk) {
      return JSON.stringify(exports.CompletionChunk$outboundSchema.parse(completionChunk));
    }
    function completionChunkFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.CompletionChunk$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'CompletionChunk' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/completiontrainingparameters.js
var require_completiontrainingparameters = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/completiontrainingparameters.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompletionTrainingParameters$ = exports.CompletionTrainingParameters$outboundSchema = exports.CompletionTrainingParameters$inboundSchema = void 0;
    exports.completionTrainingParametersToJSON = completionTrainingParametersToJSON;
    exports.completionTrainingParametersFromJSON = completionTrainingParametersFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.CompletionTrainingParameters$inboundSchema = z4.object({
      training_steps: z4.nullable(z4.number().int()).optional(),
      learning_rate: z4.number().default(1e-4),
      weight_decay: z4.nullable(z4.number()).optional(),
      warmup_fraction: z4.nullable(z4.number()).optional(),
      epochs: z4.nullable(z4.number()).optional(),
      seq_len: z4.nullable(z4.number().int()).optional(),
      fim_ratio: z4.nullable(z4.number()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "training_steps": "trainingSteps",
        "learning_rate": "learningRate",
        "weight_decay": "weightDecay",
        "warmup_fraction": "warmupFraction",
        "seq_len": "seqLen",
        "fim_ratio": "fimRatio"
      });
    });
    exports.CompletionTrainingParameters$outboundSchema = z4.object({
      trainingSteps: z4.nullable(z4.number().int()).optional(),
      learningRate: z4.number().default(1e-4),
      weightDecay: z4.nullable(z4.number()).optional(),
      warmupFraction: z4.nullable(z4.number()).optional(),
      epochs: z4.nullable(z4.number()).optional(),
      seqLen: z4.nullable(z4.number().int()).optional(),
      fimRatio: z4.nullable(z4.number()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        trainingSteps: "training_steps",
        learningRate: "learning_rate",
        weightDecay: "weight_decay",
        warmupFraction: "warmup_fraction",
        seqLen: "seq_len",
        fimRatio: "fim_ratio"
      });
    });
    var CompletionTrainingParameters$;
    (function(CompletionTrainingParameters$2) {
      CompletionTrainingParameters$2.inboundSchema = exports.CompletionTrainingParameters$inboundSchema;
      CompletionTrainingParameters$2.outboundSchema = exports.CompletionTrainingParameters$outboundSchema;
    })(CompletionTrainingParameters$ || (exports.CompletionTrainingParameters$ = CompletionTrainingParameters$ = {}));
    function completionTrainingParametersToJSON(completionTrainingParameters) {
      return JSON.stringify(exports.CompletionTrainingParameters$outboundSchema.parse(completionTrainingParameters));
    }
    function completionTrainingParametersFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.CompletionTrainingParameters$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'CompletionTrainingParameters' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/githubrepositoryout.js
var require_githubrepositoryout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/githubrepositoryout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GithubRepositoryOut$ = exports.GithubRepositoryOut$outboundSchema = exports.GithubRepositoryOut$inboundSchema = exports.GithubRepositoryOutType$ = exports.GithubRepositoryOutType$outboundSchema = exports.GithubRepositoryOutType$inboundSchema = exports.GithubRepositoryOutType = void 0;
    exports.githubRepositoryOutToJSON = githubRepositoryOutToJSON;
    exports.githubRepositoryOutFromJSON = githubRepositoryOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.GithubRepositoryOutType = {
      Github: "github"
    };
    exports.GithubRepositoryOutType$inboundSchema = z4.nativeEnum(exports.GithubRepositoryOutType);
    exports.GithubRepositoryOutType$outboundSchema = exports.GithubRepositoryOutType$inboundSchema;
    var GithubRepositoryOutType$;
    (function(GithubRepositoryOutType$2) {
      GithubRepositoryOutType$2.inboundSchema = exports.GithubRepositoryOutType$inboundSchema;
      GithubRepositoryOutType$2.outboundSchema = exports.GithubRepositoryOutType$outboundSchema;
    })(GithubRepositoryOutType$ || (exports.GithubRepositoryOutType$ = GithubRepositoryOutType$ = {}));
    exports.GithubRepositoryOut$inboundSchema = z4.object({
      type: exports.GithubRepositoryOutType$inboundSchema.default("github"),
      name: z4.string(),
      owner: z4.string(),
      ref: z4.nullable(z4.string()).optional(),
      weight: z4.number().default(1),
      commit_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "commit_id": "commitId"
      });
    });
    exports.GithubRepositoryOut$outboundSchema = z4.object({
      type: exports.GithubRepositoryOutType$outboundSchema.default("github"),
      name: z4.string(),
      owner: z4.string(),
      ref: z4.nullable(z4.string()).optional(),
      weight: z4.number().default(1),
      commitId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        commitId: "commit_id"
      });
    });
    var GithubRepositoryOut$;
    (function(GithubRepositoryOut$2) {
      GithubRepositoryOut$2.inboundSchema = exports.GithubRepositoryOut$inboundSchema;
      GithubRepositoryOut$2.outboundSchema = exports.GithubRepositoryOut$outboundSchema;
    })(GithubRepositoryOut$ || (exports.GithubRepositoryOut$ = GithubRepositoryOut$ = {}));
    function githubRepositoryOutToJSON(githubRepositoryOut) {
      return JSON.stringify(exports.GithubRepositoryOut$outboundSchema.parse(githubRepositoryOut));
    }
    function githubRepositoryOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.GithubRepositoryOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'GithubRepositoryOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/completiondetailedjobout.js
var require_completiondetailedjobout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/completiondetailedjobout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompletionDetailedJobOut$ = exports.CompletionDetailedJobOut$outboundSchema = exports.CompletionDetailedJobOut$inboundSchema = exports.CompletionDetailedJobOutRepositories$ = exports.CompletionDetailedJobOutRepositories$outboundSchema = exports.CompletionDetailedJobOutRepositories$inboundSchema = exports.CompletionDetailedJobOutJobType$ = exports.CompletionDetailedJobOutJobType$outboundSchema = exports.CompletionDetailedJobOutJobType$inboundSchema = exports.CompletionDetailedJobOutIntegrations$ = exports.CompletionDetailedJobOutIntegrations$outboundSchema = exports.CompletionDetailedJobOutIntegrations$inboundSchema = exports.CompletionDetailedJobOutObject$ = exports.CompletionDetailedJobOutObject$outboundSchema = exports.CompletionDetailedJobOutObject$inboundSchema = exports.CompletionDetailedJobOutStatus$ = exports.CompletionDetailedJobOutStatus$outboundSchema = exports.CompletionDetailedJobOutStatus$inboundSchema = exports.CompletionDetailedJobOutJobType = exports.CompletionDetailedJobOutObject = exports.CompletionDetailedJobOutStatus = void 0;
    exports.completionDetailedJobOutIntegrationsToJSON = completionDetailedJobOutIntegrationsToJSON;
    exports.completionDetailedJobOutIntegrationsFromJSON = completionDetailedJobOutIntegrationsFromJSON;
    exports.completionDetailedJobOutRepositoriesToJSON = completionDetailedJobOutRepositoriesToJSON;
    exports.completionDetailedJobOutRepositoriesFromJSON = completionDetailedJobOutRepositoriesFromJSON;
    exports.completionDetailedJobOutToJSON = completionDetailedJobOutToJSON;
    exports.completionDetailedJobOutFromJSON = completionDetailedJobOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var checkpointout_js_1 = require_checkpointout();
    var completiontrainingparameters_js_1 = require_completiontrainingparameters();
    var eventout_js_1 = require_eventout();
    var githubrepositoryout_js_1 = require_githubrepositoryout();
    var jobmetadataout_js_1 = require_jobmetadataout();
    var wandbintegrationout_js_1 = require_wandbintegrationout();
    exports.CompletionDetailedJobOutStatus = {
      Queued: "QUEUED",
      Started: "STARTED",
      Validating: "VALIDATING",
      Validated: "VALIDATED",
      Running: "RUNNING",
      FailedValidation: "FAILED_VALIDATION",
      Failed: "FAILED",
      Success: "SUCCESS",
      Cancelled: "CANCELLED",
      CancellationRequested: "CANCELLATION_REQUESTED"
    };
    exports.CompletionDetailedJobOutObject = {
      Job: "job"
    };
    exports.CompletionDetailedJobOutJobType = {
      Completion: "completion"
    };
    exports.CompletionDetailedJobOutStatus$inboundSchema = z4.nativeEnum(exports.CompletionDetailedJobOutStatus);
    exports.CompletionDetailedJobOutStatus$outboundSchema = exports.CompletionDetailedJobOutStatus$inboundSchema;
    var CompletionDetailedJobOutStatus$;
    (function(CompletionDetailedJobOutStatus$2) {
      CompletionDetailedJobOutStatus$2.inboundSchema = exports.CompletionDetailedJobOutStatus$inboundSchema;
      CompletionDetailedJobOutStatus$2.outboundSchema = exports.CompletionDetailedJobOutStatus$outboundSchema;
    })(CompletionDetailedJobOutStatus$ || (exports.CompletionDetailedJobOutStatus$ = CompletionDetailedJobOutStatus$ = {}));
    exports.CompletionDetailedJobOutObject$inboundSchema = z4.nativeEnum(exports.CompletionDetailedJobOutObject);
    exports.CompletionDetailedJobOutObject$outboundSchema = exports.CompletionDetailedJobOutObject$inboundSchema;
    var CompletionDetailedJobOutObject$;
    (function(CompletionDetailedJobOutObject$2) {
      CompletionDetailedJobOutObject$2.inboundSchema = exports.CompletionDetailedJobOutObject$inboundSchema;
      CompletionDetailedJobOutObject$2.outboundSchema = exports.CompletionDetailedJobOutObject$outboundSchema;
    })(CompletionDetailedJobOutObject$ || (exports.CompletionDetailedJobOutObject$ = CompletionDetailedJobOutObject$ = {}));
    exports.CompletionDetailedJobOutIntegrations$inboundSchema = wandbintegrationout_js_1.WandbIntegrationOut$inboundSchema;
    exports.CompletionDetailedJobOutIntegrations$outboundSchema = wandbintegrationout_js_1.WandbIntegrationOut$outboundSchema;
    var CompletionDetailedJobOutIntegrations$;
    (function(CompletionDetailedJobOutIntegrations$2) {
      CompletionDetailedJobOutIntegrations$2.inboundSchema = exports.CompletionDetailedJobOutIntegrations$inboundSchema;
      CompletionDetailedJobOutIntegrations$2.outboundSchema = exports.CompletionDetailedJobOutIntegrations$outboundSchema;
    })(CompletionDetailedJobOutIntegrations$ || (exports.CompletionDetailedJobOutIntegrations$ = CompletionDetailedJobOutIntegrations$ = {}));
    function completionDetailedJobOutIntegrationsToJSON(completionDetailedJobOutIntegrations) {
      return JSON.stringify(exports.CompletionDetailedJobOutIntegrations$outboundSchema.parse(completionDetailedJobOutIntegrations));
    }
    function completionDetailedJobOutIntegrationsFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.CompletionDetailedJobOutIntegrations$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'CompletionDetailedJobOutIntegrations' from JSON`);
    }
    exports.CompletionDetailedJobOutJobType$inboundSchema = z4.nativeEnum(exports.CompletionDetailedJobOutJobType);
    exports.CompletionDetailedJobOutJobType$outboundSchema = exports.CompletionDetailedJobOutJobType$inboundSchema;
    var CompletionDetailedJobOutJobType$;
    (function(CompletionDetailedJobOutJobType$2) {
      CompletionDetailedJobOutJobType$2.inboundSchema = exports.CompletionDetailedJobOutJobType$inboundSchema;
      CompletionDetailedJobOutJobType$2.outboundSchema = exports.CompletionDetailedJobOutJobType$outboundSchema;
    })(CompletionDetailedJobOutJobType$ || (exports.CompletionDetailedJobOutJobType$ = CompletionDetailedJobOutJobType$ = {}));
    exports.CompletionDetailedJobOutRepositories$inboundSchema = githubrepositoryout_js_1.GithubRepositoryOut$inboundSchema;
    exports.CompletionDetailedJobOutRepositories$outboundSchema = githubrepositoryout_js_1.GithubRepositoryOut$outboundSchema;
    var CompletionDetailedJobOutRepositories$;
    (function(CompletionDetailedJobOutRepositories$2) {
      CompletionDetailedJobOutRepositories$2.inboundSchema = exports.CompletionDetailedJobOutRepositories$inboundSchema;
      CompletionDetailedJobOutRepositories$2.outboundSchema = exports.CompletionDetailedJobOutRepositories$outboundSchema;
    })(CompletionDetailedJobOutRepositories$ || (exports.CompletionDetailedJobOutRepositories$ = CompletionDetailedJobOutRepositories$ = {}));
    function completionDetailedJobOutRepositoriesToJSON(completionDetailedJobOutRepositories) {
      return JSON.stringify(exports.CompletionDetailedJobOutRepositories$outboundSchema.parse(completionDetailedJobOutRepositories));
    }
    function completionDetailedJobOutRepositoriesFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.CompletionDetailedJobOutRepositories$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'CompletionDetailedJobOutRepositories' from JSON`);
    }
    exports.CompletionDetailedJobOut$inboundSchema = z4.object({
      id: z4.string(),
      auto_start: z4.boolean(),
      model: z4.string(),
      status: exports.CompletionDetailedJobOutStatus$inboundSchema,
      created_at: z4.number().int(),
      modified_at: z4.number().int(),
      training_files: z4.array(z4.string()),
      validation_files: z4.nullable(z4.array(z4.string())).optional(),
      object: exports.CompletionDetailedJobOutObject$inboundSchema.default("job"),
      fine_tuned_model: z4.nullable(z4.string()).optional(),
      suffix: z4.nullable(z4.string()).optional(),
      integrations: z4.nullable(z4.array(wandbintegrationout_js_1.WandbIntegrationOut$inboundSchema)).optional(),
      trained_tokens: z4.nullable(z4.number().int()).optional(),
      metadata: z4.nullable(jobmetadataout_js_1.JobMetadataOut$inboundSchema).optional(),
      job_type: exports.CompletionDetailedJobOutJobType$inboundSchema.default("completion"),
      hyperparameters: completiontrainingparameters_js_1.CompletionTrainingParameters$inboundSchema,
      repositories: z4.array(githubrepositoryout_js_1.GithubRepositoryOut$inboundSchema).optional(),
      events: z4.array(eventout_js_1.EventOut$inboundSchema).optional(),
      checkpoints: z4.array(checkpointout_js_1.CheckpointOut$inboundSchema).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "auto_start": "autoStart",
        "created_at": "createdAt",
        "modified_at": "modifiedAt",
        "training_files": "trainingFiles",
        "validation_files": "validationFiles",
        "fine_tuned_model": "fineTunedModel",
        "trained_tokens": "trainedTokens",
        "job_type": "jobType"
      });
    });
    exports.CompletionDetailedJobOut$outboundSchema = z4.object({
      id: z4.string(),
      autoStart: z4.boolean(),
      model: z4.string(),
      status: exports.CompletionDetailedJobOutStatus$outboundSchema,
      createdAt: z4.number().int(),
      modifiedAt: z4.number().int(),
      trainingFiles: z4.array(z4.string()),
      validationFiles: z4.nullable(z4.array(z4.string())).optional(),
      object: exports.CompletionDetailedJobOutObject$outboundSchema.default("job"),
      fineTunedModel: z4.nullable(z4.string()).optional(),
      suffix: z4.nullable(z4.string()).optional(),
      integrations: z4.nullable(z4.array(wandbintegrationout_js_1.WandbIntegrationOut$outboundSchema)).optional(),
      trainedTokens: z4.nullable(z4.number().int()).optional(),
      metadata: z4.nullable(jobmetadataout_js_1.JobMetadataOut$outboundSchema).optional(),
      jobType: exports.CompletionDetailedJobOutJobType$outboundSchema.default("completion"),
      hyperparameters: completiontrainingparameters_js_1.CompletionTrainingParameters$outboundSchema,
      repositories: z4.array(githubrepositoryout_js_1.GithubRepositoryOut$outboundSchema).optional(),
      events: z4.array(eventout_js_1.EventOut$outboundSchema).optional(),
      checkpoints: z4.array(checkpointout_js_1.CheckpointOut$outboundSchema).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        autoStart: "auto_start",
        createdAt: "created_at",
        modifiedAt: "modified_at",
        trainingFiles: "training_files",
        validationFiles: "validation_files",
        fineTunedModel: "fine_tuned_model",
        trainedTokens: "trained_tokens",
        jobType: "job_type"
      });
    });
    var CompletionDetailedJobOut$;
    (function(CompletionDetailedJobOut$2) {
      CompletionDetailedJobOut$2.inboundSchema = exports.CompletionDetailedJobOut$inboundSchema;
      CompletionDetailedJobOut$2.outboundSchema = exports.CompletionDetailedJobOut$outboundSchema;
    })(CompletionDetailedJobOut$ || (exports.CompletionDetailedJobOut$ = CompletionDetailedJobOut$ = {}));
    function completionDetailedJobOutToJSON(completionDetailedJobOut) {
      return JSON.stringify(exports.CompletionDetailedJobOut$outboundSchema.parse(completionDetailedJobOut));
    }
    function completionDetailedJobOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.CompletionDetailedJobOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'CompletionDetailedJobOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/completionevent.js
var require_completionevent = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/completionevent.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompletionEvent$ = exports.CompletionEvent$outboundSchema = exports.CompletionEvent$inboundSchema = void 0;
    exports.completionEventToJSON = completionEventToJSON;
    exports.completionEventFromJSON = completionEventFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var completionchunk_js_1 = require_completionchunk();
    exports.CompletionEvent$inboundSchema = z4.object({
      data: z4.string().transform((v2, ctx) => {
        try {
          return JSON.parse(v2);
        } catch (err) {
          ctx.addIssue({
            code: z4.ZodIssueCode.custom,
            message: `malformed json: ${err}`
          });
          return z4.NEVER;
        }
      }).pipe(completionchunk_js_1.CompletionChunk$inboundSchema)
    });
    exports.CompletionEvent$outboundSchema = z4.object({
      data: completionchunk_js_1.CompletionChunk$outboundSchema
    });
    var CompletionEvent$;
    (function(CompletionEvent$2) {
      CompletionEvent$2.inboundSchema = exports.CompletionEvent$inboundSchema;
      CompletionEvent$2.outboundSchema = exports.CompletionEvent$outboundSchema;
    })(CompletionEvent$ || (exports.CompletionEvent$ = CompletionEvent$ = {}));
    function completionEventToJSON(completionEvent) {
      return JSON.stringify(exports.CompletionEvent$outboundSchema.parse(completionEvent));
    }
    function completionEventFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.CompletionEvent$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'CompletionEvent' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/completionftmodelout.js
var require_completionftmodelout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/completionftmodelout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompletionFTModelOut$ = exports.CompletionFTModelOut$outboundSchema = exports.CompletionFTModelOut$inboundSchema = exports.ModelType$ = exports.ModelType$outboundSchema = exports.ModelType$inboundSchema = exports.CompletionFTModelOutObject$ = exports.CompletionFTModelOutObject$outboundSchema = exports.CompletionFTModelOutObject$inboundSchema = exports.ModelType = exports.CompletionFTModelOutObject = void 0;
    exports.completionFTModelOutToJSON = completionFTModelOutToJSON;
    exports.completionFTModelOutFromJSON = completionFTModelOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var ftmodelcapabilitiesout_js_1 = require_ftmodelcapabilitiesout();
    exports.CompletionFTModelOutObject = {
      Model: "model"
    };
    exports.ModelType = {
      Completion: "completion"
    };
    exports.CompletionFTModelOutObject$inboundSchema = z4.nativeEnum(exports.CompletionFTModelOutObject);
    exports.CompletionFTModelOutObject$outboundSchema = exports.CompletionFTModelOutObject$inboundSchema;
    var CompletionFTModelOutObject$;
    (function(CompletionFTModelOutObject$2) {
      CompletionFTModelOutObject$2.inboundSchema = exports.CompletionFTModelOutObject$inboundSchema;
      CompletionFTModelOutObject$2.outboundSchema = exports.CompletionFTModelOutObject$outboundSchema;
    })(CompletionFTModelOutObject$ || (exports.CompletionFTModelOutObject$ = CompletionFTModelOutObject$ = {}));
    exports.ModelType$inboundSchema = z4.nativeEnum(exports.ModelType);
    exports.ModelType$outboundSchema = exports.ModelType$inboundSchema;
    var ModelType$;
    (function(ModelType$2) {
      ModelType$2.inboundSchema = exports.ModelType$inboundSchema;
      ModelType$2.outboundSchema = exports.ModelType$outboundSchema;
    })(ModelType$ || (exports.ModelType$ = ModelType$ = {}));
    exports.CompletionFTModelOut$inboundSchema = z4.object({
      id: z4.string(),
      object: exports.CompletionFTModelOutObject$inboundSchema.default("model"),
      created: z4.number().int(),
      owned_by: z4.string(),
      workspace_id: z4.string(),
      root: z4.string(),
      root_version: z4.string(),
      archived: z4.boolean(),
      name: z4.nullable(z4.string()).optional(),
      description: z4.nullable(z4.string()).optional(),
      capabilities: ftmodelcapabilitiesout_js_1.FTModelCapabilitiesOut$inboundSchema,
      max_context_length: z4.number().int().default(32768),
      aliases: z4.array(z4.string()).optional(),
      job: z4.string(),
      model_type: exports.ModelType$inboundSchema.default("completion")
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "owned_by": "ownedBy",
        "workspace_id": "workspaceId",
        "root_version": "rootVersion",
        "max_context_length": "maxContextLength",
        "model_type": "modelType"
      });
    });
    exports.CompletionFTModelOut$outboundSchema = z4.object({
      id: z4.string(),
      object: exports.CompletionFTModelOutObject$outboundSchema.default("model"),
      created: z4.number().int(),
      ownedBy: z4.string(),
      workspaceId: z4.string(),
      root: z4.string(),
      rootVersion: z4.string(),
      archived: z4.boolean(),
      name: z4.nullable(z4.string()).optional(),
      description: z4.nullable(z4.string()).optional(),
      capabilities: ftmodelcapabilitiesout_js_1.FTModelCapabilitiesOut$outboundSchema,
      maxContextLength: z4.number().int().default(32768),
      aliases: z4.array(z4.string()).optional(),
      job: z4.string(),
      modelType: exports.ModelType$outboundSchema.default("completion")
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        ownedBy: "owned_by",
        workspaceId: "workspace_id",
        rootVersion: "root_version",
        maxContextLength: "max_context_length",
        modelType: "model_type"
      });
    });
    var CompletionFTModelOut$;
    (function(CompletionFTModelOut$2) {
      CompletionFTModelOut$2.inboundSchema = exports.CompletionFTModelOut$inboundSchema;
      CompletionFTModelOut$2.outboundSchema = exports.CompletionFTModelOut$outboundSchema;
    })(CompletionFTModelOut$ || (exports.CompletionFTModelOut$ = CompletionFTModelOut$ = {}));
    function completionFTModelOutToJSON(completionFTModelOut) {
      return JSON.stringify(exports.CompletionFTModelOut$outboundSchema.parse(completionFTModelOut));
    }
    function completionFTModelOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.CompletionFTModelOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'CompletionFTModelOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/completionjobout.js
var require_completionjobout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/completionjobout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompletionJobOut$ = exports.CompletionJobOut$outboundSchema = exports.CompletionJobOut$inboundSchema = exports.Repositories$ = exports.Repositories$outboundSchema = exports.Repositories$inboundSchema = exports.JobType$ = exports.JobType$outboundSchema = exports.JobType$inboundSchema = exports.Integrations$ = exports.Integrations$outboundSchema = exports.Integrations$inboundSchema = exports.CompletionJobOutObject$ = exports.CompletionJobOutObject$outboundSchema = exports.CompletionJobOutObject$inboundSchema = exports.Status$ = exports.Status$outboundSchema = exports.Status$inboundSchema = exports.JobType = exports.CompletionJobOutObject = exports.Status = void 0;
    exports.integrationsToJSON = integrationsToJSON;
    exports.integrationsFromJSON = integrationsFromJSON;
    exports.repositoriesToJSON = repositoriesToJSON;
    exports.repositoriesFromJSON = repositoriesFromJSON;
    exports.completionJobOutToJSON = completionJobOutToJSON;
    exports.completionJobOutFromJSON = completionJobOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var completiontrainingparameters_js_1 = require_completiontrainingparameters();
    var githubrepositoryout_js_1 = require_githubrepositoryout();
    var jobmetadataout_js_1 = require_jobmetadataout();
    var wandbintegrationout_js_1 = require_wandbintegrationout();
    exports.Status = {
      Queued: "QUEUED",
      Started: "STARTED",
      Validating: "VALIDATING",
      Validated: "VALIDATED",
      Running: "RUNNING",
      FailedValidation: "FAILED_VALIDATION",
      Failed: "FAILED",
      Success: "SUCCESS",
      Cancelled: "CANCELLED",
      CancellationRequested: "CANCELLATION_REQUESTED"
    };
    exports.CompletionJobOutObject = {
      Job: "job"
    };
    exports.JobType = {
      Completion: "completion"
    };
    exports.Status$inboundSchema = z4.nativeEnum(exports.Status);
    exports.Status$outboundSchema = exports.Status$inboundSchema;
    var Status$;
    (function(Status$2) {
      Status$2.inboundSchema = exports.Status$inboundSchema;
      Status$2.outboundSchema = exports.Status$outboundSchema;
    })(Status$ || (exports.Status$ = Status$ = {}));
    exports.CompletionJobOutObject$inboundSchema = z4.nativeEnum(exports.CompletionJobOutObject);
    exports.CompletionJobOutObject$outboundSchema = exports.CompletionJobOutObject$inboundSchema;
    var CompletionJobOutObject$;
    (function(CompletionJobOutObject$2) {
      CompletionJobOutObject$2.inboundSchema = exports.CompletionJobOutObject$inboundSchema;
      CompletionJobOutObject$2.outboundSchema = exports.CompletionJobOutObject$outboundSchema;
    })(CompletionJobOutObject$ || (exports.CompletionJobOutObject$ = CompletionJobOutObject$ = {}));
    exports.Integrations$inboundSchema = wandbintegrationout_js_1.WandbIntegrationOut$inboundSchema;
    exports.Integrations$outboundSchema = wandbintegrationout_js_1.WandbIntegrationOut$outboundSchema;
    var Integrations$;
    (function(Integrations$2) {
      Integrations$2.inboundSchema = exports.Integrations$inboundSchema;
      Integrations$2.outboundSchema = exports.Integrations$outboundSchema;
    })(Integrations$ || (exports.Integrations$ = Integrations$ = {}));
    function integrationsToJSON(integrations) {
      return JSON.stringify(exports.Integrations$outboundSchema.parse(integrations));
    }
    function integrationsFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.Integrations$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'Integrations' from JSON`);
    }
    exports.JobType$inboundSchema = z4.nativeEnum(exports.JobType);
    exports.JobType$outboundSchema = exports.JobType$inboundSchema;
    var JobType$;
    (function(JobType$2) {
      JobType$2.inboundSchema = exports.JobType$inboundSchema;
      JobType$2.outboundSchema = exports.JobType$outboundSchema;
    })(JobType$ || (exports.JobType$ = JobType$ = {}));
    exports.Repositories$inboundSchema = githubrepositoryout_js_1.GithubRepositoryOut$inboundSchema;
    exports.Repositories$outboundSchema = githubrepositoryout_js_1.GithubRepositoryOut$outboundSchema;
    var Repositories$;
    (function(Repositories$2) {
      Repositories$2.inboundSchema = exports.Repositories$inboundSchema;
      Repositories$2.outboundSchema = exports.Repositories$outboundSchema;
    })(Repositories$ || (exports.Repositories$ = Repositories$ = {}));
    function repositoriesToJSON(repositories) {
      return JSON.stringify(exports.Repositories$outboundSchema.parse(repositories));
    }
    function repositoriesFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.Repositories$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'Repositories' from JSON`);
    }
    exports.CompletionJobOut$inboundSchema = z4.object({
      id: z4.string(),
      auto_start: z4.boolean(),
      model: z4.string(),
      status: exports.Status$inboundSchema,
      created_at: z4.number().int(),
      modified_at: z4.number().int(),
      training_files: z4.array(z4.string()),
      validation_files: z4.nullable(z4.array(z4.string())).optional(),
      object: exports.CompletionJobOutObject$inboundSchema.default("job"),
      fine_tuned_model: z4.nullable(z4.string()).optional(),
      suffix: z4.nullable(z4.string()).optional(),
      integrations: z4.nullable(z4.array(wandbintegrationout_js_1.WandbIntegrationOut$inboundSchema)).optional(),
      trained_tokens: z4.nullable(z4.number().int()).optional(),
      metadata: z4.nullable(jobmetadataout_js_1.JobMetadataOut$inboundSchema).optional(),
      job_type: exports.JobType$inboundSchema.default("completion"),
      hyperparameters: completiontrainingparameters_js_1.CompletionTrainingParameters$inboundSchema,
      repositories: z4.array(githubrepositoryout_js_1.GithubRepositoryOut$inboundSchema).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "auto_start": "autoStart",
        "created_at": "createdAt",
        "modified_at": "modifiedAt",
        "training_files": "trainingFiles",
        "validation_files": "validationFiles",
        "fine_tuned_model": "fineTunedModel",
        "trained_tokens": "trainedTokens",
        "job_type": "jobType"
      });
    });
    exports.CompletionJobOut$outboundSchema = z4.object({
      id: z4.string(),
      autoStart: z4.boolean(),
      model: z4.string(),
      status: exports.Status$outboundSchema,
      createdAt: z4.number().int(),
      modifiedAt: z4.number().int(),
      trainingFiles: z4.array(z4.string()),
      validationFiles: z4.nullable(z4.array(z4.string())).optional(),
      object: exports.CompletionJobOutObject$outboundSchema.default("job"),
      fineTunedModel: z4.nullable(z4.string()).optional(),
      suffix: z4.nullable(z4.string()).optional(),
      integrations: z4.nullable(z4.array(wandbintegrationout_js_1.WandbIntegrationOut$outboundSchema)).optional(),
      trainedTokens: z4.nullable(z4.number().int()).optional(),
      metadata: z4.nullable(jobmetadataout_js_1.JobMetadataOut$outboundSchema).optional(),
      jobType: exports.JobType$outboundSchema.default("completion"),
      hyperparameters: completiontrainingparameters_js_1.CompletionTrainingParameters$outboundSchema,
      repositories: z4.array(githubrepositoryout_js_1.GithubRepositoryOut$outboundSchema).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        autoStart: "auto_start",
        createdAt: "created_at",
        modifiedAt: "modified_at",
        trainingFiles: "training_files",
        validationFiles: "validation_files",
        fineTunedModel: "fine_tuned_model",
        trainedTokens: "trained_tokens",
        jobType: "job_type"
      });
    });
    var CompletionJobOut$;
    (function(CompletionJobOut$2) {
      CompletionJobOut$2.inboundSchema = exports.CompletionJobOut$inboundSchema;
      CompletionJobOut$2.outboundSchema = exports.CompletionJobOut$outboundSchema;
    })(CompletionJobOut$ || (exports.CompletionJobOut$ = CompletionJobOut$ = {}));
    function completionJobOutToJSON(completionJobOut) {
      return JSON.stringify(exports.CompletionJobOut$outboundSchema.parse(completionJobOut));
    }
    function completionJobOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.CompletionJobOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'CompletionJobOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/completiontrainingparametersin.js
var require_completiontrainingparametersin = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/completiontrainingparametersin.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompletionTrainingParametersIn$ = exports.CompletionTrainingParametersIn$outboundSchema = exports.CompletionTrainingParametersIn$inboundSchema = void 0;
    exports.completionTrainingParametersInToJSON = completionTrainingParametersInToJSON;
    exports.completionTrainingParametersInFromJSON = completionTrainingParametersInFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.CompletionTrainingParametersIn$inboundSchema = z4.object({
      training_steps: z4.nullable(z4.number().int()).optional(),
      learning_rate: z4.number().default(1e-4),
      weight_decay: z4.nullable(z4.number()).optional(),
      warmup_fraction: z4.nullable(z4.number()).optional(),
      epochs: z4.nullable(z4.number()).optional(),
      seq_len: z4.nullable(z4.number().int()).optional(),
      fim_ratio: z4.nullable(z4.number()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "training_steps": "trainingSteps",
        "learning_rate": "learningRate",
        "weight_decay": "weightDecay",
        "warmup_fraction": "warmupFraction",
        "seq_len": "seqLen",
        "fim_ratio": "fimRatio"
      });
    });
    exports.CompletionTrainingParametersIn$outboundSchema = z4.object({
      trainingSteps: z4.nullable(z4.number().int()).optional(),
      learningRate: z4.number().default(1e-4),
      weightDecay: z4.nullable(z4.number()).optional(),
      warmupFraction: z4.nullable(z4.number()).optional(),
      epochs: z4.nullable(z4.number()).optional(),
      seqLen: z4.nullable(z4.number().int()).optional(),
      fimRatio: z4.nullable(z4.number()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        trainingSteps: "training_steps",
        learningRate: "learning_rate",
        weightDecay: "weight_decay",
        warmupFraction: "warmup_fraction",
        seqLen: "seq_len",
        fimRatio: "fim_ratio"
      });
    });
    var CompletionTrainingParametersIn$;
    (function(CompletionTrainingParametersIn$2) {
      CompletionTrainingParametersIn$2.inboundSchema = exports.CompletionTrainingParametersIn$inboundSchema;
      CompletionTrainingParametersIn$2.outboundSchema = exports.CompletionTrainingParametersIn$outboundSchema;
    })(CompletionTrainingParametersIn$ || (exports.CompletionTrainingParametersIn$ = CompletionTrainingParametersIn$ = {}));
    function completionTrainingParametersInToJSON(completionTrainingParametersIn) {
      return JSON.stringify(exports.CompletionTrainingParametersIn$outboundSchema.parse(completionTrainingParametersIn));
    }
    function completionTrainingParametersInFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.CompletionTrainingParametersIn$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'CompletionTrainingParametersIn' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/functioncallentryarguments.js
var require_functioncallentryarguments = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/functioncallentryarguments.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FunctionCallEntryArguments$ = exports.FunctionCallEntryArguments$outboundSchema = exports.FunctionCallEntryArguments$inboundSchema = void 0;
    exports.functionCallEntryArgumentsToJSON = functionCallEntryArgumentsToJSON;
    exports.functionCallEntryArgumentsFromJSON = functionCallEntryArgumentsFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    exports.FunctionCallEntryArguments$inboundSchema = z4.union([z4.record(z4.any()), z4.string()]);
    exports.FunctionCallEntryArguments$outboundSchema = z4.union([z4.record(z4.any()), z4.string()]);
    var FunctionCallEntryArguments$;
    (function(FunctionCallEntryArguments$2) {
      FunctionCallEntryArguments$2.inboundSchema = exports.FunctionCallEntryArguments$inboundSchema;
      FunctionCallEntryArguments$2.outboundSchema = exports.FunctionCallEntryArguments$outboundSchema;
    })(FunctionCallEntryArguments$ || (exports.FunctionCallEntryArguments$ = FunctionCallEntryArguments$ = {}));
    function functionCallEntryArgumentsToJSON(functionCallEntryArguments) {
      return JSON.stringify(exports.FunctionCallEntryArguments$outboundSchema.parse(functionCallEntryArguments));
    }
    function functionCallEntryArgumentsFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.FunctionCallEntryArguments$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'FunctionCallEntryArguments' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/functioncallentry.js
var require_functioncallentry = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/functioncallentry.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FunctionCallEntry$ = exports.FunctionCallEntry$outboundSchema = exports.FunctionCallEntry$inboundSchema = exports.FunctionCallEntryType$ = exports.FunctionCallEntryType$outboundSchema = exports.FunctionCallEntryType$inboundSchema = exports.FunctionCallEntryObject$ = exports.FunctionCallEntryObject$outboundSchema = exports.FunctionCallEntryObject$inboundSchema = exports.FunctionCallEntryType = exports.FunctionCallEntryObject = void 0;
    exports.functionCallEntryToJSON = functionCallEntryToJSON;
    exports.functionCallEntryFromJSON = functionCallEntryFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var functioncallentryarguments_js_1 = require_functioncallentryarguments();
    exports.FunctionCallEntryObject = {
      Entry: "entry"
    };
    exports.FunctionCallEntryType = {
      FunctionCall: "function.call"
    };
    exports.FunctionCallEntryObject$inboundSchema = z4.nativeEnum(exports.FunctionCallEntryObject);
    exports.FunctionCallEntryObject$outboundSchema = exports.FunctionCallEntryObject$inboundSchema;
    var FunctionCallEntryObject$;
    (function(FunctionCallEntryObject$2) {
      FunctionCallEntryObject$2.inboundSchema = exports.FunctionCallEntryObject$inboundSchema;
      FunctionCallEntryObject$2.outboundSchema = exports.FunctionCallEntryObject$outboundSchema;
    })(FunctionCallEntryObject$ || (exports.FunctionCallEntryObject$ = FunctionCallEntryObject$ = {}));
    exports.FunctionCallEntryType$inboundSchema = z4.nativeEnum(exports.FunctionCallEntryType);
    exports.FunctionCallEntryType$outboundSchema = exports.FunctionCallEntryType$inboundSchema;
    var FunctionCallEntryType$;
    (function(FunctionCallEntryType$2) {
      FunctionCallEntryType$2.inboundSchema = exports.FunctionCallEntryType$inboundSchema;
      FunctionCallEntryType$2.outboundSchema = exports.FunctionCallEntryType$outboundSchema;
    })(FunctionCallEntryType$ || (exports.FunctionCallEntryType$ = FunctionCallEntryType$ = {}));
    exports.FunctionCallEntry$inboundSchema = z4.object({
      object: exports.FunctionCallEntryObject$inboundSchema.default("entry"),
      type: exports.FunctionCallEntryType$inboundSchema.default("function.call"),
      created_at: z4.string().datetime({ offset: true }).transform((v2) => new Date(v2)).optional(),
      completed_at: z4.nullable(z4.string().datetime({ offset: true }).transform((v2) => new Date(v2))).optional(),
      id: z4.string().optional(),
      tool_call_id: z4.string(),
      name: z4.string(),
      arguments: functioncallentryarguments_js_1.FunctionCallEntryArguments$inboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "created_at": "createdAt",
        "completed_at": "completedAt",
        "tool_call_id": "toolCallId"
      });
    });
    exports.FunctionCallEntry$outboundSchema = z4.object({
      object: exports.FunctionCallEntryObject$outboundSchema.default("entry"),
      type: exports.FunctionCallEntryType$outboundSchema.default("function.call"),
      createdAt: z4.date().transform((v2) => v2.toISOString()).optional(),
      completedAt: z4.nullable(z4.date().transform((v2) => v2.toISOString())).optional(),
      id: z4.string().optional(),
      toolCallId: z4.string(),
      name: z4.string(),
      arguments: functioncallentryarguments_js_1.FunctionCallEntryArguments$outboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        createdAt: "created_at",
        completedAt: "completed_at",
        toolCallId: "tool_call_id"
      });
    });
    var FunctionCallEntry$;
    (function(FunctionCallEntry$2) {
      FunctionCallEntry$2.inboundSchema = exports.FunctionCallEntry$inboundSchema;
      FunctionCallEntry$2.outboundSchema = exports.FunctionCallEntry$outboundSchema;
    })(FunctionCallEntry$ || (exports.FunctionCallEntry$ = FunctionCallEntry$ = {}));
    function functionCallEntryToJSON(functionCallEntry) {
      return JSON.stringify(exports.FunctionCallEntry$outboundSchema.parse(functionCallEntry));
    }
    function functionCallEntryFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.FunctionCallEntry$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'FunctionCallEntry' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/functionresultentry.js
var require_functionresultentry = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/functionresultentry.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FunctionResultEntry$ = exports.FunctionResultEntry$outboundSchema = exports.FunctionResultEntry$inboundSchema = exports.FunctionResultEntryType$ = exports.FunctionResultEntryType$outboundSchema = exports.FunctionResultEntryType$inboundSchema = exports.FunctionResultEntryObject$ = exports.FunctionResultEntryObject$outboundSchema = exports.FunctionResultEntryObject$inboundSchema = exports.FunctionResultEntryType = exports.FunctionResultEntryObject = void 0;
    exports.functionResultEntryToJSON = functionResultEntryToJSON;
    exports.functionResultEntryFromJSON = functionResultEntryFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.FunctionResultEntryObject = {
      Entry: "entry"
    };
    exports.FunctionResultEntryType = {
      FunctionResult: "function.result"
    };
    exports.FunctionResultEntryObject$inboundSchema = z4.nativeEnum(exports.FunctionResultEntryObject);
    exports.FunctionResultEntryObject$outboundSchema = exports.FunctionResultEntryObject$inboundSchema;
    var FunctionResultEntryObject$;
    (function(FunctionResultEntryObject$2) {
      FunctionResultEntryObject$2.inboundSchema = exports.FunctionResultEntryObject$inboundSchema;
      FunctionResultEntryObject$2.outboundSchema = exports.FunctionResultEntryObject$outboundSchema;
    })(FunctionResultEntryObject$ || (exports.FunctionResultEntryObject$ = FunctionResultEntryObject$ = {}));
    exports.FunctionResultEntryType$inboundSchema = z4.nativeEnum(exports.FunctionResultEntryType);
    exports.FunctionResultEntryType$outboundSchema = exports.FunctionResultEntryType$inboundSchema;
    var FunctionResultEntryType$;
    (function(FunctionResultEntryType$2) {
      FunctionResultEntryType$2.inboundSchema = exports.FunctionResultEntryType$inboundSchema;
      FunctionResultEntryType$2.outboundSchema = exports.FunctionResultEntryType$outboundSchema;
    })(FunctionResultEntryType$ || (exports.FunctionResultEntryType$ = FunctionResultEntryType$ = {}));
    exports.FunctionResultEntry$inboundSchema = z4.object({
      object: exports.FunctionResultEntryObject$inboundSchema.default("entry"),
      type: exports.FunctionResultEntryType$inboundSchema.default("function.result"),
      created_at: z4.string().datetime({ offset: true }).transform((v2) => new Date(v2)).optional(),
      completed_at: z4.nullable(z4.string().datetime({ offset: true }).transform((v2) => new Date(v2))).optional(),
      id: z4.string().optional(),
      tool_call_id: z4.string(),
      result: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "created_at": "createdAt",
        "completed_at": "completedAt",
        "tool_call_id": "toolCallId"
      });
    });
    exports.FunctionResultEntry$outboundSchema = z4.object({
      object: exports.FunctionResultEntryObject$outboundSchema.default("entry"),
      type: exports.FunctionResultEntryType$outboundSchema.default("function.result"),
      createdAt: z4.date().transform((v2) => v2.toISOString()).optional(),
      completedAt: z4.nullable(z4.date().transform((v2) => v2.toISOString())).optional(),
      id: z4.string().optional(),
      toolCallId: z4.string(),
      result: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        createdAt: "created_at",
        completedAt: "completed_at",
        toolCallId: "tool_call_id"
      });
    });
    var FunctionResultEntry$;
    (function(FunctionResultEntry$2) {
      FunctionResultEntry$2.inboundSchema = exports.FunctionResultEntry$inboundSchema;
      FunctionResultEntry$2.outboundSchema = exports.FunctionResultEntry$outboundSchema;
    })(FunctionResultEntry$ || (exports.FunctionResultEntry$ = FunctionResultEntry$ = {}));
    function functionResultEntryToJSON(functionResultEntry) {
      return JSON.stringify(exports.FunctionResultEntry$outboundSchema.parse(functionResultEntry));
    }
    function functionResultEntryFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.FunctionResultEntry$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'FunctionResultEntry' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/toolfilechunk.js
var require_toolfilechunk = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/toolfilechunk.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ToolFileChunk$ = exports.ToolFileChunk$outboundSchema = exports.ToolFileChunk$inboundSchema = exports.ToolFileChunkType$ = exports.ToolFileChunkType$outboundSchema = exports.ToolFileChunkType$inboundSchema = exports.ToolFileChunkType = void 0;
    exports.toolFileChunkToJSON = toolFileChunkToJSON;
    exports.toolFileChunkFromJSON = toolFileChunkFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var builtinconnectors_js_1 = require_builtinconnectors();
    exports.ToolFileChunkType = {
      ToolFile: "tool_file"
    };
    exports.ToolFileChunkType$inboundSchema = z4.nativeEnum(exports.ToolFileChunkType);
    exports.ToolFileChunkType$outboundSchema = exports.ToolFileChunkType$inboundSchema;
    var ToolFileChunkType$;
    (function(ToolFileChunkType$2) {
      ToolFileChunkType$2.inboundSchema = exports.ToolFileChunkType$inboundSchema;
      ToolFileChunkType$2.outboundSchema = exports.ToolFileChunkType$outboundSchema;
    })(ToolFileChunkType$ || (exports.ToolFileChunkType$ = ToolFileChunkType$ = {}));
    exports.ToolFileChunk$inboundSchema = z4.object({
      type: exports.ToolFileChunkType$inboundSchema.default("tool_file"),
      tool: builtinconnectors_js_1.BuiltInConnectors$inboundSchema,
      file_id: z4.string(),
      file_name: z4.nullable(z4.string()).optional(),
      file_type: z4.nullable(z4.string()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "file_id": "fileId",
        "file_name": "fileName",
        "file_type": "fileType"
      });
    });
    exports.ToolFileChunk$outboundSchema = z4.object({
      type: exports.ToolFileChunkType$outboundSchema.default("tool_file"),
      tool: builtinconnectors_js_1.BuiltInConnectors$outboundSchema,
      fileId: z4.string(),
      fileName: z4.nullable(z4.string()).optional(),
      fileType: z4.nullable(z4.string()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        fileId: "file_id",
        fileName: "file_name",
        fileType: "file_type"
      });
    });
    var ToolFileChunk$;
    (function(ToolFileChunk$2) {
      ToolFileChunk$2.inboundSchema = exports.ToolFileChunk$inboundSchema;
      ToolFileChunk$2.outboundSchema = exports.ToolFileChunk$outboundSchema;
    })(ToolFileChunk$ || (exports.ToolFileChunk$ = ToolFileChunk$ = {}));
    function toolFileChunkToJSON(toolFileChunk) {
      return JSON.stringify(exports.ToolFileChunk$outboundSchema.parse(toolFileChunk));
    }
    function toolFileChunkFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ToolFileChunk$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ToolFileChunk' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/messageinputcontentchunks.js
var require_messageinputcontentchunks = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/messageinputcontentchunks.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageInputContentChunks$ = exports.MessageInputContentChunks$outboundSchema = exports.MessageInputContentChunks$inboundSchema = void 0;
    exports.messageInputContentChunksToJSON = messageInputContentChunksToJSON;
    exports.messageInputContentChunksFromJSON = messageInputContentChunksFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var documenturlchunk_js_1 = require_documenturlchunk();
    var imageurlchunk_js_1 = require_imageurlchunk();
    var textchunk_js_1 = require_textchunk();
    var toolfilechunk_js_1 = require_toolfilechunk();
    exports.MessageInputContentChunks$inboundSchema = z4.union([
      textchunk_js_1.TextChunk$inboundSchema,
      imageurlchunk_js_1.ImageURLChunk$inboundSchema,
      documenturlchunk_js_1.DocumentURLChunk$inboundSchema,
      toolfilechunk_js_1.ToolFileChunk$inboundSchema
    ]);
    exports.MessageInputContentChunks$outboundSchema = z4.union([
      textchunk_js_1.TextChunk$outboundSchema,
      imageurlchunk_js_1.ImageURLChunk$outboundSchema,
      documenturlchunk_js_1.DocumentURLChunk$outboundSchema,
      toolfilechunk_js_1.ToolFileChunk$outboundSchema
    ]);
    var MessageInputContentChunks$;
    (function(MessageInputContentChunks$2) {
      MessageInputContentChunks$2.inboundSchema = exports.MessageInputContentChunks$inboundSchema;
      MessageInputContentChunks$2.outboundSchema = exports.MessageInputContentChunks$outboundSchema;
    })(MessageInputContentChunks$ || (exports.MessageInputContentChunks$ = MessageInputContentChunks$ = {}));
    function messageInputContentChunksToJSON(messageInputContentChunks) {
      return JSON.stringify(exports.MessageInputContentChunks$outboundSchema.parse(messageInputContentChunks));
    }
    function messageInputContentChunksFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.MessageInputContentChunks$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'MessageInputContentChunks' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/messageinputentry.js
var require_messageinputentry = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/messageinputentry.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageInputEntry$ = exports.MessageInputEntry$outboundSchema = exports.MessageInputEntry$inboundSchema = exports.MessageInputEntryContent$ = exports.MessageInputEntryContent$outboundSchema = exports.MessageInputEntryContent$inboundSchema = exports.MessageInputEntryRole$ = exports.MessageInputEntryRole$outboundSchema = exports.MessageInputEntryRole$inboundSchema = exports.MessageInputEntryType$ = exports.MessageInputEntryType$outboundSchema = exports.MessageInputEntryType$inboundSchema = exports.ObjectT$ = exports.ObjectT$outboundSchema = exports.ObjectT$inboundSchema = exports.MessageInputEntryRole = exports.MessageInputEntryType = exports.ObjectT = void 0;
    exports.messageInputEntryContentToJSON = messageInputEntryContentToJSON;
    exports.messageInputEntryContentFromJSON = messageInputEntryContentFromJSON;
    exports.messageInputEntryToJSON = messageInputEntryToJSON;
    exports.messageInputEntryFromJSON = messageInputEntryFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var messageinputcontentchunks_js_1 = require_messageinputcontentchunks();
    exports.ObjectT = {
      Entry: "entry"
    };
    exports.MessageInputEntryType = {
      MessageInput: "message.input"
    };
    exports.MessageInputEntryRole = {
      Assistant: "assistant",
      User: "user"
    };
    exports.ObjectT$inboundSchema = z4.nativeEnum(exports.ObjectT);
    exports.ObjectT$outboundSchema = exports.ObjectT$inboundSchema;
    var ObjectT$;
    (function(ObjectT$2) {
      ObjectT$2.inboundSchema = exports.ObjectT$inboundSchema;
      ObjectT$2.outboundSchema = exports.ObjectT$outboundSchema;
    })(ObjectT$ || (exports.ObjectT$ = ObjectT$ = {}));
    exports.MessageInputEntryType$inboundSchema = z4.nativeEnum(exports.MessageInputEntryType);
    exports.MessageInputEntryType$outboundSchema = exports.MessageInputEntryType$inboundSchema;
    var MessageInputEntryType$;
    (function(MessageInputEntryType$2) {
      MessageInputEntryType$2.inboundSchema = exports.MessageInputEntryType$inboundSchema;
      MessageInputEntryType$2.outboundSchema = exports.MessageInputEntryType$outboundSchema;
    })(MessageInputEntryType$ || (exports.MessageInputEntryType$ = MessageInputEntryType$ = {}));
    exports.MessageInputEntryRole$inboundSchema = z4.nativeEnum(exports.MessageInputEntryRole);
    exports.MessageInputEntryRole$outboundSchema = exports.MessageInputEntryRole$inboundSchema;
    var MessageInputEntryRole$;
    (function(MessageInputEntryRole$2) {
      MessageInputEntryRole$2.inboundSchema = exports.MessageInputEntryRole$inboundSchema;
      MessageInputEntryRole$2.outboundSchema = exports.MessageInputEntryRole$outboundSchema;
    })(MessageInputEntryRole$ || (exports.MessageInputEntryRole$ = MessageInputEntryRole$ = {}));
    exports.MessageInputEntryContent$inboundSchema = z4.union([z4.string(), z4.array(messageinputcontentchunks_js_1.MessageInputContentChunks$inboundSchema)]);
    exports.MessageInputEntryContent$outboundSchema = z4.union([z4.string(), z4.array(messageinputcontentchunks_js_1.MessageInputContentChunks$outboundSchema)]);
    var MessageInputEntryContent$;
    (function(MessageInputEntryContent$2) {
      MessageInputEntryContent$2.inboundSchema = exports.MessageInputEntryContent$inboundSchema;
      MessageInputEntryContent$2.outboundSchema = exports.MessageInputEntryContent$outboundSchema;
    })(MessageInputEntryContent$ || (exports.MessageInputEntryContent$ = MessageInputEntryContent$ = {}));
    function messageInputEntryContentToJSON(messageInputEntryContent) {
      return JSON.stringify(exports.MessageInputEntryContent$outboundSchema.parse(messageInputEntryContent));
    }
    function messageInputEntryContentFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.MessageInputEntryContent$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'MessageInputEntryContent' from JSON`);
    }
    exports.MessageInputEntry$inboundSchema = z4.object({
      object: exports.ObjectT$inboundSchema.default("entry"),
      type: exports.MessageInputEntryType$inboundSchema.default("message.input"),
      created_at: z4.string().datetime({ offset: true }).transform((v2) => new Date(v2)).optional(),
      completed_at: z4.nullable(z4.string().datetime({ offset: true }).transform((v2) => new Date(v2))).optional(),
      id: z4.string().optional(),
      role: exports.MessageInputEntryRole$inboundSchema,
      content: z4.union([
        z4.string(),
        z4.array(messageinputcontentchunks_js_1.MessageInputContentChunks$inboundSchema)
      ]),
      prefix: z4.boolean().default(false)
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "created_at": "createdAt",
        "completed_at": "completedAt"
      });
    });
    exports.MessageInputEntry$outboundSchema = z4.object({
      object: exports.ObjectT$outboundSchema.default("entry"),
      type: exports.MessageInputEntryType$outboundSchema.default("message.input"),
      createdAt: z4.date().transform((v2) => v2.toISOString()).optional(),
      completedAt: z4.nullable(z4.date().transform((v2) => v2.toISOString())).optional(),
      id: z4.string().optional(),
      role: exports.MessageInputEntryRole$outboundSchema,
      content: z4.union([
        z4.string(),
        z4.array(messageinputcontentchunks_js_1.MessageInputContentChunks$outboundSchema)
      ]),
      prefix: z4.boolean().default(false)
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        createdAt: "created_at",
        completedAt: "completed_at"
      });
    });
    var MessageInputEntry$;
    (function(MessageInputEntry$2) {
      MessageInputEntry$2.inboundSchema = exports.MessageInputEntry$inboundSchema;
      MessageInputEntry$2.outboundSchema = exports.MessageInputEntry$outboundSchema;
    })(MessageInputEntry$ || (exports.MessageInputEntry$ = MessageInputEntry$ = {}));
    function messageInputEntryToJSON(messageInputEntry) {
      return JSON.stringify(exports.MessageInputEntry$outboundSchema.parse(messageInputEntry));
    }
    function messageInputEntryFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.MessageInputEntry$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'MessageInputEntry' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/toolreferencechunk.js
var require_toolreferencechunk = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/toolreferencechunk.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ToolReferenceChunk$ = exports.ToolReferenceChunk$outboundSchema = exports.ToolReferenceChunk$inboundSchema = exports.ToolReferenceChunkType$ = exports.ToolReferenceChunkType$outboundSchema = exports.ToolReferenceChunkType$inboundSchema = exports.ToolReferenceChunkType = void 0;
    exports.toolReferenceChunkToJSON = toolReferenceChunkToJSON;
    exports.toolReferenceChunkFromJSON = toolReferenceChunkFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var builtinconnectors_js_1 = require_builtinconnectors();
    exports.ToolReferenceChunkType = {
      ToolReference: "tool_reference"
    };
    exports.ToolReferenceChunkType$inboundSchema = z4.nativeEnum(exports.ToolReferenceChunkType);
    exports.ToolReferenceChunkType$outboundSchema = exports.ToolReferenceChunkType$inboundSchema;
    var ToolReferenceChunkType$;
    (function(ToolReferenceChunkType$2) {
      ToolReferenceChunkType$2.inboundSchema = exports.ToolReferenceChunkType$inboundSchema;
      ToolReferenceChunkType$2.outboundSchema = exports.ToolReferenceChunkType$outboundSchema;
    })(ToolReferenceChunkType$ || (exports.ToolReferenceChunkType$ = ToolReferenceChunkType$ = {}));
    exports.ToolReferenceChunk$inboundSchema = z4.object({
      type: exports.ToolReferenceChunkType$inboundSchema.default("tool_reference"),
      tool: builtinconnectors_js_1.BuiltInConnectors$inboundSchema,
      title: z4.string(),
      url: z4.nullable(z4.string()).optional(),
      favicon: z4.nullable(z4.string()).optional(),
      description: z4.nullable(z4.string()).optional()
    });
    exports.ToolReferenceChunk$outboundSchema = z4.object({
      type: exports.ToolReferenceChunkType$outboundSchema.default("tool_reference"),
      tool: builtinconnectors_js_1.BuiltInConnectors$outboundSchema,
      title: z4.string(),
      url: z4.nullable(z4.string()).optional(),
      favicon: z4.nullable(z4.string()).optional(),
      description: z4.nullable(z4.string()).optional()
    });
    var ToolReferenceChunk$;
    (function(ToolReferenceChunk$2) {
      ToolReferenceChunk$2.inboundSchema = exports.ToolReferenceChunk$inboundSchema;
      ToolReferenceChunk$2.outboundSchema = exports.ToolReferenceChunk$outboundSchema;
    })(ToolReferenceChunk$ || (exports.ToolReferenceChunk$ = ToolReferenceChunk$ = {}));
    function toolReferenceChunkToJSON(toolReferenceChunk) {
      return JSON.stringify(exports.ToolReferenceChunk$outboundSchema.parse(toolReferenceChunk));
    }
    function toolReferenceChunkFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ToolReferenceChunk$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ToolReferenceChunk' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/messageoutputcontentchunks.js
var require_messageoutputcontentchunks = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/messageoutputcontentchunks.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageOutputContentChunks$ = exports.MessageOutputContentChunks$outboundSchema = exports.MessageOutputContentChunks$inboundSchema = void 0;
    exports.messageOutputContentChunksToJSON = messageOutputContentChunksToJSON;
    exports.messageOutputContentChunksFromJSON = messageOutputContentChunksFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var documenturlchunk_js_1 = require_documenturlchunk();
    var imageurlchunk_js_1 = require_imageurlchunk();
    var textchunk_js_1 = require_textchunk();
    var toolfilechunk_js_1 = require_toolfilechunk();
    var toolreferencechunk_js_1 = require_toolreferencechunk();
    exports.MessageOutputContentChunks$inboundSchema = z4.union([
      textchunk_js_1.TextChunk$inboundSchema,
      imageurlchunk_js_1.ImageURLChunk$inboundSchema,
      documenturlchunk_js_1.DocumentURLChunk$inboundSchema,
      toolfilechunk_js_1.ToolFileChunk$inboundSchema,
      toolreferencechunk_js_1.ToolReferenceChunk$inboundSchema
    ]);
    exports.MessageOutputContentChunks$outboundSchema = z4.union([
      textchunk_js_1.TextChunk$outboundSchema,
      imageurlchunk_js_1.ImageURLChunk$outboundSchema,
      documenturlchunk_js_1.DocumentURLChunk$outboundSchema,
      toolfilechunk_js_1.ToolFileChunk$outboundSchema,
      toolreferencechunk_js_1.ToolReferenceChunk$outboundSchema
    ]);
    var MessageOutputContentChunks$;
    (function(MessageOutputContentChunks$2) {
      MessageOutputContentChunks$2.inboundSchema = exports.MessageOutputContentChunks$inboundSchema;
      MessageOutputContentChunks$2.outboundSchema = exports.MessageOutputContentChunks$outboundSchema;
    })(MessageOutputContentChunks$ || (exports.MessageOutputContentChunks$ = MessageOutputContentChunks$ = {}));
    function messageOutputContentChunksToJSON(messageOutputContentChunks) {
      return JSON.stringify(exports.MessageOutputContentChunks$outboundSchema.parse(messageOutputContentChunks));
    }
    function messageOutputContentChunksFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.MessageOutputContentChunks$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'MessageOutputContentChunks' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/messageoutputentry.js
var require_messageoutputentry = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/messageoutputentry.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageOutputEntry$ = exports.MessageOutputEntry$outboundSchema = exports.MessageOutputEntry$inboundSchema = exports.MessageOutputEntryContent$ = exports.MessageOutputEntryContent$outboundSchema = exports.MessageOutputEntryContent$inboundSchema = exports.MessageOutputEntryRole$ = exports.MessageOutputEntryRole$outboundSchema = exports.MessageOutputEntryRole$inboundSchema = exports.MessageOutputEntryType$ = exports.MessageOutputEntryType$outboundSchema = exports.MessageOutputEntryType$inboundSchema = exports.MessageOutputEntryObject$ = exports.MessageOutputEntryObject$outboundSchema = exports.MessageOutputEntryObject$inboundSchema = exports.MessageOutputEntryRole = exports.MessageOutputEntryType = exports.MessageOutputEntryObject = void 0;
    exports.messageOutputEntryContentToJSON = messageOutputEntryContentToJSON;
    exports.messageOutputEntryContentFromJSON = messageOutputEntryContentFromJSON;
    exports.messageOutputEntryToJSON = messageOutputEntryToJSON;
    exports.messageOutputEntryFromJSON = messageOutputEntryFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var messageoutputcontentchunks_js_1 = require_messageoutputcontentchunks();
    exports.MessageOutputEntryObject = {
      Entry: "entry"
    };
    exports.MessageOutputEntryType = {
      MessageOutput: "message.output"
    };
    exports.MessageOutputEntryRole = {
      Assistant: "assistant"
    };
    exports.MessageOutputEntryObject$inboundSchema = z4.nativeEnum(exports.MessageOutputEntryObject);
    exports.MessageOutputEntryObject$outboundSchema = exports.MessageOutputEntryObject$inboundSchema;
    var MessageOutputEntryObject$;
    (function(MessageOutputEntryObject$2) {
      MessageOutputEntryObject$2.inboundSchema = exports.MessageOutputEntryObject$inboundSchema;
      MessageOutputEntryObject$2.outboundSchema = exports.MessageOutputEntryObject$outboundSchema;
    })(MessageOutputEntryObject$ || (exports.MessageOutputEntryObject$ = MessageOutputEntryObject$ = {}));
    exports.MessageOutputEntryType$inboundSchema = z4.nativeEnum(exports.MessageOutputEntryType);
    exports.MessageOutputEntryType$outboundSchema = exports.MessageOutputEntryType$inboundSchema;
    var MessageOutputEntryType$;
    (function(MessageOutputEntryType$2) {
      MessageOutputEntryType$2.inboundSchema = exports.MessageOutputEntryType$inboundSchema;
      MessageOutputEntryType$2.outboundSchema = exports.MessageOutputEntryType$outboundSchema;
    })(MessageOutputEntryType$ || (exports.MessageOutputEntryType$ = MessageOutputEntryType$ = {}));
    exports.MessageOutputEntryRole$inboundSchema = z4.nativeEnum(exports.MessageOutputEntryRole);
    exports.MessageOutputEntryRole$outboundSchema = exports.MessageOutputEntryRole$inboundSchema;
    var MessageOutputEntryRole$;
    (function(MessageOutputEntryRole$2) {
      MessageOutputEntryRole$2.inboundSchema = exports.MessageOutputEntryRole$inboundSchema;
      MessageOutputEntryRole$2.outboundSchema = exports.MessageOutputEntryRole$outboundSchema;
    })(MessageOutputEntryRole$ || (exports.MessageOutputEntryRole$ = MessageOutputEntryRole$ = {}));
    exports.MessageOutputEntryContent$inboundSchema = z4.union([z4.string(), z4.array(messageoutputcontentchunks_js_1.MessageOutputContentChunks$inboundSchema)]);
    exports.MessageOutputEntryContent$outboundSchema = z4.union([z4.string(), z4.array(messageoutputcontentchunks_js_1.MessageOutputContentChunks$outboundSchema)]);
    var MessageOutputEntryContent$;
    (function(MessageOutputEntryContent$2) {
      MessageOutputEntryContent$2.inboundSchema = exports.MessageOutputEntryContent$inboundSchema;
      MessageOutputEntryContent$2.outboundSchema = exports.MessageOutputEntryContent$outboundSchema;
    })(MessageOutputEntryContent$ || (exports.MessageOutputEntryContent$ = MessageOutputEntryContent$ = {}));
    function messageOutputEntryContentToJSON(messageOutputEntryContent) {
      return JSON.stringify(exports.MessageOutputEntryContent$outboundSchema.parse(messageOutputEntryContent));
    }
    function messageOutputEntryContentFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.MessageOutputEntryContent$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'MessageOutputEntryContent' from JSON`);
    }
    exports.MessageOutputEntry$inboundSchema = z4.object({
      object: exports.MessageOutputEntryObject$inboundSchema.default("entry"),
      type: exports.MessageOutputEntryType$inboundSchema.default("message.output"),
      created_at: z4.string().datetime({ offset: true }).transform((v2) => new Date(v2)).optional(),
      completed_at: z4.nullable(z4.string().datetime({ offset: true }).transform((v2) => new Date(v2))).optional(),
      id: z4.string().optional(),
      agent_id: z4.nullable(z4.string()).optional(),
      model: z4.nullable(z4.string()).optional(),
      role: exports.MessageOutputEntryRole$inboundSchema.default("assistant"),
      content: z4.union([
        z4.string(),
        z4.array(messageoutputcontentchunks_js_1.MessageOutputContentChunks$inboundSchema)
      ])
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "created_at": "createdAt",
        "completed_at": "completedAt",
        "agent_id": "agentId"
      });
    });
    exports.MessageOutputEntry$outboundSchema = z4.object({
      object: exports.MessageOutputEntryObject$outboundSchema.default("entry"),
      type: exports.MessageOutputEntryType$outboundSchema.default("message.output"),
      createdAt: z4.date().transform((v2) => v2.toISOString()).optional(),
      completedAt: z4.nullable(z4.date().transform((v2) => v2.toISOString())).optional(),
      id: z4.string().optional(),
      agentId: z4.nullable(z4.string()).optional(),
      model: z4.nullable(z4.string()).optional(),
      role: exports.MessageOutputEntryRole$outboundSchema.default("assistant"),
      content: z4.union([
        z4.string(),
        z4.array(messageoutputcontentchunks_js_1.MessageOutputContentChunks$outboundSchema)
      ])
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        createdAt: "created_at",
        completedAt: "completed_at",
        agentId: "agent_id"
      });
    });
    var MessageOutputEntry$;
    (function(MessageOutputEntry$2) {
      MessageOutputEntry$2.inboundSchema = exports.MessageOutputEntry$inboundSchema;
      MessageOutputEntry$2.outboundSchema = exports.MessageOutputEntry$outboundSchema;
    })(MessageOutputEntry$ || (exports.MessageOutputEntry$ = MessageOutputEntry$ = {}));
    function messageOutputEntryToJSON(messageOutputEntry) {
      return JSON.stringify(exports.MessageOutputEntry$outboundSchema.parse(messageOutputEntry));
    }
    function messageOutputEntryFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.MessageOutputEntry$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'MessageOutputEntry' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/toolexecutionentry.js
var require_toolexecutionentry = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/toolexecutionentry.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ToolExecutionEntry$ = exports.ToolExecutionEntry$outboundSchema = exports.ToolExecutionEntry$inboundSchema = exports.ToolExecutionEntryType$ = exports.ToolExecutionEntryType$outboundSchema = exports.ToolExecutionEntryType$inboundSchema = exports.ToolExecutionEntryObject$ = exports.ToolExecutionEntryObject$outboundSchema = exports.ToolExecutionEntryObject$inboundSchema = exports.ToolExecutionEntryType = exports.ToolExecutionEntryObject = void 0;
    exports.toolExecutionEntryToJSON = toolExecutionEntryToJSON;
    exports.toolExecutionEntryFromJSON = toolExecutionEntryFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var builtinconnectors_js_1 = require_builtinconnectors();
    exports.ToolExecutionEntryObject = {
      Entry: "entry"
    };
    exports.ToolExecutionEntryType = {
      ToolExecution: "tool.execution"
    };
    exports.ToolExecutionEntryObject$inboundSchema = z4.nativeEnum(exports.ToolExecutionEntryObject);
    exports.ToolExecutionEntryObject$outboundSchema = exports.ToolExecutionEntryObject$inboundSchema;
    var ToolExecutionEntryObject$;
    (function(ToolExecutionEntryObject$2) {
      ToolExecutionEntryObject$2.inboundSchema = exports.ToolExecutionEntryObject$inboundSchema;
      ToolExecutionEntryObject$2.outboundSchema = exports.ToolExecutionEntryObject$outboundSchema;
    })(ToolExecutionEntryObject$ || (exports.ToolExecutionEntryObject$ = ToolExecutionEntryObject$ = {}));
    exports.ToolExecutionEntryType$inboundSchema = z4.nativeEnum(exports.ToolExecutionEntryType);
    exports.ToolExecutionEntryType$outboundSchema = exports.ToolExecutionEntryType$inboundSchema;
    var ToolExecutionEntryType$;
    (function(ToolExecutionEntryType$2) {
      ToolExecutionEntryType$2.inboundSchema = exports.ToolExecutionEntryType$inboundSchema;
      ToolExecutionEntryType$2.outboundSchema = exports.ToolExecutionEntryType$outboundSchema;
    })(ToolExecutionEntryType$ || (exports.ToolExecutionEntryType$ = ToolExecutionEntryType$ = {}));
    exports.ToolExecutionEntry$inboundSchema = z4.object({
      object: exports.ToolExecutionEntryObject$inboundSchema.default("entry"),
      type: exports.ToolExecutionEntryType$inboundSchema.default("tool.execution"),
      created_at: z4.string().datetime({ offset: true }).transform((v2) => new Date(v2)).optional(),
      completed_at: z4.nullable(z4.string().datetime({ offset: true }).transform((v2) => new Date(v2))).optional(),
      id: z4.string().optional(),
      name: builtinconnectors_js_1.BuiltInConnectors$inboundSchema,
      arguments: z4.string(),
      info: z4.record(z4.any()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "created_at": "createdAt",
        "completed_at": "completedAt"
      });
    });
    exports.ToolExecutionEntry$outboundSchema = z4.object({
      object: exports.ToolExecutionEntryObject$outboundSchema.default("entry"),
      type: exports.ToolExecutionEntryType$outboundSchema.default("tool.execution"),
      createdAt: z4.date().transform((v2) => v2.toISOString()).optional(),
      completedAt: z4.nullable(z4.date().transform((v2) => v2.toISOString())).optional(),
      id: z4.string().optional(),
      name: builtinconnectors_js_1.BuiltInConnectors$outboundSchema,
      arguments: z4.string(),
      info: z4.record(z4.any()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        createdAt: "created_at",
        completedAt: "completed_at"
      });
    });
    var ToolExecutionEntry$;
    (function(ToolExecutionEntry$2) {
      ToolExecutionEntry$2.inboundSchema = exports.ToolExecutionEntry$inboundSchema;
      ToolExecutionEntry$2.outboundSchema = exports.ToolExecutionEntry$outboundSchema;
    })(ToolExecutionEntry$ || (exports.ToolExecutionEntry$ = ToolExecutionEntry$ = {}));
    function toolExecutionEntryToJSON(toolExecutionEntry) {
      return JSON.stringify(exports.ToolExecutionEntry$outboundSchema.parse(toolExecutionEntry));
    }
    function toolExecutionEntryFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ToolExecutionEntry$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ToolExecutionEntry' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/inputentries.js
var require_inputentries = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/inputentries.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputEntries$ = exports.InputEntries$outboundSchema = exports.InputEntries$inboundSchema = void 0;
    exports.inputEntriesToJSON = inputEntriesToJSON;
    exports.inputEntriesFromJSON = inputEntriesFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var agenthandoffentry_js_1 = require_agenthandoffentry();
    var functioncallentry_js_1 = require_functioncallentry();
    var functionresultentry_js_1 = require_functionresultentry();
    var messageinputentry_js_1 = require_messageinputentry();
    var messageoutputentry_js_1 = require_messageoutputentry();
    var toolexecutionentry_js_1 = require_toolexecutionentry();
    exports.InputEntries$inboundSchema = z4.union([
      functionresultentry_js_1.FunctionResultEntry$inboundSchema,
      messageinputentry_js_1.MessageInputEntry$inboundSchema,
      functioncallentry_js_1.FunctionCallEntry$inboundSchema,
      toolexecutionentry_js_1.ToolExecutionEntry$inboundSchema,
      messageoutputentry_js_1.MessageOutputEntry$inboundSchema,
      agenthandoffentry_js_1.AgentHandoffEntry$inboundSchema
    ]);
    exports.InputEntries$outboundSchema = z4.union([
      functionresultentry_js_1.FunctionResultEntry$outboundSchema,
      messageinputentry_js_1.MessageInputEntry$outboundSchema,
      functioncallentry_js_1.FunctionCallEntry$outboundSchema,
      toolexecutionentry_js_1.ToolExecutionEntry$outboundSchema,
      messageoutputentry_js_1.MessageOutputEntry$outboundSchema,
      agenthandoffentry_js_1.AgentHandoffEntry$outboundSchema
    ]);
    var InputEntries$;
    (function(InputEntries$2) {
      InputEntries$2.inboundSchema = exports.InputEntries$inboundSchema;
      InputEntries$2.outboundSchema = exports.InputEntries$outboundSchema;
    })(InputEntries$ || (exports.InputEntries$ = InputEntries$ = {}));
    function inputEntriesToJSON(inputEntries) {
      return JSON.stringify(exports.InputEntries$outboundSchema.parse(inputEntries));
    }
    function inputEntriesFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.InputEntries$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'InputEntries' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/conversationinputs.js
var require_conversationinputs = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/conversationinputs.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConversationInputs$ = exports.ConversationInputs$outboundSchema = exports.ConversationInputs$inboundSchema = void 0;
    exports.conversationInputsToJSON = conversationInputsToJSON;
    exports.conversationInputsFromJSON = conversationInputsFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var inputentries_js_1 = require_inputentries();
    exports.ConversationInputs$inboundSchema = z4.union([z4.string(), z4.array(inputentries_js_1.InputEntries$inboundSchema)]);
    exports.ConversationInputs$outboundSchema = z4.union([z4.string(), z4.array(inputentries_js_1.InputEntries$outboundSchema)]);
    var ConversationInputs$;
    (function(ConversationInputs$2) {
      ConversationInputs$2.inboundSchema = exports.ConversationInputs$inboundSchema;
      ConversationInputs$2.outboundSchema = exports.ConversationInputs$outboundSchema;
    })(ConversationInputs$ || (exports.ConversationInputs$ = ConversationInputs$ = {}));
    function conversationInputsToJSON(conversationInputs) {
      return JSON.stringify(exports.ConversationInputs$outboundSchema.parse(conversationInputs));
    }
    function conversationInputsFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ConversationInputs$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ConversationInputs' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/conversationappendrequest.js
var require_conversationappendrequest = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/conversationappendrequest.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConversationAppendRequest$ = exports.ConversationAppendRequest$outboundSchema = exports.ConversationAppendRequest$inboundSchema = exports.ConversationAppendRequestHandoffExecution$ = exports.ConversationAppendRequestHandoffExecution$outboundSchema = exports.ConversationAppendRequestHandoffExecution$inboundSchema = exports.ConversationAppendRequestHandoffExecution = void 0;
    exports.conversationAppendRequestToJSON = conversationAppendRequestToJSON;
    exports.conversationAppendRequestFromJSON = conversationAppendRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var completionargs_js_1 = require_completionargs();
    var conversationinputs_js_1 = require_conversationinputs();
    exports.ConversationAppendRequestHandoffExecution = {
      Client: "client",
      Server: "server"
    };
    exports.ConversationAppendRequestHandoffExecution$inboundSchema = z4.nativeEnum(exports.ConversationAppendRequestHandoffExecution);
    exports.ConversationAppendRequestHandoffExecution$outboundSchema = exports.ConversationAppendRequestHandoffExecution$inboundSchema;
    var ConversationAppendRequestHandoffExecution$;
    (function(ConversationAppendRequestHandoffExecution$2) {
      ConversationAppendRequestHandoffExecution$2.inboundSchema = exports.ConversationAppendRequestHandoffExecution$inboundSchema;
      ConversationAppendRequestHandoffExecution$2.outboundSchema = exports.ConversationAppendRequestHandoffExecution$outboundSchema;
    })(ConversationAppendRequestHandoffExecution$ || (exports.ConversationAppendRequestHandoffExecution$ = ConversationAppendRequestHandoffExecution$ = {}));
    exports.ConversationAppendRequest$inboundSchema = z4.object({
      inputs: conversationinputs_js_1.ConversationInputs$inboundSchema,
      stream: z4.boolean().default(false),
      store: z4.boolean().default(true),
      handoff_execution: exports.ConversationAppendRequestHandoffExecution$inboundSchema.default("server"),
      completion_args: completionargs_js_1.CompletionArgs$inboundSchema.optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "handoff_execution": "handoffExecution",
        "completion_args": "completionArgs"
      });
    });
    exports.ConversationAppendRequest$outboundSchema = z4.object({
      inputs: conversationinputs_js_1.ConversationInputs$outboundSchema,
      stream: z4.boolean().default(false),
      store: z4.boolean().default(true),
      handoffExecution: exports.ConversationAppendRequestHandoffExecution$outboundSchema.default("server"),
      completionArgs: completionargs_js_1.CompletionArgs$outboundSchema.optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        handoffExecution: "handoff_execution",
        completionArgs: "completion_args"
      });
    });
    var ConversationAppendRequest$;
    (function(ConversationAppendRequest$2) {
      ConversationAppendRequest$2.inboundSchema = exports.ConversationAppendRequest$inboundSchema;
      ConversationAppendRequest$2.outboundSchema = exports.ConversationAppendRequest$outboundSchema;
    })(ConversationAppendRequest$ || (exports.ConversationAppendRequest$ = ConversationAppendRequest$ = {}));
    function conversationAppendRequestToJSON(conversationAppendRequest) {
      return JSON.stringify(exports.ConversationAppendRequest$outboundSchema.parse(conversationAppendRequest));
    }
    function conversationAppendRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ConversationAppendRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ConversationAppendRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/conversationappendstreamrequest.js
var require_conversationappendstreamrequest = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/conversationappendstreamrequest.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConversationAppendStreamRequest$ = exports.ConversationAppendStreamRequest$outboundSchema = exports.ConversationAppendStreamRequest$inboundSchema = exports.ConversationAppendStreamRequestHandoffExecution$ = exports.ConversationAppendStreamRequestHandoffExecution$outboundSchema = exports.ConversationAppendStreamRequestHandoffExecution$inboundSchema = exports.ConversationAppendStreamRequestHandoffExecution = void 0;
    exports.conversationAppendStreamRequestToJSON = conversationAppendStreamRequestToJSON;
    exports.conversationAppendStreamRequestFromJSON = conversationAppendStreamRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var completionargs_js_1 = require_completionargs();
    var conversationinputs_js_1 = require_conversationinputs();
    exports.ConversationAppendStreamRequestHandoffExecution = {
      Client: "client",
      Server: "server"
    };
    exports.ConversationAppendStreamRequestHandoffExecution$inboundSchema = z4.nativeEnum(exports.ConversationAppendStreamRequestHandoffExecution);
    exports.ConversationAppendStreamRequestHandoffExecution$outboundSchema = exports.ConversationAppendStreamRequestHandoffExecution$inboundSchema;
    var ConversationAppendStreamRequestHandoffExecution$;
    (function(ConversationAppendStreamRequestHandoffExecution$2) {
      ConversationAppendStreamRequestHandoffExecution$2.inboundSchema = exports.ConversationAppendStreamRequestHandoffExecution$inboundSchema;
      ConversationAppendStreamRequestHandoffExecution$2.outboundSchema = exports.ConversationAppendStreamRequestHandoffExecution$outboundSchema;
    })(ConversationAppendStreamRequestHandoffExecution$ || (exports.ConversationAppendStreamRequestHandoffExecution$ = ConversationAppendStreamRequestHandoffExecution$ = {}));
    exports.ConversationAppendStreamRequest$inboundSchema = z4.object({
      inputs: conversationinputs_js_1.ConversationInputs$inboundSchema,
      stream: z4.boolean().default(true),
      store: z4.boolean().default(true),
      handoff_execution: exports.ConversationAppendStreamRequestHandoffExecution$inboundSchema.default("server"),
      completion_args: completionargs_js_1.CompletionArgs$inboundSchema.optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "handoff_execution": "handoffExecution",
        "completion_args": "completionArgs"
      });
    });
    exports.ConversationAppendStreamRequest$outboundSchema = z4.object({
      inputs: conversationinputs_js_1.ConversationInputs$outboundSchema,
      stream: z4.boolean().default(true),
      store: z4.boolean().default(true),
      handoffExecution: exports.ConversationAppendStreamRequestHandoffExecution$outboundSchema.default("server"),
      completionArgs: completionargs_js_1.CompletionArgs$outboundSchema.optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        handoffExecution: "handoff_execution",
        completionArgs: "completion_args"
      });
    });
    var ConversationAppendStreamRequest$;
    (function(ConversationAppendStreamRequest$2) {
      ConversationAppendStreamRequest$2.inboundSchema = exports.ConversationAppendStreamRequest$inboundSchema;
      ConversationAppendStreamRequest$2.outboundSchema = exports.ConversationAppendStreamRequest$outboundSchema;
    })(ConversationAppendStreamRequest$ || (exports.ConversationAppendStreamRequest$ = ConversationAppendStreamRequest$ = {}));
    function conversationAppendStreamRequestToJSON(conversationAppendStreamRequest) {
      return JSON.stringify(exports.ConversationAppendStreamRequest$outboundSchema.parse(conversationAppendStreamRequest));
    }
    function conversationAppendStreamRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ConversationAppendStreamRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ConversationAppendStreamRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/functioncallevent.js
var require_functioncallevent = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/functioncallevent.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FunctionCallEvent$ = exports.FunctionCallEvent$outboundSchema = exports.FunctionCallEvent$inboundSchema = exports.FunctionCallEventType$ = exports.FunctionCallEventType$outboundSchema = exports.FunctionCallEventType$inboundSchema = exports.FunctionCallEventType = void 0;
    exports.functionCallEventToJSON = functionCallEventToJSON;
    exports.functionCallEventFromJSON = functionCallEventFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.FunctionCallEventType = {
      FunctionCallDelta: "function.call.delta"
    };
    exports.FunctionCallEventType$inboundSchema = z4.nativeEnum(exports.FunctionCallEventType);
    exports.FunctionCallEventType$outboundSchema = exports.FunctionCallEventType$inboundSchema;
    var FunctionCallEventType$;
    (function(FunctionCallEventType$2) {
      FunctionCallEventType$2.inboundSchema = exports.FunctionCallEventType$inboundSchema;
      FunctionCallEventType$2.outboundSchema = exports.FunctionCallEventType$outboundSchema;
    })(FunctionCallEventType$ || (exports.FunctionCallEventType$ = FunctionCallEventType$ = {}));
    exports.FunctionCallEvent$inboundSchema = z4.object({
      type: exports.FunctionCallEventType$inboundSchema.default("function.call.delta"),
      created_at: z4.string().datetime({ offset: true }).transform((v2) => new Date(v2)).optional(),
      output_index: z4.number().int().default(0),
      id: z4.string(),
      name: z4.string(),
      tool_call_id: z4.string(),
      arguments: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "created_at": "createdAt",
        "output_index": "outputIndex",
        "tool_call_id": "toolCallId"
      });
    });
    exports.FunctionCallEvent$outboundSchema = z4.object({
      type: exports.FunctionCallEventType$outboundSchema.default("function.call.delta"),
      createdAt: z4.date().transform((v2) => v2.toISOString()).optional(),
      outputIndex: z4.number().int().default(0),
      id: z4.string(),
      name: z4.string(),
      toolCallId: z4.string(),
      arguments: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        createdAt: "created_at",
        outputIndex: "output_index",
        toolCallId: "tool_call_id"
      });
    });
    var FunctionCallEvent$;
    (function(FunctionCallEvent$2) {
      FunctionCallEvent$2.inboundSchema = exports.FunctionCallEvent$inboundSchema;
      FunctionCallEvent$2.outboundSchema = exports.FunctionCallEvent$outboundSchema;
    })(FunctionCallEvent$ || (exports.FunctionCallEvent$ = FunctionCallEvent$ = {}));
    function functionCallEventToJSON(functionCallEvent) {
      return JSON.stringify(exports.FunctionCallEvent$outboundSchema.parse(functionCallEvent));
    }
    function functionCallEventFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.FunctionCallEvent$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'FunctionCallEvent' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/outputcontentchunks.js
var require_outputcontentchunks = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/outputcontentchunks.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OutputContentChunks$ = exports.OutputContentChunks$outboundSchema = exports.OutputContentChunks$inboundSchema = void 0;
    exports.outputContentChunksToJSON = outputContentChunksToJSON;
    exports.outputContentChunksFromJSON = outputContentChunksFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var documenturlchunk_js_1 = require_documenturlchunk();
    var imageurlchunk_js_1 = require_imageurlchunk();
    var textchunk_js_1 = require_textchunk();
    var toolfilechunk_js_1 = require_toolfilechunk();
    var toolreferencechunk_js_1 = require_toolreferencechunk();
    exports.OutputContentChunks$inboundSchema = z4.union([
      textchunk_js_1.TextChunk$inboundSchema,
      imageurlchunk_js_1.ImageURLChunk$inboundSchema,
      documenturlchunk_js_1.DocumentURLChunk$inboundSchema,
      toolfilechunk_js_1.ToolFileChunk$inboundSchema,
      toolreferencechunk_js_1.ToolReferenceChunk$inboundSchema
    ]);
    exports.OutputContentChunks$outboundSchema = z4.union([
      textchunk_js_1.TextChunk$outboundSchema,
      imageurlchunk_js_1.ImageURLChunk$outboundSchema,
      documenturlchunk_js_1.DocumentURLChunk$outboundSchema,
      toolfilechunk_js_1.ToolFileChunk$outboundSchema,
      toolreferencechunk_js_1.ToolReferenceChunk$outboundSchema
    ]);
    var OutputContentChunks$;
    (function(OutputContentChunks$2) {
      OutputContentChunks$2.inboundSchema = exports.OutputContentChunks$inboundSchema;
      OutputContentChunks$2.outboundSchema = exports.OutputContentChunks$outboundSchema;
    })(OutputContentChunks$ || (exports.OutputContentChunks$ = OutputContentChunks$ = {}));
    function outputContentChunksToJSON(outputContentChunks) {
      return JSON.stringify(exports.OutputContentChunks$outboundSchema.parse(outputContentChunks));
    }
    function outputContentChunksFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.OutputContentChunks$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'OutputContentChunks' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/messageoutputevent.js
var require_messageoutputevent = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/messageoutputevent.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageOutputEvent$ = exports.MessageOutputEvent$outboundSchema = exports.MessageOutputEvent$inboundSchema = exports.MessageOutputEventContent$ = exports.MessageOutputEventContent$outboundSchema = exports.MessageOutputEventContent$inboundSchema = exports.MessageOutputEventRole$ = exports.MessageOutputEventRole$outboundSchema = exports.MessageOutputEventRole$inboundSchema = exports.MessageOutputEventType$ = exports.MessageOutputEventType$outboundSchema = exports.MessageOutputEventType$inboundSchema = exports.MessageOutputEventRole = exports.MessageOutputEventType = void 0;
    exports.messageOutputEventContentToJSON = messageOutputEventContentToJSON;
    exports.messageOutputEventContentFromJSON = messageOutputEventContentFromJSON;
    exports.messageOutputEventToJSON = messageOutputEventToJSON;
    exports.messageOutputEventFromJSON = messageOutputEventFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var outputcontentchunks_js_1 = require_outputcontentchunks();
    exports.MessageOutputEventType = {
      MessageOutputDelta: "message.output.delta"
    };
    exports.MessageOutputEventRole = {
      Assistant: "assistant"
    };
    exports.MessageOutputEventType$inboundSchema = z4.nativeEnum(exports.MessageOutputEventType);
    exports.MessageOutputEventType$outboundSchema = exports.MessageOutputEventType$inboundSchema;
    var MessageOutputEventType$;
    (function(MessageOutputEventType$2) {
      MessageOutputEventType$2.inboundSchema = exports.MessageOutputEventType$inboundSchema;
      MessageOutputEventType$2.outboundSchema = exports.MessageOutputEventType$outboundSchema;
    })(MessageOutputEventType$ || (exports.MessageOutputEventType$ = MessageOutputEventType$ = {}));
    exports.MessageOutputEventRole$inboundSchema = z4.nativeEnum(exports.MessageOutputEventRole);
    exports.MessageOutputEventRole$outboundSchema = exports.MessageOutputEventRole$inboundSchema;
    var MessageOutputEventRole$;
    (function(MessageOutputEventRole$2) {
      MessageOutputEventRole$2.inboundSchema = exports.MessageOutputEventRole$inboundSchema;
      MessageOutputEventRole$2.outboundSchema = exports.MessageOutputEventRole$outboundSchema;
    })(MessageOutputEventRole$ || (exports.MessageOutputEventRole$ = MessageOutputEventRole$ = {}));
    exports.MessageOutputEventContent$inboundSchema = z4.union([z4.string(), outputcontentchunks_js_1.OutputContentChunks$inboundSchema]);
    exports.MessageOutputEventContent$outboundSchema = z4.union([z4.string(), outputcontentchunks_js_1.OutputContentChunks$outboundSchema]);
    var MessageOutputEventContent$;
    (function(MessageOutputEventContent$2) {
      MessageOutputEventContent$2.inboundSchema = exports.MessageOutputEventContent$inboundSchema;
      MessageOutputEventContent$2.outboundSchema = exports.MessageOutputEventContent$outboundSchema;
    })(MessageOutputEventContent$ || (exports.MessageOutputEventContent$ = MessageOutputEventContent$ = {}));
    function messageOutputEventContentToJSON(messageOutputEventContent) {
      return JSON.stringify(exports.MessageOutputEventContent$outboundSchema.parse(messageOutputEventContent));
    }
    function messageOutputEventContentFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.MessageOutputEventContent$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'MessageOutputEventContent' from JSON`);
    }
    exports.MessageOutputEvent$inboundSchema = z4.object({
      type: exports.MessageOutputEventType$inboundSchema.default("message.output.delta"),
      created_at: z4.string().datetime({ offset: true }).transform((v2) => new Date(v2)).optional(),
      output_index: z4.number().int().default(0),
      id: z4.string(),
      content_index: z4.number().int().default(0),
      model: z4.nullable(z4.string()).optional(),
      agent_id: z4.nullable(z4.string()).optional(),
      role: exports.MessageOutputEventRole$inboundSchema.default("assistant"),
      content: z4.union([z4.string(), outputcontentchunks_js_1.OutputContentChunks$inboundSchema])
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "created_at": "createdAt",
        "output_index": "outputIndex",
        "content_index": "contentIndex",
        "agent_id": "agentId"
      });
    });
    exports.MessageOutputEvent$outboundSchema = z4.object({
      type: exports.MessageOutputEventType$outboundSchema.default("message.output.delta"),
      createdAt: z4.date().transform((v2) => v2.toISOString()).optional(),
      outputIndex: z4.number().int().default(0),
      id: z4.string(),
      contentIndex: z4.number().int().default(0),
      model: z4.nullable(z4.string()).optional(),
      agentId: z4.nullable(z4.string()).optional(),
      role: exports.MessageOutputEventRole$outboundSchema.default("assistant"),
      content: z4.union([z4.string(), outputcontentchunks_js_1.OutputContentChunks$outboundSchema])
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        createdAt: "created_at",
        outputIndex: "output_index",
        contentIndex: "content_index",
        agentId: "agent_id"
      });
    });
    var MessageOutputEvent$;
    (function(MessageOutputEvent$2) {
      MessageOutputEvent$2.inboundSchema = exports.MessageOutputEvent$inboundSchema;
      MessageOutputEvent$2.outboundSchema = exports.MessageOutputEvent$outboundSchema;
    })(MessageOutputEvent$ || (exports.MessageOutputEvent$ = MessageOutputEvent$ = {}));
    function messageOutputEventToJSON(messageOutputEvent) {
      return JSON.stringify(exports.MessageOutputEvent$outboundSchema.parse(messageOutputEvent));
    }
    function messageOutputEventFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.MessageOutputEvent$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'MessageOutputEvent' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/conversationusageinfo.js
var require_conversationusageinfo = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/conversationusageinfo.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConversationUsageInfo$ = exports.ConversationUsageInfo$outboundSchema = exports.ConversationUsageInfo$inboundSchema = void 0;
    exports.conversationUsageInfoToJSON = conversationUsageInfoToJSON;
    exports.conversationUsageInfoFromJSON = conversationUsageInfoFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.ConversationUsageInfo$inboundSchema = z4.object({
      prompt_tokens: z4.number().int().default(0),
      completion_tokens: z4.number().int().default(0),
      total_tokens: z4.number().int().default(0),
      connector_tokens: z4.nullable(z4.number().int()).optional(),
      connectors: z4.nullable(z4.record(z4.number().int())).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "prompt_tokens": "promptTokens",
        "completion_tokens": "completionTokens",
        "total_tokens": "totalTokens",
        "connector_tokens": "connectorTokens"
      });
    });
    exports.ConversationUsageInfo$outboundSchema = z4.object({
      promptTokens: z4.number().int().default(0),
      completionTokens: z4.number().int().default(0),
      totalTokens: z4.number().int().default(0),
      connectorTokens: z4.nullable(z4.number().int()).optional(),
      connectors: z4.nullable(z4.record(z4.number().int())).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        promptTokens: "prompt_tokens",
        completionTokens: "completion_tokens",
        totalTokens: "total_tokens",
        connectorTokens: "connector_tokens"
      });
    });
    var ConversationUsageInfo$;
    (function(ConversationUsageInfo$2) {
      ConversationUsageInfo$2.inboundSchema = exports.ConversationUsageInfo$inboundSchema;
      ConversationUsageInfo$2.outboundSchema = exports.ConversationUsageInfo$outboundSchema;
    })(ConversationUsageInfo$ || (exports.ConversationUsageInfo$ = ConversationUsageInfo$ = {}));
    function conversationUsageInfoToJSON(conversationUsageInfo) {
      return JSON.stringify(exports.ConversationUsageInfo$outboundSchema.parse(conversationUsageInfo));
    }
    function conversationUsageInfoFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ConversationUsageInfo$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ConversationUsageInfo' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/responsedoneevent.js
var require_responsedoneevent = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/responsedoneevent.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ResponseDoneEvent$ = exports.ResponseDoneEvent$outboundSchema = exports.ResponseDoneEvent$inboundSchema = exports.ResponseDoneEventType$ = exports.ResponseDoneEventType$outboundSchema = exports.ResponseDoneEventType$inboundSchema = exports.ResponseDoneEventType = void 0;
    exports.responseDoneEventToJSON = responseDoneEventToJSON;
    exports.responseDoneEventFromJSON = responseDoneEventFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var conversationusageinfo_js_1 = require_conversationusageinfo();
    exports.ResponseDoneEventType = {
      ConversationResponseDone: "conversation.response.done"
    };
    exports.ResponseDoneEventType$inboundSchema = z4.nativeEnum(exports.ResponseDoneEventType);
    exports.ResponseDoneEventType$outboundSchema = exports.ResponseDoneEventType$inboundSchema;
    var ResponseDoneEventType$;
    (function(ResponseDoneEventType$2) {
      ResponseDoneEventType$2.inboundSchema = exports.ResponseDoneEventType$inboundSchema;
      ResponseDoneEventType$2.outboundSchema = exports.ResponseDoneEventType$outboundSchema;
    })(ResponseDoneEventType$ || (exports.ResponseDoneEventType$ = ResponseDoneEventType$ = {}));
    exports.ResponseDoneEvent$inboundSchema = z4.object({
      type: exports.ResponseDoneEventType$inboundSchema.default("conversation.response.done"),
      created_at: z4.string().datetime({ offset: true }).transform((v2) => new Date(v2)).optional(),
      usage: conversationusageinfo_js_1.ConversationUsageInfo$inboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "created_at": "createdAt"
      });
    });
    exports.ResponseDoneEvent$outboundSchema = z4.object({
      type: exports.ResponseDoneEventType$outboundSchema.default("conversation.response.done"),
      createdAt: z4.date().transform((v2) => v2.toISOString()).optional(),
      usage: conversationusageinfo_js_1.ConversationUsageInfo$outboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        createdAt: "created_at"
      });
    });
    var ResponseDoneEvent$;
    (function(ResponseDoneEvent$2) {
      ResponseDoneEvent$2.inboundSchema = exports.ResponseDoneEvent$inboundSchema;
      ResponseDoneEvent$2.outboundSchema = exports.ResponseDoneEvent$outboundSchema;
    })(ResponseDoneEvent$ || (exports.ResponseDoneEvent$ = ResponseDoneEvent$ = {}));
    function responseDoneEventToJSON(responseDoneEvent) {
      return JSON.stringify(exports.ResponseDoneEvent$outboundSchema.parse(responseDoneEvent));
    }
    function responseDoneEventFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ResponseDoneEvent$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ResponseDoneEvent' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/responseerrorevent.js
var require_responseerrorevent = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/responseerrorevent.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ResponseErrorEvent$ = exports.ResponseErrorEvent$outboundSchema = exports.ResponseErrorEvent$inboundSchema = exports.ResponseErrorEventType$ = exports.ResponseErrorEventType$outboundSchema = exports.ResponseErrorEventType$inboundSchema = exports.ResponseErrorEventType = void 0;
    exports.responseErrorEventToJSON = responseErrorEventToJSON;
    exports.responseErrorEventFromJSON = responseErrorEventFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.ResponseErrorEventType = {
      ConversationResponseError: "conversation.response.error"
    };
    exports.ResponseErrorEventType$inboundSchema = z4.nativeEnum(exports.ResponseErrorEventType);
    exports.ResponseErrorEventType$outboundSchema = exports.ResponseErrorEventType$inboundSchema;
    var ResponseErrorEventType$;
    (function(ResponseErrorEventType$2) {
      ResponseErrorEventType$2.inboundSchema = exports.ResponseErrorEventType$inboundSchema;
      ResponseErrorEventType$2.outboundSchema = exports.ResponseErrorEventType$outboundSchema;
    })(ResponseErrorEventType$ || (exports.ResponseErrorEventType$ = ResponseErrorEventType$ = {}));
    exports.ResponseErrorEvent$inboundSchema = z4.object({
      type: exports.ResponseErrorEventType$inboundSchema.default("conversation.response.error"),
      created_at: z4.string().datetime({ offset: true }).transform((v2) => new Date(v2)).optional(),
      message: z4.string(),
      code: z4.number().int()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "created_at": "createdAt"
      });
    });
    exports.ResponseErrorEvent$outboundSchema = z4.object({
      type: exports.ResponseErrorEventType$outboundSchema.default("conversation.response.error"),
      createdAt: z4.date().transform((v2) => v2.toISOString()).optional(),
      message: z4.string(),
      code: z4.number().int()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        createdAt: "created_at"
      });
    });
    var ResponseErrorEvent$;
    (function(ResponseErrorEvent$2) {
      ResponseErrorEvent$2.inboundSchema = exports.ResponseErrorEvent$inboundSchema;
      ResponseErrorEvent$2.outboundSchema = exports.ResponseErrorEvent$outboundSchema;
    })(ResponseErrorEvent$ || (exports.ResponseErrorEvent$ = ResponseErrorEvent$ = {}));
    function responseErrorEventToJSON(responseErrorEvent) {
      return JSON.stringify(exports.ResponseErrorEvent$outboundSchema.parse(responseErrorEvent));
    }
    function responseErrorEventFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ResponseErrorEvent$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ResponseErrorEvent' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/responsestartedevent.js
var require_responsestartedevent = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/responsestartedevent.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ResponseStartedEvent$ = exports.ResponseStartedEvent$outboundSchema = exports.ResponseStartedEvent$inboundSchema = exports.ResponseStartedEventType$ = exports.ResponseStartedEventType$outboundSchema = exports.ResponseStartedEventType$inboundSchema = exports.ResponseStartedEventType = void 0;
    exports.responseStartedEventToJSON = responseStartedEventToJSON;
    exports.responseStartedEventFromJSON = responseStartedEventFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.ResponseStartedEventType = {
      ConversationResponseStarted: "conversation.response.started"
    };
    exports.ResponseStartedEventType$inboundSchema = z4.nativeEnum(exports.ResponseStartedEventType);
    exports.ResponseStartedEventType$outboundSchema = exports.ResponseStartedEventType$inboundSchema;
    var ResponseStartedEventType$;
    (function(ResponseStartedEventType$2) {
      ResponseStartedEventType$2.inboundSchema = exports.ResponseStartedEventType$inboundSchema;
      ResponseStartedEventType$2.outboundSchema = exports.ResponseStartedEventType$outboundSchema;
    })(ResponseStartedEventType$ || (exports.ResponseStartedEventType$ = ResponseStartedEventType$ = {}));
    exports.ResponseStartedEvent$inboundSchema = z4.object({
      type: exports.ResponseStartedEventType$inboundSchema.default("conversation.response.started"),
      created_at: z4.string().datetime({ offset: true }).transform((v2) => new Date(v2)).optional(),
      conversation_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "created_at": "createdAt",
        "conversation_id": "conversationId"
      });
    });
    exports.ResponseStartedEvent$outboundSchema = z4.object({
      type: exports.ResponseStartedEventType$outboundSchema.default("conversation.response.started"),
      createdAt: z4.date().transform((v2) => v2.toISOString()).optional(),
      conversationId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        createdAt: "created_at",
        conversationId: "conversation_id"
      });
    });
    var ResponseStartedEvent$;
    (function(ResponseStartedEvent$2) {
      ResponseStartedEvent$2.inboundSchema = exports.ResponseStartedEvent$inboundSchema;
      ResponseStartedEvent$2.outboundSchema = exports.ResponseStartedEvent$outboundSchema;
    })(ResponseStartedEvent$ || (exports.ResponseStartedEvent$ = ResponseStartedEvent$ = {}));
    function responseStartedEventToJSON(responseStartedEvent) {
      return JSON.stringify(exports.ResponseStartedEvent$outboundSchema.parse(responseStartedEvent));
    }
    function responseStartedEventFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ResponseStartedEvent$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ResponseStartedEvent' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/ssetypes.js
var require_ssetypes = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/ssetypes.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SSETypes$ = exports.SSETypes$outboundSchema = exports.SSETypes$inboundSchema = exports.SSETypes = void 0;
    var z4 = __importStar(__require("zod"));
    exports.SSETypes = {
      ConversationResponseStarted: "conversation.response.started",
      ConversationResponseDone: "conversation.response.done",
      ConversationResponseError: "conversation.response.error",
      MessageOutputDelta: "message.output.delta",
      ToolExecutionStarted: "tool.execution.started",
      ToolExecutionDelta: "tool.execution.delta",
      ToolExecutionDone: "tool.execution.done",
      AgentHandoffStarted: "agent.handoff.started",
      AgentHandoffDone: "agent.handoff.done",
      FunctionCallDelta: "function.call.delta"
    };
    exports.SSETypes$inboundSchema = z4.nativeEnum(exports.SSETypes);
    exports.SSETypes$outboundSchema = exports.SSETypes$inboundSchema;
    var SSETypes$;
    (function(SSETypes$2) {
      SSETypes$2.inboundSchema = exports.SSETypes$inboundSchema;
      SSETypes$2.outboundSchema = exports.SSETypes$outboundSchema;
    })(SSETypes$ || (exports.SSETypes$ = SSETypes$ = {}));
  }
});

// ../node_modules/@mistralai/mistralai/models/components/toolexecutiondeltaevent.js
var require_toolexecutiondeltaevent = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/toolexecutiondeltaevent.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ToolExecutionDeltaEvent$ = exports.ToolExecutionDeltaEvent$outboundSchema = exports.ToolExecutionDeltaEvent$inboundSchema = exports.ToolExecutionDeltaEventType$ = exports.ToolExecutionDeltaEventType$outboundSchema = exports.ToolExecutionDeltaEventType$inboundSchema = exports.ToolExecutionDeltaEventType = void 0;
    exports.toolExecutionDeltaEventToJSON = toolExecutionDeltaEventToJSON;
    exports.toolExecutionDeltaEventFromJSON = toolExecutionDeltaEventFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var builtinconnectors_js_1 = require_builtinconnectors();
    exports.ToolExecutionDeltaEventType = {
      ToolExecutionDelta: "tool.execution.delta"
    };
    exports.ToolExecutionDeltaEventType$inboundSchema = z4.nativeEnum(exports.ToolExecutionDeltaEventType);
    exports.ToolExecutionDeltaEventType$outboundSchema = exports.ToolExecutionDeltaEventType$inboundSchema;
    var ToolExecutionDeltaEventType$;
    (function(ToolExecutionDeltaEventType$2) {
      ToolExecutionDeltaEventType$2.inboundSchema = exports.ToolExecutionDeltaEventType$inboundSchema;
      ToolExecutionDeltaEventType$2.outboundSchema = exports.ToolExecutionDeltaEventType$outboundSchema;
    })(ToolExecutionDeltaEventType$ || (exports.ToolExecutionDeltaEventType$ = ToolExecutionDeltaEventType$ = {}));
    exports.ToolExecutionDeltaEvent$inboundSchema = z4.object({
      type: exports.ToolExecutionDeltaEventType$inboundSchema.default("tool.execution.delta"),
      created_at: z4.string().datetime({ offset: true }).transform((v2) => new Date(v2)).optional(),
      output_index: z4.number().int().default(0),
      id: z4.string(),
      name: builtinconnectors_js_1.BuiltInConnectors$inboundSchema,
      arguments: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "created_at": "createdAt",
        "output_index": "outputIndex"
      });
    });
    exports.ToolExecutionDeltaEvent$outboundSchema = z4.object({
      type: exports.ToolExecutionDeltaEventType$outboundSchema.default("tool.execution.delta"),
      createdAt: z4.date().transform((v2) => v2.toISOString()).optional(),
      outputIndex: z4.number().int().default(0),
      id: z4.string(),
      name: builtinconnectors_js_1.BuiltInConnectors$outboundSchema,
      arguments: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        createdAt: "created_at",
        outputIndex: "output_index"
      });
    });
    var ToolExecutionDeltaEvent$;
    (function(ToolExecutionDeltaEvent$2) {
      ToolExecutionDeltaEvent$2.inboundSchema = exports.ToolExecutionDeltaEvent$inboundSchema;
      ToolExecutionDeltaEvent$2.outboundSchema = exports.ToolExecutionDeltaEvent$outboundSchema;
    })(ToolExecutionDeltaEvent$ || (exports.ToolExecutionDeltaEvent$ = ToolExecutionDeltaEvent$ = {}));
    function toolExecutionDeltaEventToJSON(toolExecutionDeltaEvent) {
      return JSON.stringify(exports.ToolExecutionDeltaEvent$outboundSchema.parse(toolExecutionDeltaEvent));
    }
    function toolExecutionDeltaEventFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ToolExecutionDeltaEvent$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ToolExecutionDeltaEvent' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/toolexecutiondoneevent.js
var require_toolexecutiondoneevent = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/toolexecutiondoneevent.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ToolExecutionDoneEvent$ = exports.ToolExecutionDoneEvent$outboundSchema = exports.ToolExecutionDoneEvent$inboundSchema = exports.ToolExecutionDoneEventType$ = exports.ToolExecutionDoneEventType$outboundSchema = exports.ToolExecutionDoneEventType$inboundSchema = exports.ToolExecutionDoneEventType = void 0;
    exports.toolExecutionDoneEventToJSON = toolExecutionDoneEventToJSON;
    exports.toolExecutionDoneEventFromJSON = toolExecutionDoneEventFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var builtinconnectors_js_1 = require_builtinconnectors();
    exports.ToolExecutionDoneEventType = {
      ToolExecutionDone: "tool.execution.done"
    };
    exports.ToolExecutionDoneEventType$inboundSchema = z4.nativeEnum(exports.ToolExecutionDoneEventType);
    exports.ToolExecutionDoneEventType$outboundSchema = exports.ToolExecutionDoneEventType$inboundSchema;
    var ToolExecutionDoneEventType$;
    (function(ToolExecutionDoneEventType$2) {
      ToolExecutionDoneEventType$2.inboundSchema = exports.ToolExecutionDoneEventType$inboundSchema;
      ToolExecutionDoneEventType$2.outboundSchema = exports.ToolExecutionDoneEventType$outboundSchema;
    })(ToolExecutionDoneEventType$ || (exports.ToolExecutionDoneEventType$ = ToolExecutionDoneEventType$ = {}));
    exports.ToolExecutionDoneEvent$inboundSchema = z4.object({
      type: exports.ToolExecutionDoneEventType$inboundSchema.default("tool.execution.done"),
      created_at: z4.string().datetime({ offset: true }).transform((v2) => new Date(v2)).optional(),
      output_index: z4.number().int().default(0),
      id: z4.string(),
      name: builtinconnectors_js_1.BuiltInConnectors$inboundSchema,
      info: z4.record(z4.any()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "created_at": "createdAt",
        "output_index": "outputIndex"
      });
    });
    exports.ToolExecutionDoneEvent$outboundSchema = z4.object({
      type: exports.ToolExecutionDoneEventType$outboundSchema.default("tool.execution.done"),
      createdAt: z4.date().transform((v2) => v2.toISOString()).optional(),
      outputIndex: z4.number().int().default(0),
      id: z4.string(),
      name: builtinconnectors_js_1.BuiltInConnectors$outboundSchema,
      info: z4.record(z4.any()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        createdAt: "created_at",
        outputIndex: "output_index"
      });
    });
    var ToolExecutionDoneEvent$;
    (function(ToolExecutionDoneEvent$2) {
      ToolExecutionDoneEvent$2.inboundSchema = exports.ToolExecutionDoneEvent$inboundSchema;
      ToolExecutionDoneEvent$2.outboundSchema = exports.ToolExecutionDoneEvent$outboundSchema;
    })(ToolExecutionDoneEvent$ || (exports.ToolExecutionDoneEvent$ = ToolExecutionDoneEvent$ = {}));
    function toolExecutionDoneEventToJSON(toolExecutionDoneEvent) {
      return JSON.stringify(exports.ToolExecutionDoneEvent$outboundSchema.parse(toolExecutionDoneEvent));
    }
    function toolExecutionDoneEventFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ToolExecutionDoneEvent$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ToolExecutionDoneEvent' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/toolexecutionstartedevent.js
var require_toolexecutionstartedevent = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/toolexecutionstartedevent.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ToolExecutionStartedEvent$ = exports.ToolExecutionStartedEvent$outboundSchema = exports.ToolExecutionStartedEvent$inboundSchema = exports.ToolExecutionStartedEventType$ = exports.ToolExecutionStartedEventType$outboundSchema = exports.ToolExecutionStartedEventType$inboundSchema = exports.ToolExecutionStartedEventType = void 0;
    exports.toolExecutionStartedEventToJSON = toolExecutionStartedEventToJSON;
    exports.toolExecutionStartedEventFromJSON = toolExecutionStartedEventFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var builtinconnectors_js_1 = require_builtinconnectors();
    exports.ToolExecutionStartedEventType = {
      ToolExecutionStarted: "tool.execution.started"
    };
    exports.ToolExecutionStartedEventType$inboundSchema = z4.nativeEnum(exports.ToolExecutionStartedEventType);
    exports.ToolExecutionStartedEventType$outboundSchema = exports.ToolExecutionStartedEventType$inboundSchema;
    var ToolExecutionStartedEventType$;
    (function(ToolExecutionStartedEventType$2) {
      ToolExecutionStartedEventType$2.inboundSchema = exports.ToolExecutionStartedEventType$inboundSchema;
      ToolExecutionStartedEventType$2.outboundSchema = exports.ToolExecutionStartedEventType$outboundSchema;
    })(ToolExecutionStartedEventType$ || (exports.ToolExecutionStartedEventType$ = ToolExecutionStartedEventType$ = {}));
    exports.ToolExecutionStartedEvent$inboundSchema = z4.object({
      type: exports.ToolExecutionStartedEventType$inboundSchema.default("tool.execution.started"),
      created_at: z4.string().datetime({ offset: true }).transform((v2) => new Date(v2)).optional(),
      output_index: z4.number().int().default(0),
      id: z4.string(),
      name: builtinconnectors_js_1.BuiltInConnectors$inboundSchema,
      arguments: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "created_at": "createdAt",
        "output_index": "outputIndex"
      });
    });
    exports.ToolExecutionStartedEvent$outboundSchema = z4.object({
      type: exports.ToolExecutionStartedEventType$outboundSchema.default("tool.execution.started"),
      createdAt: z4.date().transform((v2) => v2.toISOString()).optional(),
      outputIndex: z4.number().int().default(0),
      id: z4.string(),
      name: builtinconnectors_js_1.BuiltInConnectors$outboundSchema,
      arguments: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        createdAt: "created_at",
        outputIndex: "output_index"
      });
    });
    var ToolExecutionStartedEvent$;
    (function(ToolExecutionStartedEvent$2) {
      ToolExecutionStartedEvent$2.inboundSchema = exports.ToolExecutionStartedEvent$inboundSchema;
      ToolExecutionStartedEvent$2.outboundSchema = exports.ToolExecutionStartedEvent$outboundSchema;
    })(ToolExecutionStartedEvent$ || (exports.ToolExecutionStartedEvent$ = ToolExecutionStartedEvent$ = {}));
    function toolExecutionStartedEventToJSON(toolExecutionStartedEvent) {
      return JSON.stringify(exports.ToolExecutionStartedEvent$outboundSchema.parse(toolExecutionStartedEvent));
    }
    function toolExecutionStartedEventFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ToolExecutionStartedEvent$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ToolExecutionStartedEvent' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/conversationevents.js
var require_conversationevents = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/conversationevents.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConversationEvents$ = exports.ConversationEvents$outboundSchema = exports.ConversationEvents$inboundSchema = exports.ConversationEventsData$ = exports.ConversationEventsData$outboundSchema = exports.ConversationEventsData$inboundSchema = void 0;
    exports.conversationEventsDataToJSON = conversationEventsDataToJSON;
    exports.conversationEventsDataFromJSON = conversationEventsDataFromJSON;
    exports.conversationEventsToJSON = conversationEventsToJSON;
    exports.conversationEventsFromJSON = conversationEventsFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var agenthandoffdoneevent_js_1 = require_agenthandoffdoneevent();
    var agenthandoffstartedevent_js_1 = require_agenthandoffstartedevent();
    var functioncallevent_js_1 = require_functioncallevent();
    var messageoutputevent_js_1 = require_messageoutputevent();
    var responsedoneevent_js_1 = require_responsedoneevent();
    var responseerrorevent_js_1 = require_responseerrorevent();
    var responsestartedevent_js_1 = require_responsestartedevent();
    var ssetypes_js_1 = require_ssetypes();
    var toolexecutiondeltaevent_js_1 = require_toolexecutiondeltaevent();
    var toolexecutiondoneevent_js_1 = require_toolexecutiondoneevent();
    var toolexecutionstartedevent_js_1 = require_toolexecutionstartedevent();
    exports.ConversationEventsData$inboundSchema = z4.union([
      responsedoneevent_js_1.ResponseDoneEvent$inboundSchema.and(z4.object({ type: z4.literal("conversation.response.done") }).transform((v2) => ({ type: v2.type }))),
      responsestartedevent_js_1.ResponseStartedEvent$inboundSchema.and(z4.object({ type: z4.literal("conversation.response.started") }).transform((v2) => ({ type: v2.type }))),
      responseerrorevent_js_1.ResponseErrorEvent$inboundSchema.and(z4.object({ type: z4.literal("conversation.response.error") }).transform((v2) => ({ type: v2.type }))),
      agenthandoffdoneevent_js_1.AgentHandoffDoneEvent$inboundSchema.and(z4.object({ type: z4.literal("agent.handoff.done") }).transform((v2) => ({
        type: v2.type
      }))),
      agenthandoffstartedevent_js_1.AgentHandoffStartedEvent$inboundSchema.and(z4.object({ type: z4.literal("agent.handoff.started") }).transform((v2) => ({
        type: v2.type
      }))),
      toolexecutiondeltaevent_js_1.ToolExecutionDeltaEvent$inboundSchema.and(z4.object({ type: z4.literal("tool.execution.delta") }).transform((v2) => ({
        type: v2.type
      }))),
      toolexecutiondoneevent_js_1.ToolExecutionDoneEvent$inboundSchema.and(z4.object({ type: z4.literal("tool.execution.done") }).transform((v2) => ({
        type: v2.type
      }))),
      toolexecutionstartedevent_js_1.ToolExecutionStartedEvent$inboundSchema.and(z4.object({ type: z4.literal("tool.execution.started") }).transform((v2) => ({
        type: v2.type
      }))),
      functioncallevent_js_1.FunctionCallEvent$inboundSchema.and(z4.object({ type: z4.literal("function.call.delta") }).transform((v2) => ({
        type: v2.type
      }))),
      messageoutputevent_js_1.MessageOutputEvent$inboundSchema.and(z4.object({ type: z4.literal("message.output.delta") }).transform((v2) => ({
        type: v2.type
      })))
    ]);
    exports.ConversationEventsData$outboundSchema = z4.union([
      responsedoneevent_js_1.ResponseDoneEvent$outboundSchema.and(z4.object({ type: z4.literal("conversation.response.done") }).transform((v2) => ({ type: v2.type }))),
      responsestartedevent_js_1.ResponseStartedEvent$outboundSchema.and(z4.object({ type: z4.literal("conversation.response.started") }).transform((v2) => ({ type: v2.type }))),
      responseerrorevent_js_1.ResponseErrorEvent$outboundSchema.and(z4.object({ type: z4.literal("conversation.response.error") }).transform((v2) => ({ type: v2.type }))),
      agenthandoffdoneevent_js_1.AgentHandoffDoneEvent$outboundSchema.and(z4.object({ type: z4.literal("agent.handoff.done") }).transform((v2) => ({
        type: v2.type
      }))),
      agenthandoffstartedevent_js_1.AgentHandoffStartedEvent$outboundSchema.and(z4.object({ type: z4.literal("agent.handoff.started") }).transform((v2) => ({
        type: v2.type
      }))),
      toolexecutiondeltaevent_js_1.ToolExecutionDeltaEvent$outboundSchema.and(z4.object({ type: z4.literal("tool.execution.delta") }).transform((v2) => ({
        type: v2.type
      }))),
      toolexecutiondoneevent_js_1.ToolExecutionDoneEvent$outboundSchema.and(z4.object({ type: z4.literal("tool.execution.done") }).transform((v2) => ({
        type: v2.type
      }))),
      toolexecutionstartedevent_js_1.ToolExecutionStartedEvent$outboundSchema.and(z4.object({ type: z4.literal("tool.execution.started") }).transform((v2) => ({
        type: v2.type
      }))),
      functioncallevent_js_1.FunctionCallEvent$outboundSchema.and(z4.object({ type: z4.literal("function.call.delta") }).transform((v2) => ({
        type: v2.type
      }))),
      messageoutputevent_js_1.MessageOutputEvent$outboundSchema.and(z4.object({ type: z4.literal("message.output.delta") }).transform((v2) => ({
        type: v2.type
      })))
    ]);
    var ConversationEventsData$;
    (function(ConversationEventsData$2) {
      ConversationEventsData$2.inboundSchema = exports.ConversationEventsData$inboundSchema;
      ConversationEventsData$2.outboundSchema = exports.ConversationEventsData$outboundSchema;
    })(ConversationEventsData$ || (exports.ConversationEventsData$ = ConversationEventsData$ = {}));
    function conversationEventsDataToJSON(conversationEventsData) {
      return JSON.stringify(exports.ConversationEventsData$outboundSchema.parse(conversationEventsData));
    }
    function conversationEventsDataFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ConversationEventsData$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ConversationEventsData' from JSON`);
    }
    exports.ConversationEvents$inboundSchema = z4.object({
      event: ssetypes_js_1.SSETypes$inboundSchema,
      data: z4.string().transform((v2, ctx) => {
        try {
          return JSON.parse(v2);
        } catch (err) {
          ctx.addIssue({
            code: z4.ZodIssueCode.custom,
            message: `malformed json: ${err}`
          });
          return z4.NEVER;
        }
      }).pipe(z4.union([
        responsedoneevent_js_1.ResponseDoneEvent$inboundSchema.and(z4.object({ type: z4.literal("conversation.response.done") }).transform((v2) => ({ type: v2.type }))),
        responsestartedevent_js_1.ResponseStartedEvent$inboundSchema.and(z4.object({ type: z4.literal("conversation.response.started") }).transform((v2) => ({ type: v2.type }))),
        responseerrorevent_js_1.ResponseErrorEvent$inboundSchema.and(z4.object({ type: z4.literal("conversation.response.error") }).transform((v2) => ({ type: v2.type }))),
        agenthandoffdoneevent_js_1.AgentHandoffDoneEvent$inboundSchema.and(z4.object({ type: z4.literal("agent.handoff.done") }).transform((v2) => ({
          type: v2.type
        }))),
        agenthandoffstartedevent_js_1.AgentHandoffStartedEvent$inboundSchema.and(z4.object({ type: z4.literal("agent.handoff.started") }).transform((v2) => ({ type: v2.type }))),
        toolexecutiondeltaevent_js_1.ToolExecutionDeltaEvent$inboundSchema.and(z4.object({ type: z4.literal("tool.execution.delta") }).transform((v2) => ({ type: v2.type }))),
        toolexecutiondoneevent_js_1.ToolExecutionDoneEvent$inboundSchema.and(z4.object({ type: z4.literal("tool.execution.done") }).transform((v2) => ({
          type: v2.type
        }))),
        toolexecutionstartedevent_js_1.ToolExecutionStartedEvent$inboundSchema.and(z4.object({ type: z4.literal("tool.execution.started") }).transform((v2) => ({ type: v2.type }))),
        functioncallevent_js_1.FunctionCallEvent$inboundSchema.and(z4.object({ type: z4.literal("function.call.delta") }).transform((v2) => ({
          type: v2.type
        }))),
        messageoutputevent_js_1.MessageOutputEvent$inboundSchema.and(z4.object({ type: z4.literal("message.output.delta") }).transform((v2) => ({ type: v2.type })))
      ]))
    });
    exports.ConversationEvents$outboundSchema = z4.object({
      event: ssetypes_js_1.SSETypes$outboundSchema,
      data: z4.union([
        responsedoneevent_js_1.ResponseDoneEvent$outboundSchema.and(z4.object({ type: z4.literal("conversation.response.done") }).transform((v2) => ({ type: v2.type }))),
        responsestartedevent_js_1.ResponseStartedEvent$outboundSchema.and(z4.object({ type: z4.literal("conversation.response.started") }).transform((v2) => ({ type: v2.type }))),
        responseerrorevent_js_1.ResponseErrorEvent$outboundSchema.and(z4.object({ type: z4.literal("conversation.response.error") }).transform((v2) => ({ type: v2.type }))),
        agenthandoffdoneevent_js_1.AgentHandoffDoneEvent$outboundSchema.and(z4.object({ type: z4.literal("agent.handoff.done") }).transform((v2) => ({
          type: v2.type
        }))),
        agenthandoffstartedevent_js_1.AgentHandoffStartedEvent$outboundSchema.and(z4.object({ type: z4.literal("agent.handoff.started") }).transform((v2) => ({
          type: v2.type
        }))),
        toolexecutiondeltaevent_js_1.ToolExecutionDeltaEvent$outboundSchema.and(z4.object({ type: z4.literal("tool.execution.delta") }).transform((v2) => ({
          type: v2.type
        }))),
        toolexecutiondoneevent_js_1.ToolExecutionDoneEvent$outboundSchema.and(z4.object({ type: z4.literal("tool.execution.done") }).transform((v2) => ({
          type: v2.type
        }))),
        toolexecutionstartedevent_js_1.ToolExecutionStartedEvent$outboundSchema.and(z4.object({ type: z4.literal("tool.execution.started") }).transform((v2) => ({ type: v2.type }))),
        functioncallevent_js_1.FunctionCallEvent$outboundSchema.and(z4.object({ type: z4.literal("function.call.delta") }).transform((v2) => ({
          type: v2.type
        }))),
        messageoutputevent_js_1.MessageOutputEvent$outboundSchema.and(z4.object({ type: z4.literal("message.output.delta") }).transform((v2) => ({
          type: v2.type
        })))
      ])
    });
    var ConversationEvents$;
    (function(ConversationEvents$2) {
      ConversationEvents$2.inboundSchema = exports.ConversationEvents$inboundSchema;
      ConversationEvents$2.outboundSchema = exports.ConversationEvents$outboundSchema;
    })(ConversationEvents$ || (exports.ConversationEvents$ = ConversationEvents$ = {}));
    function conversationEventsToJSON(conversationEvents) {
      return JSON.stringify(exports.ConversationEvents$outboundSchema.parse(conversationEvents));
    }
    function conversationEventsFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ConversationEvents$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ConversationEvents' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/conversationhistory.js
var require_conversationhistory = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/conversationhistory.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConversationHistory$ = exports.ConversationHistory$outboundSchema = exports.ConversationHistory$inboundSchema = exports.Entries$ = exports.Entries$outboundSchema = exports.Entries$inboundSchema = exports.ConversationHistoryObject$ = exports.ConversationHistoryObject$outboundSchema = exports.ConversationHistoryObject$inboundSchema = exports.ConversationHistoryObject = void 0;
    exports.entriesToJSON = entriesToJSON;
    exports.entriesFromJSON = entriesFromJSON;
    exports.conversationHistoryToJSON = conversationHistoryToJSON;
    exports.conversationHistoryFromJSON = conversationHistoryFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var agenthandoffentry_js_1 = require_agenthandoffentry();
    var functioncallentry_js_1 = require_functioncallentry();
    var functionresultentry_js_1 = require_functionresultentry();
    var messageinputentry_js_1 = require_messageinputentry();
    var messageoutputentry_js_1 = require_messageoutputentry();
    var toolexecutionentry_js_1 = require_toolexecutionentry();
    exports.ConversationHistoryObject = {
      ConversationHistory: "conversation.history"
    };
    exports.ConversationHistoryObject$inboundSchema = z4.nativeEnum(exports.ConversationHistoryObject);
    exports.ConversationHistoryObject$outboundSchema = exports.ConversationHistoryObject$inboundSchema;
    var ConversationHistoryObject$;
    (function(ConversationHistoryObject$2) {
      ConversationHistoryObject$2.inboundSchema = exports.ConversationHistoryObject$inboundSchema;
      ConversationHistoryObject$2.outboundSchema = exports.ConversationHistoryObject$outboundSchema;
    })(ConversationHistoryObject$ || (exports.ConversationHistoryObject$ = ConversationHistoryObject$ = {}));
    exports.Entries$inboundSchema = z4.union([
      functionresultentry_js_1.FunctionResultEntry$inboundSchema,
      messageinputentry_js_1.MessageInputEntry$inboundSchema,
      functioncallentry_js_1.FunctionCallEntry$inboundSchema,
      toolexecutionentry_js_1.ToolExecutionEntry$inboundSchema,
      messageoutputentry_js_1.MessageOutputEntry$inboundSchema,
      agenthandoffentry_js_1.AgentHandoffEntry$inboundSchema
    ]);
    exports.Entries$outboundSchema = z4.union([
      functionresultentry_js_1.FunctionResultEntry$outboundSchema,
      messageinputentry_js_1.MessageInputEntry$outboundSchema,
      functioncallentry_js_1.FunctionCallEntry$outboundSchema,
      toolexecutionentry_js_1.ToolExecutionEntry$outboundSchema,
      messageoutputentry_js_1.MessageOutputEntry$outboundSchema,
      agenthandoffentry_js_1.AgentHandoffEntry$outboundSchema
    ]);
    var Entries$;
    (function(Entries$2) {
      Entries$2.inboundSchema = exports.Entries$inboundSchema;
      Entries$2.outboundSchema = exports.Entries$outboundSchema;
    })(Entries$ || (exports.Entries$ = Entries$ = {}));
    function entriesToJSON(entries) {
      return JSON.stringify(exports.Entries$outboundSchema.parse(entries));
    }
    function entriesFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.Entries$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'Entries' from JSON`);
    }
    exports.ConversationHistory$inboundSchema = z4.object({
      object: exports.ConversationHistoryObject$inboundSchema.default("conversation.history"),
      conversation_id: z4.string(),
      entries: z4.array(z4.union([
        functionresultentry_js_1.FunctionResultEntry$inboundSchema,
        messageinputentry_js_1.MessageInputEntry$inboundSchema,
        functioncallentry_js_1.FunctionCallEntry$inboundSchema,
        toolexecutionentry_js_1.ToolExecutionEntry$inboundSchema,
        messageoutputentry_js_1.MessageOutputEntry$inboundSchema,
        agenthandoffentry_js_1.AgentHandoffEntry$inboundSchema
      ]))
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "conversation_id": "conversationId"
      });
    });
    exports.ConversationHistory$outboundSchema = z4.object({
      object: exports.ConversationHistoryObject$outboundSchema.default("conversation.history"),
      conversationId: z4.string(),
      entries: z4.array(z4.union([
        functionresultentry_js_1.FunctionResultEntry$outboundSchema,
        messageinputentry_js_1.MessageInputEntry$outboundSchema,
        functioncallentry_js_1.FunctionCallEntry$outboundSchema,
        toolexecutionentry_js_1.ToolExecutionEntry$outboundSchema,
        messageoutputentry_js_1.MessageOutputEntry$outboundSchema,
        agenthandoffentry_js_1.AgentHandoffEntry$outboundSchema
      ]))
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        conversationId: "conversation_id"
      });
    });
    var ConversationHistory$;
    (function(ConversationHistory$2) {
      ConversationHistory$2.inboundSchema = exports.ConversationHistory$inboundSchema;
      ConversationHistory$2.outboundSchema = exports.ConversationHistory$outboundSchema;
    })(ConversationHistory$ || (exports.ConversationHistory$ = ConversationHistory$ = {}));
    function conversationHistoryToJSON(conversationHistory) {
      return JSON.stringify(exports.ConversationHistory$outboundSchema.parse(conversationHistory));
    }
    function conversationHistoryFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ConversationHistory$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ConversationHistory' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/messageentries.js
var require_messageentries = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/messageentries.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageEntries$ = exports.MessageEntries$outboundSchema = exports.MessageEntries$inboundSchema = void 0;
    exports.messageEntriesToJSON = messageEntriesToJSON;
    exports.messageEntriesFromJSON = messageEntriesFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var messageinputentry_js_1 = require_messageinputentry();
    var messageoutputentry_js_1 = require_messageoutputentry();
    exports.MessageEntries$inboundSchema = z4.union([
      messageinputentry_js_1.MessageInputEntry$inboundSchema,
      messageoutputentry_js_1.MessageOutputEntry$inboundSchema
    ]);
    exports.MessageEntries$outboundSchema = z4.union([
      messageinputentry_js_1.MessageInputEntry$outboundSchema,
      messageoutputentry_js_1.MessageOutputEntry$outboundSchema
    ]);
    var MessageEntries$;
    (function(MessageEntries$2) {
      MessageEntries$2.inboundSchema = exports.MessageEntries$inboundSchema;
      MessageEntries$2.outboundSchema = exports.MessageEntries$outboundSchema;
    })(MessageEntries$ || (exports.MessageEntries$ = MessageEntries$ = {}));
    function messageEntriesToJSON(messageEntries) {
      return JSON.stringify(exports.MessageEntries$outboundSchema.parse(messageEntries));
    }
    function messageEntriesFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.MessageEntries$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'MessageEntries' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/conversationmessages.js
var require_conversationmessages = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/conversationmessages.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConversationMessages$ = exports.ConversationMessages$outboundSchema = exports.ConversationMessages$inboundSchema = exports.ConversationMessagesObject$ = exports.ConversationMessagesObject$outboundSchema = exports.ConversationMessagesObject$inboundSchema = exports.ConversationMessagesObject = void 0;
    exports.conversationMessagesToJSON = conversationMessagesToJSON;
    exports.conversationMessagesFromJSON = conversationMessagesFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var messageentries_js_1 = require_messageentries();
    exports.ConversationMessagesObject = {
      ConversationMessages: "conversation.messages"
    };
    exports.ConversationMessagesObject$inboundSchema = z4.nativeEnum(exports.ConversationMessagesObject);
    exports.ConversationMessagesObject$outboundSchema = exports.ConversationMessagesObject$inboundSchema;
    var ConversationMessagesObject$;
    (function(ConversationMessagesObject$2) {
      ConversationMessagesObject$2.inboundSchema = exports.ConversationMessagesObject$inboundSchema;
      ConversationMessagesObject$2.outboundSchema = exports.ConversationMessagesObject$outboundSchema;
    })(ConversationMessagesObject$ || (exports.ConversationMessagesObject$ = ConversationMessagesObject$ = {}));
    exports.ConversationMessages$inboundSchema = z4.object({
      object: exports.ConversationMessagesObject$inboundSchema.default("conversation.messages"),
      conversation_id: z4.string(),
      messages: z4.array(messageentries_js_1.MessageEntries$inboundSchema)
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "conversation_id": "conversationId"
      });
    });
    exports.ConversationMessages$outboundSchema = z4.object({
      object: exports.ConversationMessagesObject$outboundSchema.default("conversation.messages"),
      conversationId: z4.string(),
      messages: z4.array(messageentries_js_1.MessageEntries$outboundSchema)
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        conversationId: "conversation_id"
      });
    });
    var ConversationMessages$;
    (function(ConversationMessages$2) {
      ConversationMessages$2.inboundSchema = exports.ConversationMessages$inboundSchema;
      ConversationMessages$2.outboundSchema = exports.ConversationMessages$outboundSchema;
    })(ConversationMessages$ || (exports.ConversationMessages$ = ConversationMessages$ = {}));
    function conversationMessagesToJSON(conversationMessages) {
      return JSON.stringify(exports.ConversationMessages$outboundSchema.parse(conversationMessages));
    }
    function conversationMessagesFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ConversationMessages$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ConversationMessages' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/conversationrequest.js
var require_conversationrequest = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/conversationrequest.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConversationRequest$ = exports.ConversationRequest$outboundSchema = exports.ConversationRequest$inboundSchema = exports.Tools$ = exports.Tools$outboundSchema = exports.Tools$inboundSchema = exports.HandoffExecution$ = exports.HandoffExecution$outboundSchema = exports.HandoffExecution$inboundSchema = exports.HandoffExecution = void 0;
    exports.toolsToJSON = toolsToJSON;
    exports.toolsFromJSON = toolsFromJSON;
    exports.conversationRequestToJSON = conversationRequestToJSON;
    exports.conversationRequestFromJSON = conversationRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var codeinterpretertool_js_1 = require_codeinterpretertool();
    var completionargs_js_1 = require_completionargs();
    var conversationinputs_js_1 = require_conversationinputs();
    var documentlibrarytool_js_1 = require_documentlibrarytool();
    var functiontool_js_1 = require_functiontool();
    var imagegenerationtool_js_1 = require_imagegenerationtool();
    var websearchpremiumtool_js_1 = require_websearchpremiumtool();
    var websearchtool_js_1 = require_websearchtool();
    exports.HandoffExecution = {
      Client: "client",
      Server: "server"
    };
    exports.HandoffExecution$inboundSchema = z4.nativeEnum(exports.HandoffExecution);
    exports.HandoffExecution$outboundSchema = exports.HandoffExecution$inboundSchema;
    var HandoffExecution$;
    (function(HandoffExecution$2) {
      HandoffExecution$2.inboundSchema = exports.HandoffExecution$inboundSchema;
      HandoffExecution$2.outboundSchema = exports.HandoffExecution$outboundSchema;
    })(HandoffExecution$ || (exports.HandoffExecution$ = HandoffExecution$ = {}));
    exports.Tools$inboundSchema = z4.union([
      codeinterpretertool_js_1.CodeInterpreterTool$inboundSchema.and(z4.object({ type: z4.literal("code_interpreter") }).transform((v2) => ({
        type: v2.type
      }))),
      imagegenerationtool_js_1.ImageGenerationTool$inboundSchema.and(z4.object({ type: z4.literal("image_generation") }).transform((v2) => ({
        type: v2.type
      }))),
      websearchtool_js_1.WebSearchTool$inboundSchema.and(z4.object({ type: z4.literal("web_search") }).transform((v2) => ({
        type: v2.type
      }))),
      websearchpremiumtool_js_1.WebSearchPremiumTool$inboundSchema.and(z4.object({ type: z4.literal("web_search_premium") }).transform((v2) => ({
        type: v2.type
      }))),
      documentlibrarytool_js_1.DocumentLibraryTool$inboundSchema.and(z4.object({ type: z4.literal("document_library") }).transform((v2) => ({
        type: v2.type
      }))),
      functiontool_js_1.FunctionTool$inboundSchema.and(z4.object({ type: z4.literal("function") }).transform((v2) => ({
        type: v2.type
      })))
    ]);
    exports.Tools$outboundSchema = z4.union([
      codeinterpretertool_js_1.CodeInterpreterTool$outboundSchema.and(z4.object({ type: z4.literal("code_interpreter") }).transform((v2) => ({
        type: v2.type
      }))),
      imagegenerationtool_js_1.ImageGenerationTool$outboundSchema.and(z4.object({ type: z4.literal("image_generation") }).transform((v2) => ({
        type: v2.type
      }))),
      websearchtool_js_1.WebSearchTool$outboundSchema.and(z4.object({ type: z4.literal("web_search") }).transform((v2) => ({
        type: v2.type
      }))),
      websearchpremiumtool_js_1.WebSearchPremiumTool$outboundSchema.and(z4.object({ type: z4.literal("web_search_premium") }).transform((v2) => ({
        type: v2.type
      }))),
      documentlibrarytool_js_1.DocumentLibraryTool$outboundSchema.and(z4.object({ type: z4.literal("document_library") }).transform((v2) => ({
        type: v2.type
      }))),
      functiontool_js_1.FunctionTool$outboundSchema.and(z4.object({ type: z4.literal("function") }).transform((v2) => ({
        type: v2.type
      })))
    ]);
    var Tools$;
    (function(Tools$2) {
      Tools$2.inboundSchema = exports.Tools$inboundSchema;
      Tools$2.outboundSchema = exports.Tools$outboundSchema;
    })(Tools$ || (exports.Tools$ = Tools$ = {}));
    function toolsToJSON(tools) {
      return JSON.stringify(exports.Tools$outboundSchema.parse(tools));
    }
    function toolsFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.Tools$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'Tools' from JSON`);
    }
    exports.ConversationRequest$inboundSchema = z4.object({
      inputs: conversationinputs_js_1.ConversationInputs$inboundSchema,
      stream: z4.boolean().default(false),
      store: z4.nullable(z4.boolean()).optional(),
      handoff_execution: z4.nullable(exports.HandoffExecution$inboundSchema).optional(),
      instructions: z4.nullable(z4.string()).optional(),
      tools: z4.nullable(z4.array(z4.union([
        codeinterpretertool_js_1.CodeInterpreterTool$inboundSchema.and(z4.object({ type: z4.literal("code_interpreter") }).transform((v2) => ({
          type: v2.type
        }))),
        imagegenerationtool_js_1.ImageGenerationTool$inboundSchema.and(z4.object({ type: z4.literal("image_generation") }).transform((v2) => ({
          type: v2.type
        }))),
        websearchtool_js_1.WebSearchTool$inboundSchema.and(z4.object({ type: z4.literal("web_search") }).transform((v2) => ({
          type: v2.type
        }))),
        websearchpremiumtool_js_1.WebSearchPremiumTool$inboundSchema.and(z4.object({ type: z4.literal("web_search_premium") }).transform((v2) => ({ type: v2.type }))),
        documentlibrarytool_js_1.DocumentLibraryTool$inboundSchema.and(z4.object({ type: z4.literal("document_library") }).transform((v2) => ({
          type: v2.type
        }))),
        functiontool_js_1.FunctionTool$inboundSchema.and(z4.object({ type: z4.literal("function") }).transform((v2) => ({
          type: v2.type
        })))
      ]))).optional(),
      completion_args: z4.nullable(completionargs_js_1.CompletionArgs$inboundSchema).optional(),
      name: z4.nullable(z4.string()).optional(),
      description: z4.nullable(z4.string()).optional(),
      agent_id: z4.nullable(z4.string()).optional(),
      model: z4.nullable(z4.string()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "handoff_execution": "handoffExecution",
        "completion_args": "completionArgs",
        "agent_id": "agentId"
      });
    });
    exports.ConversationRequest$outboundSchema = z4.object({
      inputs: conversationinputs_js_1.ConversationInputs$outboundSchema,
      stream: z4.boolean().default(false),
      store: z4.nullable(z4.boolean()).optional(),
      handoffExecution: z4.nullable(exports.HandoffExecution$outboundSchema).optional(),
      instructions: z4.nullable(z4.string()).optional(),
      tools: z4.nullable(z4.array(z4.union([
        codeinterpretertool_js_1.CodeInterpreterTool$outboundSchema.and(z4.object({ type: z4.literal("code_interpreter") }).transform((v2) => ({
          type: v2.type
        }))),
        imagegenerationtool_js_1.ImageGenerationTool$outboundSchema.and(z4.object({ type: z4.literal("image_generation") }).transform((v2) => ({
          type: v2.type
        }))),
        websearchtool_js_1.WebSearchTool$outboundSchema.and(z4.object({ type: z4.literal("web_search") }).transform((v2) => ({
          type: v2.type
        }))),
        websearchpremiumtool_js_1.WebSearchPremiumTool$outboundSchema.and(z4.object({ type: z4.literal("web_search_premium") }).transform((v2) => ({ type: v2.type }))),
        documentlibrarytool_js_1.DocumentLibraryTool$outboundSchema.and(z4.object({ type: z4.literal("document_library") }).transform((v2) => ({
          type: v2.type
        }))),
        functiontool_js_1.FunctionTool$outboundSchema.and(z4.object({ type: z4.literal("function") }).transform((v2) => ({
          type: v2.type
        })))
      ]))).optional(),
      completionArgs: z4.nullable(completionargs_js_1.CompletionArgs$outboundSchema).optional(),
      name: z4.nullable(z4.string()).optional(),
      description: z4.nullable(z4.string()).optional(),
      agentId: z4.nullable(z4.string()).optional(),
      model: z4.nullable(z4.string()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        handoffExecution: "handoff_execution",
        completionArgs: "completion_args",
        agentId: "agent_id"
      });
    });
    var ConversationRequest$;
    (function(ConversationRequest$2) {
      ConversationRequest$2.inboundSchema = exports.ConversationRequest$inboundSchema;
      ConversationRequest$2.outboundSchema = exports.ConversationRequest$outboundSchema;
    })(ConversationRequest$ || (exports.ConversationRequest$ = ConversationRequest$ = {}));
    function conversationRequestToJSON(conversationRequest) {
      return JSON.stringify(exports.ConversationRequest$outboundSchema.parse(conversationRequest));
    }
    function conversationRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ConversationRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ConversationRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/conversationresponse.js
var require_conversationresponse = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/conversationresponse.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConversationResponse$ = exports.ConversationResponse$outboundSchema = exports.ConversationResponse$inboundSchema = exports.Outputs$ = exports.Outputs$outboundSchema = exports.Outputs$inboundSchema = exports.ConversationResponseObject$ = exports.ConversationResponseObject$outboundSchema = exports.ConversationResponseObject$inboundSchema = exports.ConversationResponseObject = void 0;
    exports.outputsToJSON = outputsToJSON;
    exports.outputsFromJSON = outputsFromJSON;
    exports.conversationResponseToJSON = conversationResponseToJSON;
    exports.conversationResponseFromJSON = conversationResponseFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var agenthandoffentry_js_1 = require_agenthandoffentry();
    var conversationusageinfo_js_1 = require_conversationusageinfo();
    var functioncallentry_js_1 = require_functioncallentry();
    var messageoutputentry_js_1 = require_messageoutputentry();
    var toolexecutionentry_js_1 = require_toolexecutionentry();
    exports.ConversationResponseObject = {
      ConversationResponse: "conversation.response"
    };
    exports.ConversationResponseObject$inboundSchema = z4.nativeEnum(exports.ConversationResponseObject);
    exports.ConversationResponseObject$outboundSchema = exports.ConversationResponseObject$inboundSchema;
    var ConversationResponseObject$;
    (function(ConversationResponseObject$2) {
      ConversationResponseObject$2.inboundSchema = exports.ConversationResponseObject$inboundSchema;
      ConversationResponseObject$2.outboundSchema = exports.ConversationResponseObject$outboundSchema;
    })(ConversationResponseObject$ || (exports.ConversationResponseObject$ = ConversationResponseObject$ = {}));
    exports.Outputs$inboundSchema = z4.union([
      toolexecutionentry_js_1.ToolExecutionEntry$inboundSchema,
      functioncallentry_js_1.FunctionCallEntry$inboundSchema,
      messageoutputentry_js_1.MessageOutputEntry$inboundSchema,
      agenthandoffentry_js_1.AgentHandoffEntry$inboundSchema
    ]);
    exports.Outputs$outboundSchema = z4.union([
      toolexecutionentry_js_1.ToolExecutionEntry$outboundSchema,
      functioncallentry_js_1.FunctionCallEntry$outboundSchema,
      messageoutputentry_js_1.MessageOutputEntry$outboundSchema,
      agenthandoffentry_js_1.AgentHandoffEntry$outboundSchema
    ]);
    var Outputs$;
    (function(Outputs$2) {
      Outputs$2.inboundSchema = exports.Outputs$inboundSchema;
      Outputs$2.outboundSchema = exports.Outputs$outboundSchema;
    })(Outputs$ || (exports.Outputs$ = Outputs$ = {}));
    function outputsToJSON(outputs) {
      return JSON.stringify(exports.Outputs$outboundSchema.parse(outputs));
    }
    function outputsFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.Outputs$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'Outputs' from JSON`);
    }
    exports.ConversationResponse$inboundSchema = z4.object({
      object: exports.ConversationResponseObject$inboundSchema.default("conversation.response"),
      conversation_id: z4.string(),
      outputs: z4.array(z4.union([
        toolexecutionentry_js_1.ToolExecutionEntry$inboundSchema,
        functioncallentry_js_1.FunctionCallEntry$inboundSchema,
        messageoutputentry_js_1.MessageOutputEntry$inboundSchema,
        agenthandoffentry_js_1.AgentHandoffEntry$inboundSchema
      ])),
      usage: conversationusageinfo_js_1.ConversationUsageInfo$inboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "conversation_id": "conversationId"
      });
    });
    exports.ConversationResponse$outboundSchema = z4.object({
      object: exports.ConversationResponseObject$outboundSchema.default("conversation.response"),
      conversationId: z4.string(),
      outputs: z4.array(z4.union([
        toolexecutionentry_js_1.ToolExecutionEntry$outboundSchema,
        functioncallentry_js_1.FunctionCallEntry$outboundSchema,
        messageoutputentry_js_1.MessageOutputEntry$outboundSchema,
        agenthandoffentry_js_1.AgentHandoffEntry$outboundSchema
      ])),
      usage: conversationusageinfo_js_1.ConversationUsageInfo$outboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        conversationId: "conversation_id"
      });
    });
    var ConversationResponse$;
    (function(ConversationResponse$2) {
      ConversationResponse$2.inboundSchema = exports.ConversationResponse$inboundSchema;
      ConversationResponse$2.outboundSchema = exports.ConversationResponse$outboundSchema;
    })(ConversationResponse$ || (exports.ConversationResponse$ = ConversationResponse$ = {}));
    function conversationResponseToJSON(conversationResponse) {
      return JSON.stringify(exports.ConversationResponse$outboundSchema.parse(conversationResponse));
    }
    function conversationResponseFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ConversationResponse$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ConversationResponse' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/conversationrestartrequest.js
var require_conversationrestartrequest = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/conversationrestartrequest.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConversationRestartRequest$ = exports.ConversationRestartRequest$outboundSchema = exports.ConversationRestartRequest$inboundSchema = exports.ConversationRestartRequestHandoffExecution$ = exports.ConversationRestartRequestHandoffExecution$outboundSchema = exports.ConversationRestartRequestHandoffExecution$inboundSchema = exports.ConversationRestartRequestHandoffExecution = void 0;
    exports.conversationRestartRequestToJSON = conversationRestartRequestToJSON;
    exports.conversationRestartRequestFromJSON = conversationRestartRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var completionargs_js_1 = require_completionargs();
    var conversationinputs_js_1 = require_conversationinputs();
    exports.ConversationRestartRequestHandoffExecution = {
      Client: "client",
      Server: "server"
    };
    exports.ConversationRestartRequestHandoffExecution$inboundSchema = z4.nativeEnum(exports.ConversationRestartRequestHandoffExecution);
    exports.ConversationRestartRequestHandoffExecution$outboundSchema = exports.ConversationRestartRequestHandoffExecution$inboundSchema;
    var ConversationRestartRequestHandoffExecution$;
    (function(ConversationRestartRequestHandoffExecution$2) {
      ConversationRestartRequestHandoffExecution$2.inboundSchema = exports.ConversationRestartRequestHandoffExecution$inboundSchema;
      ConversationRestartRequestHandoffExecution$2.outboundSchema = exports.ConversationRestartRequestHandoffExecution$outboundSchema;
    })(ConversationRestartRequestHandoffExecution$ || (exports.ConversationRestartRequestHandoffExecution$ = ConversationRestartRequestHandoffExecution$ = {}));
    exports.ConversationRestartRequest$inboundSchema = z4.object({
      inputs: conversationinputs_js_1.ConversationInputs$inboundSchema,
      stream: z4.boolean().default(false),
      store: z4.boolean().default(true),
      handoff_execution: exports.ConversationRestartRequestHandoffExecution$inboundSchema.default("server"),
      completion_args: completionargs_js_1.CompletionArgs$inboundSchema.optional(),
      from_entry_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "handoff_execution": "handoffExecution",
        "completion_args": "completionArgs",
        "from_entry_id": "fromEntryId"
      });
    });
    exports.ConversationRestartRequest$outboundSchema = z4.object({
      inputs: conversationinputs_js_1.ConversationInputs$outboundSchema,
      stream: z4.boolean().default(false),
      store: z4.boolean().default(true),
      handoffExecution: exports.ConversationRestartRequestHandoffExecution$outboundSchema.default("server"),
      completionArgs: completionargs_js_1.CompletionArgs$outboundSchema.optional(),
      fromEntryId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        handoffExecution: "handoff_execution",
        completionArgs: "completion_args",
        fromEntryId: "from_entry_id"
      });
    });
    var ConversationRestartRequest$;
    (function(ConversationRestartRequest$2) {
      ConversationRestartRequest$2.inboundSchema = exports.ConversationRestartRequest$inboundSchema;
      ConversationRestartRequest$2.outboundSchema = exports.ConversationRestartRequest$outboundSchema;
    })(ConversationRestartRequest$ || (exports.ConversationRestartRequest$ = ConversationRestartRequest$ = {}));
    function conversationRestartRequestToJSON(conversationRestartRequest) {
      return JSON.stringify(exports.ConversationRestartRequest$outboundSchema.parse(conversationRestartRequest));
    }
    function conversationRestartRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ConversationRestartRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ConversationRestartRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/conversationrestartstreamrequest.js
var require_conversationrestartstreamrequest = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/conversationrestartstreamrequest.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConversationRestartStreamRequest$ = exports.ConversationRestartStreamRequest$outboundSchema = exports.ConversationRestartStreamRequest$inboundSchema = exports.ConversationRestartStreamRequestHandoffExecution$ = exports.ConversationRestartStreamRequestHandoffExecution$outboundSchema = exports.ConversationRestartStreamRequestHandoffExecution$inboundSchema = exports.ConversationRestartStreamRequestHandoffExecution = void 0;
    exports.conversationRestartStreamRequestToJSON = conversationRestartStreamRequestToJSON;
    exports.conversationRestartStreamRequestFromJSON = conversationRestartStreamRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var completionargs_js_1 = require_completionargs();
    var conversationinputs_js_1 = require_conversationinputs();
    exports.ConversationRestartStreamRequestHandoffExecution = {
      Client: "client",
      Server: "server"
    };
    exports.ConversationRestartStreamRequestHandoffExecution$inboundSchema = z4.nativeEnum(exports.ConversationRestartStreamRequestHandoffExecution);
    exports.ConversationRestartStreamRequestHandoffExecution$outboundSchema = exports.ConversationRestartStreamRequestHandoffExecution$inboundSchema;
    var ConversationRestartStreamRequestHandoffExecution$;
    (function(ConversationRestartStreamRequestHandoffExecution$2) {
      ConversationRestartStreamRequestHandoffExecution$2.inboundSchema = exports.ConversationRestartStreamRequestHandoffExecution$inboundSchema;
      ConversationRestartStreamRequestHandoffExecution$2.outboundSchema = exports.ConversationRestartStreamRequestHandoffExecution$outboundSchema;
    })(ConversationRestartStreamRequestHandoffExecution$ || (exports.ConversationRestartStreamRequestHandoffExecution$ = ConversationRestartStreamRequestHandoffExecution$ = {}));
    exports.ConversationRestartStreamRequest$inboundSchema = z4.object({
      inputs: conversationinputs_js_1.ConversationInputs$inboundSchema,
      stream: z4.boolean().default(true),
      store: z4.boolean().default(true),
      handoff_execution: exports.ConversationRestartStreamRequestHandoffExecution$inboundSchema.default("server"),
      completion_args: completionargs_js_1.CompletionArgs$inboundSchema.optional(),
      from_entry_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "handoff_execution": "handoffExecution",
        "completion_args": "completionArgs",
        "from_entry_id": "fromEntryId"
      });
    });
    exports.ConversationRestartStreamRequest$outboundSchema = z4.object({
      inputs: conversationinputs_js_1.ConversationInputs$outboundSchema,
      stream: z4.boolean().default(true),
      store: z4.boolean().default(true),
      handoffExecution: exports.ConversationRestartStreamRequestHandoffExecution$outboundSchema.default("server"),
      completionArgs: completionargs_js_1.CompletionArgs$outboundSchema.optional(),
      fromEntryId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        handoffExecution: "handoff_execution",
        completionArgs: "completion_args",
        fromEntryId: "from_entry_id"
      });
    });
    var ConversationRestartStreamRequest$;
    (function(ConversationRestartStreamRequest$2) {
      ConversationRestartStreamRequest$2.inboundSchema = exports.ConversationRestartStreamRequest$inboundSchema;
      ConversationRestartStreamRequest$2.outboundSchema = exports.ConversationRestartStreamRequest$outboundSchema;
    })(ConversationRestartStreamRequest$ || (exports.ConversationRestartStreamRequest$ = ConversationRestartStreamRequest$ = {}));
    function conversationRestartStreamRequestToJSON(conversationRestartStreamRequest) {
      return JSON.stringify(exports.ConversationRestartStreamRequest$outboundSchema.parse(conversationRestartStreamRequest));
    }
    function conversationRestartStreamRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ConversationRestartStreamRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ConversationRestartStreamRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/conversationstreamrequest.js
var require_conversationstreamrequest = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/conversationstreamrequest.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConversationStreamRequest$ = exports.ConversationStreamRequest$outboundSchema = exports.ConversationStreamRequest$inboundSchema = exports.ConversationStreamRequestTools$ = exports.ConversationStreamRequestTools$outboundSchema = exports.ConversationStreamRequestTools$inboundSchema = exports.ConversationStreamRequestHandoffExecution$ = exports.ConversationStreamRequestHandoffExecution$outboundSchema = exports.ConversationStreamRequestHandoffExecution$inboundSchema = exports.ConversationStreamRequestHandoffExecution = void 0;
    exports.conversationStreamRequestToolsToJSON = conversationStreamRequestToolsToJSON;
    exports.conversationStreamRequestToolsFromJSON = conversationStreamRequestToolsFromJSON;
    exports.conversationStreamRequestToJSON = conversationStreamRequestToJSON;
    exports.conversationStreamRequestFromJSON = conversationStreamRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var codeinterpretertool_js_1 = require_codeinterpretertool();
    var completionargs_js_1 = require_completionargs();
    var conversationinputs_js_1 = require_conversationinputs();
    var documentlibrarytool_js_1 = require_documentlibrarytool();
    var functiontool_js_1 = require_functiontool();
    var imagegenerationtool_js_1 = require_imagegenerationtool();
    var websearchpremiumtool_js_1 = require_websearchpremiumtool();
    var websearchtool_js_1 = require_websearchtool();
    exports.ConversationStreamRequestHandoffExecution = {
      Client: "client",
      Server: "server"
    };
    exports.ConversationStreamRequestHandoffExecution$inboundSchema = z4.nativeEnum(exports.ConversationStreamRequestHandoffExecution);
    exports.ConversationStreamRequestHandoffExecution$outboundSchema = exports.ConversationStreamRequestHandoffExecution$inboundSchema;
    var ConversationStreamRequestHandoffExecution$;
    (function(ConversationStreamRequestHandoffExecution$2) {
      ConversationStreamRequestHandoffExecution$2.inboundSchema = exports.ConversationStreamRequestHandoffExecution$inboundSchema;
      ConversationStreamRequestHandoffExecution$2.outboundSchema = exports.ConversationStreamRequestHandoffExecution$outboundSchema;
    })(ConversationStreamRequestHandoffExecution$ || (exports.ConversationStreamRequestHandoffExecution$ = ConversationStreamRequestHandoffExecution$ = {}));
    exports.ConversationStreamRequestTools$inboundSchema = z4.union([
      codeinterpretertool_js_1.CodeInterpreterTool$inboundSchema.and(z4.object({ type: z4.literal("code_interpreter") }).transform((v2) => ({
        type: v2.type
      }))),
      imagegenerationtool_js_1.ImageGenerationTool$inboundSchema.and(z4.object({ type: z4.literal("image_generation") }).transform((v2) => ({
        type: v2.type
      }))),
      websearchtool_js_1.WebSearchTool$inboundSchema.and(z4.object({ type: z4.literal("web_search") }).transform((v2) => ({
        type: v2.type
      }))),
      websearchpremiumtool_js_1.WebSearchPremiumTool$inboundSchema.and(z4.object({ type: z4.literal("web_search_premium") }).transform((v2) => ({
        type: v2.type
      }))),
      documentlibrarytool_js_1.DocumentLibraryTool$inboundSchema.and(z4.object({ type: z4.literal("document_library") }).transform((v2) => ({
        type: v2.type
      }))),
      functiontool_js_1.FunctionTool$inboundSchema.and(z4.object({ type: z4.literal("function") }).transform((v2) => ({
        type: v2.type
      })))
    ]);
    exports.ConversationStreamRequestTools$outboundSchema = z4.union([
      codeinterpretertool_js_1.CodeInterpreterTool$outboundSchema.and(z4.object({ type: z4.literal("code_interpreter") }).transform((v2) => ({
        type: v2.type
      }))),
      imagegenerationtool_js_1.ImageGenerationTool$outboundSchema.and(z4.object({ type: z4.literal("image_generation") }).transform((v2) => ({
        type: v2.type
      }))),
      websearchtool_js_1.WebSearchTool$outboundSchema.and(z4.object({ type: z4.literal("web_search") }).transform((v2) => ({
        type: v2.type
      }))),
      websearchpremiumtool_js_1.WebSearchPremiumTool$outboundSchema.and(z4.object({ type: z4.literal("web_search_premium") }).transform((v2) => ({
        type: v2.type
      }))),
      documentlibrarytool_js_1.DocumentLibraryTool$outboundSchema.and(z4.object({ type: z4.literal("document_library") }).transform((v2) => ({
        type: v2.type
      }))),
      functiontool_js_1.FunctionTool$outboundSchema.and(z4.object({ type: z4.literal("function") }).transform((v2) => ({
        type: v2.type
      })))
    ]);
    var ConversationStreamRequestTools$;
    (function(ConversationStreamRequestTools$2) {
      ConversationStreamRequestTools$2.inboundSchema = exports.ConversationStreamRequestTools$inboundSchema;
      ConversationStreamRequestTools$2.outboundSchema = exports.ConversationStreamRequestTools$outboundSchema;
    })(ConversationStreamRequestTools$ || (exports.ConversationStreamRequestTools$ = ConversationStreamRequestTools$ = {}));
    function conversationStreamRequestToolsToJSON(conversationStreamRequestTools) {
      return JSON.stringify(exports.ConversationStreamRequestTools$outboundSchema.parse(conversationStreamRequestTools));
    }
    function conversationStreamRequestToolsFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ConversationStreamRequestTools$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ConversationStreamRequestTools' from JSON`);
    }
    exports.ConversationStreamRequest$inboundSchema = z4.object({
      inputs: conversationinputs_js_1.ConversationInputs$inboundSchema,
      stream: z4.boolean().default(true),
      store: z4.nullable(z4.boolean()).optional(),
      handoff_execution: z4.nullable(exports.ConversationStreamRequestHandoffExecution$inboundSchema).optional(),
      instructions: z4.nullable(z4.string()).optional(),
      tools: z4.nullable(z4.array(z4.union([
        codeinterpretertool_js_1.CodeInterpreterTool$inboundSchema.and(z4.object({ type: z4.literal("code_interpreter") }).transform((v2) => ({
          type: v2.type
        }))),
        imagegenerationtool_js_1.ImageGenerationTool$inboundSchema.and(z4.object({ type: z4.literal("image_generation") }).transform((v2) => ({
          type: v2.type
        }))),
        websearchtool_js_1.WebSearchTool$inboundSchema.and(z4.object({ type: z4.literal("web_search") }).transform((v2) => ({
          type: v2.type
        }))),
        websearchpremiumtool_js_1.WebSearchPremiumTool$inboundSchema.and(z4.object({ type: z4.literal("web_search_premium") }).transform((v2) => ({ type: v2.type }))),
        documentlibrarytool_js_1.DocumentLibraryTool$inboundSchema.and(z4.object({ type: z4.literal("document_library") }).transform((v2) => ({
          type: v2.type
        }))),
        functiontool_js_1.FunctionTool$inboundSchema.and(z4.object({ type: z4.literal("function") }).transform((v2) => ({
          type: v2.type
        })))
      ]))).optional(),
      completion_args: z4.nullable(completionargs_js_1.CompletionArgs$inboundSchema).optional(),
      name: z4.nullable(z4.string()).optional(),
      description: z4.nullable(z4.string()).optional(),
      agent_id: z4.nullable(z4.string()).optional(),
      model: z4.nullable(z4.string()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "handoff_execution": "handoffExecution",
        "completion_args": "completionArgs",
        "agent_id": "agentId"
      });
    });
    exports.ConversationStreamRequest$outboundSchema = z4.object({
      inputs: conversationinputs_js_1.ConversationInputs$outboundSchema,
      stream: z4.boolean().default(true),
      store: z4.nullable(z4.boolean()).optional(),
      handoffExecution: z4.nullable(exports.ConversationStreamRequestHandoffExecution$outboundSchema).optional(),
      instructions: z4.nullable(z4.string()).optional(),
      tools: z4.nullable(z4.array(z4.union([
        codeinterpretertool_js_1.CodeInterpreterTool$outboundSchema.and(z4.object({ type: z4.literal("code_interpreter") }).transform((v2) => ({
          type: v2.type
        }))),
        imagegenerationtool_js_1.ImageGenerationTool$outboundSchema.and(z4.object({ type: z4.literal("image_generation") }).transform((v2) => ({
          type: v2.type
        }))),
        websearchtool_js_1.WebSearchTool$outboundSchema.and(z4.object({ type: z4.literal("web_search") }).transform((v2) => ({
          type: v2.type
        }))),
        websearchpremiumtool_js_1.WebSearchPremiumTool$outboundSchema.and(z4.object({ type: z4.literal("web_search_premium") }).transform((v2) => ({ type: v2.type }))),
        documentlibrarytool_js_1.DocumentLibraryTool$outboundSchema.and(z4.object({ type: z4.literal("document_library") }).transform((v2) => ({
          type: v2.type
        }))),
        functiontool_js_1.FunctionTool$outboundSchema.and(z4.object({ type: z4.literal("function") }).transform((v2) => ({
          type: v2.type
        })))
      ]))).optional(),
      completionArgs: z4.nullable(completionargs_js_1.CompletionArgs$outboundSchema).optional(),
      name: z4.nullable(z4.string()).optional(),
      description: z4.nullable(z4.string()).optional(),
      agentId: z4.nullable(z4.string()).optional(),
      model: z4.nullable(z4.string()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        handoffExecution: "handoff_execution",
        completionArgs: "completion_args",
        agentId: "agent_id"
      });
    });
    var ConversationStreamRequest$;
    (function(ConversationStreamRequest$2) {
      ConversationStreamRequest$2.inboundSchema = exports.ConversationStreamRequest$inboundSchema;
      ConversationStreamRequest$2.outboundSchema = exports.ConversationStreamRequest$outboundSchema;
    })(ConversationStreamRequest$ || (exports.ConversationStreamRequest$ = ConversationStreamRequest$ = {}));
    function conversationStreamRequestToJSON(conversationStreamRequest) {
      return JSON.stringify(exports.ConversationStreamRequest$outboundSchema.parse(conversationStreamRequest));
    }
    function conversationStreamRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ConversationStreamRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ConversationStreamRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/deletefileout.js
var require_deletefileout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/deletefileout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeleteFileOut$ = exports.DeleteFileOut$outboundSchema = exports.DeleteFileOut$inboundSchema = void 0;
    exports.deleteFileOutToJSON = deleteFileOutToJSON;
    exports.deleteFileOutFromJSON = deleteFileOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    exports.DeleteFileOut$inboundSchema = z4.object({
      id: z4.string(),
      object: z4.string(),
      deleted: z4.boolean()
    });
    exports.DeleteFileOut$outboundSchema = z4.object({
      id: z4.string(),
      object: z4.string(),
      deleted: z4.boolean()
    });
    var DeleteFileOut$;
    (function(DeleteFileOut$2) {
      DeleteFileOut$2.inboundSchema = exports.DeleteFileOut$inboundSchema;
      DeleteFileOut$2.outboundSchema = exports.DeleteFileOut$outboundSchema;
    })(DeleteFileOut$ || (exports.DeleteFileOut$ = DeleteFileOut$ = {}));
    function deleteFileOutToJSON(deleteFileOut) {
      return JSON.stringify(exports.DeleteFileOut$outboundSchema.parse(deleteFileOut));
    }
    function deleteFileOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.DeleteFileOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'DeleteFileOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/deletemodelout.js
var require_deletemodelout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/deletemodelout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeleteModelOut$ = exports.DeleteModelOut$outboundSchema = exports.DeleteModelOut$inboundSchema = void 0;
    exports.deleteModelOutToJSON = deleteModelOutToJSON;
    exports.deleteModelOutFromJSON = deleteModelOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    exports.DeleteModelOut$inboundSchema = z4.object({
      id: z4.string(),
      object: z4.string().default("model"),
      deleted: z4.boolean().default(true)
    });
    exports.DeleteModelOut$outboundSchema = z4.object({
      id: z4.string(),
      object: z4.string().default("model"),
      deleted: z4.boolean().default(true)
    });
    var DeleteModelOut$;
    (function(DeleteModelOut$2) {
      DeleteModelOut$2.inboundSchema = exports.DeleteModelOut$inboundSchema;
      DeleteModelOut$2.outboundSchema = exports.DeleteModelOut$outboundSchema;
    })(DeleteModelOut$ || (exports.DeleteModelOut$ = DeleteModelOut$ = {}));
    function deleteModelOutToJSON(deleteModelOut) {
      return JSON.stringify(exports.DeleteModelOut$outboundSchema.parse(deleteModelOut));
    }
    function deleteModelOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.DeleteModelOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'DeleteModelOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/documentout.js
var require_documentout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/documentout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DocumentOut$ = exports.DocumentOut$outboundSchema = exports.DocumentOut$inboundSchema = void 0;
    exports.documentOutToJSON = documentOutToJSON;
    exports.documentOutFromJSON = documentOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.DocumentOut$inboundSchema = z4.object({
      id: z4.string(),
      library_id: z4.string(),
      hash: z4.string(),
      mime_type: z4.string(),
      extension: z4.string(),
      size: z4.number().int(),
      name: z4.string(),
      summary: z4.nullable(z4.string()).optional(),
      created_at: z4.string().datetime({ offset: true }).transform((v2) => new Date(v2)),
      last_processed_at: z4.nullable(z4.string().datetime({ offset: true }).transform((v2) => new Date(v2))).optional(),
      number_of_pages: z4.nullable(z4.number().int()).optional(),
      processing_status: z4.string(),
      uploaded_by_id: z4.string(),
      uploaded_by_type: z4.string(),
      tokens_processing_main_content: z4.nullable(z4.number().int()).optional(),
      tokens_processing_summary: z4.nullable(z4.number().int()).optional(),
      tokens_processing_total: z4.number().int()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "library_id": "libraryId",
        "mime_type": "mimeType",
        "created_at": "createdAt",
        "last_processed_at": "lastProcessedAt",
        "number_of_pages": "numberOfPages",
        "processing_status": "processingStatus",
        "uploaded_by_id": "uploadedById",
        "uploaded_by_type": "uploadedByType",
        "tokens_processing_main_content": "tokensProcessingMainContent",
        "tokens_processing_summary": "tokensProcessingSummary",
        "tokens_processing_total": "tokensProcessingTotal"
      });
    });
    exports.DocumentOut$outboundSchema = z4.object({
      id: z4.string(),
      libraryId: z4.string(),
      hash: z4.string(),
      mimeType: z4.string(),
      extension: z4.string(),
      size: z4.number().int(),
      name: z4.string(),
      summary: z4.nullable(z4.string()).optional(),
      createdAt: z4.date().transform((v2) => v2.toISOString()),
      lastProcessedAt: z4.nullable(z4.date().transform((v2) => v2.toISOString())).optional(),
      numberOfPages: z4.nullable(z4.number().int()).optional(),
      processingStatus: z4.string(),
      uploadedById: z4.string(),
      uploadedByType: z4.string(),
      tokensProcessingMainContent: z4.nullable(z4.number().int()).optional(),
      tokensProcessingSummary: z4.nullable(z4.number().int()).optional(),
      tokensProcessingTotal: z4.number().int()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        libraryId: "library_id",
        mimeType: "mime_type",
        createdAt: "created_at",
        lastProcessedAt: "last_processed_at",
        numberOfPages: "number_of_pages",
        processingStatus: "processing_status",
        uploadedById: "uploaded_by_id",
        uploadedByType: "uploaded_by_type",
        tokensProcessingMainContent: "tokens_processing_main_content",
        tokensProcessingSummary: "tokens_processing_summary",
        tokensProcessingTotal: "tokens_processing_total"
      });
    });
    var DocumentOut$;
    (function(DocumentOut$2) {
      DocumentOut$2.inboundSchema = exports.DocumentOut$inboundSchema;
      DocumentOut$2.outboundSchema = exports.DocumentOut$outboundSchema;
    })(DocumentOut$ || (exports.DocumentOut$ = DocumentOut$ = {}));
    function documentOutToJSON(documentOut) {
      return JSON.stringify(exports.DocumentOut$outboundSchema.parse(documentOut));
    }
    function documentOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.DocumentOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'DocumentOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/documenttextcontent.js
var require_documenttextcontent = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/documenttextcontent.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DocumentTextContent$ = exports.DocumentTextContent$outboundSchema = exports.DocumentTextContent$inboundSchema = void 0;
    exports.documentTextContentToJSON = documentTextContentToJSON;
    exports.documentTextContentFromJSON = documentTextContentFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    exports.DocumentTextContent$inboundSchema = z4.object({
      text: z4.string()
    });
    exports.DocumentTextContent$outboundSchema = z4.object({
      text: z4.string()
    });
    var DocumentTextContent$;
    (function(DocumentTextContent$2) {
      DocumentTextContent$2.inboundSchema = exports.DocumentTextContent$inboundSchema;
      DocumentTextContent$2.outboundSchema = exports.DocumentTextContent$outboundSchema;
    })(DocumentTextContent$ || (exports.DocumentTextContent$ = DocumentTextContent$ = {}));
    function documentTextContentToJSON(documentTextContent) {
      return JSON.stringify(exports.DocumentTextContent$outboundSchema.parse(documentTextContent));
    }
    function documentTextContentFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.DocumentTextContent$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'DocumentTextContent' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/documentupdatein.js
var require_documentupdatein = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/documentupdatein.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DocumentUpdateIn$ = exports.DocumentUpdateIn$outboundSchema = exports.DocumentUpdateIn$inboundSchema = void 0;
    exports.documentUpdateInToJSON = documentUpdateInToJSON;
    exports.documentUpdateInFromJSON = documentUpdateInFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    exports.DocumentUpdateIn$inboundSchema = z4.object({
      name: z4.nullable(z4.string()).optional()
    });
    exports.DocumentUpdateIn$outboundSchema = z4.object({
      name: z4.nullable(z4.string()).optional()
    });
    var DocumentUpdateIn$;
    (function(DocumentUpdateIn$2) {
      DocumentUpdateIn$2.inboundSchema = exports.DocumentUpdateIn$inboundSchema;
      DocumentUpdateIn$2.outboundSchema = exports.DocumentUpdateIn$outboundSchema;
    })(DocumentUpdateIn$ || (exports.DocumentUpdateIn$ = DocumentUpdateIn$ = {}));
    function documentUpdateInToJSON(documentUpdateIn) {
      return JSON.stringify(exports.DocumentUpdateIn$outboundSchema.parse(documentUpdateIn));
    }
    function documentUpdateInFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.DocumentUpdateIn$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'DocumentUpdateIn' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/embeddingdtype.js
var require_embeddingdtype = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/embeddingdtype.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EmbeddingDtype$ = exports.EmbeddingDtype$outboundSchema = exports.EmbeddingDtype$inboundSchema = exports.EmbeddingDtype = void 0;
    var z4 = __importStar(__require("zod"));
    exports.EmbeddingDtype = {
      Float: "float",
      Int8: "int8",
      Uint8: "uint8",
      Binary: "binary",
      Ubinary: "ubinary"
    };
    exports.EmbeddingDtype$inboundSchema = z4.nativeEnum(exports.EmbeddingDtype);
    exports.EmbeddingDtype$outboundSchema = exports.EmbeddingDtype$inboundSchema;
    var EmbeddingDtype$;
    (function(EmbeddingDtype$2) {
      EmbeddingDtype$2.inboundSchema = exports.EmbeddingDtype$inboundSchema;
      EmbeddingDtype$2.outboundSchema = exports.EmbeddingDtype$outboundSchema;
    })(EmbeddingDtype$ || (exports.EmbeddingDtype$ = EmbeddingDtype$ = {}));
  }
});

// ../node_modules/@mistralai/mistralai/models/components/embeddingrequest.js
var require_embeddingrequest = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/embeddingrequest.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EmbeddingRequest$ = exports.EmbeddingRequest$outboundSchema = exports.EmbeddingRequest$inboundSchema = exports.EmbeddingRequestInputs$ = exports.EmbeddingRequestInputs$outboundSchema = exports.EmbeddingRequestInputs$inboundSchema = void 0;
    exports.embeddingRequestInputsToJSON = embeddingRequestInputsToJSON;
    exports.embeddingRequestInputsFromJSON = embeddingRequestInputsFromJSON;
    exports.embeddingRequestToJSON = embeddingRequestToJSON;
    exports.embeddingRequestFromJSON = embeddingRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var embeddingdtype_js_1 = require_embeddingdtype();
    exports.EmbeddingRequestInputs$inboundSchema = z4.union([z4.string(), z4.array(z4.string())]);
    exports.EmbeddingRequestInputs$outboundSchema = z4.union([z4.string(), z4.array(z4.string())]);
    var EmbeddingRequestInputs$;
    (function(EmbeddingRequestInputs$2) {
      EmbeddingRequestInputs$2.inboundSchema = exports.EmbeddingRequestInputs$inboundSchema;
      EmbeddingRequestInputs$2.outboundSchema = exports.EmbeddingRequestInputs$outboundSchema;
    })(EmbeddingRequestInputs$ || (exports.EmbeddingRequestInputs$ = EmbeddingRequestInputs$ = {}));
    function embeddingRequestInputsToJSON(embeddingRequestInputs) {
      return JSON.stringify(exports.EmbeddingRequestInputs$outboundSchema.parse(embeddingRequestInputs));
    }
    function embeddingRequestInputsFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.EmbeddingRequestInputs$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'EmbeddingRequestInputs' from JSON`);
    }
    exports.EmbeddingRequest$inboundSchema = z4.object({
      model: z4.string(),
      input: z4.union([z4.string(), z4.array(z4.string())]),
      output_dimension: z4.nullable(z4.number().int()).optional(),
      output_dtype: embeddingdtype_js_1.EmbeddingDtype$inboundSchema.optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "input": "inputs",
        "output_dimension": "outputDimension",
        "output_dtype": "outputDtype"
      });
    });
    exports.EmbeddingRequest$outboundSchema = z4.object({
      model: z4.string(),
      inputs: z4.union([z4.string(), z4.array(z4.string())]),
      outputDimension: z4.nullable(z4.number().int()).optional(),
      outputDtype: embeddingdtype_js_1.EmbeddingDtype$outboundSchema.optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        inputs: "input",
        outputDimension: "output_dimension",
        outputDtype: "output_dtype"
      });
    });
    var EmbeddingRequest$;
    (function(EmbeddingRequest$2) {
      EmbeddingRequest$2.inboundSchema = exports.EmbeddingRequest$inboundSchema;
      EmbeddingRequest$2.outboundSchema = exports.EmbeddingRequest$outboundSchema;
    })(EmbeddingRequest$ || (exports.EmbeddingRequest$ = EmbeddingRequest$ = {}));
    function embeddingRequestToJSON(embeddingRequest) {
      return JSON.stringify(exports.EmbeddingRequest$outboundSchema.parse(embeddingRequest));
    }
    function embeddingRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.EmbeddingRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'EmbeddingRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/embeddingresponsedata.js
var require_embeddingresponsedata = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/embeddingresponsedata.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EmbeddingResponseData$ = exports.EmbeddingResponseData$outboundSchema = exports.EmbeddingResponseData$inboundSchema = void 0;
    exports.embeddingResponseDataToJSON = embeddingResponseDataToJSON;
    exports.embeddingResponseDataFromJSON = embeddingResponseDataFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    exports.EmbeddingResponseData$inboundSchema = z4.object({
      object: z4.string().optional(),
      embedding: z4.array(z4.number()).optional(),
      index: z4.number().int().optional()
    });
    exports.EmbeddingResponseData$outboundSchema = z4.object({
      object: z4.string().optional(),
      embedding: z4.array(z4.number()).optional(),
      index: z4.number().int().optional()
    });
    var EmbeddingResponseData$;
    (function(EmbeddingResponseData$2) {
      EmbeddingResponseData$2.inboundSchema = exports.EmbeddingResponseData$inboundSchema;
      EmbeddingResponseData$2.outboundSchema = exports.EmbeddingResponseData$outboundSchema;
    })(EmbeddingResponseData$ || (exports.EmbeddingResponseData$ = EmbeddingResponseData$ = {}));
    function embeddingResponseDataToJSON(embeddingResponseData) {
      return JSON.stringify(exports.EmbeddingResponseData$outboundSchema.parse(embeddingResponseData));
    }
    function embeddingResponseDataFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.EmbeddingResponseData$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'EmbeddingResponseData' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/embeddingresponse.js
var require_embeddingresponse = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/embeddingresponse.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EmbeddingResponse$ = exports.EmbeddingResponse$outboundSchema = exports.EmbeddingResponse$inboundSchema = void 0;
    exports.embeddingResponseToJSON = embeddingResponseToJSON;
    exports.embeddingResponseFromJSON = embeddingResponseFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var embeddingresponsedata_js_1 = require_embeddingresponsedata();
    var usageinfo_js_1 = require_usageinfo();
    exports.EmbeddingResponse$inboundSchema = z4.object({
      id: z4.string(),
      object: z4.string(),
      model: z4.string(),
      usage: usageinfo_js_1.UsageInfo$inboundSchema,
      data: z4.array(embeddingresponsedata_js_1.EmbeddingResponseData$inboundSchema)
    });
    exports.EmbeddingResponse$outboundSchema = z4.object({
      id: z4.string(),
      object: z4.string(),
      model: z4.string(),
      usage: usageinfo_js_1.UsageInfo$outboundSchema,
      data: z4.array(embeddingresponsedata_js_1.EmbeddingResponseData$outboundSchema)
    });
    var EmbeddingResponse$;
    (function(EmbeddingResponse$2) {
      EmbeddingResponse$2.inboundSchema = exports.EmbeddingResponse$inboundSchema;
      EmbeddingResponse$2.outboundSchema = exports.EmbeddingResponse$outboundSchema;
    })(EmbeddingResponse$ || (exports.EmbeddingResponse$ = EmbeddingResponse$ = {}));
    function embeddingResponseToJSON(embeddingResponse) {
      return JSON.stringify(exports.EmbeddingResponse$outboundSchema.parse(embeddingResponse));
    }
    function embeddingResponseFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.EmbeddingResponse$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'EmbeddingResponse' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/entitytype.js
var require_entitytype = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/entitytype.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntityType$ = exports.EntityType$outboundSchema = exports.EntityType$inboundSchema = exports.EntityType = void 0;
    var z4 = __importStar(__require("zod"));
    var enums_js_1 = require_enums();
    exports.EntityType = {
      User: "User",
      Workspace: "Workspace",
      Org: "Org"
    };
    exports.EntityType$inboundSchema = z4.union([
      z4.nativeEnum(exports.EntityType),
      z4.string().transform(enums_js_1.catchUnrecognizedEnum)
    ]);
    exports.EntityType$outboundSchema = z4.union([
      z4.nativeEnum(exports.EntityType),
      z4.string().and(z4.custom())
    ]);
    var EntityType$;
    (function(EntityType$2) {
      EntityType$2.inboundSchema = exports.EntityType$inboundSchema;
      EntityType$2.outboundSchema = exports.EntityType$outboundSchema;
    })(EntityType$ || (exports.EntityType$ = EntityType$ = {}));
  }
});

// ../node_modules/@mistralai/mistralai/models/components/filepurpose.js
var require_filepurpose = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/filepurpose.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FilePurpose$ = exports.FilePurpose$outboundSchema = exports.FilePurpose$inboundSchema = exports.FilePurpose = void 0;
    var z4 = __importStar(__require("zod"));
    var enums_js_1 = require_enums();
    exports.FilePurpose = {
      FineTune: "fine-tune",
      Batch: "batch",
      Ocr: "ocr"
    };
    exports.FilePurpose$inboundSchema = z4.union([
      z4.nativeEnum(exports.FilePurpose),
      z4.string().transform(enums_js_1.catchUnrecognizedEnum)
    ]);
    exports.FilePurpose$outboundSchema = z4.union([
      z4.nativeEnum(exports.FilePurpose),
      z4.string().and(z4.custom())
    ]);
    var FilePurpose$;
    (function(FilePurpose$2) {
      FilePurpose$2.inboundSchema = exports.FilePurpose$inboundSchema;
      FilePurpose$2.outboundSchema = exports.FilePurpose$outboundSchema;
    })(FilePurpose$ || (exports.FilePurpose$ = FilePurpose$ = {}));
  }
});

// ../node_modules/@mistralai/mistralai/models/components/sampletype.js
var require_sampletype = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/sampletype.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SampleType$ = exports.SampleType$outboundSchema = exports.SampleType$inboundSchema = exports.SampleType = void 0;
    var z4 = __importStar(__require("zod"));
    var enums_js_1 = require_enums();
    exports.SampleType = {
      Pretrain: "pretrain",
      Instruct: "instruct",
      BatchRequest: "batch_request",
      BatchResult: "batch_result",
      BatchError: "batch_error"
    };
    exports.SampleType$inboundSchema = z4.union([
      z4.nativeEnum(exports.SampleType),
      z4.string().transform(enums_js_1.catchUnrecognizedEnum)
    ]);
    exports.SampleType$outboundSchema = z4.union([
      z4.nativeEnum(exports.SampleType),
      z4.string().and(z4.custom())
    ]);
    var SampleType$;
    (function(SampleType$2) {
      SampleType$2.inboundSchema = exports.SampleType$inboundSchema;
      SampleType$2.outboundSchema = exports.SampleType$outboundSchema;
    })(SampleType$ || (exports.SampleType$ = SampleType$ = {}));
  }
});

// ../node_modules/@mistralai/mistralai/models/components/source.js
var require_source = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/source.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Source$ = exports.Source$outboundSchema = exports.Source$inboundSchema = exports.Source = void 0;
    var z4 = __importStar(__require("zod"));
    var enums_js_1 = require_enums();
    exports.Source = {
      Upload: "upload",
      Repository: "repository",
      Mistral: "mistral"
    };
    exports.Source$inboundSchema = z4.union([
      z4.nativeEnum(exports.Source),
      z4.string().transform(enums_js_1.catchUnrecognizedEnum)
    ]);
    exports.Source$outboundSchema = z4.union([
      z4.nativeEnum(exports.Source),
      z4.string().and(z4.custom())
    ]);
    var Source$;
    (function(Source$2) {
      Source$2.inboundSchema = exports.Source$inboundSchema;
      Source$2.outboundSchema = exports.Source$outboundSchema;
    })(Source$ || (exports.Source$ = Source$ = {}));
  }
});

// ../node_modules/@mistralai/mistralai/models/components/fileschema.js
var require_fileschema = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/fileschema.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FileSchema$ = exports.FileSchema$outboundSchema = exports.FileSchema$inboundSchema = void 0;
    exports.fileSchemaToJSON = fileSchemaToJSON;
    exports.fileSchemaFromJSON = fileSchemaFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var filepurpose_js_1 = require_filepurpose();
    var sampletype_js_1 = require_sampletype();
    var source_js_1 = require_source();
    exports.FileSchema$inboundSchema = z4.object({
      id: z4.string(),
      object: z4.string(),
      bytes: z4.number().int(),
      created_at: z4.number().int(),
      filename: z4.string(),
      purpose: filepurpose_js_1.FilePurpose$inboundSchema,
      sample_type: sampletype_js_1.SampleType$inboundSchema,
      num_lines: z4.nullable(z4.number().int()).optional(),
      mimetype: z4.nullable(z4.string()).optional(),
      source: source_js_1.Source$inboundSchema,
      signature: z4.nullable(z4.string()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "bytes": "sizeBytes",
        "created_at": "createdAt",
        "sample_type": "sampleType",
        "num_lines": "numLines"
      });
    });
    exports.FileSchema$outboundSchema = z4.object({
      id: z4.string(),
      object: z4.string(),
      sizeBytes: z4.number().int(),
      createdAt: z4.number().int(),
      filename: z4.string(),
      purpose: filepurpose_js_1.FilePurpose$outboundSchema,
      sampleType: sampletype_js_1.SampleType$outboundSchema,
      numLines: z4.nullable(z4.number().int()).optional(),
      mimetype: z4.nullable(z4.string()).optional(),
      source: source_js_1.Source$outboundSchema,
      signature: z4.nullable(z4.string()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        sizeBytes: "bytes",
        createdAt: "created_at",
        sampleType: "sample_type",
        numLines: "num_lines"
      });
    });
    var FileSchema$;
    (function(FileSchema$2) {
      FileSchema$2.inboundSchema = exports.FileSchema$inboundSchema;
      FileSchema$2.outboundSchema = exports.FileSchema$outboundSchema;
    })(FileSchema$ || (exports.FileSchema$ = FileSchema$ = {}));
    function fileSchemaToJSON(fileSchema) {
      return JSON.stringify(exports.FileSchema$outboundSchema.parse(fileSchema));
    }
    function fileSchemaFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.FileSchema$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'FileSchema' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/filesignedurl.js
var require_filesignedurl = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/filesignedurl.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FileSignedURL$ = exports.FileSignedURL$outboundSchema = exports.FileSignedURL$inboundSchema = void 0;
    exports.fileSignedURLToJSON = fileSignedURLToJSON;
    exports.fileSignedURLFromJSON = fileSignedURLFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    exports.FileSignedURL$inboundSchema = z4.object({
      url: z4.string()
    });
    exports.FileSignedURL$outboundSchema = z4.object({
      url: z4.string()
    });
    var FileSignedURL$;
    (function(FileSignedURL$2) {
      FileSignedURL$2.inboundSchema = exports.FileSignedURL$inboundSchema;
      FileSignedURL$2.outboundSchema = exports.FileSignedURL$outboundSchema;
    })(FileSignedURL$ || (exports.FileSignedURL$ = FileSignedURL$ = {}));
    function fileSignedURLToJSON(fileSignedURL) {
      return JSON.stringify(exports.FileSignedURL$outboundSchema.parse(fileSignedURL));
    }
    function fileSignedURLFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.FileSignedURL$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'FileSignedURL' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/fimcompletionrequest.js
var require_fimcompletionrequest = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/fimcompletionrequest.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FIMCompletionRequest$ = exports.FIMCompletionRequest$outboundSchema = exports.FIMCompletionRequest$inboundSchema = exports.FIMCompletionRequestStop$ = exports.FIMCompletionRequestStop$outboundSchema = exports.FIMCompletionRequestStop$inboundSchema = void 0;
    exports.fimCompletionRequestStopToJSON = fimCompletionRequestStopToJSON;
    exports.fimCompletionRequestStopFromJSON = fimCompletionRequestStopFromJSON;
    exports.fimCompletionRequestToJSON = fimCompletionRequestToJSON;
    exports.fimCompletionRequestFromJSON = fimCompletionRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.FIMCompletionRequestStop$inboundSchema = z4.union([z4.string(), z4.array(z4.string())]);
    exports.FIMCompletionRequestStop$outboundSchema = z4.union([z4.string(), z4.array(z4.string())]);
    var FIMCompletionRequestStop$;
    (function(FIMCompletionRequestStop$2) {
      FIMCompletionRequestStop$2.inboundSchema = exports.FIMCompletionRequestStop$inboundSchema;
      FIMCompletionRequestStop$2.outboundSchema = exports.FIMCompletionRequestStop$outboundSchema;
    })(FIMCompletionRequestStop$ || (exports.FIMCompletionRequestStop$ = FIMCompletionRequestStop$ = {}));
    function fimCompletionRequestStopToJSON(fimCompletionRequestStop) {
      return JSON.stringify(exports.FIMCompletionRequestStop$outboundSchema.parse(fimCompletionRequestStop));
    }
    function fimCompletionRequestStopFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.FIMCompletionRequestStop$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'FIMCompletionRequestStop' from JSON`);
    }
    exports.FIMCompletionRequest$inboundSchema = z4.object({
      model: z4.string(),
      temperature: z4.nullable(z4.number()).optional(),
      top_p: z4.number().default(1),
      max_tokens: z4.nullable(z4.number().int()).optional(),
      stream: z4.boolean().default(false),
      stop: z4.union([z4.string(), z4.array(z4.string())]).optional(),
      random_seed: z4.nullable(z4.number().int()).optional(),
      prompt: z4.string(),
      suffix: z4.nullable(z4.string()).optional(),
      min_tokens: z4.nullable(z4.number().int()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "top_p": "topP",
        "max_tokens": "maxTokens",
        "random_seed": "randomSeed",
        "min_tokens": "minTokens"
      });
    });
    exports.FIMCompletionRequest$outboundSchema = z4.object({
      model: z4.string(),
      temperature: z4.nullable(z4.number()).optional(),
      topP: z4.number().default(1),
      maxTokens: z4.nullable(z4.number().int()).optional(),
      stream: z4.boolean().default(false),
      stop: z4.union([z4.string(), z4.array(z4.string())]).optional(),
      randomSeed: z4.nullable(z4.number().int()).optional(),
      prompt: z4.string(),
      suffix: z4.nullable(z4.string()).optional(),
      minTokens: z4.nullable(z4.number().int()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        topP: "top_p",
        maxTokens: "max_tokens",
        randomSeed: "random_seed",
        minTokens: "min_tokens"
      });
    });
    var FIMCompletionRequest$;
    (function(FIMCompletionRequest$2) {
      FIMCompletionRequest$2.inboundSchema = exports.FIMCompletionRequest$inboundSchema;
      FIMCompletionRequest$2.outboundSchema = exports.FIMCompletionRequest$outboundSchema;
    })(FIMCompletionRequest$ || (exports.FIMCompletionRequest$ = FIMCompletionRequest$ = {}));
    function fimCompletionRequestToJSON(fimCompletionRequest) {
      return JSON.stringify(exports.FIMCompletionRequest$outboundSchema.parse(fimCompletionRequest));
    }
    function fimCompletionRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.FIMCompletionRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'FIMCompletionRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/fimcompletionresponse.js
var require_fimcompletionresponse = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/fimcompletionresponse.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FIMCompletionResponse$ = exports.FIMCompletionResponse$outboundSchema = exports.FIMCompletionResponse$inboundSchema = void 0;
    exports.fimCompletionResponseToJSON = fimCompletionResponseToJSON;
    exports.fimCompletionResponseFromJSON = fimCompletionResponseFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var chatcompletionchoice_js_1 = require_chatcompletionchoice();
    var usageinfo_js_1 = require_usageinfo();
    exports.FIMCompletionResponse$inboundSchema = z4.object({
      id: z4.string(),
      object: z4.string(),
      model: z4.string(),
      usage: usageinfo_js_1.UsageInfo$inboundSchema,
      created: z4.number().int(),
      choices: z4.array(chatcompletionchoice_js_1.ChatCompletionChoice$inboundSchema)
    });
    exports.FIMCompletionResponse$outboundSchema = z4.object({
      id: z4.string(),
      object: z4.string(),
      model: z4.string(),
      usage: usageinfo_js_1.UsageInfo$outboundSchema,
      created: z4.number().int(),
      choices: z4.array(chatcompletionchoice_js_1.ChatCompletionChoice$outboundSchema)
    });
    var FIMCompletionResponse$;
    (function(FIMCompletionResponse$2) {
      FIMCompletionResponse$2.inboundSchema = exports.FIMCompletionResponse$inboundSchema;
      FIMCompletionResponse$2.outboundSchema = exports.FIMCompletionResponse$outboundSchema;
    })(FIMCompletionResponse$ || (exports.FIMCompletionResponse$ = FIMCompletionResponse$ = {}));
    function fimCompletionResponseToJSON(fimCompletionResponse) {
      return JSON.stringify(exports.FIMCompletionResponse$outboundSchema.parse(fimCompletionResponse));
    }
    function fimCompletionResponseFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.FIMCompletionResponse$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'FIMCompletionResponse' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/fimcompletionstreamrequest.js
var require_fimcompletionstreamrequest = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/fimcompletionstreamrequest.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FIMCompletionStreamRequest$ = exports.FIMCompletionStreamRequest$outboundSchema = exports.FIMCompletionStreamRequest$inboundSchema = exports.FIMCompletionStreamRequestStop$ = exports.FIMCompletionStreamRequestStop$outboundSchema = exports.FIMCompletionStreamRequestStop$inboundSchema = void 0;
    exports.fimCompletionStreamRequestStopToJSON = fimCompletionStreamRequestStopToJSON;
    exports.fimCompletionStreamRequestStopFromJSON = fimCompletionStreamRequestStopFromJSON;
    exports.fimCompletionStreamRequestToJSON = fimCompletionStreamRequestToJSON;
    exports.fimCompletionStreamRequestFromJSON = fimCompletionStreamRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.FIMCompletionStreamRequestStop$inboundSchema = z4.union([z4.string(), z4.array(z4.string())]);
    exports.FIMCompletionStreamRequestStop$outboundSchema = z4.union([z4.string(), z4.array(z4.string())]);
    var FIMCompletionStreamRequestStop$;
    (function(FIMCompletionStreamRequestStop$2) {
      FIMCompletionStreamRequestStop$2.inboundSchema = exports.FIMCompletionStreamRequestStop$inboundSchema;
      FIMCompletionStreamRequestStop$2.outboundSchema = exports.FIMCompletionStreamRequestStop$outboundSchema;
    })(FIMCompletionStreamRequestStop$ || (exports.FIMCompletionStreamRequestStop$ = FIMCompletionStreamRequestStop$ = {}));
    function fimCompletionStreamRequestStopToJSON(fimCompletionStreamRequestStop) {
      return JSON.stringify(exports.FIMCompletionStreamRequestStop$outboundSchema.parse(fimCompletionStreamRequestStop));
    }
    function fimCompletionStreamRequestStopFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.FIMCompletionStreamRequestStop$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'FIMCompletionStreamRequestStop' from JSON`);
    }
    exports.FIMCompletionStreamRequest$inboundSchema = z4.object({
      model: z4.string(),
      temperature: z4.nullable(z4.number()).optional(),
      top_p: z4.number().default(1),
      max_tokens: z4.nullable(z4.number().int()).optional(),
      stream: z4.boolean().default(true),
      stop: z4.union([z4.string(), z4.array(z4.string())]).optional(),
      random_seed: z4.nullable(z4.number().int()).optional(),
      prompt: z4.string(),
      suffix: z4.nullable(z4.string()).optional(),
      min_tokens: z4.nullable(z4.number().int()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "top_p": "topP",
        "max_tokens": "maxTokens",
        "random_seed": "randomSeed",
        "min_tokens": "minTokens"
      });
    });
    exports.FIMCompletionStreamRequest$outboundSchema = z4.object({
      model: z4.string(),
      temperature: z4.nullable(z4.number()).optional(),
      topP: z4.number().default(1),
      maxTokens: z4.nullable(z4.number().int()).optional(),
      stream: z4.boolean().default(true),
      stop: z4.union([z4.string(), z4.array(z4.string())]).optional(),
      randomSeed: z4.nullable(z4.number().int()).optional(),
      prompt: z4.string(),
      suffix: z4.nullable(z4.string()).optional(),
      minTokens: z4.nullable(z4.number().int()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        topP: "top_p",
        maxTokens: "max_tokens",
        randomSeed: "random_seed",
        minTokens: "min_tokens"
      });
    });
    var FIMCompletionStreamRequest$;
    (function(FIMCompletionStreamRequest$2) {
      FIMCompletionStreamRequest$2.inboundSchema = exports.FIMCompletionStreamRequest$inboundSchema;
      FIMCompletionStreamRequest$2.outboundSchema = exports.FIMCompletionStreamRequest$outboundSchema;
    })(FIMCompletionStreamRequest$ || (exports.FIMCompletionStreamRequest$ = FIMCompletionStreamRequest$ = {}));
    function fimCompletionStreamRequestToJSON(fimCompletionStreamRequest) {
      return JSON.stringify(exports.FIMCompletionStreamRequest$outboundSchema.parse(fimCompletionStreamRequest));
    }
    function fimCompletionStreamRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.FIMCompletionStreamRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'FIMCompletionStreamRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/finetuneablemodeltype.js
var require_finetuneablemodeltype = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/finetuneablemodeltype.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FineTuneableModelType$ = exports.FineTuneableModelType$outboundSchema = exports.FineTuneableModelType$inboundSchema = exports.FineTuneableModelType = void 0;
    var z4 = __importStar(__require("zod"));
    exports.FineTuneableModelType = {
      Completion: "completion",
      Classifier: "classifier"
    };
    exports.FineTuneableModelType$inboundSchema = z4.nativeEnum(exports.FineTuneableModelType);
    exports.FineTuneableModelType$outboundSchema = exports.FineTuneableModelType$inboundSchema;
    var FineTuneableModelType$;
    (function(FineTuneableModelType$2) {
      FineTuneableModelType$2.inboundSchema = exports.FineTuneableModelType$inboundSchema;
      FineTuneableModelType$2.outboundSchema = exports.FineTuneableModelType$outboundSchema;
    })(FineTuneableModelType$ || (exports.FineTuneableModelType$ = FineTuneableModelType$ = {}));
  }
});

// ../node_modules/@mistralai/mistralai/models/components/ftmodelcard.js
var require_ftmodelcard = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/ftmodelcard.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FTModelCard$ = exports.FTModelCard$outboundSchema = exports.FTModelCard$inboundSchema = exports.FTModelCardType$ = exports.FTModelCardType$outboundSchema = exports.FTModelCardType$inboundSchema = exports.FTModelCardType = void 0;
    exports.ftModelCardToJSON = ftModelCardToJSON;
    exports.ftModelCardFromJSON = ftModelCardFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var modelcapabilities_js_1 = require_modelcapabilities();
    exports.FTModelCardType = {
      FineTuned: "fine-tuned"
    };
    exports.FTModelCardType$inboundSchema = z4.nativeEnum(exports.FTModelCardType);
    exports.FTModelCardType$outboundSchema = exports.FTModelCardType$inboundSchema;
    var FTModelCardType$;
    (function(FTModelCardType$2) {
      FTModelCardType$2.inboundSchema = exports.FTModelCardType$inboundSchema;
      FTModelCardType$2.outboundSchema = exports.FTModelCardType$outboundSchema;
    })(FTModelCardType$ || (exports.FTModelCardType$ = FTModelCardType$ = {}));
    exports.FTModelCard$inboundSchema = z4.object({
      id: z4.string(),
      object: z4.string().default("model"),
      created: z4.number().int().optional(),
      owned_by: z4.string().default("mistralai"),
      capabilities: modelcapabilities_js_1.ModelCapabilities$inboundSchema,
      name: z4.nullable(z4.string()).optional(),
      description: z4.nullable(z4.string()).optional(),
      max_context_length: z4.number().int().default(32768),
      aliases: z4.array(z4.string()).optional(),
      deprecation: z4.nullable(z4.string().datetime({ offset: true }).transform((v2) => new Date(v2))).optional(),
      deprecation_replacement_model: z4.nullable(z4.string()).optional(),
      default_model_temperature: z4.nullable(z4.number()).optional(),
      type: z4.literal("fine-tuned").default("fine-tuned"),
      job: z4.string(),
      root: z4.string(),
      archived: z4.boolean().default(false)
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "owned_by": "ownedBy",
        "max_context_length": "maxContextLength",
        "deprecation_replacement_model": "deprecationReplacementModel",
        "default_model_temperature": "defaultModelTemperature"
      });
    });
    exports.FTModelCard$outboundSchema = z4.object({
      id: z4.string(),
      object: z4.string().default("model"),
      created: z4.number().int().optional(),
      ownedBy: z4.string().default("mistralai"),
      capabilities: modelcapabilities_js_1.ModelCapabilities$outboundSchema,
      name: z4.nullable(z4.string()).optional(),
      description: z4.nullable(z4.string()).optional(),
      maxContextLength: z4.number().int().default(32768),
      aliases: z4.array(z4.string()).optional(),
      deprecation: z4.nullable(z4.date().transform((v2) => v2.toISOString())).optional(),
      deprecationReplacementModel: z4.nullable(z4.string()).optional(),
      defaultModelTemperature: z4.nullable(z4.number()).optional(),
      type: z4.literal("fine-tuned").default("fine-tuned"),
      job: z4.string(),
      root: z4.string(),
      archived: z4.boolean().default(false)
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        ownedBy: "owned_by",
        maxContextLength: "max_context_length",
        deprecationReplacementModel: "deprecation_replacement_model",
        defaultModelTemperature: "default_model_temperature"
      });
    });
    var FTModelCard$;
    (function(FTModelCard$2) {
      FTModelCard$2.inboundSchema = exports.FTModelCard$inboundSchema;
      FTModelCard$2.outboundSchema = exports.FTModelCard$outboundSchema;
    })(FTModelCard$ || (exports.FTModelCard$ = FTModelCard$ = {}));
    function ftModelCardToJSON(ftModelCard) {
      return JSON.stringify(exports.FTModelCard$outboundSchema.parse(ftModelCard));
    }
    function ftModelCardFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.FTModelCard$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'FTModelCard' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/githubrepositoryin.js
var require_githubrepositoryin = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/githubrepositoryin.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GithubRepositoryIn$ = exports.GithubRepositoryIn$outboundSchema = exports.GithubRepositoryIn$inboundSchema = exports.GithubRepositoryInType$ = exports.GithubRepositoryInType$outboundSchema = exports.GithubRepositoryInType$inboundSchema = exports.GithubRepositoryInType = void 0;
    exports.githubRepositoryInToJSON = githubRepositoryInToJSON;
    exports.githubRepositoryInFromJSON = githubRepositoryInFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    exports.GithubRepositoryInType = {
      Github: "github"
    };
    exports.GithubRepositoryInType$inboundSchema = z4.nativeEnum(exports.GithubRepositoryInType);
    exports.GithubRepositoryInType$outboundSchema = exports.GithubRepositoryInType$inboundSchema;
    var GithubRepositoryInType$;
    (function(GithubRepositoryInType$2) {
      GithubRepositoryInType$2.inboundSchema = exports.GithubRepositoryInType$inboundSchema;
      GithubRepositoryInType$2.outboundSchema = exports.GithubRepositoryInType$outboundSchema;
    })(GithubRepositoryInType$ || (exports.GithubRepositoryInType$ = GithubRepositoryInType$ = {}));
    exports.GithubRepositoryIn$inboundSchema = z4.object({
      type: exports.GithubRepositoryInType$inboundSchema.default("github"),
      name: z4.string(),
      owner: z4.string(),
      ref: z4.nullable(z4.string()).optional(),
      weight: z4.number().default(1),
      token: z4.string()
    });
    exports.GithubRepositoryIn$outboundSchema = z4.object({
      type: exports.GithubRepositoryInType$outboundSchema.default("github"),
      name: z4.string(),
      owner: z4.string(),
      ref: z4.nullable(z4.string()).optional(),
      weight: z4.number().default(1),
      token: z4.string()
    });
    var GithubRepositoryIn$;
    (function(GithubRepositoryIn$2) {
      GithubRepositoryIn$2.inboundSchema = exports.GithubRepositoryIn$inboundSchema;
      GithubRepositoryIn$2.outboundSchema = exports.GithubRepositoryIn$outboundSchema;
    })(GithubRepositoryIn$ || (exports.GithubRepositoryIn$ = GithubRepositoryIn$ = {}));
    function githubRepositoryInToJSON(githubRepositoryIn) {
      return JSON.stringify(exports.GithubRepositoryIn$outboundSchema.parse(githubRepositoryIn));
    }
    function githubRepositoryInFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.GithubRepositoryIn$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'GithubRepositoryIn' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/trainingfile.js
var require_trainingfile = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/trainingfile.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TrainingFile$ = exports.TrainingFile$outboundSchema = exports.TrainingFile$inboundSchema = void 0;
    exports.trainingFileToJSON = trainingFileToJSON;
    exports.trainingFileFromJSON = trainingFileFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.TrainingFile$inboundSchema = z4.object({
      file_id: z4.string(),
      weight: z4.number().default(1)
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "file_id": "fileId"
      });
    });
    exports.TrainingFile$outboundSchema = z4.object({
      fileId: z4.string(),
      weight: z4.number().default(1)
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        fileId: "file_id"
      });
    });
    var TrainingFile$;
    (function(TrainingFile$2) {
      TrainingFile$2.inboundSchema = exports.TrainingFile$inboundSchema;
      TrainingFile$2.outboundSchema = exports.TrainingFile$outboundSchema;
    })(TrainingFile$ || (exports.TrainingFile$ = TrainingFile$ = {}));
    function trainingFileToJSON(trainingFile) {
      return JSON.stringify(exports.TrainingFile$outboundSchema.parse(trainingFile));
    }
    function trainingFileFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.TrainingFile$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'TrainingFile' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/wandbintegration.js
var require_wandbintegration = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/wandbintegration.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WandbIntegration$ = exports.WandbIntegration$outboundSchema = exports.WandbIntegration$inboundSchema = exports.WandbIntegrationType$ = exports.WandbIntegrationType$outboundSchema = exports.WandbIntegrationType$inboundSchema = exports.WandbIntegrationType = void 0;
    exports.wandbIntegrationToJSON = wandbIntegrationToJSON;
    exports.wandbIntegrationFromJSON = wandbIntegrationFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.WandbIntegrationType = {
      Wandb: "wandb"
    };
    exports.WandbIntegrationType$inboundSchema = z4.nativeEnum(exports.WandbIntegrationType);
    exports.WandbIntegrationType$outboundSchema = exports.WandbIntegrationType$inboundSchema;
    var WandbIntegrationType$;
    (function(WandbIntegrationType$2) {
      WandbIntegrationType$2.inboundSchema = exports.WandbIntegrationType$inboundSchema;
      WandbIntegrationType$2.outboundSchema = exports.WandbIntegrationType$outboundSchema;
    })(WandbIntegrationType$ || (exports.WandbIntegrationType$ = WandbIntegrationType$ = {}));
    exports.WandbIntegration$inboundSchema = z4.object({
      type: exports.WandbIntegrationType$inboundSchema.default("wandb"),
      project: z4.string(),
      name: z4.nullable(z4.string()).optional(),
      api_key: z4.string(),
      run_name: z4.nullable(z4.string()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "api_key": "apiKey",
        "run_name": "runName"
      });
    });
    exports.WandbIntegration$outboundSchema = z4.object({
      type: exports.WandbIntegrationType$outboundSchema.default("wandb"),
      project: z4.string(),
      name: z4.nullable(z4.string()).optional(),
      apiKey: z4.string(),
      runName: z4.nullable(z4.string()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        apiKey: "api_key",
        runName: "run_name"
      });
    });
    var WandbIntegration$;
    (function(WandbIntegration$2) {
      WandbIntegration$2.inboundSchema = exports.WandbIntegration$inboundSchema;
      WandbIntegration$2.outboundSchema = exports.WandbIntegration$outboundSchema;
    })(WandbIntegration$ || (exports.WandbIntegration$ = WandbIntegration$ = {}));
    function wandbIntegrationToJSON(wandbIntegration) {
      return JSON.stringify(exports.WandbIntegration$outboundSchema.parse(wandbIntegration));
    }
    function wandbIntegrationFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.WandbIntegration$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'WandbIntegration' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/jobin.js
var require_jobin = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/jobin.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JobIn$ = exports.JobIn$outboundSchema = exports.JobIn$inboundSchema = exports.JobInRepositories$ = exports.JobInRepositories$outboundSchema = exports.JobInRepositories$inboundSchema = exports.Hyperparameters$ = exports.Hyperparameters$outboundSchema = exports.Hyperparameters$inboundSchema = exports.JobInIntegrations$ = exports.JobInIntegrations$outboundSchema = exports.JobInIntegrations$inboundSchema = void 0;
    exports.jobInIntegrationsToJSON = jobInIntegrationsToJSON;
    exports.jobInIntegrationsFromJSON = jobInIntegrationsFromJSON;
    exports.hyperparametersToJSON = hyperparametersToJSON;
    exports.hyperparametersFromJSON = hyperparametersFromJSON;
    exports.jobInRepositoriesToJSON = jobInRepositoriesToJSON;
    exports.jobInRepositoriesFromJSON = jobInRepositoriesFromJSON;
    exports.jobInToJSON = jobInToJSON;
    exports.jobInFromJSON = jobInFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var classifiertargetin_js_1 = require_classifiertargetin();
    var classifiertrainingparametersin_js_1 = require_classifiertrainingparametersin();
    var completiontrainingparametersin_js_1 = require_completiontrainingparametersin();
    var finetuneablemodeltype_js_1 = require_finetuneablemodeltype();
    var githubrepositoryin_js_1 = require_githubrepositoryin();
    var trainingfile_js_1 = require_trainingfile();
    var wandbintegration_js_1 = require_wandbintegration();
    exports.JobInIntegrations$inboundSchema = wandbintegration_js_1.WandbIntegration$inboundSchema;
    exports.JobInIntegrations$outboundSchema = wandbintegration_js_1.WandbIntegration$outboundSchema;
    var JobInIntegrations$;
    (function(JobInIntegrations$2) {
      JobInIntegrations$2.inboundSchema = exports.JobInIntegrations$inboundSchema;
      JobInIntegrations$2.outboundSchema = exports.JobInIntegrations$outboundSchema;
    })(JobInIntegrations$ || (exports.JobInIntegrations$ = JobInIntegrations$ = {}));
    function jobInIntegrationsToJSON(jobInIntegrations) {
      return JSON.stringify(exports.JobInIntegrations$outboundSchema.parse(jobInIntegrations));
    }
    function jobInIntegrationsFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.JobInIntegrations$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'JobInIntegrations' from JSON`);
    }
    exports.Hyperparameters$inboundSchema = z4.union([
      classifiertrainingparametersin_js_1.ClassifierTrainingParametersIn$inboundSchema,
      completiontrainingparametersin_js_1.CompletionTrainingParametersIn$inboundSchema
    ]);
    exports.Hyperparameters$outboundSchema = z4.union([
      classifiertrainingparametersin_js_1.ClassifierTrainingParametersIn$outboundSchema,
      completiontrainingparametersin_js_1.CompletionTrainingParametersIn$outboundSchema
    ]);
    var Hyperparameters$;
    (function(Hyperparameters$2) {
      Hyperparameters$2.inboundSchema = exports.Hyperparameters$inboundSchema;
      Hyperparameters$2.outboundSchema = exports.Hyperparameters$outboundSchema;
    })(Hyperparameters$ || (exports.Hyperparameters$ = Hyperparameters$ = {}));
    function hyperparametersToJSON(hyperparameters) {
      return JSON.stringify(exports.Hyperparameters$outboundSchema.parse(hyperparameters));
    }
    function hyperparametersFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.Hyperparameters$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'Hyperparameters' from JSON`);
    }
    exports.JobInRepositories$inboundSchema = githubrepositoryin_js_1.GithubRepositoryIn$inboundSchema;
    exports.JobInRepositories$outboundSchema = githubrepositoryin_js_1.GithubRepositoryIn$outboundSchema;
    var JobInRepositories$;
    (function(JobInRepositories$2) {
      JobInRepositories$2.inboundSchema = exports.JobInRepositories$inboundSchema;
      JobInRepositories$2.outboundSchema = exports.JobInRepositories$outboundSchema;
    })(JobInRepositories$ || (exports.JobInRepositories$ = JobInRepositories$ = {}));
    function jobInRepositoriesToJSON(jobInRepositories) {
      return JSON.stringify(exports.JobInRepositories$outboundSchema.parse(jobInRepositories));
    }
    function jobInRepositoriesFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.JobInRepositories$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'JobInRepositories' from JSON`);
    }
    exports.JobIn$inboundSchema = z4.object({
      model: z4.string(),
      training_files: z4.array(trainingfile_js_1.TrainingFile$inboundSchema).optional(),
      validation_files: z4.nullable(z4.array(z4.string())).optional(),
      suffix: z4.nullable(z4.string()).optional(),
      integrations: z4.nullable(z4.array(wandbintegration_js_1.WandbIntegration$inboundSchema)).optional(),
      auto_start: z4.boolean().optional(),
      invalid_sample_skip_percentage: z4.number().default(0),
      job_type: z4.nullable(finetuneablemodeltype_js_1.FineTuneableModelType$inboundSchema).optional(),
      hyperparameters: z4.union([
        classifiertrainingparametersin_js_1.ClassifierTrainingParametersIn$inboundSchema,
        completiontrainingparametersin_js_1.CompletionTrainingParametersIn$inboundSchema
      ]),
      repositories: z4.nullable(z4.array(githubrepositoryin_js_1.GithubRepositoryIn$inboundSchema)).optional(),
      classifier_targets: z4.nullable(z4.array(classifiertargetin_js_1.ClassifierTargetIn$inboundSchema)).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "training_files": "trainingFiles",
        "validation_files": "validationFiles",
        "auto_start": "autoStart",
        "invalid_sample_skip_percentage": "invalidSampleSkipPercentage",
        "job_type": "jobType",
        "classifier_targets": "classifierTargets"
      });
    });
    exports.JobIn$outboundSchema = z4.object({
      model: z4.string(),
      trainingFiles: z4.array(trainingfile_js_1.TrainingFile$outboundSchema).optional(),
      validationFiles: z4.nullable(z4.array(z4.string())).optional(),
      suffix: z4.nullable(z4.string()).optional(),
      integrations: z4.nullable(z4.array(wandbintegration_js_1.WandbIntegration$outboundSchema)).optional(),
      autoStart: z4.boolean().optional(),
      invalidSampleSkipPercentage: z4.number().default(0),
      jobType: z4.nullable(finetuneablemodeltype_js_1.FineTuneableModelType$outboundSchema).optional(),
      hyperparameters: z4.union([
        classifiertrainingparametersin_js_1.ClassifierTrainingParametersIn$outboundSchema,
        completiontrainingparametersin_js_1.CompletionTrainingParametersIn$outboundSchema
      ]),
      repositories: z4.nullable(z4.array(githubrepositoryin_js_1.GithubRepositoryIn$outboundSchema)).optional(),
      classifierTargets: z4.nullable(z4.array(classifiertargetin_js_1.ClassifierTargetIn$outboundSchema)).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        trainingFiles: "training_files",
        validationFiles: "validation_files",
        autoStart: "auto_start",
        invalidSampleSkipPercentage: "invalid_sample_skip_percentage",
        jobType: "job_type",
        classifierTargets: "classifier_targets"
      });
    });
    var JobIn$;
    (function(JobIn$2) {
      JobIn$2.inboundSchema = exports.JobIn$inboundSchema;
      JobIn$2.outboundSchema = exports.JobIn$outboundSchema;
    })(JobIn$ || (exports.JobIn$ = JobIn$ = {}));
    function jobInToJSON(jobIn) {
      return JSON.stringify(exports.JobIn$outboundSchema.parse(jobIn));
    }
    function jobInFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.JobIn$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'JobIn' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/jobsout.js
var require_jobsout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/jobsout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JobsOut$ = exports.JobsOut$outboundSchema = exports.JobsOut$inboundSchema = exports.JobsOutObject$ = exports.JobsOutObject$outboundSchema = exports.JobsOutObject$inboundSchema = exports.JobsOutData$ = exports.JobsOutData$outboundSchema = exports.JobsOutData$inboundSchema = exports.JobsOutObject = void 0;
    exports.jobsOutDataToJSON = jobsOutDataToJSON;
    exports.jobsOutDataFromJSON = jobsOutDataFromJSON;
    exports.jobsOutToJSON = jobsOutToJSON;
    exports.jobsOutFromJSON = jobsOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var classifierjobout_js_1 = require_classifierjobout();
    var completionjobout_js_1 = require_completionjobout();
    exports.JobsOutObject = {
      List: "list"
    };
    exports.JobsOutData$inboundSchema = z4.union([
      classifierjobout_js_1.ClassifierJobOut$inboundSchema.and(z4.object({ job_type: z4.literal("classifier") }).transform((v2) => ({
        jobType: v2.job_type
      }))),
      completionjobout_js_1.CompletionJobOut$inboundSchema.and(z4.object({ job_type: z4.literal("completion") }).transform((v2) => ({
        jobType: v2.job_type
      })))
    ]);
    exports.JobsOutData$outboundSchema = z4.union([
      classifierjobout_js_1.ClassifierJobOut$outboundSchema.and(z4.object({ jobType: z4.literal("classifier") }).transform((v2) => ({
        job_type: v2.jobType
      }))),
      completionjobout_js_1.CompletionJobOut$outboundSchema.and(z4.object({ jobType: z4.literal("completion") }).transform((v2) => ({
        job_type: v2.jobType
      })))
    ]);
    var JobsOutData$;
    (function(JobsOutData$2) {
      JobsOutData$2.inboundSchema = exports.JobsOutData$inboundSchema;
      JobsOutData$2.outboundSchema = exports.JobsOutData$outboundSchema;
    })(JobsOutData$ || (exports.JobsOutData$ = JobsOutData$ = {}));
    function jobsOutDataToJSON(jobsOutData) {
      return JSON.stringify(exports.JobsOutData$outboundSchema.parse(jobsOutData));
    }
    function jobsOutDataFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.JobsOutData$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'JobsOutData' from JSON`);
    }
    exports.JobsOutObject$inboundSchema = z4.nativeEnum(exports.JobsOutObject);
    exports.JobsOutObject$outboundSchema = exports.JobsOutObject$inboundSchema;
    var JobsOutObject$;
    (function(JobsOutObject$2) {
      JobsOutObject$2.inboundSchema = exports.JobsOutObject$inboundSchema;
      JobsOutObject$2.outboundSchema = exports.JobsOutObject$outboundSchema;
    })(JobsOutObject$ || (exports.JobsOutObject$ = JobsOutObject$ = {}));
    exports.JobsOut$inboundSchema = z4.object({
      data: z4.array(z4.union([
        classifierjobout_js_1.ClassifierJobOut$inboundSchema.and(z4.object({ job_type: z4.literal("classifier") }).transform((v2) => ({
          jobType: v2.job_type
        }))),
        completionjobout_js_1.CompletionJobOut$inboundSchema.and(z4.object({ job_type: z4.literal("completion") }).transform((v2) => ({
          jobType: v2.job_type
        })))
      ])).optional(),
      object: exports.JobsOutObject$inboundSchema.default("list"),
      total: z4.number().int()
    });
    exports.JobsOut$outboundSchema = z4.object({
      data: z4.array(z4.union([
        classifierjobout_js_1.ClassifierJobOut$outboundSchema.and(z4.object({ jobType: z4.literal("classifier") }).transform((v2) => ({
          job_type: v2.jobType
        }))),
        completionjobout_js_1.CompletionJobOut$outboundSchema.and(z4.object({ jobType: z4.literal("completion") }).transform((v2) => ({
          job_type: v2.jobType
        })))
      ])).optional(),
      object: exports.JobsOutObject$outboundSchema.default("list"),
      total: z4.number().int()
    });
    var JobsOut$;
    (function(JobsOut$2) {
      JobsOut$2.inboundSchema = exports.JobsOut$inboundSchema;
      JobsOut$2.outboundSchema = exports.JobsOut$outboundSchema;
    })(JobsOut$ || (exports.JobsOut$ = JobsOut$ = {}));
    function jobsOutToJSON(jobsOut) {
      return JSON.stringify(exports.JobsOut$outboundSchema.parse(jobsOut));
    }
    function jobsOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.JobsOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'JobsOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/legacyjobmetadataout.js
var require_legacyjobmetadataout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/legacyjobmetadataout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LegacyJobMetadataOut$ = exports.LegacyJobMetadataOut$outboundSchema = exports.LegacyJobMetadataOut$inboundSchema = exports.LegacyJobMetadataOutObject$ = exports.LegacyJobMetadataOutObject$outboundSchema = exports.LegacyJobMetadataOutObject$inboundSchema = exports.LegacyJobMetadataOutObject = void 0;
    exports.legacyJobMetadataOutToJSON = legacyJobMetadataOutToJSON;
    exports.legacyJobMetadataOutFromJSON = legacyJobMetadataOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.LegacyJobMetadataOutObject = {
      JobMetadata: "job.metadata"
    };
    exports.LegacyJobMetadataOutObject$inboundSchema = z4.nativeEnum(exports.LegacyJobMetadataOutObject);
    exports.LegacyJobMetadataOutObject$outboundSchema = exports.LegacyJobMetadataOutObject$inboundSchema;
    var LegacyJobMetadataOutObject$;
    (function(LegacyJobMetadataOutObject$2) {
      LegacyJobMetadataOutObject$2.inboundSchema = exports.LegacyJobMetadataOutObject$inboundSchema;
      LegacyJobMetadataOutObject$2.outboundSchema = exports.LegacyJobMetadataOutObject$outboundSchema;
    })(LegacyJobMetadataOutObject$ || (exports.LegacyJobMetadataOutObject$ = LegacyJobMetadataOutObject$ = {}));
    exports.LegacyJobMetadataOut$inboundSchema = z4.object({
      expected_duration_seconds: z4.nullable(z4.number().int()).optional(),
      cost: z4.nullable(z4.number()).optional(),
      cost_currency: z4.nullable(z4.string()).optional(),
      train_tokens_per_step: z4.nullable(z4.number().int()).optional(),
      train_tokens: z4.nullable(z4.number().int()).optional(),
      data_tokens: z4.nullable(z4.number().int()).optional(),
      estimated_start_time: z4.nullable(z4.number().int()).optional(),
      deprecated: z4.boolean().default(true),
      details: z4.string(),
      epochs: z4.nullable(z4.number()).optional(),
      training_steps: z4.nullable(z4.number().int()).optional(),
      object: exports.LegacyJobMetadataOutObject$inboundSchema.default("job.metadata")
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "expected_duration_seconds": "expectedDurationSeconds",
        "cost_currency": "costCurrency",
        "train_tokens_per_step": "trainTokensPerStep",
        "train_tokens": "trainTokens",
        "data_tokens": "dataTokens",
        "estimated_start_time": "estimatedStartTime",
        "training_steps": "trainingSteps"
      });
    });
    exports.LegacyJobMetadataOut$outboundSchema = z4.object({
      expectedDurationSeconds: z4.nullable(z4.number().int()).optional(),
      cost: z4.nullable(z4.number()).optional(),
      costCurrency: z4.nullable(z4.string()).optional(),
      trainTokensPerStep: z4.nullable(z4.number().int()).optional(),
      trainTokens: z4.nullable(z4.number().int()).optional(),
      dataTokens: z4.nullable(z4.number().int()).optional(),
      estimatedStartTime: z4.nullable(z4.number().int()).optional(),
      deprecated: z4.boolean().default(true),
      details: z4.string(),
      epochs: z4.nullable(z4.number()).optional(),
      trainingSteps: z4.nullable(z4.number().int()).optional(),
      object: exports.LegacyJobMetadataOutObject$outboundSchema.default("job.metadata")
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        expectedDurationSeconds: "expected_duration_seconds",
        costCurrency: "cost_currency",
        trainTokensPerStep: "train_tokens_per_step",
        trainTokens: "train_tokens",
        dataTokens: "data_tokens",
        estimatedStartTime: "estimated_start_time",
        trainingSteps: "training_steps"
      });
    });
    var LegacyJobMetadataOut$;
    (function(LegacyJobMetadataOut$2) {
      LegacyJobMetadataOut$2.inboundSchema = exports.LegacyJobMetadataOut$inboundSchema;
      LegacyJobMetadataOut$2.outboundSchema = exports.LegacyJobMetadataOut$outboundSchema;
    })(LegacyJobMetadataOut$ || (exports.LegacyJobMetadataOut$ = LegacyJobMetadataOut$ = {}));
    function legacyJobMetadataOutToJSON(legacyJobMetadataOut) {
      return JSON.stringify(exports.LegacyJobMetadataOut$outboundSchema.parse(legacyJobMetadataOut));
    }
    function legacyJobMetadataOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.LegacyJobMetadataOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'LegacyJobMetadataOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/libraryin.js
var require_libraryin = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/libraryin.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LibraryIn$ = exports.LibraryIn$outboundSchema = exports.LibraryIn$inboundSchema = void 0;
    exports.libraryInToJSON = libraryInToJSON;
    exports.libraryInFromJSON = libraryInFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.LibraryIn$inboundSchema = z4.object({
      name: z4.string(),
      description: z4.nullable(z4.string()).optional(),
      chunk_size: z4.nullable(z4.number().int()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "chunk_size": "chunkSize"
      });
    });
    exports.LibraryIn$outboundSchema = z4.object({
      name: z4.string(),
      description: z4.nullable(z4.string()).optional(),
      chunkSize: z4.nullable(z4.number().int()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        chunkSize: "chunk_size"
      });
    });
    var LibraryIn$;
    (function(LibraryIn$2) {
      LibraryIn$2.inboundSchema = exports.LibraryIn$inboundSchema;
      LibraryIn$2.outboundSchema = exports.LibraryIn$outboundSchema;
    })(LibraryIn$ || (exports.LibraryIn$ = LibraryIn$ = {}));
    function libraryInToJSON(libraryIn) {
      return JSON.stringify(exports.LibraryIn$outboundSchema.parse(libraryIn));
    }
    function libraryInFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.LibraryIn$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'LibraryIn' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/libraryinupdate.js
var require_libraryinupdate = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/libraryinupdate.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LibraryInUpdate$ = exports.LibraryInUpdate$outboundSchema = exports.LibraryInUpdate$inboundSchema = void 0;
    exports.libraryInUpdateToJSON = libraryInUpdateToJSON;
    exports.libraryInUpdateFromJSON = libraryInUpdateFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    exports.LibraryInUpdate$inboundSchema = z4.object({
      name: z4.nullable(z4.string()).optional(),
      description: z4.nullable(z4.string()).optional()
    });
    exports.LibraryInUpdate$outboundSchema = z4.object({
      name: z4.nullable(z4.string()).optional(),
      description: z4.nullable(z4.string()).optional()
    });
    var LibraryInUpdate$;
    (function(LibraryInUpdate$2) {
      LibraryInUpdate$2.inboundSchema = exports.LibraryInUpdate$inboundSchema;
      LibraryInUpdate$2.outboundSchema = exports.LibraryInUpdate$outboundSchema;
    })(LibraryInUpdate$ || (exports.LibraryInUpdate$ = LibraryInUpdate$ = {}));
    function libraryInUpdateToJSON(libraryInUpdate) {
      return JSON.stringify(exports.LibraryInUpdate$outboundSchema.parse(libraryInUpdate));
    }
    function libraryInUpdateFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.LibraryInUpdate$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'LibraryInUpdate' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/libraryout.js
var require_libraryout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/libraryout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LibraryOut$ = exports.LibraryOut$outboundSchema = exports.LibraryOut$inboundSchema = void 0;
    exports.libraryOutToJSON = libraryOutToJSON;
    exports.libraryOutFromJSON = libraryOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.LibraryOut$inboundSchema = z4.object({
      id: z4.string(),
      name: z4.string(),
      created_at: z4.string().datetime({ offset: true }).transform((v2) => new Date(v2)),
      updated_at: z4.string().datetime({ offset: true }).transform((v2) => new Date(v2)),
      owner_id: z4.string(),
      owner_type: z4.string(),
      total_size: z4.number().int(),
      nb_documents: z4.number().int(),
      chunk_size: z4.nullable(z4.number().int()),
      emoji: z4.nullable(z4.string()).optional(),
      description: z4.nullable(z4.string()).optional(),
      generated_name: z4.nullable(z4.string()).optional(),
      generated_description: z4.nullable(z4.string()).optional(),
      explicit_user_members_count: z4.nullable(z4.number().int()).optional(),
      explicit_workspace_members_count: z4.nullable(z4.number().int()).optional(),
      org_sharing_role: z4.nullable(z4.string()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "created_at": "createdAt",
        "updated_at": "updatedAt",
        "owner_id": "ownerId",
        "owner_type": "ownerType",
        "total_size": "totalSize",
        "nb_documents": "nbDocuments",
        "chunk_size": "chunkSize",
        "generated_name": "generatedName",
        "generated_description": "generatedDescription",
        "explicit_user_members_count": "explicitUserMembersCount",
        "explicit_workspace_members_count": "explicitWorkspaceMembersCount",
        "org_sharing_role": "orgSharingRole"
      });
    });
    exports.LibraryOut$outboundSchema = z4.object({
      id: z4.string(),
      name: z4.string(),
      createdAt: z4.date().transform((v2) => v2.toISOString()),
      updatedAt: z4.date().transform((v2) => v2.toISOString()),
      ownerId: z4.string(),
      ownerType: z4.string(),
      totalSize: z4.number().int(),
      nbDocuments: z4.number().int(),
      chunkSize: z4.nullable(z4.number().int()),
      emoji: z4.nullable(z4.string()).optional(),
      description: z4.nullable(z4.string()).optional(),
      generatedName: z4.nullable(z4.string()).optional(),
      generatedDescription: z4.nullable(z4.string()).optional(),
      explicitUserMembersCount: z4.nullable(z4.number().int()).optional(),
      explicitWorkspaceMembersCount: z4.nullable(z4.number().int()).optional(),
      orgSharingRole: z4.nullable(z4.string()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        createdAt: "created_at",
        updatedAt: "updated_at",
        ownerId: "owner_id",
        ownerType: "owner_type",
        totalSize: "total_size",
        nbDocuments: "nb_documents",
        chunkSize: "chunk_size",
        generatedName: "generated_name",
        generatedDescription: "generated_description",
        explicitUserMembersCount: "explicit_user_members_count",
        explicitWorkspaceMembersCount: "explicit_workspace_members_count",
        orgSharingRole: "org_sharing_role"
      });
    });
    var LibraryOut$;
    (function(LibraryOut$2) {
      LibraryOut$2.inboundSchema = exports.LibraryOut$inboundSchema;
      LibraryOut$2.outboundSchema = exports.LibraryOut$outboundSchema;
    })(LibraryOut$ || (exports.LibraryOut$ = LibraryOut$ = {}));
    function libraryOutToJSON(libraryOut) {
      return JSON.stringify(exports.LibraryOut$outboundSchema.parse(libraryOut));
    }
    function libraryOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.LibraryOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'LibraryOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/paginationinfo.js
var require_paginationinfo = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/paginationinfo.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PaginationInfo$ = exports.PaginationInfo$outboundSchema = exports.PaginationInfo$inboundSchema = void 0;
    exports.paginationInfoToJSON = paginationInfoToJSON;
    exports.paginationInfoFromJSON = paginationInfoFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.PaginationInfo$inboundSchema = z4.object({
      total_items: z4.number().int(),
      total_pages: z4.number().int(),
      current_page: z4.number().int(),
      page_size: z4.number().int(),
      has_more: z4.boolean()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "total_items": "totalItems",
        "total_pages": "totalPages",
        "current_page": "currentPage",
        "page_size": "pageSize",
        "has_more": "hasMore"
      });
    });
    exports.PaginationInfo$outboundSchema = z4.object({
      totalItems: z4.number().int(),
      totalPages: z4.number().int(),
      currentPage: z4.number().int(),
      pageSize: z4.number().int(),
      hasMore: z4.boolean()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        totalItems: "total_items",
        totalPages: "total_pages",
        currentPage: "current_page",
        pageSize: "page_size",
        hasMore: "has_more"
      });
    });
    var PaginationInfo$;
    (function(PaginationInfo$2) {
      PaginationInfo$2.inboundSchema = exports.PaginationInfo$inboundSchema;
      PaginationInfo$2.outboundSchema = exports.PaginationInfo$outboundSchema;
    })(PaginationInfo$ || (exports.PaginationInfo$ = PaginationInfo$ = {}));
    function paginationInfoToJSON(paginationInfo) {
      return JSON.stringify(exports.PaginationInfo$outboundSchema.parse(paginationInfo));
    }
    function paginationInfoFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.PaginationInfo$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'PaginationInfo' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/listdocumentout.js
var require_listdocumentout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/listdocumentout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListDocumentOut$ = exports.ListDocumentOut$outboundSchema = exports.ListDocumentOut$inboundSchema = void 0;
    exports.listDocumentOutToJSON = listDocumentOutToJSON;
    exports.listDocumentOutFromJSON = listDocumentOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var documentout_js_1 = require_documentout();
    var paginationinfo_js_1 = require_paginationinfo();
    exports.ListDocumentOut$inboundSchema = z4.object({
      pagination: paginationinfo_js_1.PaginationInfo$inboundSchema,
      data: z4.array(documentout_js_1.DocumentOut$inboundSchema)
    });
    exports.ListDocumentOut$outboundSchema = z4.object({
      pagination: paginationinfo_js_1.PaginationInfo$outboundSchema,
      data: z4.array(documentout_js_1.DocumentOut$outboundSchema)
    });
    var ListDocumentOut$;
    (function(ListDocumentOut$2) {
      ListDocumentOut$2.inboundSchema = exports.ListDocumentOut$inboundSchema;
      ListDocumentOut$2.outboundSchema = exports.ListDocumentOut$outboundSchema;
    })(ListDocumentOut$ || (exports.ListDocumentOut$ = ListDocumentOut$ = {}));
    function listDocumentOutToJSON(listDocumentOut) {
      return JSON.stringify(exports.ListDocumentOut$outboundSchema.parse(listDocumentOut));
    }
    function listDocumentOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ListDocumentOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ListDocumentOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/listfilesout.js
var require_listfilesout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/listfilesout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListFilesOut$ = exports.ListFilesOut$outboundSchema = exports.ListFilesOut$inboundSchema = void 0;
    exports.listFilesOutToJSON = listFilesOutToJSON;
    exports.listFilesOutFromJSON = listFilesOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var fileschema_js_1 = require_fileschema();
    exports.ListFilesOut$inboundSchema = z4.object({
      data: z4.array(fileschema_js_1.FileSchema$inboundSchema),
      object: z4.string(),
      total: z4.number().int()
    });
    exports.ListFilesOut$outboundSchema = z4.object({
      data: z4.array(fileschema_js_1.FileSchema$outboundSchema),
      object: z4.string(),
      total: z4.number().int()
    });
    var ListFilesOut$;
    (function(ListFilesOut$2) {
      ListFilesOut$2.inboundSchema = exports.ListFilesOut$inboundSchema;
      ListFilesOut$2.outboundSchema = exports.ListFilesOut$outboundSchema;
    })(ListFilesOut$ || (exports.ListFilesOut$ = ListFilesOut$ = {}));
    function listFilesOutToJSON(listFilesOut) {
      return JSON.stringify(exports.ListFilesOut$outboundSchema.parse(listFilesOut));
    }
    function listFilesOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ListFilesOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ListFilesOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/listlibraryout.js
var require_listlibraryout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/listlibraryout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListLibraryOut$ = exports.ListLibraryOut$outboundSchema = exports.ListLibraryOut$inboundSchema = void 0;
    exports.listLibraryOutToJSON = listLibraryOutToJSON;
    exports.listLibraryOutFromJSON = listLibraryOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var libraryout_js_1 = require_libraryout();
    exports.ListLibraryOut$inboundSchema = z4.object({
      data: z4.array(libraryout_js_1.LibraryOut$inboundSchema)
    });
    exports.ListLibraryOut$outboundSchema = z4.object({
      data: z4.array(libraryout_js_1.LibraryOut$outboundSchema)
    });
    var ListLibraryOut$;
    (function(ListLibraryOut$2) {
      ListLibraryOut$2.inboundSchema = exports.ListLibraryOut$inboundSchema;
      ListLibraryOut$2.outboundSchema = exports.ListLibraryOut$outboundSchema;
    })(ListLibraryOut$ || (exports.ListLibraryOut$ = ListLibraryOut$ = {}));
    function listLibraryOutToJSON(listLibraryOut) {
      return JSON.stringify(exports.ListLibraryOut$outboundSchema.parse(listLibraryOut));
    }
    function listLibraryOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ListLibraryOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ListLibraryOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/sharingout.js
var require_sharingout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/sharingout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SharingOut$ = exports.SharingOut$outboundSchema = exports.SharingOut$inboundSchema = void 0;
    exports.sharingOutToJSON = sharingOutToJSON;
    exports.sharingOutFromJSON = sharingOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.SharingOut$inboundSchema = z4.object({
      library_id: z4.string(),
      user_id: z4.nullable(z4.string()).optional(),
      org_id: z4.string(),
      role: z4.string(),
      share_with_type: z4.string(),
      share_with_uuid: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "library_id": "libraryId",
        "user_id": "userId",
        "org_id": "orgId",
        "share_with_type": "shareWithType",
        "share_with_uuid": "shareWithUuid"
      });
    });
    exports.SharingOut$outboundSchema = z4.object({
      libraryId: z4.string(),
      userId: z4.nullable(z4.string()).optional(),
      orgId: z4.string(),
      role: z4.string(),
      shareWithType: z4.string(),
      shareWithUuid: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        libraryId: "library_id",
        userId: "user_id",
        orgId: "org_id",
        shareWithType: "share_with_type",
        shareWithUuid: "share_with_uuid"
      });
    });
    var SharingOut$;
    (function(SharingOut$2) {
      SharingOut$2.inboundSchema = exports.SharingOut$inboundSchema;
      SharingOut$2.outboundSchema = exports.SharingOut$outboundSchema;
    })(SharingOut$ || (exports.SharingOut$ = SharingOut$ = {}));
    function sharingOutToJSON(sharingOut) {
      return JSON.stringify(exports.SharingOut$outboundSchema.parse(sharingOut));
    }
    function sharingOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.SharingOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'SharingOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/listsharingout.js
var require_listsharingout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/listsharingout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListSharingOut$ = exports.ListSharingOut$outboundSchema = exports.ListSharingOut$inboundSchema = void 0;
    exports.listSharingOutToJSON = listSharingOutToJSON;
    exports.listSharingOutFromJSON = listSharingOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var sharingout_js_1 = require_sharingout();
    exports.ListSharingOut$inboundSchema = z4.object({
      data: z4.array(sharingout_js_1.SharingOut$inboundSchema)
    });
    exports.ListSharingOut$outboundSchema = z4.object({
      data: z4.array(sharingout_js_1.SharingOut$outboundSchema)
    });
    var ListSharingOut$;
    (function(ListSharingOut$2) {
      ListSharingOut$2.inboundSchema = exports.ListSharingOut$inboundSchema;
      ListSharingOut$2.outboundSchema = exports.ListSharingOut$outboundSchema;
    })(ListSharingOut$ || (exports.ListSharingOut$ = ListSharingOut$ = {}));
    function listSharingOutToJSON(listSharingOut) {
      return JSON.stringify(exports.ListSharingOut$outboundSchema.parse(listSharingOut));
    }
    function listSharingOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ListSharingOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ListSharingOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/modelconversation.js
var require_modelconversation = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/modelconversation.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ModelConversation$ = exports.ModelConversation$outboundSchema = exports.ModelConversation$inboundSchema = exports.ModelConversationObject$ = exports.ModelConversationObject$outboundSchema = exports.ModelConversationObject$inboundSchema = exports.ModelConversationTools$ = exports.ModelConversationTools$outboundSchema = exports.ModelConversationTools$inboundSchema = exports.ModelConversationObject = void 0;
    exports.modelConversationToolsToJSON = modelConversationToolsToJSON;
    exports.modelConversationToolsFromJSON = modelConversationToolsFromJSON;
    exports.modelConversationToJSON = modelConversationToJSON;
    exports.modelConversationFromJSON = modelConversationFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var codeinterpretertool_js_1 = require_codeinterpretertool();
    var completionargs_js_1 = require_completionargs();
    var documentlibrarytool_js_1 = require_documentlibrarytool();
    var functiontool_js_1 = require_functiontool();
    var imagegenerationtool_js_1 = require_imagegenerationtool();
    var websearchpremiumtool_js_1 = require_websearchpremiumtool();
    var websearchtool_js_1 = require_websearchtool();
    exports.ModelConversationObject = {
      Conversation: "conversation"
    };
    exports.ModelConversationTools$inboundSchema = z4.union([
      codeinterpretertool_js_1.CodeInterpreterTool$inboundSchema.and(z4.object({ type: z4.literal("code_interpreter") }).transform((v2) => ({
        type: v2.type
      }))),
      imagegenerationtool_js_1.ImageGenerationTool$inboundSchema.and(z4.object({ type: z4.literal("image_generation") }).transform((v2) => ({
        type: v2.type
      }))),
      websearchtool_js_1.WebSearchTool$inboundSchema.and(z4.object({ type: z4.literal("web_search") }).transform((v2) => ({
        type: v2.type
      }))),
      websearchpremiumtool_js_1.WebSearchPremiumTool$inboundSchema.and(z4.object({ type: z4.literal("web_search_premium") }).transform((v2) => ({
        type: v2.type
      }))),
      documentlibrarytool_js_1.DocumentLibraryTool$inboundSchema.and(z4.object({ type: z4.literal("document_library") }).transform((v2) => ({
        type: v2.type
      }))),
      functiontool_js_1.FunctionTool$inboundSchema.and(z4.object({ type: z4.literal("function") }).transform((v2) => ({
        type: v2.type
      })))
    ]);
    exports.ModelConversationTools$outboundSchema = z4.union([
      codeinterpretertool_js_1.CodeInterpreterTool$outboundSchema.and(z4.object({ type: z4.literal("code_interpreter") }).transform((v2) => ({
        type: v2.type
      }))),
      imagegenerationtool_js_1.ImageGenerationTool$outboundSchema.and(z4.object({ type: z4.literal("image_generation") }).transform((v2) => ({
        type: v2.type
      }))),
      websearchtool_js_1.WebSearchTool$outboundSchema.and(z4.object({ type: z4.literal("web_search") }).transform((v2) => ({
        type: v2.type
      }))),
      websearchpremiumtool_js_1.WebSearchPremiumTool$outboundSchema.and(z4.object({ type: z4.literal("web_search_premium") }).transform((v2) => ({
        type: v2.type
      }))),
      documentlibrarytool_js_1.DocumentLibraryTool$outboundSchema.and(z4.object({ type: z4.literal("document_library") }).transform((v2) => ({
        type: v2.type
      }))),
      functiontool_js_1.FunctionTool$outboundSchema.and(z4.object({ type: z4.literal("function") }).transform((v2) => ({
        type: v2.type
      })))
    ]);
    var ModelConversationTools$;
    (function(ModelConversationTools$2) {
      ModelConversationTools$2.inboundSchema = exports.ModelConversationTools$inboundSchema;
      ModelConversationTools$2.outboundSchema = exports.ModelConversationTools$outboundSchema;
    })(ModelConversationTools$ || (exports.ModelConversationTools$ = ModelConversationTools$ = {}));
    function modelConversationToolsToJSON(modelConversationTools) {
      return JSON.stringify(exports.ModelConversationTools$outboundSchema.parse(modelConversationTools));
    }
    function modelConversationToolsFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ModelConversationTools$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ModelConversationTools' from JSON`);
    }
    exports.ModelConversationObject$inboundSchema = z4.nativeEnum(exports.ModelConversationObject);
    exports.ModelConversationObject$outboundSchema = exports.ModelConversationObject$inboundSchema;
    var ModelConversationObject$;
    (function(ModelConversationObject$2) {
      ModelConversationObject$2.inboundSchema = exports.ModelConversationObject$inboundSchema;
      ModelConversationObject$2.outboundSchema = exports.ModelConversationObject$outboundSchema;
    })(ModelConversationObject$ || (exports.ModelConversationObject$ = ModelConversationObject$ = {}));
    exports.ModelConversation$inboundSchema = z4.object({
      instructions: z4.nullable(z4.string()).optional(),
      tools: z4.array(z4.union([
        codeinterpretertool_js_1.CodeInterpreterTool$inboundSchema.and(z4.object({ type: z4.literal("code_interpreter") }).transform((v2) => ({
          type: v2.type
        }))),
        imagegenerationtool_js_1.ImageGenerationTool$inboundSchema.and(z4.object({ type: z4.literal("image_generation") }).transform((v2) => ({
          type: v2.type
        }))),
        websearchtool_js_1.WebSearchTool$inboundSchema.and(z4.object({ type: z4.literal("web_search") }).transform((v2) => ({
          type: v2.type
        }))),
        websearchpremiumtool_js_1.WebSearchPremiumTool$inboundSchema.and(z4.object({ type: z4.literal("web_search_premium") }).transform((v2) => ({
          type: v2.type
        }))),
        documentlibrarytool_js_1.DocumentLibraryTool$inboundSchema.and(z4.object({ type: z4.literal("document_library") }).transform((v2) => ({
          type: v2.type
        }))),
        functiontool_js_1.FunctionTool$inboundSchema.and(z4.object({ type: z4.literal("function") }).transform((v2) => ({
          type: v2.type
        })))
      ])).optional(),
      completion_args: completionargs_js_1.CompletionArgs$inboundSchema.optional(),
      name: z4.nullable(z4.string()).optional(),
      description: z4.nullable(z4.string()).optional(),
      object: exports.ModelConversationObject$inboundSchema.default("conversation"),
      id: z4.string(),
      created_at: z4.string().datetime({ offset: true }).transform((v2) => new Date(v2)),
      updated_at: z4.string().datetime({ offset: true }).transform((v2) => new Date(v2)),
      model: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "completion_args": "completionArgs",
        "created_at": "createdAt",
        "updated_at": "updatedAt"
      });
    });
    exports.ModelConversation$outboundSchema = z4.object({
      instructions: z4.nullable(z4.string()).optional(),
      tools: z4.array(z4.union([
        codeinterpretertool_js_1.CodeInterpreterTool$outboundSchema.and(z4.object({ type: z4.literal("code_interpreter") }).transform((v2) => ({
          type: v2.type
        }))),
        imagegenerationtool_js_1.ImageGenerationTool$outboundSchema.and(z4.object({ type: z4.literal("image_generation") }).transform((v2) => ({
          type: v2.type
        }))),
        websearchtool_js_1.WebSearchTool$outboundSchema.and(z4.object({ type: z4.literal("web_search") }).transform((v2) => ({
          type: v2.type
        }))),
        websearchpremiumtool_js_1.WebSearchPremiumTool$outboundSchema.and(z4.object({ type: z4.literal("web_search_premium") }).transform((v2) => ({
          type: v2.type
        }))),
        documentlibrarytool_js_1.DocumentLibraryTool$outboundSchema.and(z4.object({ type: z4.literal("document_library") }).transform((v2) => ({
          type: v2.type
        }))),
        functiontool_js_1.FunctionTool$outboundSchema.and(z4.object({ type: z4.literal("function") }).transform((v2) => ({
          type: v2.type
        })))
      ])).optional(),
      completionArgs: completionargs_js_1.CompletionArgs$outboundSchema.optional(),
      name: z4.nullable(z4.string()).optional(),
      description: z4.nullable(z4.string()).optional(),
      object: exports.ModelConversationObject$outboundSchema.default("conversation"),
      id: z4.string(),
      createdAt: z4.date().transform((v2) => v2.toISOString()),
      updatedAt: z4.date().transform((v2) => v2.toISOString()),
      model: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        completionArgs: "completion_args",
        createdAt: "created_at",
        updatedAt: "updated_at"
      });
    });
    var ModelConversation$;
    (function(ModelConversation$2) {
      ModelConversation$2.inboundSchema = exports.ModelConversation$inboundSchema;
      ModelConversation$2.outboundSchema = exports.ModelConversation$outboundSchema;
    })(ModelConversation$ || (exports.ModelConversation$ = ModelConversation$ = {}));
    function modelConversationToJSON(modelConversation) {
      return JSON.stringify(exports.ModelConversation$outboundSchema.parse(modelConversation));
    }
    function modelConversationFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ModelConversation$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ModelConversation' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/modellist.js
var require_modellist = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/modellist.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ModelList$ = exports.ModelList$outboundSchema = exports.ModelList$inboundSchema = exports.Data$ = exports.Data$outboundSchema = exports.Data$inboundSchema = void 0;
    exports.dataToJSON = dataToJSON;
    exports.dataFromJSON = dataFromJSON;
    exports.modelListToJSON = modelListToJSON;
    exports.modelListFromJSON = modelListFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var basemodelcard_js_1 = require_basemodelcard();
    var ftmodelcard_js_1 = require_ftmodelcard();
    exports.Data$inboundSchema = z4.union([
      basemodelcard_js_1.BaseModelCard$inboundSchema.and(z4.object({ type: z4.literal("base") }).transform((v2) => ({
        type: v2.type
      }))),
      ftmodelcard_js_1.FTModelCard$inboundSchema.and(z4.object({ type: z4.literal("fine-tuned") }).transform((v2) => ({
        type: v2.type
      })))
    ]);
    exports.Data$outboundSchema = z4.union([
      basemodelcard_js_1.BaseModelCard$outboundSchema.and(z4.object({ type: z4.literal("base") }).transform((v2) => ({
        type: v2.type
      }))),
      ftmodelcard_js_1.FTModelCard$outboundSchema.and(z4.object({ type: z4.literal("fine-tuned") }).transform((v2) => ({
        type: v2.type
      })))
    ]);
    var Data$;
    (function(Data$2) {
      Data$2.inboundSchema = exports.Data$inboundSchema;
      Data$2.outboundSchema = exports.Data$outboundSchema;
    })(Data$ || (exports.Data$ = Data$ = {}));
    function dataToJSON(data) {
      return JSON.stringify(exports.Data$outboundSchema.parse(data));
    }
    function dataFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.Data$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'Data' from JSON`);
    }
    exports.ModelList$inboundSchema = z4.object({
      object: z4.string().default("list"),
      data: z4.array(z4.union([
        basemodelcard_js_1.BaseModelCard$inboundSchema.and(z4.object({ type: z4.literal("base") }).transform((v2) => ({
          type: v2.type
        }))),
        ftmodelcard_js_1.FTModelCard$inboundSchema.and(z4.object({ type: z4.literal("fine-tuned") }).transform((v2) => ({
          type: v2.type
        })))
      ])).optional()
    });
    exports.ModelList$outboundSchema = z4.object({
      object: z4.string().default("list"),
      data: z4.array(z4.union([
        basemodelcard_js_1.BaseModelCard$outboundSchema.and(z4.object({ type: z4.literal("base") }).transform((v2) => ({
          type: v2.type
        }))),
        ftmodelcard_js_1.FTModelCard$outboundSchema.and(z4.object({ type: z4.literal("fine-tuned") }).transform((v2) => ({
          type: v2.type
        })))
      ])).optional()
    });
    var ModelList$;
    (function(ModelList$2) {
      ModelList$2.inboundSchema = exports.ModelList$inboundSchema;
      ModelList$2.outboundSchema = exports.ModelList$outboundSchema;
    })(ModelList$ || (exports.ModelList$ = ModelList$ = {}));
    function modelListToJSON(modelList) {
      return JSON.stringify(exports.ModelList$outboundSchema.parse(modelList));
    }
    function modelListFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ModelList$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ModelList' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/moderationobject.js
var require_moderationobject = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/moderationobject.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ModerationObject$ = exports.ModerationObject$outboundSchema = exports.ModerationObject$inboundSchema = void 0;
    exports.moderationObjectToJSON = moderationObjectToJSON;
    exports.moderationObjectFromJSON = moderationObjectFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.ModerationObject$inboundSchema = z4.object({
      categories: z4.record(z4.boolean()).optional(),
      category_scores: z4.record(z4.number()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "category_scores": "categoryScores"
      });
    });
    exports.ModerationObject$outboundSchema = z4.object({
      categories: z4.record(z4.boolean()).optional(),
      categoryScores: z4.record(z4.number()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        categoryScores: "category_scores"
      });
    });
    var ModerationObject$;
    (function(ModerationObject$2) {
      ModerationObject$2.inboundSchema = exports.ModerationObject$inboundSchema;
      ModerationObject$2.outboundSchema = exports.ModerationObject$outboundSchema;
    })(ModerationObject$ || (exports.ModerationObject$ = ModerationObject$ = {}));
    function moderationObjectToJSON(moderationObject) {
      return JSON.stringify(exports.ModerationObject$outboundSchema.parse(moderationObject));
    }
    function moderationObjectFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ModerationObject$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ModerationObject' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/moderationresponse.js
var require_moderationresponse = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/moderationresponse.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ModerationResponse$ = exports.ModerationResponse$outboundSchema = exports.ModerationResponse$inboundSchema = void 0;
    exports.moderationResponseToJSON = moderationResponseToJSON;
    exports.moderationResponseFromJSON = moderationResponseFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var moderationobject_js_1 = require_moderationobject();
    exports.ModerationResponse$inboundSchema = z4.object({
      id: z4.string(),
      model: z4.string(),
      results: z4.array(moderationobject_js_1.ModerationObject$inboundSchema)
    });
    exports.ModerationResponse$outboundSchema = z4.object({
      id: z4.string(),
      model: z4.string(),
      results: z4.array(moderationobject_js_1.ModerationObject$outboundSchema)
    });
    var ModerationResponse$;
    (function(ModerationResponse$2) {
      ModerationResponse$2.inboundSchema = exports.ModerationResponse$inboundSchema;
      ModerationResponse$2.outboundSchema = exports.ModerationResponse$outboundSchema;
    })(ModerationResponse$ || (exports.ModerationResponse$ = ModerationResponse$ = {}));
    function moderationResponseToJSON(moderationResponse) {
      return JSON.stringify(exports.ModerationResponse$outboundSchema.parse(moderationResponse));
    }
    function moderationResponseFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ModerationResponse$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ModerationResponse' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/ocrimageobject.js
var require_ocrimageobject = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/ocrimageobject.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OCRImageObject$ = exports.OCRImageObject$outboundSchema = exports.OCRImageObject$inboundSchema = void 0;
    exports.ocrImageObjectToJSON = ocrImageObjectToJSON;
    exports.ocrImageObjectFromJSON = ocrImageObjectFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.OCRImageObject$inboundSchema = z4.object({
      id: z4.string(),
      top_left_x: z4.nullable(z4.number().int()),
      top_left_y: z4.nullable(z4.number().int()),
      bottom_right_x: z4.nullable(z4.number().int()),
      bottom_right_y: z4.nullable(z4.number().int()),
      image_base64: z4.nullable(z4.string()).optional(),
      image_annotation: z4.nullable(z4.string()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "top_left_x": "topLeftX",
        "top_left_y": "topLeftY",
        "bottom_right_x": "bottomRightX",
        "bottom_right_y": "bottomRightY",
        "image_base64": "imageBase64",
        "image_annotation": "imageAnnotation"
      });
    });
    exports.OCRImageObject$outboundSchema = z4.object({
      id: z4.string(),
      topLeftX: z4.nullable(z4.number().int()),
      topLeftY: z4.nullable(z4.number().int()),
      bottomRightX: z4.nullable(z4.number().int()),
      bottomRightY: z4.nullable(z4.number().int()),
      imageBase64: z4.nullable(z4.string()).optional(),
      imageAnnotation: z4.nullable(z4.string()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        topLeftX: "top_left_x",
        topLeftY: "top_left_y",
        bottomRightX: "bottom_right_x",
        bottomRightY: "bottom_right_y",
        imageBase64: "image_base64",
        imageAnnotation: "image_annotation"
      });
    });
    var OCRImageObject$;
    (function(OCRImageObject$2) {
      OCRImageObject$2.inboundSchema = exports.OCRImageObject$inboundSchema;
      OCRImageObject$2.outboundSchema = exports.OCRImageObject$outboundSchema;
    })(OCRImageObject$ || (exports.OCRImageObject$ = OCRImageObject$ = {}));
    function ocrImageObjectToJSON(ocrImageObject) {
      return JSON.stringify(exports.OCRImageObject$outboundSchema.parse(ocrImageObject));
    }
    function ocrImageObjectFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.OCRImageObject$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'OCRImageObject' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/ocrpagedimensions.js
var require_ocrpagedimensions = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/ocrpagedimensions.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OCRPageDimensions$ = exports.OCRPageDimensions$outboundSchema = exports.OCRPageDimensions$inboundSchema = void 0;
    exports.ocrPageDimensionsToJSON = ocrPageDimensionsToJSON;
    exports.ocrPageDimensionsFromJSON = ocrPageDimensionsFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    exports.OCRPageDimensions$inboundSchema = z4.object({
      dpi: z4.number().int(),
      height: z4.number().int(),
      width: z4.number().int()
    });
    exports.OCRPageDimensions$outboundSchema = z4.object({
      dpi: z4.number().int(),
      height: z4.number().int(),
      width: z4.number().int()
    });
    var OCRPageDimensions$;
    (function(OCRPageDimensions$2) {
      OCRPageDimensions$2.inboundSchema = exports.OCRPageDimensions$inboundSchema;
      OCRPageDimensions$2.outboundSchema = exports.OCRPageDimensions$outboundSchema;
    })(OCRPageDimensions$ || (exports.OCRPageDimensions$ = OCRPageDimensions$ = {}));
    function ocrPageDimensionsToJSON(ocrPageDimensions) {
      return JSON.stringify(exports.OCRPageDimensions$outboundSchema.parse(ocrPageDimensions));
    }
    function ocrPageDimensionsFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.OCRPageDimensions$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'OCRPageDimensions' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/ocrpageobject.js
var require_ocrpageobject = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/ocrpageobject.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OCRPageObject$ = exports.OCRPageObject$outboundSchema = exports.OCRPageObject$inboundSchema = void 0;
    exports.ocrPageObjectToJSON = ocrPageObjectToJSON;
    exports.ocrPageObjectFromJSON = ocrPageObjectFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var ocrimageobject_js_1 = require_ocrimageobject();
    var ocrpagedimensions_js_1 = require_ocrpagedimensions();
    exports.OCRPageObject$inboundSchema = z4.object({
      index: z4.number().int(),
      markdown: z4.string(),
      images: z4.array(ocrimageobject_js_1.OCRImageObject$inboundSchema),
      dimensions: z4.nullable(ocrpagedimensions_js_1.OCRPageDimensions$inboundSchema)
    });
    exports.OCRPageObject$outboundSchema = z4.object({
      index: z4.number().int(),
      markdown: z4.string(),
      images: z4.array(ocrimageobject_js_1.OCRImageObject$outboundSchema),
      dimensions: z4.nullable(ocrpagedimensions_js_1.OCRPageDimensions$outboundSchema)
    });
    var OCRPageObject$;
    (function(OCRPageObject$2) {
      OCRPageObject$2.inboundSchema = exports.OCRPageObject$inboundSchema;
      OCRPageObject$2.outboundSchema = exports.OCRPageObject$outboundSchema;
    })(OCRPageObject$ || (exports.OCRPageObject$ = OCRPageObject$ = {}));
    function ocrPageObjectToJSON(ocrPageObject) {
      return JSON.stringify(exports.OCRPageObject$outboundSchema.parse(ocrPageObject));
    }
    function ocrPageObjectFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.OCRPageObject$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'OCRPageObject' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/ocrrequest.js
var require_ocrrequest = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/ocrrequest.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OCRRequest$ = exports.OCRRequest$outboundSchema = exports.OCRRequest$inboundSchema = exports.Document$ = exports.Document$outboundSchema = exports.Document$inboundSchema = void 0;
    exports.documentToJSON = documentToJSON;
    exports.documentFromJSON = documentFromJSON;
    exports.ocrRequestToJSON = ocrRequestToJSON;
    exports.ocrRequestFromJSON = ocrRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var documenturlchunk_js_1 = require_documenturlchunk();
    var filechunk_js_1 = require_filechunk();
    var imageurlchunk_js_1 = require_imageurlchunk();
    var responseformat_js_1 = require_responseformat();
    exports.Document$inboundSchema = z4.union([
      filechunk_js_1.FileChunk$inboundSchema,
      imageurlchunk_js_1.ImageURLChunk$inboundSchema,
      documenturlchunk_js_1.DocumentURLChunk$inboundSchema
    ]);
    exports.Document$outboundSchema = z4.union([
      filechunk_js_1.FileChunk$outboundSchema,
      imageurlchunk_js_1.ImageURLChunk$outboundSchema,
      documenturlchunk_js_1.DocumentURLChunk$outboundSchema
    ]);
    var Document$;
    (function(Document$2) {
      Document$2.inboundSchema = exports.Document$inboundSchema;
      Document$2.outboundSchema = exports.Document$outboundSchema;
    })(Document$ || (exports.Document$ = Document$ = {}));
    function documentToJSON(document2) {
      return JSON.stringify(exports.Document$outboundSchema.parse(document2));
    }
    function documentFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.Document$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'Document' from JSON`);
    }
    exports.OCRRequest$inboundSchema = z4.object({
      model: z4.nullable(z4.string()),
      id: z4.string().optional(),
      document: z4.union([
        filechunk_js_1.FileChunk$inboundSchema,
        imageurlchunk_js_1.ImageURLChunk$inboundSchema,
        documenturlchunk_js_1.DocumentURLChunk$inboundSchema
      ]),
      pages: z4.nullable(z4.array(z4.number().int())).optional(),
      include_image_base64: z4.nullable(z4.boolean()).optional(),
      image_limit: z4.nullable(z4.number().int()).optional(),
      image_min_size: z4.nullable(z4.number().int()).optional(),
      bbox_annotation_format: z4.nullable(responseformat_js_1.ResponseFormat$inboundSchema).optional(),
      document_annotation_format: z4.nullable(responseformat_js_1.ResponseFormat$inboundSchema).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "include_image_base64": "includeImageBase64",
        "image_limit": "imageLimit",
        "image_min_size": "imageMinSize",
        "bbox_annotation_format": "bboxAnnotationFormat",
        "document_annotation_format": "documentAnnotationFormat"
      });
    });
    exports.OCRRequest$outboundSchema = z4.object({
      model: z4.nullable(z4.string()),
      id: z4.string().optional(),
      document: z4.union([
        filechunk_js_1.FileChunk$outboundSchema,
        imageurlchunk_js_1.ImageURLChunk$outboundSchema,
        documenturlchunk_js_1.DocumentURLChunk$outboundSchema
      ]),
      pages: z4.nullable(z4.array(z4.number().int())).optional(),
      includeImageBase64: z4.nullable(z4.boolean()).optional(),
      imageLimit: z4.nullable(z4.number().int()).optional(),
      imageMinSize: z4.nullable(z4.number().int()).optional(),
      bboxAnnotationFormat: z4.nullable(responseformat_js_1.ResponseFormat$outboundSchema).optional(),
      documentAnnotationFormat: z4.nullable(responseformat_js_1.ResponseFormat$outboundSchema).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        includeImageBase64: "include_image_base64",
        imageLimit: "image_limit",
        imageMinSize: "image_min_size",
        bboxAnnotationFormat: "bbox_annotation_format",
        documentAnnotationFormat: "document_annotation_format"
      });
    });
    var OCRRequest$;
    (function(OCRRequest$2) {
      OCRRequest$2.inboundSchema = exports.OCRRequest$inboundSchema;
      OCRRequest$2.outboundSchema = exports.OCRRequest$outboundSchema;
    })(OCRRequest$ || (exports.OCRRequest$ = OCRRequest$ = {}));
    function ocrRequestToJSON(ocrRequest) {
      return JSON.stringify(exports.OCRRequest$outboundSchema.parse(ocrRequest));
    }
    function ocrRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.OCRRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'OCRRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/ocrusageinfo.js
var require_ocrusageinfo = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/ocrusageinfo.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OCRUsageInfo$ = exports.OCRUsageInfo$outboundSchema = exports.OCRUsageInfo$inboundSchema = void 0;
    exports.ocrUsageInfoToJSON = ocrUsageInfoToJSON;
    exports.ocrUsageInfoFromJSON = ocrUsageInfoFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.OCRUsageInfo$inboundSchema = z4.object({
      pages_processed: z4.number().int(),
      doc_size_bytes: z4.nullable(z4.number().int()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "pages_processed": "pagesProcessed",
        "doc_size_bytes": "docSizeBytes"
      });
    });
    exports.OCRUsageInfo$outboundSchema = z4.object({
      pagesProcessed: z4.number().int(),
      docSizeBytes: z4.nullable(z4.number().int()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        pagesProcessed: "pages_processed",
        docSizeBytes: "doc_size_bytes"
      });
    });
    var OCRUsageInfo$;
    (function(OCRUsageInfo$2) {
      OCRUsageInfo$2.inboundSchema = exports.OCRUsageInfo$inboundSchema;
      OCRUsageInfo$2.outboundSchema = exports.OCRUsageInfo$outboundSchema;
    })(OCRUsageInfo$ || (exports.OCRUsageInfo$ = OCRUsageInfo$ = {}));
    function ocrUsageInfoToJSON(ocrUsageInfo) {
      return JSON.stringify(exports.OCRUsageInfo$outboundSchema.parse(ocrUsageInfo));
    }
    function ocrUsageInfoFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.OCRUsageInfo$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'OCRUsageInfo' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/ocrresponse.js
var require_ocrresponse = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/ocrresponse.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OCRResponse$ = exports.OCRResponse$outboundSchema = exports.OCRResponse$inboundSchema = void 0;
    exports.ocrResponseToJSON = ocrResponseToJSON;
    exports.ocrResponseFromJSON = ocrResponseFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var ocrpageobject_js_1 = require_ocrpageobject();
    var ocrusageinfo_js_1 = require_ocrusageinfo();
    exports.OCRResponse$inboundSchema = z4.object({
      pages: z4.array(ocrpageobject_js_1.OCRPageObject$inboundSchema),
      model: z4.string(),
      document_annotation: z4.nullable(z4.string()).optional(),
      usage_info: ocrusageinfo_js_1.OCRUsageInfo$inboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "document_annotation": "documentAnnotation",
        "usage_info": "usageInfo"
      });
    });
    exports.OCRResponse$outboundSchema = z4.object({
      pages: z4.array(ocrpageobject_js_1.OCRPageObject$outboundSchema),
      model: z4.string(),
      documentAnnotation: z4.nullable(z4.string()).optional(),
      usageInfo: ocrusageinfo_js_1.OCRUsageInfo$outboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        documentAnnotation: "document_annotation",
        usageInfo: "usage_info"
      });
    });
    var OCRResponse$;
    (function(OCRResponse$2) {
      OCRResponse$2.inboundSchema = exports.OCRResponse$inboundSchema;
      OCRResponse$2.outboundSchema = exports.OCRResponse$outboundSchema;
    })(OCRResponse$ || (exports.OCRResponse$ = OCRResponse$ = {}));
    function ocrResponseToJSON(ocrResponse) {
      return JSON.stringify(exports.OCRResponse$outboundSchema.parse(ocrResponse));
    }
    function ocrResponseFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.OCRResponse$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'OCRResponse' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/processingstatusout.js
var require_processingstatusout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/processingstatusout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProcessingStatusOut$ = exports.ProcessingStatusOut$outboundSchema = exports.ProcessingStatusOut$inboundSchema = void 0;
    exports.processingStatusOutToJSON = processingStatusOutToJSON;
    exports.processingStatusOutFromJSON = processingStatusOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.ProcessingStatusOut$inboundSchema = z4.object({
      document_id: z4.string(),
      processing_status: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "document_id": "documentId",
        "processing_status": "processingStatus"
      });
    });
    exports.ProcessingStatusOut$outboundSchema = z4.object({
      documentId: z4.string(),
      processingStatus: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        documentId: "document_id",
        processingStatus: "processing_status"
      });
    });
    var ProcessingStatusOut$;
    (function(ProcessingStatusOut$2) {
      ProcessingStatusOut$2.inboundSchema = exports.ProcessingStatusOut$inboundSchema;
      ProcessingStatusOut$2.outboundSchema = exports.ProcessingStatusOut$outboundSchema;
    })(ProcessingStatusOut$ || (exports.ProcessingStatusOut$ = ProcessingStatusOut$ = {}));
    function processingStatusOutToJSON(processingStatusOut) {
      return JSON.stringify(exports.ProcessingStatusOut$outboundSchema.parse(processingStatusOut));
    }
    function processingStatusOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ProcessingStatusOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ProcessingStatusOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/retrievefileout.js
var require_retrievefileout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/retrievefileout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RetrieveFileOut$ = exports.RetrieveFileOut$outboundSchema = exports.RetrieveFileOut$inboundSchema = void 0;
    exports.retrieveFileOutToJSON = retrieveFileOutToJSON;
    exports.retrieveFileOutFromJSON = retrieveFileOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var filepurpose_js_1 = require_filepurpose();
    var sampletype_js_1 = require_sampletype();
    var source_js_1 = require_source();
    exports.RetrieveFileOut$inboundSchema = z4.object({
      id: z4.string(),
      object: z4.string(),
      bytes: z4.number().int(),
      created_at: z4.number().int(),
      filename: z4.string(),
      purpose: filepurpose_js_1.FilePurpose$inboundSchema,
      sample_type: sampletype_js_1.SampleType$inboundSchema,
      num_lines: z4.nullable(z4.number().int()).optional(),
      mimetype: z4.nullable(z4.string()).optional(),
      source: source_js_1.Source$inboundSchema,
      signature: z4.nullable(z4.string()).optional(),
      deleted: z4.boolean()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "bytes": "sizeBytes",
        "created_at": "createdAt",
        "sample_type": "sampleType",
        "num_lines": "numLines"
      });
    });
    exports.RetrieveFileOut$outboundSchema = z4.object({
      id: z4.string(),
      object: z4.string(),
      sizeBytes: z4.number().int(),
      createdAt: z4.number().int(),
      filename: z4.string(),
      purpose: filepurpose_js_1.FilePurpose$outboundSchema,
      sampleType: sampletype_js_1.SampleType$outboundSchema,
      numLines: z4.nullable(z4.number().int()).optional(),
      mimetype: z4.nullable(z4.string()).optional(),
      source: source_js_1.Source$outboundSchema,
      signature: z4.nullable(z4.string()).optional(),
      deleted: z4.boolean()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        sizeBytes: "bytes",
        createdAt: "created_at",
        sampleType: "sample_type",
        numLines: "num_lines"
      });
    });
    var RetrieveFileOut$;
    (function(RetrieveFileOut$2) {
      RetrieveFileOut$2.inboundSchema = exports.RetrieveFileOut$inboundSchema;
      RetrieveFileOut$2.outboundSchema = exports.RetrieveFileOut$outboundSchema;
    })(RetrieveFileOut$ || (exports.RetrieveFileOut$ = RetrieveFileOut$ = {}));
    function retrieveFileOutToJSON(retrieveFileOut) {
      return JSON.stringify(exports.RetrieveFileOut$outboundSchema.parse(retrieveFileOut));
    }
    function retrieveFileOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.RetrieveFileOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'RetrieveFileOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/security.js
var require_security2 = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/security.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Security$ = exports.Security$outboundSchema = exports.Security$inboundSchema = void 0;
    exports.securityToJSON = securityToJSON;
    exports.securityFromJSON = securityFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.Security$inboundSchema = z4.object({
      ApiKey: z4.string().optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "ApiKey": "apiKey"
      });
    });
    exports.Security$outboundSchema = z4.object({
      apiKey: z4.string().optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        apiKey: "ApiKey"
      });
    });
    var Security$;
    (function(Security$2) {
      Security$2.inboundSchema = exports.Security$inboundSchema;
      Security$2.outboundSchema = exports.Security$outboundSchema;
    })(Security$ || (exports.Security$ = Security$ = {}));
    function securityToJSON(security) {
      return JSON.stringify(exports.Security$outboundSchema.parse(security));
    }
    function securityFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.Security$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'Security' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/shareenum.js
var require_shareenum = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/shareenum.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ShareEnum$ = exports.ShareEnum$outboundSchema = exports.ShareEnum$inboundSchema = exports.ShareEnum = void 0;
    var z4 = __importStar(__require("zod"));
    var enums_js_1 = require_enums();
    exports.ShareEnum = {
      Viewer: "Viewer",
      Editor: "Editor"
    };
    exports.ShareEnum$inboundSchema = z4.union([
      z4.nativeEnum(exports.ShareEnum),
      z4.string().transform(enums_js_1.catchUnrecognizedEnum)
    ]);
    exports.ShareEnum$outboundSchema = z4.union([
      z4.nativeEnum(exports.ShareEnum),
      z4.string().and(z4.custom())
    ]);
    var ShareEnum$;
    (function(ShareEnum$2) {
      ShareEnum$2.inboundSchema = exports.ShareEnum$inboundSchema;
      ShareEnum$2.outboundSchema = exports.ShareEnum$outboundSchema;
    })(ShareEnum$ || (exports.ShareEnum$ = ShareEnum$ = {}));
  }
});

// ../node_modules/@mistralai/mistralai/models/components/sharingdelete.js
var require_sharingdelete = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/sharingdelete.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SharingDelete$ = exports.SharingDelete$outboundSchema = exports.SharingDelete$inboundSchema = void 0;
    exports.sharingDeleteToJSON = sharingDeleteToJSON;
    exports.sharingDeleteFromJSON = sharingDeleteFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var entitytype_js_1 = require_entitytype();
    exports.SharingDelete$inboundSchema = z4.object({
      org_id: z4.string(),
      share_with_uuid: z4.string(),
      share_with_type: entitytype_js_1.EntityType$inboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "org_id": "orgId",
        "share_with_uuid": "shareWithUuid",
        "share_with_type": "shareWithType"
      });
    });
    exports.SharingDelete$outboundSchema = z4.object({
      orgId: z4.string(),
      shareWithUuid: z4.string(),
      shareWithType: entitytype_js_1.EntityType$outboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        orgId: "org_id",
        shareWithUuid: "share_with_uuid",
        shareWithType: "share_with_type"
      });
    });
    var SharingDelete$;
    (function(SharingDelete$2) {
      SharingDelete$2.inboundSchema = exports.SharingDelete$inboundSchema;
      SharingDelete$2.outboundSchema = exports.SharingDelete$outboundSchema;
    })(SharingDelete$ || (exports.SharingDelete$ = SharingDelete$ = {}));
    function sharingDeleteToJSON(sharingDelete) {
      return JSON.stringify(exports.SharingDelete$outboundSchema.parse(sharingDelete));
    }
    function sharingDeleteFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.SharingDelete$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'SharingDelete' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/sharingin.js
var require_sharingin = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/sharingin.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SharingIn$ = exports.SharingIn$outboundSchema = exports.SharingIn$inboundSchema = void 0;
    exports.sharingInToJSON = sharingInToJSON;
    exports.sharingInFromJSON = sharingInFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var entitytype_js_1 = require_entitytype();
    var shareenum_js_1 = require_shareenum();
    exports.SharingIn$inboundSchema = z4.object({
      org_id: z4.string(),
      level: shareenum_js_1.ShareEnum$inboundSchema,
      share_with_uuid: z4.string(),
      share_with_type: entitytype_js_1.EntityType$inboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "org_id": "orgId",
        "share_with_uuid": "shareWithUuid",
        "share_with_type": "shareWithType"
      });
    });
    exports.SharingIn$outboundSchema = z4.object({
      orgId: z4.string(),
      level: shareenum_js_1.ShareEnum$outboundSchema,
      shareWithUuid: z4.string(),
      shareWithType: entitytype_js_1.EntityType$outboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        orgId: "org_id",
        shareWithUuid: "share_with_uuid",
        shareWithType: "share_with_type"
      });
    });
    var SharingIn$;
    (function(SharingIn$2) {
      SharingIn$2.inboundSchema = exports.SharingIn$inboundSchema;
      SharingIn$2.outboundSchema = exports.SharingIn$outboundSchema;
    })(SharingIn$ || (exports.SharingIn$ = SharingIn$ = {}));
    function sharingInToJSON(sharingIn) {
      return JSON.stringify(exports.SharingIn$outboundSchema.parse(sharingIn));
    }
    function sharingInFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.SharingIn$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'SharingIn' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/transcriptionsegmentchunk.js
var require_transcriptionsegmentchunk = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/transcriptionsegmentchunk.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TranscriptionSegmentChunk$ = exports.TranscriptionSegmentChunk$outboundSchema = exports.TranscriptionSegmentChunk$inboundSchema = exports.Type$ = exports.Type$outboundSchema = exports.Type$inboundSchema = exports.Type = void 0;
    exports.transcriptionSegmentChunkToJSON = transcriptionSegmentChunkToJSON;
    exports.transcriptionSegmentChunkFromJSON = transcriptionSegmentChunkFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.Type = {
      TranscriptionSegment: "transcription_segment"
    };
    exports.Type$inboundSchema = z4.nativeEnum(exports.Type);
    exports.Type$outboundSchema = exports.Type$inboundSchema;
    var Type$;
    (function(Type$2) {
      Type$2.inboundSchema = exports.Type$inboundSchema;
      Type$2.outboundSchema = exports.Type$outboundSchema;
    })(Type$ || (exports.Type$ = Type$ = {}));
    exports.TranscriptionSegmentChunk$inboundSchema = (0, schemas_js_1.collectExtraKeys)(z4.object({
      text: z4.string(),
      start: z4.number(),
      end: z4.number(),
      type: exports.Type$inboundSchema.default("transcription_segment")
    }).catchall(z4.any()), "additionalProperties", true);
    exports.TranscriptionSegmentChunk$outboundSchema = z4.object({
      text: z4.string(),
      start: z4.number(),
      end: z4.number(),
      type: exports.Type$outboundSchema.default("transcription_segment"),
      additionalProperties: z4.record(z4.any())
    }).transform((v2) => {
      return {
        ...v2.additionalProperties,
        ...(0, primitives_js_1.remap)(v2, {
          additionalProperties: null
        })
      };
    });
    var TranscriptionSegmentChunk$;
    (function(TranscriptionSegmentChunk$2) {
      TranscriptionSegmentChunk$2.inboundSchema = exports.TranscriptionSegmentChunk$inboundSchema;
      TranscriptionSegmentChunk$2.outboundSchema = exports.TranscriptionSegmentChunk$outboundSchema;
    })(TranscriptionSegmentChunk$ || (exports.TranscriptionSegmentChunk$ = TranscriptionSegmentChunk$ = {}));
    function transcriptionSegmentChunkToJSON(transcriptionSegmentChunk) {
      return JSON.stringify(exports.TranscriptionSegmentChunk$outboundSchema.parse(transcriptionSegmentChunk));
    }
    function transcriptionSegmentChunkFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.TranscriptionSegmentChunk$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'TranscriptionSegmentChunk' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/transcriptionresponse.js
var require_transcriptionresponse = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/transcriptionresponse.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TranscriptionResponse$ = exports.TranscriptionResponse$outboundSchema = exports.TranscriptionResponse$inboundSchema = void 0;
    exports.transcriptionResponseToJSON = transcriptionResponseToJSON;
    exports.transcriptionResponseFromJSON = transcriptionResponseFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var transcriptionsegmentchunk_js_1 = require_transcriptionsegmentchunk();
    var usageinfo_js_1 = require_usageinfo();
    exports.TranscriptionResponse$inboundSchema = (0, schemas_js_1.collectExtraKeys)(z4.object({
      model: z4.string(),
      text: z4.string(),
      segments: z4.array(transcriptionsegmentchunk_js_1.TranscriptionSegmentChunk$inboundSchema).optional(),
      usage: usageinfo_js_1.UsageInfo$inboundSchema,
      language: z4.nullable(z4.string())
    }).catchall(z4.any()), "additionalProperties", true);
    exports.TranscriptionResponse$outboundSchema = z4.object({
      model: z4.string(),
      text: z4.string(),
      segments: z4.array(transcriptionsegmentchunk_js_1.TranscriptionSegmentChunk$outboundSchema).optional(),
      usage: usageinfo_js_1.UsageInfo$outboundSchema,
      language: z4.nullable(z4.string()),
      additionalProperties: z4.record(z4.any())
    }).transform((v2) => {
      return {
        ...v2.additionalProperties,
        ...(0, primitives_js_1.remap)(v2, {
          additionalProperties: null
        })
      };
    });
    var TranscriptionResponse$;
    (function(TranscriptionResponse$2) {
      TranscriptionResponse$2.inboundSchema = exports.TranscriptionResponse$inboundSchema;
      TranscriptionResponse$2.outboundSchema = exports.TranscriptionResponse$outboundSchema;
    })(TranscriptionResponse$ || (exports.TranscriptionResponse$ = TranscriptionResponse$ = {}));
    function transcriptionResponseToJSON(transcriptionResponse) {
      return JSON.stringify(exports.TranscriptionResponse$outboundSchema.parse(transcriptionResponse));
    }
    function transcriptionResponseFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.TranscriptionResponse$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'TranscriptionResponse' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/transcriptionstreamdone.js
var require_transcriptionstreamdone = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/transcriptionstreamdone.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TranscriptionStreamDone$ = exports.TranscriptionStreamDone$outboundSchema = exports.TranscriptionStreamDone$inboundSchema = exports.TranscriptionStreamDoneType$ = exports.TranscriptionStreamDoneType$outboundSchema = exports.TranscriptionStreamDoneType$inboundSchema = exports.TranscriptionStreamDoneType = void 0;
    exports.transcriptionStreamDoneToJSON = transcriptionStreamDoneToJSON;
    exports.transcriptionStreamDoneFromJSON = transcriptionStreamDoneFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var transcriptionsegmentchunk_js_1 = require_transcriptionsegmentchunk();
    var usageinfo_js_1 = require_usageinfo();
    exports.TranscriptionStreamDoneType = {
      TranscriptionDone: "transcription.done"
    };
    exports.TranscriptionStreamDoneType$inboundSchema = z4.nativeEnum(exports.TranscriptionStreamDoneType);
    exports.TranscriptionStreamDoneType$outboundSchema = exports.TranscriptionStreamDoneType$inboundSchema;
    var TranscriptionStreamDoneType$;
    (function(TranscriptionStreamDoneType$2) {
      TranscriptionStreamDoneType$2.inboundSchema = exports.TranscriptionStreamDoneType$inboundSchema;
      TranscriptionStreamDoneType$2.outboundSchema = exports.TranscriptionStreamDoneType$outboundSchema;
    })(TranscriptionStreamDoneType$ || (exports.TranscriptionStreamDoneType$ = TranscriptionStreamDoneType$ = {}));
    exports.TranscriptionStreamDone$inboundSchema = (0, schemas_js_1.collectExtraKeys)(z4.object({
      model: z4.string(),
      text: z4.string(),
      segments: z4.array(transcriptionsegmentchunk_js_1.TranscriptionSegmentChunk$inboundSchema).optional(),
      usage: usageinfo_js_1.UsageInfo$inboundSchema,
      type: exports.TranscriptionStreamDoneType$inboundSchema.default("transcription.done"),
      language: z4.nullable(z4.string())
    }).catchall(z4.any()), "additionalProperties", true);
    exports.TranscriptionStreamDone$outboundSchema = z4.object({
      model: z4.string(),
      text: z4.string(),
      segments: z4.array(transcriptionsegmentchunk_js_1.TranscriptionSegmentChunk$outboundSchema).optional(),
      usage: usageinfo_js_1.UsageInfo$outboundSchema,
      type: exports.TranscriptionStreamDoneType$outboundSchema.default("transcription.done"),
      language: z4.nullable(z4.string()),
      additionalProperties: z4.record(z4.any())
    }).transform((v2) => {
      return {
        ...v2.additionalProperties,
        ...(0, primitives_js_1.remap)(v2, {
          additionalProperties: null
        })
      };
    });
    var TranscriptionStreamDone$;
    (function(TranscriptionStreamDone$2) {
      TranscriptionStreamDone$2.inboundSchema = exports.TranscriptionStreamDone$inboundSchema;
      TranscriptionStreamDone$2.outboundSchema = exports.TranscriptionStreamDone$outboundSchema;
    })(TranscriptionStreamDone$ || (exports.TranscriptionStreamDone$ = TranscriptionStreamDone$ = {}));
    function transcriptionStreamDoneToJSON(transcriptionStreamDone) {
      return JSON.stringify(exports.TranscriptionStreamDone$outboundSchema.parse(transcriptionStreamDone));
    }
    function transcriptionStreamDoneFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.TranscriptionStreamDone$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'TranscriptionStreamDone' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/transcriptionstreameventtypes.js
var require_transcriptionstreameventtypes = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/transcriptionstreameventtypes.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TranscriptionStreamEventTypes$ = exports.TranscriptionStreamEventTypes$outboundSchema = exports.TranscriptionStreamEventTypes$inboundSchema = exports.TranscriptionStreamEventTypes = void 0;
    var z4 = __importStar(__require("zod"));
    exports.TranscriptionStreamEventTypes = {
      TranscriptionLanguage: "transcription.language",
      TranscriptionSegment: "transcription.segment",
      TranscriptionTextDelta: "transcription.text.delta",
      TranscriptionDone: "transcription.done"
    };
    exports.TranscriptionStreamEventTypes$inboundSchema = z4.nativeEnum(exports.TranscriptionStreamEventTypes);
    exports.TranscriptionStreamEventTypes$outboundSchema = exports.TranscriptionStreamEventTypes$inboundSchema;
    var TranscriptionStreamEventTypes$;
    (function(TranscriptionStreamEventTypes$2) {
      TranscriptionStreamEventTypes$2.inboundSchema = exports.TranscriptionStreamEventTypes$inboundSchema;
      TranscriptionStreamEventTypes$2.outboundSchema = exports.TranscriptionStreamEventTypes$outboundSchema;
    })(TranscriptionStreamEventTypes$ || (exports.TranscriptionStreamEventTypes$ = TranscriptionStreamEventTypes$ = {}));
  }
});

// ../node_modules/@mistralai/mistralai/models/components/transcriptionstreamlanguage.js
var require_transcriptionstreamlanguage = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/transcriptionstreamlanguage.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TranscriptionStreamLanguage$ = exports.TranscriptionStreamLanguage$outboundSchema = exports.TranscriptionStreamLanguage$inboundSchema = exports.TranscriptionStreamLanguageType$ = exports.TranscriptionStreamLanguageType$outboundSchema = exports.TranscriptionStreamLanguageType$inboundSchema = exports.TranscriptionStreamLanguageType = void 0;
    exports.transcriptionStreamLanguageToJSON = transcriptionStreamLanguageToJSON;
    exports.transcriptionStreamLanguageFromJSON = transcriptionStreamLanguageFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.TranscriptionStreamLanguageType = {
      TranscriptionLanguage: "transcription.language"
    };
    exports.TranscriptionStreamLanguageType$inboundSchema = z4.nativeEnum(exports.TranscriptionStreamLanguageType);
    exports.TranscriptionStreamLanguageType$outboundSchema = exports.TranscriptionStreamLanguageType$inboundSchema;
    var TranscriptionStreamLanguageType$;
    (function(TranscriptionStreamLanguageType$2) {
      TranscriptionStreamLanguageType$2.inboundSchema = exports.TranscriptionStreamLanguageType$inboundSchema;
      TranscriptionStreamLanguageType$2.outboundSchema = exports.TranscriptionStreamLanguageType$outboundSchema;
    })(TranscriptionStreamLanguageType$ || (exports.TranscriptionStreamLanguageType$ = TranscriptionStreamLanguageType$ = {}));
    exports.TranscriptionStreamLanguage$inboundSchema = (0, schemas_js_1.collectExtraKeys)(z4.object({
      type: exports.TranscriptionStreamLanguageType$inboundSchema.default("transcription.language"),
      audio_language: z4.string()
    }).catchall(z4.any()), "additionalProperties", true).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "audio_language": "audioLanguage"
      });
    });
    exports.TranscriptionStreamLanguage$outboundSchema = z4.object({
      type: exports.TranscriptionStreamLanguageType$outboundSchema.default("transcription.language"),
      audioLanguage: z4.string(),
      additionalProperties: z4.record(z4.any())
    }).transform((v2) => {
      return {
        ...v2.additionalProperties,
        ...(0, primitives_js_1.remap)(v2, {
          audioLanguage: "audio_language",
          additionalProperties: null
        })
      };
    });
    var TranscriptionStreamLanguage$;
    (function(TranscriptionStreamLanguage$2) {
      TranscriptionStreamLanguage$2.inboundSchema = exports.TranscriptionStreamLanguage$inboundSchema;
      TranscriptionStreamLanguage$2.outboundSchema = exports.TranscriptionStreamLanguage$outboundSchema;
    })(TranscriptionStreamLanguage$ || (exports.TranscriptionStreamLanguage$ = TranscriptionStreamLanguage$ = {}));
    function transcriptionStreamLanguageToJSON(transcriptionStreamLanguage) {
      return JSON.stringify(exports.TranscriptionStreamLanguage$outboundSchema.parse(transcriptionStreamLanguage));
    }
    function transcriptionStreamLanguageFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.TranscriptionStreamLanguage$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'TranscriptionStreamLanguage' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/transcriptionstreamsegmentdelta.js
var require_transcriptionstreamsegmentdelta = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/transcriptionstreamsegmentdelta.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TranscriptionStreamSegmentDelta$ = exports.TranscriptionStreamSegmentDelta$outboundSchema = exports.TranscriptionStreamSegmentDelta$inboundSchema = exports.TranscriptionStreamSegmentDeltaType$ = exports.TranscriptionStreamSegmentDeltaType$outboundSchema = exports.TranscriptionStreamSegmentDeltaType$inboundSchema = exports.TranscriptionStreamSegmentDeltaType = void 0;
    exports.transcriptionStreamSegmentDeltaToJSON = transcriptionStreamSegmentDeltaToJSON;
    exports.transcriptionStreamSegmentDeltaFromJSON = transcriptionStreamSegmentDeltaFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.TranscriptionStreamSegmentDeltaType = {
      TranscriptionSegment: "transcription.segment"
    };
    exports.TranscriptionStreamSegmentDeltaType$inboundSchema = z4.nativeEnum(exports.TranscriptionStreamSegmentDeltaType);
    exports.TranscriptionStreamSegmentDeltaType$outboundSchema = exports.TranscriptionStreamSegmentDeltaType$inboundSchema;
    var TranscriptionStreamSegmentDeltaType$;
    (function(TranscriptionStreamSegmentDeltaType$2) {
      TranscriptionStreamSegmentDeltaType$2.inboundSchema = exports.TranscriptionStreamSegmentDeltaType$inboundSchema;
      TranscriptionStreamSegmentDeltaType$2.outboundSchema = exports.TranscriptionStreamSegmentDeltaType$outboundSchema;
    })(TranscriptionStreamSegmentDeltaType$ || (exports.TranscriptionStreamSegmentDeltaType$ = TranscriptionStreamSegmentDeltaType$ = {}));
    exports.TranscriptionStreamSegmentDelta$inboundSchema = (0, schemas_js_1.collectExtraKeys)(z4.object({
      text: z4.string(),
      start: z4.number(),
      end: z4.number(),
      type: exports.TranscriptionStreamSegmentDeltaType$inboundSchema.default("transcription.segment")
    }).catchall(z4.any()), "additionalProperties", true);
    exports.TranscriptionStreamSegmentDelta$outboundSchema = z4.object({
      text: z4.string(),
      start: z4.number(),
      end: z4.number(),
      type: exports.TranscriptionStreamSegmentDeltaType$outboundSchema.default("transcription.segment"),
      additionalProperties: z4.record(z4.any())
    }).transform((v2) => {
      return {
        ...v2.additionalProperties,
        ...(0, primitives_js_1.remap)(v2, {
          additionalProperties: null
        })
      };
    });
    var TranscriptionStreamSegmentDelta$;
    (function(TranscriptionStreamSegmentDelta$2) {
      TranscriptionStreamSegmentDelta$2.inboundSchema = exports.TranscriptionStreamSegmentDelta$inboundSchema;
      TranscriptionStreamSegmentDelta$2.outboundSchema = exports.TranscriptionStreamSegmentDelta$outboundSchema;
    })(TranscriptionStreamSegmentDelta$ || (exports.TranscriptionStreamSegmentDelta$ = TranscriptionStreamSegmentDelta$ = {}));
    function transcriptionStreamSegmentDeltaToJSON(transcriptionStreamSegmentDelta) {
      return JSON.stringify(exports.TranscriptionStreamSegmentDelta$outboundSchema.parse(transcriptionStreamSegmentDelta));
    }
    function transcriptionStreamSegmentDeltaFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.TranscriptionStreamSegmentDelta$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'TranscriptionStreamSegmentDelta' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/transcriptionstreamtextdelta.js
var require_transcriptionstreamtextdelta = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/transcriptionstreamtextdelta.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TranscriptionStreamTextDelta$ = exports.TranscriptionStreamTextDelta$outboundSchema = exports.TranscriptionStreamTextDelta$inboundSchema = exports.TranscriptionStreamTextDeltaType$ = exports.TranscriptionStreamTextDeltaType$outboundSchema = exports.TranscriptionStreamTextDeltaType$inboundSchema = exports.TranscriptionStreamTextDeltaType = void 0;
    exports.transcriptionStreamTextDeltaToJSON = transcriptionStreamTextDeltaToJSON;
    exports.transcriptionStreamTextDeltaFromJSON = transcriptionStreamTextDeltaFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.TranscriptionStreamTextDeltaType = {
      TranscriptionTextDelta: "transcription.text.delta"
    };
    exports.TranscriptionStreamTextDeltaType$inboundSchema = z4.nativeEnum(exports.TranscriptionStreamTextDeltaType);
    exports.TranscriptionStreamTextDeltaType$outboundSchema = exports.TranscriptionStreamTextDeltaType$inboundSchema;
    var TranscriptionStreamTextDeltaType$;
    (function(TranscriptionStreamTextDeltaType$2) {
      TranscriptionStreamTextDeltaType$2.inboundSchema = exports.TranscriptionStreamTextDeltaType$inboundSchema;
      TranscriptionStreamTextDeltaType$2.outboundSchema = exports.TranscriptionStreamTextDeltaType$outboundSchema;
    })(TranscriptionStreamTextDeltaType$ || (exports.TranscriptionStreamTextDeltaType$ = TranscriptionStreamTextDeltaType$ = {}));
    exports.TranscriptionStreamTextDelta$inboundSchema = (0, schemas_js_1.collectExtraKeys)(z4.object({
      text: z4.string(),
      type: exports.TranscriptionStreamTextDeltaType$inboundSchema.default("transcription.text.delta")
    }).catchall(z4.any()), "additionalProperties", true);
    exports.TranscriptionStreamTextDelta$outboundSchema = z4.object({
      text: z4.string(),
      type: exports.TranscriptionStreamTextDeltaType$outboundSchema.default("transcription.text.delta"),
      additionalProperties: z4.record(z4.any())
    }).transform((v2) => {
      return {
        ...v2.additionalProperties,
        ...(0, primitives_js_1.remap)(v2, {
          additionalProperties: null
        })
      };
    });
    var TranscriptionStreamTextDelta$;
    (function(TranscriptionStreamTextDelta$2) {
      TranscriptionStreamTextDelta$2.inboundSchema = exports.TranscriptionStreamTextDelta$inboundSchema;
      TranscriptionStreamTextDelta$2.outboundSchema = exports.TranscriptionStreamTextDelta$outboundSchema;
    })(TranscriptionStreamTextDelta$ || (exports.TranscriptionStreamTextDelta$ = TranscriptionStreamTextDelta$ = {}));
    function transcriptionStreamTextDeltaToJSON(transcriptionStreamTextDelta) {
      return JSON.stringify(exports.TranscriptionStreamTextDelta$outboundSchema.parse(transcriptionStreamTextDelta));
    }
    function transcriptionStreamTextDeltaFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.TranscriptionStreamTextDelta$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'TranscriptionStreamTextDelta' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/transcriptionstreamevents.js
var require_transcriptionstreamevents = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/transcriptionstreamevents.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TranscriptionStreamEvents$ = exports.TranscriptionStreamEvents$outboundSchema = exports.TranscriptionStreamEvents$inboundSchema = exports.TranscriptionStreamEventsData$ = exports.TranscriptionStreamEventsData$outboundSchema = exports.TranscriptionStreamEventsData$inboundSchema = void 0;
    exports.transcriptionStreamEventsDataToJSON = transcriptionStreamEventsDataToJSON;
    exports.transcriptionStreamEventsDataFromJSON = transcriptionStreamEventsDataFromJSON;
    exports.transcriptionStreamEventsToJSON = transcriptionStreamEventsToJSON;
    exports.transcriptionStreamEventsFromJSON = transcriptionStreamEventsFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var transcriptionstreamdone_js_1 = require_transcriptionstreamdone();
    var transcriptionstreameventtypes_js_1 = require_transcriptionstreameventtypes();
    var transcriptionstreamlanguage_js_1 = require_transcriptionstreamlanguage();
    var transcriptionstreamsegmentdelta_js_1 = require_transcriptionstreamsegmentdelta();
    var transcriptionstreamtextdelta_js_1 = require_transcriptionstreamtextdelta();
    exports.TranscriptionStreamEventsData$inboundSchema = z4.union([
      transcriptionstreamlanguage_js_1.TranscriptionStreamLanguage$inboundSchema.and(z4.object({ type: z4.literal("transcription.language") }).transform((v2) => ({
        type: v2.type
      }))),
      transcriptionstreamtextdelta_js_1.TranscriptionStreamTextDelta$inboundSchema.and(z4.object({ type: z4.literal("transcription.text.delta") }).transform((v2) => ({ type: v2.type }))),
      transcriptionstreamsegmentdelta_js_1.TranscriptionStreamSegmentDelta$inboundSchema.and(z4.object({ type: z4.literal("transcription.segment") }).transform((v2) => ({
        type: v2.type
      }))),
      transcriptionstreamdone_js_1.TranscriptionStreamDone$inboundSchema.and(z4.object({ type: z4.literal("transcription.done") }).transform((v2) => ({
        type: v2.type
      })))
    ]);
    exports.TranscriptionStreamEventsData$outboundSchema = z4.union([
      transcriptionstreamlanguage_js_1.TranscriptionStreamLanguage$outboundSchema.and(z4.object({ type: z4.literal("transcription.language") }).transform((v2) => ({
        type: v2.type
      }))),
      transcriptionstreamtextdelta_js_1.TranscriptionStreamTextDelta$outboundSchema.and(z4.object({ type: z4.literal("transcription.text.delta") }).transform((v2) => ({ type: v2.type }))),
      transcriptionstreamsegmentdelta_js_1.TranscriptionStreamSegmentDelta$outboundSchema.and(z4.object({ type: z4.literal("transcription.segment") }).transform((v2) => ({
        type: v2.type
      }))),
      transcriptionstreamdone_js_1.TranscriptionStreamDone$outboundSchema.and(z4.object({ type: z4.literal("transcription.done") }).transform((v2) => ({
        type: v2.type
      })))
    ]);
    var TranscriptionStreamEventsData$;
    (function(TranscriptionStreamEventsData$2) {
      TranscriptionStreamEventsData$2.inboundSchema = exports.TranscriptionStreamEventsData$inboundSchema;
      TranscriptionStreamEventsData$2.outboundSchema = exports.TranscriptionStreamEventsData$outboundSchema;
    })(TranscriptionStreamEventsData$ || (exports.TranscriptionStreamEventsData$ = TranscriptionStreamEventsData$ = {}));
    function transcriptionStreamEventsDataToJSON(transcriptionStreamEventsData) {
      return JSON.stringify(exports.TranscriptionStreamEventsData$outboundSchema.parse(transcriptionStreamEventsData));
    }
    function transcriptionStreamEventsDataFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.TranscriptionStreamEventsData$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'TranscriptionStreamEventsData' from JSON`);
    }
    exports.TranscriptionStreamEvents$inboundSchema = z4.object({
      event: transcriptionstreameventtypes_js_1.TranscriptionStreamEventTypes$inboundSchema,
      data: z4.string().transform((v2, ctx) => {
        try {
          return JSON.parse(v2);
        } catch (err) {
          ctx.addIssue({
            code: z4.ZodIssueCode.custom,
            message: `malformed json: ${err}`
          });
          return z4.NEVER;
        }
      }).pipe(z4.union([
        transcriptionstreamlanguage_js_1.TranscriptionStreamLanguage$inboundSchema.and(z4.object({ type: z4.literal("transcription.language") }).transform((v2) => ({ type: v2.type }))),
        transcriptionstreamtextdelta_js_1.TranscriptionStreamTextDelta$inboundSchema.and(z4.object({ type: z4.literal("transcription.text.delta") }).transform((v2) => ({ type: v2.type }))),
        transcriptionstreamsegmentdelta_js_1.TranscriptionStreamSegmentDelta$inboundSchema.and(z4.object({ type: z4.literal("transcription.segment") }).transform((v2) => ({ type: v2.type }))),
        transcriptionstreamdone_js_1.TranscriptionStreamDone$inboundSchema.and(z4.object({ type: z4.literal("transcription.done") }).transform((v2) => ({
          type: v2.type
        })))
      ]))
    });
    exports.TranscriptionStreamEvents$outboundSchema = z4.object({
      event: transcriptionstreameventtypes_js_1.TranscriptionStreamEventTypes$outboundSchema,
      data: z4.union([
        transcriptionstreamlanguage_js_1.TranscriptionStreamLanguage$outboundSchema.and(z4.object({ type: z4.literal("transcription.language") }).transform((v2) => ({ type: v2.type }))),
        transcriptionstreamtextdelta_js_1.TranscriptionStreamTextDelta$outboundSchema.and(z4.object({ type: z4.literal("transcription.text.delta") }).transform((v2) => ({ type: v2.type }))),
        transcriptionstreamsegmentdelta_js_1.TranscriptionStreamSegmentDelta$outboundSchema.and(z4.object({ type: z4.literal("transcription.segment") }).transform((v2) => ({
          type: v2.type
        }))),
        transcriptionstreamdone_js_1.TranscriptionStreamDone$outboundSchema.and(z4.object({ type: z4.literal("transcription.done") }).transform((v2) => ({
          type: v2.type
        })))
      ])
    });
    var TranscriptionStreamEvents$;
    (function(TranscriptionStreamEvents$2) {
      TranscriptionStreamEvents$2.inboundSchema = exports.TranscriptionStreamEvents$inboundSchema;
      TranscriptionStreamEvents$2.outboundSchema = exports.TranscriptionStreamEvents$outboundSchema;
    })(TranscriptionStreamEvents$ || (exports.TranscriptionStreamEvents$ = TranscriptionStreamEvents$ = {}));
    function transcriptionStreamEventsToJSON(transcriptionStreamEvents) {
      return JSON.stringify(exports.TranscriptionStreamEvents$outboundSchema.parse(transcriptionStreamEvents));
    }
    function transcriptionStreamEventsFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.TranscriptionStreamEvents$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'TranscriptionStreamEvents' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/unarchiveftmodelout.js
var require_unarchiveftmodelout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/unarchiveftmodelout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnarchiveFTModelOut$ = exports.UnarchiveFTModelOut$outboundSchema = exports.UnarchiveFTModelOut$inboundSchema = exports.UnarchiveFTModelOutObject$ = exports.UnarchiveFTModelOutObject$outboundSchema = exports.UnarchiveFTModelOutObject$inboundSchema = exports.UnarchiveFTModelOutObject = void 0;
    exports.unarchiveFTModelOutToJSON = unarchiveFTModelOutToJSON;
    exports.unarchiveFTModelOutFromJSON = unarchiveFTModelOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    exports.UnarchiveFTModelOutObject = {
      Model: "model"
    };
    exports.UnarchiveFTModelOutObject$inboundSchema = z4.nativeEnum(exports.UnarchiveFTModelOutObject);
    exports.UnarchiveFTModelOutObject$outboundSchema = exports.UnarchiveFTModelOutObject$inboundSchema;
    var UnarchiveFTModelOutObject$;
    (function(UnarchiveFTModelOutObject$2) {
      UnarchiveFTModelOutObject$2.inboundSchema = exports.UnarchiveFTModelOutObject$inboundSchema;
      UnarchiveFTModelOutObject$2.outboundSchema = exports.UnarchiveFTModelOutObject$outboundSchema;
    })(UnarchiveFTModelOutObject$ || (exports.UnarchiveFTModelOutObject$ = UnarchiveFTModelOutObject$ = {}));
    exports.UnarchiveFTModelOut$inboundSchema = z4.object({
      id: z4.string(),
      object: exports.UnarchiveFTModelOutObject$inboundSchema.default("model"),
      archived: z4.boolean().default(false)
    });
    exports.UnarchiveFTModelOut$outboundSchema = z4.object({
      id: z4.string(),
      object: exports.UnarchiveFTModelOutObject$outboundSchema.default("model"),
      archived: z4.boolean().default(false)
    });
    var UnarchiveFTModelOut$;
    (function(UnarchiveFTModelOut$2) {
      UnarchiveFTModelOut$2.inboundSchema = exports.UnarchiveFTModelOut$inboundSchema;
      UnarchiveFTModelOut$2.outboundSchema = exports.UnarchiveFTModelOut$outboundSchema;
    })(UnarchiveFTModelOut$ || (exports.UnarchiveFTModelOut$ = UnarchiveFTModelOut$ = {}));
    function unarchiveFTModelOutToJSON(unarchiveFTModelOut) {
      return JSON.stringify(exports.UnarchiveFTModelOut$outboundSchema.parse(unarchiveFTModelOut));
    }
    function unarchiveFTModelOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.UnarchiveFTModelOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'UnarchiveFTModelOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/updateftmodelin.js
var require_updateftmodelin = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/updateftmodelin.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpdateFTModelIn$ = exports.UpdateFTModelIn$outboundSchema = exports.UpdateFTModelIn$inboundSchema = void 0;
    exports.updateFTModelInToJSON = updateFTModelInToJSON;
    exports.updateFTModelInFromJSON = updateFTModelInFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    exports.UpdateFTModelIn$inboundSchema = z4.object({
      name: z4.nullable(z4.string()).optional(),
      description: z4.nullable(z4.string()).optional()
    });
    exports.UpdateFTModelIn$outboundSchema = z4.object({
      name: z4.nullable(z4.string()).optional(),
      description: z4.nullable(z4.string()).optional()
    });
    var UpdateFTModelIn$;
    (function(UpdateFTModelIn$2) {
      UpdateFTModelIn$2.inboundSchema = exports.UpdateFTModelIn$inboundSchema;
      UpdateFTModelIn$2.outboundSchema = exports.UpdateFTModelIn$outboundSchema;
    })(UpdateFTModelIn$ || (exports.UpdateFTModelIn$ = UpdateFTModelIn$ = {}));
    function updateFTModelInToJSON(updateFTModelIn) {
      return JSON.stringify(exports.UpdateFTModelIn$outboundSchema.parse(updateFTModelIn));
    }
    function updateFTModelInFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.UpdateFTModelIn$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'UpdateFTModelIn' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/uploadfileout.js
var require_uploadfileout = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/uploadfileout.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UploadFileOut$ = exports.UploadFileOut$outboundSchema = exports.UploadFileOut$inboundSchema = void 0;
    exports.uploadFileOutToJSON = uploadFileOutToJSON;
    exports.uploadFileOutFromJSON = uploadFileOutFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var filepurpose_js_1 = require_filepurpose();
    var sampletype_js_1 = require_sampletype();
    var source_js_1 = require_source();
    exports.UploadFileOut$inboundSchema = z4.object({
      id: z4.string(),
      object: z4.string(),
      bytes: z4.number().int(),
      created_at: z4.number().int(),
      filename: z4.string(),
      purpose: filepurpose_js_1.FilePurpose$inboundSchema,
      sample_type: sampletype_js_1.SampleType$inboundSchema,
      num_lines: z4.nullable(z4.number().int()).optional(),
      mimetype: z4.nullable(z4.string()).optional(),
      source: source_js_1.Source$inboundSchema,
      signature: z4.nullable(z4.string()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "bytes": "sizeBytes",
        "created_at": "createdAt",
        "sample_type": "sampleType",
        "num_lines": "numLines"
      });
    });
    exports.UploadFileOut$outboundSchema = z4.object({
      id: z4.string(),
      object: z4.string(),
      sizeBytes: z4.number().int(),
      createdAt: z4.number().int(),
      filename: z4.string(),
      purpose: filepurpose_js_1.FilePurpose$outboundSchema,
      sampleType: sampletype_js_1.SampleType$outboundSchema,
      numLines: z4.nullable(z4.number().int()).optional(),
      mimetype: z4.nullable(z4.string()).optional(),
      source: source_js_1.Source$outboundSchema,
      signature: z4.nullable(z4.string()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        sizeBytes: "bytes",
        createdAt: "created_at",
        sampleType: "sample_type",
        numLines: "num_lines"
      });
    });
    var UploadFileOut$;
    (function(UploadFileOut$2) {
      UploadFileOut$2.inboundSchema = exports.UploadFileOut$inboundSchema;
      UploadFileOut$2.outboundSchema = exports.UploadFileOut$outboundSchema;
    })(UploadFileOut$ || (exports.UploadFileOut$ = UploadFileOut$ = {}));
    function uploadFileOutToJSON(uploadFileOut) {
      return JSON.stringify(exports.UploadFileOut$outboundSchema.parse(uploadFileOut));
    }
    function uploadFileOutFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.UploadFileOut$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'UploadFileOut' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/validationerror.js
var require_validationerror = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/validationerror.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValidationError$ = exports.ValidationError$outboundSchema = exports.ValidationError$inboundSchema = exports.Loc$ = exports.Loc$outboundSchema = exports.Loc$inboundSchema = void 0;
    exports.locToJSON = locToJSON;
    exports.locFromJSON = locFromJSON;
    exports.validationErrorToJSON = validationErrorToJSON;
    exports.validationErrorFromJSON = validationErrorFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    exports.Loc$inboundSchema = z4.union([z4.string(), z4.number().int()]);
    exports.Loc$outboundSchema = z4.union([z4.string(), z4.number().int()]);
    var Loc$;
    (function(Loc$2) {
      Loc$2.inboundSchema = exports.Loc$inboundSchema;
      Loc$2.outboundSchema = exports.Loc$outboundSchema;
    })(Loc$ || (exports.Loc$ = Loc$ = {}));
    function locToJSON(loc) {
      return JSON.stringify(exports.Loc$outboundSchema.parse(loc));
    }
    function locFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.Loc$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'Loc' from JSON`);
    }
    exports.ValidationError$inboundSchema = z4.object({
      loc: z4.array(z4.union([z4.string(), z4.number().int()])),
      msg: z4.string(),
      type: z4.string()
    });
    exports.ValidationError$outboundSchema = z4.object({
      loc: z4.array(z4.union([z4.string(), z4.number().int()])),
      msg: z4.string(),
      type: z4.string()
    });
    var ValidationError$;
    (function(ValidationError$2) {
      ValidationError$2.inboundSchema = exports.ValidationError$inboundSchema;
      ValidationError$2.outboundSchema = exports.ValidationError$outboundSchema;
    })(ValidationError$ || (exports.ValidationError$ = ValidationError$ = {}));
    function validationErrorToJSON(validationError3) {
      return JSON.stringify(exports.ValidationError$outboundSchema.parse(validationError3));
    }
    function validationErrorFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ValidationError$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ValidationError' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/components/index.js
var require_components = __commonJS({
  "../node_modules/@mistralai/mistralai/models/components/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_agent2(), exports);
    __exportStar(require_agentconversation(), exports);
    __exportStar(require_agentcreationrequest(), exports);
    __exportStar(require_agenthandoffdoneevent(), exports);
    __exportStar(require_agenthandoffentry(), exports);
    __exportStar(require_agenthandoffstartedevent(), exports);
    __exportStar(require_agentscompletionrequest(), exports);
    __exportStar(require_agentscompletionstreamrequest(), exports);
    __exportStar(require_agentupdaterequest(), exports);
    __exportStar(require_apiendpoint(), exports);
    __exportStar(require_archiveftmodelout(), exports);
    __exportStar(require_assistantmessage(), exports);
    __exportStar(require_audiochunk(), exports);
    __exportStar(require_audiotranscriptionrequest(), exports);
    __exportStar(require_audiotranscriptionrequeststream(), exports);
    __exportStar(require_basemodelcard(), exports);
    __exportStar(require_batcherror(), exports);
    __exportStar(require_batchjobin(), exports);
    __exportStar(require_batchjobout(), exports);
    __exportStar(require_batchjobsout(), exports);
    __exportStar(require_batchjobstatus(), exports);
    __exportStar(require_builtinconnectors(), exports);
    __exportStar(require_chatclassificationrequest(), exports);
    __exportStar(require_chatcompletionchoice(), exports);
    __exportStar(require_chatcompletionrequest(), exports);
    __exportStar(require_chatcompletionresponse(), exports);
    __exportStar(require_chatcompletionstreamrequest(), exports);
    __exportStar(require_chatmoderationrequest(), exports);
    __exportStar(require_checkpointout(), exports);
    __exportStar(require_classificationrequest(), exports);
    __exportStar(require_classificationresponse(), exports);
    __exportStar(require_classificationtargetresult(), exports);
    __exportStar(require_classifierdetailedjobout(), exports);
    __exportStar(require_classifierftmodelout(), exports);
    __exportStar(require_classifierjobout(), exports);
    __exportStar(require_classifiertargetin(), exports);
    __exportStar(require_classifiertargetout(), exports);
    __exportStar(require_classifiertrainingparameters(), exports);
    __exportStar(require_classifiertrainingparametersin(), exports);
    __exportStar(require_codeinterpretertool(), exports);
    __exportStar(require_completionargs(), exports);
    __exportStar(require_completionargsstop(), exports);
    __exportStar(require_completionchunk(), exports);
    __exportStar(require_completiondetailedjobout(), exports);
    __exportStar(require_completionevent(), exports);
    __exportStar(require_completionftmodelout(), exports);
    __exportStar(require_completionjobout(), exports);
    __exportStar(require_completionresponsestreamchoice(), exports);
    __exportStar(require_completiontrainingparameters(), exports);
    __exportStar(require_completiontrainingparametersin(), exports);
    __exportStar(require_contentchunk(), exports);
    __exportStar(require_conversationappendrequest(), exports);
    __exportStar(require_conversationappendstreamrequest(), exports);
    __exportStar(require_conversationevents(), exports);
    __exportStar(require_conversationhistory(), exports);
    __exportStar(require_conversationinputs(), exports);
    __exportStar(require_conversationmessages(), exports);
    __exportStar(require_conversationrequest(), exports);
    __exportStar(require_conversationresponse(), exports);
    __exportStar(require_conversationrestartrequest(), exports);
    __exportStar(require_conversationrestartstreamrequest(), exports);
    __exportStar(require_conversationstreamrequest(), exports);
    __exportStar(require_conversationusageinfo(), exports);
    __exportStar(require_deletefileout(), exports);
    __exportStar(require_deletemodelout(), exports);
    __exportStar(require_deltamessage(), exports);
    __exportStar(require_documentlibrarytool(), exports);
    __exportStar(require_documentout(), exports);
    __exportStar(require_documenttextcontent(), exports);
    __exportStar(require_documentupdatein(), exports);
    __exportStar(require_documenturlchunk(), exports);
    __exportStar(require_embeddingdtype(), exports);
    __exportStar(require_embeddingrequest(), exports);
    __exportStar(require_embeddingresponse(), exports);
    __exportStar(require_embeddingresponsedata(), exports);
    __exportStar(require_entitytype(), exports);
    __exportStar(require_eventout(), exports);
    __exportStar(require_file(), exports);
    __exportStar(require_filechunk(), exports);
    __exportStar(require_filepurpose(), exports);
    __exportStar(require_fileschema(), exports);
    __exportStar(require_filesignedurl(), exports);
    __exportStar(require_fimcompletionrequest(), exports);
    __exportStar(require_fimcompletionresponse(), exports);
    __exportStar(require_fimcompletionstreamrequest(), exports);
    __exportStar(require_finetuneablemodeltype(), exports);
    __exportStar(require_ftclassifierlossfunction(), exports);
    __exportStar(require_ftmodelcapabilitiesout(), exports);
    __exportStar(require_ftmodelcard(), exports);
    __exportStar(require_function(), exports);
    __exportStar(require_functioncall(), exports);
    __exportStar(require_functioncallentry(), exports);
    __exportStar(require_functioncallentryarguments(), exports);
    __exportStar(require_functioncallevent(), exports);
    __exportStar(require_functionname(), exports);
    __exportStar(require_functionresultentry(), exports);
    __exportStar(require_functiontool(), exports);
    __exportStar(require_githubrepositoryin(), exports);
    __exportStar(require_githubrepositoryout(), exports);
    __exportStar(require_imagegenerationtool(), exports);
    __exportStar(require_imageurl(), exports);
    __exportStar(require_imageurlchunk(), exports);
    __exportStar(require_inputentries(), exports);
    __exportStar(require_inputs(), exports);
    __exportStar(require_instructrequest(), exports);
    __exportStar(require_jobin(), exports);
    __exportStar(require_jobmetadataout(), exports);
    __exportStar(require_jobsout(), exports);
    __exportStar(require_jsonschema(), exports);
    __exportStar(require_legacyjobmetadataout(), exports);
    __exportStar(require_libraryin(), exports);
    __exportStar(require_libraryinupdate(), exports);
    __exportStar(require_libraryout(), exports);
    __exportStar(require_listdocumentout(), exports);
    __exportStar(require_listfilesout(), exports);
    __exportStar(require_listlibraryout(), exports);
    __exportStar(require_listsharingout(), exports);
    __exportStar(require_messageentries(), exports);
    __exportStar(require_messageinputcontentchunks(), exports);
    __exportStar(require_messageinputentry(), exports);
    __exportStar(require_messageoutputcontentchunks(), exports);
    __exportStar(require_messageoutputentry(), exports);
    __exportStar(require_messageoutputevent(), exports);
    __exportStar(require_metricout(), exports);
    __exportStar(require_mistralpromptmode(), exports);
    __exportStar(require_modelcapabilities(), exports);
    __exportStar(require_modelconversation(), exports);
    __exportStar(require_modellist(), exports);
    __exportStar(require_moderationobject(), exports);
    __exportStar(require_moderationresponse(), exports);
    __exportStar(require_ocrimageobject(), exports);
    __exportStar(require_ocrpagedimensions(), exports);
    __exportStar(require_ocrpageobject(), exports);
    __exportStar(require_ocrrequest(), exports);
    __exportStar(require_ocrresponse(), exports);
    __exportStar(require_ocrusageinfo(), exports);
    __exportStar(require_outputcontentchunks(), exports);
    __exportStar(require_paginationinfo(), exports);
    __exportStar(require_prediction(), exports);
    __exportStar(require_processingstatusout(), exports);
    __exportStar(require_referencechunk(), exports);
    __exportStar(require_responsedoneevent(), exports);
    __exportStar(require_responseerrorevent(), exports);
    __exportStar(require_responseformat(), exports);
    __exportStar(require_responseformats(), exports);
    __exportStar(require_responsestartedevent(), exports);
    __exportStar(require_retrievefileout(), exports);
    __exportStar(require_sampletype(), exports);
    __exportStar(require_security2(), exports);
    __exportStar(require_shareenum(), exports);
    __exportStar(require_sharingdelete(), exports);
    __exportStar(require_sharingin(), exports);
    __exportStar(require_sharingout(), exports);
    __exportStar(require_source(), exports);
    __exportStar(require_ssetypes(), exports);
    __exportStar(require_systemmessage(), exports);
    __exportStar(require_textchunk(), exports);
    __exportStar(require_thinkchunk(), exports);
    __exportStar(require_timestampgranularity(), exports);
    __exportStar(require_tool(), exports);
    __exportStar(require_toolcall(), exports);
    __exportStar(require_toolchoice(), exports);
    __exportStar(require_toolchoiceenum(), exports);
    __exportStar(require_toolexecutiondeltaevent(), exports);
    __exportStar(require_toolexecutiondoneevent(), exports);
    __exportStar(require_toolexecutionentry(), exports);
    __exportStar(require_toolexecutionstartedevent(), exports);
    __exportStar(require_toolfilechunk(), exports);
    __exportStar(require_toolmessage(), exports);
    __exportStar(require_toolreferencechunk(), exports);
    __exportStar(require_tooltypes(), exports);
    __exportStar(require_trainingfile(), exports);
    __exportStar(require_transcriptionresponse(), exports);
    __exportStar(require_transcriptionsegmentchunk(), exports);
    __exportStar(require_transcriptionstreamdone(), exports);
    __exportStar(require_transcriptionstreamevents(), exports);
    __exportStar(require_transcriptionstreameventtypes(), exports);
    __exportStar(require_transcriptionstreamlanguage(), exports);
    __exportStar(require_transcriptionstreamsegmentdelta(), exports);
    __exportStar(require_transcriptionstreamtextdelta(), exports);
    __exportStar(require_unarchiveftmodelout(), exports);
    __exportStar(require_updateftmodelin(), exports);
    __exportStar(require_uploadfileout(), exports);
    __exportStar(require_usageinfo(), exports);
    __exportStar(require_usermessage(), exports);
    __exportStar(require_validationerror(), exports);
    __exportStar(require_wandbintegration(), exports);
    __exportStar(require_wandbintegrationout(), exports);
    __exportStar(require_websearchpremiumtool(), exports);
    __exportStar(require_websearchtool(), exports);
  }
});

// ../node_modules/@mistralai/mistralai/models/errors/httpvalidationerror.js
var require_httpvalidationerror = __commonJS({
  "../node_modules/@mistralai/mistralai/models/errors/httpvalidationerror.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HTTPValidationError$ = exports.HTTPValidationError$outboundSchema = exports.HTTPValidationError$inboundSchema = exports.HTTPValidationError = void 0;
    var z4 = __importStar(__require("zod"));
    var components = __importStar(require_components());
    var HTTPValidationError = class extends Error {
      constructor(err) {
        const message = "message" in err && typeof err.message === "string" ? err.message : `API error occurred: ${JSON.stringify(err)}`;
        super(message);
        this.data$ = err;
        if (err.detail != null)
          this.detail = err.detail;
        this.name = "HTTPValidationError";
      }
    };
    exports.HTTPValidationError = HTTPValidationError;
    exports.HTTPValidationError$inboundSchema = z4.object({
      detail: z4.array(components.ValidationError$inboundSchema).optional()
    }).transform((v2) => {
      return new HTTPValidationError(v2);
    });
    exports.HTTPValidationError$outboundSchema = z4.instanceof(HTTPValidationError).transform((v2) => v2.data$).pipe(z4.object({
      detail: z4.array(components.ValidationError$outboundSchema).optional()
    }));
    var HTTPValidationError$;
    (function(HTTPValidationError$2) {
      HTTPValidationError$2.inboundSchema = exports.HTTPValidationError$inboundSchema;
      HTTPValidationError$2.outboundSchema = exports.HTTPValidationError$outboundSchema;
    })(HTTPValidationError$ || (exports.HTTPValidationError$ = HTTPValidationError$ = {}));
  }
});

// ../node_modules/@mistralai/mistralai/models/errors/index.js
var require_errors = __commonJS({
  "../node_modules/@mistralai/mistralai/models/errors/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_httpclienterrors(), exports);
    __exportStar(require_httpvalidationerror(), exports);
    __exportStar(require_sdkerror(), exports);
    __exportStar(require_sdkvalidationerror(), exports);
  }
});

// ../node_modules/@mistralai/mistralai/types/async.js
var require_async = __commonJS({
  "../node_modules/@mistralai/mistralai/types/async.js"(exports) {
    "use strict";
    var __classPrivateFieldSet10 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind3, f2) {
      if (kind3 === "m") throw new TypeError("Private method is not writable");
      if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind3 === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet11 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind3, f2) {
      if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind3 === "m" ? f2 : kind3 === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
    };
    var _APIPromise_promise;
    var _APIPromise_unwrapped;
    var _a3;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.APIPromise = void 0;
    var APIPromise3 = class {
      constructor(p2) {
        _APIPromise_promise.set(this, void 0);
        _APIPromise_unwrapped.set(this, void 0);
        this[_a3] = "APIPromise";
        __classPrivateFieldSet10(this, _APIPromise_promise, p2 instanceof Promise ? p2 : Promise.resolve(p2), "f");
        __classPrivateFieldSet10(this, _APIPromise_unwrapped, p2 instanceof Promise ? __classPrivateFieldGet11(this, _APIPromise_promise, "f").then(([value]) => value) : Promise.resolve(p2[0]), "f");
      }
      then(onfulfilled, onrejected) {
        return __classPrivateFieldGet11(this, _APIPromise_promise, "f").then(onfulfilled ? ([value]) => onfulfilled(value) : void 0, onrejected);
      }
      catch(onrejected) {
        return __classPrivateFieldGet11(this, _APIPromise_unwrapped, "f").catch(onrejected);
      }
      finally(onfinally) {
        return __classPrivateFieldGet11(this, _APIPromise_unwrapped, "f").finally(onfinally);
      }
      $inspect() {
        return __classPrivateFieldGet11(this, _APIPromise_promise, "f");
      }
    };
    exports.APIPromise = APIPromise3;
    _APIPromise_promise = /* @__PURE__ */ new WeakMap(), _APIPromise_unwrapped = /* @__PURE__ */ new WeakMap(), _a3 = Symbol.toStringTag;
  }
});

// ../node_modules/@mistralai/mistralai/funcs/agentsComplete.js
var require_agentsComplete = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/agentsComplete.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.agentsComplete = agentsComplete;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var async_js_1 = require_async();
    function agentsComplete(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => components.AgentsCompletionRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = (0, encodings_js_1.encodeJSON)("body", payload, { explode: true });
      const path2 = (0, url_js_1.pathToFunc)("/v1/agents/completions")();
      const headers = new Headers((0, primitives_js_1.compactMap)({
        "Content-Type": "application/json",
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "agents_completion_v1_agents_completions_post",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.ChatCompletionResponse$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/agentsStream.js
var require_agentsStream = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/agentsStream.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.agentsStream = agentsStream;
    var z4 = __importStar(__require("zod"));
    var encodings_js_1 = require_encodings();
    var event_streams_js_1 = require_event_streams();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var async_js_1 = require_async();
    function agentsStream(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => components.AgentsCompletionStreamRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = (0, encodings_js_1.encodeJSON)("body", payload, { explode: true });
      const path2 = (0, url_js_1.pathToFunc)("/v1/agents/completions#stream")();
      const headers = new Headers((0, primitives_js_1.compactMap)({
        "Content-Type": "application/json",
        Accept: "text/event-stream"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "stream_agents",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.sse(200, z4.instanceof(ReadableStream).transform((stream) => {
        return new event_streams_js_1.EventStream({
          stream,
          decoder(rawEvent) {
            const schema = components.CompletionEvent$inboundSchema;
            return schema.parse(rawEvent);
          }
        });
      }), { sseSentinel: "[DONE]" }), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/sdk/agents.js
var require_agents = __commonJS({
  "../node_modules/@mistralai/mistralai/sdk/agents.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Agents = void 0;
    var agentsComplete_js_1 = require_agentsComplete();
    var agentsStream_js_1 = require_agentsStream();
    var sdks_js_1 = require_sdks();
    var fp_js_1 = require_fp();
    var Agents = class extends sdks_js_1.ClientSDK {
      /**
       * Agents Completion
       */
      async complete(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, agentsComplete_js_1.agentsComplete)(this, request, options));
      }
      /**
       * Stream Agents completion
       *
       * @remarks
       * Mistral AI provides the ability to stream responses back to a client in order to allow partial results for certain requests. Tokens will be sent as data-only server-sent events as they become available, with the stream terminated by a data: [DONE] message. Otherwise, the server will hold the request open until the timeout or until completion, with the response containing the full result as JSON.
       */
      async stream(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, agentsStream_js_1.agentsStream)(this, request, options));
      }
    };
    exports.Agents = Agents;
  }
});

// ../node_modules/@mistralai/mistralai/types/streams.js
var require_streams = __commonJS({
  "../node_modules/@mistralai/mistralai/types/streams.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isReadableStream = isReadableStream;
    function isReadableStream(val) {
      if (typeof val !== "object" || val === null) {
        return false;
      }
      const stream = val;
      return typeof stream.getReader === "function" && typeof stream.cancel === "function" && typeof stream.tee === "function";
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/audioTranscriptionsComplete.js
var require_audioTranscriptionsComplete = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/audioTranscriptionsComplete.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.audioTranscriptionsComplete = audioTranscriptionsComplete;
    var encodings_js_1 = require_encodings();
    var files_js_1 = require_files();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var async_js_1 = require_async();
    var blobs_js_1 = require_blobs();
    var streams_js_1 = require_streams();
    function audioTranscriptionsComplete(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => components.AudioTranscriptionRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = new FormData();
      (0, encodings_js_1.appendForm)(body, "model", payload.model);
      if (payload.file !== void 0) {
        if ((0, blobs_js_1.isBlobLike)(payload.file)) {
          (0, encodings_js_1.appendForm)(body, "file", payload.file);
        } else if ((0, streams_js_1.isReadableStream)(payload.file.content)) {
          const buffer = await (0, files_js_1.readableStreamToArrayBuffer)(payload.file.content);
          const blob = new Blob([buffer], { type: "application/octet-stream" });
          (0, encodings_js_1.appendForm)(body, "file", blob);
        } else {
          (0, encodings_js_1.appendForm)(body, "file", new Blob([payload.file.content], { type: "application/octet-stream" }), payload.file.fileName);
        }
      }
      if (payload.file_id !== void 0) {
        (0, encodings_js_1.appendForm)(body, "file_id", payload.file_id);
      }
      if (payload.file_url !== void 0) {
        (0, encodings_js_1.appendForm)(body, "file_url", payload.file_url);
      }
      if (payload.language !== void 0) {
        (0, encodings_js_1.appendForm)(body, "language", payload.language);
      }
      if (payload.stream !== void 0) {
        (0, encodings_js_1.appendForm)(body, "stream", payload.stream);
      }
      if (payload.temperature !== void 0) {
        (0, encodings_js_1.appendForm)(body, "temperature", payload.temperature);
      }
      if (payload.timestamp_granularities !== void 0) {
        (0, encodings_js_1.appendForm)(body, "timestamp_granularities", payload.timestamp_granularities);
      }
      const path2 = (0, url_js_1.pathToFunc)("/v1/audio/transcriptions")();
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "audio_api_v1_transcriptions_post",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const [result] = await M2.match(M2.json(200, components.TranscriptionResponse$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response);
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/audioTranscriptionsStream.js
var require_audioTranscriptionsStream = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/audioTranscriptionsStream.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.audioTranscriptionsStream = audioTranscriptionsStream;
    var z4 = __importStar(__require("zod"));
    var encodings_js_1 = require_encodings();
    var event_streams_js_1 = require_event_streams();
    var files_js_1 = require_files();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var async_js_1 = require_async();
    var blobs_js_1 = require_blobs();
    var streams_js_1 = require_streams();
    function audioTranscriptionsStream(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => components.AudioTranscriptionRequestStream$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = new FormData();
      (0, encodings_js_1.appendForm)(body, "model", payload.model);
      if (payload.file !== void 0) {
        if ((0, blobs_js_1.isBlobLike)(payload.file)) {
          (0, encodings_js_1.appendForm)(body, "file", payload.file);
        } else if ((0, streams_js_1.isReadableStream)(payload.file.content)) {
          const buffer = await (0, files_js_1.readableStreamToArrayBuffer)(payload.file.content);
          const blob = new Blob([buffer], { type: "application/octet-stream" });
          (0, encodings_js_1.appendForm)(body, "file", blob);
        } else {
          (0, encodings_js_1.appendForm)(body, "file", new Blob([payload.file.content], { type: "application/octet-stream" }), payload.file.fileName);
        }
      }
      if (payload.file_id !== void 0) {
        (0, encodings_js_1.appendForm)(body, "file_id", payload.file_id);
      }
      if (payload.file_url !== void 0) {
        (0, encodings_js_1.appendForm)(body, "file_url", payload.file_url);
      }
      if (payload.language !== void 0) {
        (0, encodings_js_1.appendForm)(body, "language", payload.language);
      }
      if (payload.stream !== void 0) {
        (0, encodings_js_1.appendForm)(body, "stream", payload.stream);
      }
      if (payload.temperature !== void 0) {
        (0, encodings_js_1.appendForm)(body, "temperature", payload.temperature);
      }
      if (payload.timestamp_granularities !== void 0) {
        (0, encodings_js_1.appendForm)(body, "timestamp_granularities", payload.timestamp_granularities);
      }
      const path2 = (0, url_js_1.pathToFunc)("/v1/audio/transcriptions#stream")();
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "text/event-stream"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "audio_api_v1_transcriptions_post_stream",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const [result] = await M2.match(M2.sse(200, z4.instanceof(ReadableStream).transform((stream) => {
        return new event_streams_js_1.EventStream({
          stream,
          decoder(rawEvent) {
            const schema = components.TranscriptionStreamEvents$inboundSchema;
            return schema.parse(rawEvent);
          }
        });
      })), M2.fail("4XX"), M2.fail("5XX"))(response);
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/sdk/transcriptions.js
var require_transcriptions = __commonJS({
  "../node_modules/@mistralai/mistralai/sdk/transcriptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Transcriptions = void 0;
    var audioTranscriptionsComplete_js_1 = require_audioTranscriptionsComplete();
    var audioTranscriptionsStream_js_1 = require_audioTranscriptionsStream();
    var sdks_js_1 = require_sdks();
    var fp_js_1 = require_fp();
    var Transcriptions2 = class extends sdks_js_1.ClientSDK {
      /**
       * Create Transcription
       */
      async complete(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, audioTranscriptionsComplete_js_1.audioTranscriptionsComplete)(this, request, options));
      }
      /**
       * Create streaming transcription (SSE)
       */
      async stream(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, audioTranscriptionsStream_js_1.audioTranscriptionsStream)(this, request, options));
      }
    };
    exports.Transcriptions = Transcriptions2;
  }
});

// ../node_modules/@mistralai/mistralai/sdk/audio.js
var require_audio = __commonJS({
  "../node_modules/@mistralai/mistralai/sdk/audio.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Audio = void 0;
    var sdks_js_1 = require_sdks();
    var transcriptions_js_1 = require_transcriptions();
    var Audio2 = class extends sdks_js_1.ClientSDK {
      get transcriptions() {
        return this._transcriptions ?? (this._transcriptions = new transcriptions_js_1.Transcriptions(this._options));
      }
    };
    exports.Audio = Audio2;
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/agentsapiv1agentsget.js
var require_agentsapiv1agentsget = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/agentsapiv1agentsget.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AgentsApiV1AgentsGetRequest$ = exports.AgentsApiV1AgentsGetRequest$outboundSchema = exports.AgentsApiV1AgentsGetRequest$inboundSchema = void 0;
    exports.agentsApiV1AgentsGetRequestToJSON = agentsApiV1AgentsGetRequestToJSON;
    exports.agentsApiV1AgentsGetRequestFromJSON = agentsApiV1AgentsGetRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.AgentsApiV1AgentsGetRequest$inboundSchema = z4.object({
      agent_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "agent_id": "agentId"
      });
    });
    exports.AgentsApiV1AgentsGetRequest$outboundSchema = z4.object({
      agentId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        agentId: "agent_id"
      });
    });
    var AgentsApiV1AgentsGetRequest$;
    (function(AgentsApiV1AgentsGetRequest$2) {
      AgentsApiV1AgentsGetRequest$2.inboundSchema = exports.AgentsApiV1AgentsGetRequest$inboundSchema;
      AgentsApiV1AgentsGetRequest$2.outboundSchema = exports.AgentsApiV1AgentsGetRequest$outboundSchema;
    })(AgentsApiV1AgentsGetRequest$ || (exports.AgentsApiV1AgentsGetRequest$ = AgentsApiV1AgentsGetRequest$ = {}));
    function agentsApiV1AgentsGetRequestToJSON(agentsApiV1AgentsGetRequest) {
      return JSON.stringify(exports.AgentsApiV1AgentsGetRequest$outboundSchema.parse(agentsApiV1AgentsGetRequest));
    }
    function agentsApiV1AgentsGetRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AgentsApiV1AgentsGetRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AgentsApiV1AgentsGetRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/agentsapiv1agentslist.js
var require_agentsapiv1agentslist = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/agentsapiv1agentslist.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AgentsApiV1AgentsListRequest$ = exports.AgentsApiV1AgentsListRequest$outboundSchema = exports.AgentsApiV1AgentsListRequest$inboundSchema = void 0;
    exports.agentsApiV1AgentsListRequestToJSON = agentsApiV1AgentsListRequestToJSON;
    exports.agentsApiV1AgentsListRequestFromJSON = agentsApiV1AgentsListRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.AgentsApiV1AgentsListRequest$inboundSchema = z4.object({
      page: z4.number().int().default(0),
      page_size: z4.number().int().default(20)
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "page_size": "pageSize"
      });
    });
    exports.AgentsApiV1AgentsListRequest$outboundSchema = z4.object({
      page: z4.number().int().default(0),
      pageSize: z4.number().int().default(20)
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        pageSize: "page_size"
      });
    });
    var AgentsApiV1AgentsListRequest$;
    (function(AgentsApiV1AgentsListRequest$2) {
      AgentsApiV1AgentsListRequest$2.inboundSchema = exports.AgentsApiV1AgentsListRequest$inboundSchema;
      AgentsApiV1AgentsListRequest$2.outboundSchema = exports.AgentsApiV1AgentsListRequest$outboundSchema;
    })(AgentsApiV1AgentsListRequest$ || (exports.AgentsApiV1AgentsListRequest$ = AgentsApiV1AgentsListRequest$ = {}));
    function agentsApiV1AgentsListRequestToJSON(agentsApiV1AgentsListRequest) {
      return JSON.stringify(exports.AgentsApiV1AgentsListRequest$outboundSchema.parse(agentsApiV1AgentsListRequest));
    }
    function agentsApiV1AgentsListRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AgentsApiV1AgentsListRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AgentsApiV1AgentsListRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/agentsapiv1agentsupdate.js
var require_agentsapiv1agentsupdate = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/agentsapiv1agentsupdate.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AgentsApiV1AgentsUpdateRequest$ = exports.AgentsApiV1AgentsUpdateRequest$outboundSchema = exports.AgentsApiV1AgentsUpdateRequest$inboundSchema = void 0;
    exports.agentsApiV1AgentsUpdateRequestToJSON = agentsApiV1AgentsUpdateRequestToJSON;
    exports.agentsApiV1AgentsUpdateRequestFromJSON = agentsApiV1AgentsUpdateRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var components = __importStar(require_components());
    exports.AgentsApiV1AgentsUpdateRequest$inboundSchema = z4.object({
      agent_id: z4.string(),
      AgentUpdateRequest: components.AgentUpdateRequest$inboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "agent_id": "agentId",
        "AgentUpdateRequest": "agentUpdateRequest"
      });
    });
    exports.AgentsApiV1AgentsUpdateRequest$outboundSchema = z4.object({
      agentId: z4.string(),
      agentUpdateRequest: components.AgentUpdateRequest$outboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        agentId: "agent_id",
        agentUpdateRequest: "AgentUpdateRequest"
      });
    });
    var AgentsApiV1AgentsUpdateRequest$;
    (function(AgentsApiV1AgentsUpdateRequest$2) {
      AgentsApiV1AgentsUpdateRequest$2.inboundSchema = exports.AgentsApiV1AgentsUpdateRequest$inboundSchema;
      AgentsApiV1AgentsUpdateRequest$2.outboundSchema = exports.AgentsApiV1AgentsUpdateRequest$outboundSchema;
    })(AgentsApiV1AgentsUpdateRequest$ || (exports.AgentsApiV1AgentsUpdateRequest$ = AgentsApiV1AgentsUpdateRequest$ = {}));
    function agentsApiV1AgentsUpdateRequestToJSON(agentsApiV1AgentsUpdateRequest) {
      return JSON.stringify(exports.AgentsApiV1AgentsUpdateRequest$outboundSchema.parse(agentsApiV1AgentsUpdateRequest));
    }
    function agentsApiV1AgentsUpdateRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AgentsApiV1AgentsUpdateRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AgentsApiV1AgentsUpdateRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/agentsapiv1agentsupdateversion.js
var require_agentsapiv1agentsupdateversion = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/agentsapiv1agentsupdateversion.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AgentsApiV1AgentsUpdateVersionRequest$ = exports.AgentsApiV1AgentsUpdateVersionRequest$outboundSchema = exports.AgentsApiV1AgentsUpdateVersionRequest$inboundSchema = void 0;
    exports.agentsApiV1AgentsUpdateVersionRequestToJSON = agentsApiV1AgentsUpdateVersionRequestToJSON;
    exports.agentsApiV1AgentsUpdateVersionRequestFromJSON = agentsApiV1AgentsUpdateVersionRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.AgentsApiV1AgentsUpdateVersionRequest$inboundSchema = z4.object({
      agent_id: z4.string(),
      version: z4.number().int()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "agent_id": "agentId"
      });
    });
    exports.AgentsApiV1AgentsUpdateVersionRequest$outboundSchema = z4.object({
      agentId: z4.string(),
      version: z4.number().int()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        agentId: "agent_id"
      });
    });
    var AgentsApiV1AgentsUpdateVersionRequest$;
    (function(AgentsApiV1AgentsUpdateVersionRequest$2) {
      AgentsApiV1AgentsUpdateVersionRequest$2.inboundSchema = exports.AgentsApiV1AgentsUpdateVersionRequest$inboundSchema;
      AgentsApiV1AgentsUpdateVersionRequest$2.outboundSchema = exports.AgentsApiV1AgentsUpdateVersionRequest$outboundSchema;
    })(AgentsApiV1AgentsUpdateVersionRequest$ || (exports.AgentsApiV1AgentsUpdateVersionRequest$ = AgentsApiV1AgentsUpdateVersionRequest$ = {}));
    function agentsApiV1AgentsUpdateVersionRequestToJSON(agentsApiV1AgentsUpdateVersionRequest) {
      return JSON.stringify(exports.AgentsApiV1AgentsUpdateVersionRequest$outboundSchema.parse(agentsApiV1AgentsUpdateVersionRequest));
    }
    function agentsApiV1AgentsUpdateVersionRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AgentsApiV1AgentsUpdateVersionRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AgentsApiV1AgentsUpdateVersionRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/agentsapiv1conversationsappend.js
var require_agentsapiv1conversationsappend = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/agentsapiv1conversationsappend.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AgentsApiV1ConversationsAppendRequest$ = exports.AgentsApiV1ConversationsAppendRequest$outboundSchema = exports.AgentsApiV1ConversationsAppendRequest$inboundSchema = void 0;
    exports.agentsApiV1ConversationsAppendRequestToJSON = agentsApiV1ConversationsAppendRequestToJSON;
    exports.agentsApiV1ConversationsAppendRequestFromJSON = agentsApiV1ConversationsAppendRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var components = __importStar(require_components());
    exports.AgentsApiV1ConversationsAppendRequest$inboundSchema = z4.object({
      conversation_id: z4.string(),
      ConversationAppendRequest: components.ConversationAppendRequest$inboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "conversation_id": "conversationId",
        "ConversationAppendRequest": "conversationAppendRequest"
      });
    });
    exports.AgentsApiV1ConversationsAppendRequest$outboundSchema = z4.object({
      conversationId: z4.string(),
      conversationAppendRequest: components.ConversationAppendRequest$outboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        conversationId: "conversation_id",
        conversationAppendRequest: "ConversationAppendRequest"
      });
    });
    var AgentsApiV1ConversationsAppendRequest$;
    (function(AgentsApiV1ConversationsAppendRequest$2) {
      AgentsApiV1ConversationsAppendRequest$2.inboundSchema = exports.AgentsApiV1ConversationsAppendRequest$inboundSchema;
      AgentsApiV1ConversationsAppendRequest$2.outboundSchema = exports.AgentsApiV1ConversationsAppendRequest$outboundSchema;
    })(AgentsApiV1ConversationsAppendRequest$ || (exports.AgentsApiV1ConversationsAppendRequest$ = AgentsApiV1ConversationsAppendRequest$ = {}));
    function agentsApiV1ConversationsAppendRequestToJSON(agentsApiV1ConversationsAppendRequest) {
      return JSON.stringify(exports.AgentsApiV1ConversationsAppendRequest$outboundSchema.parse(agentsApiV1ConversationsAppendRequest));
    }
    function agentsApiV1ConversationsAppendRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AgentsApiV1ConversationsAppendRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AgentsApiV1ConversationsAppendRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/agentsapiv1conversationsappendstream.js
var require_agentsapiv1conversationsappendstream = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/agentsapiv1conversationsappendstream.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AgentsApiV1ConversationsAppendStreamRequest$ = exports.AgentsApiV1ConversationsAppendStreamRequest$outboundSchema = exports.AgentsApiV1ConversationsAppendStreamRequest$inboundSchema = void 0;
    exports.agentsApiV1ConversationsAppendStreamRequestToJSON = agentsApiV1ConversationsAppendStreamRequestToJSON;
    exports.agentsApiV1ConversationsAppendStreamRequestFromJSON = agentsApiV1ConversationsAppendStreamRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var components = __importStar(require_components());
    exports.AgentsApiV1ConversationsAppendStreamRequest$inboundSchema = z4.object({
      conversation_id: z4.string(),
      ConversationAppendStreamRequest: components.ConversationAppendStreamRequest$inboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "conversation_id": "conversationId",
        "ConversationAppendStreamRequest": "conversationAppendStreamRequest"
      });
    });
    exports.AgentsApiV1ConversationsAppendStreamRequest$outboundSchema = z4.object({
      conversationId: z4.string(),
      conversationAppendStreamRequest: components.ConversationAppendStreamRequest$outboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        conversationId: "conversation_id",
        conversationAppendStreamRequest: "ConversationAppendStreamRequest"
      });
    });
    var AgentsApiV1ConversationsAppendStreamRequest$;
    (function(AgentsApiV1ConversationsAppendStreamRequest$2) {
      AgentsApiV1ConversationsAppendStreamRequest$2.inboundSchema = exports.AgentsApiV1ConversationsAppendStreamRequest$inboundSchema;
      AgentsApiV1ConversationsAppendStreamRequest$2.outboundSchema = exports.AgentsApiV1ConversationsAppendStreamRequest$outboundSchema;
    })(AgentsApiV1ConversationsAppendStreamRequest$ || (exports.AgentsApiV1ConversationsAppendStreamRequest$ = AgentsApiV1ConversationsAppendStreamRequest$ = {}));
    function agentsApiV1ConversationsAppendStreamRequestToJSON(agentsApiV1ConversationsAppendStreamRequest) {
      return JSON.stringify(exports.AgentsApiV1ConversationsAppendStreamRequest$outboundSchema.parse(agentsApiV1ConversationsAppendStreamRequest));
    }
    function agentsApiV1ConversationsAppendStreamRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AgentsApiV1ConversationsAppendStreamRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AgentsApiV1ConversationsAppendStreamRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/agentsapiv1conversationsget.js
var require_agentsapiv1conversationsget = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/agentsapiv1conversationsget.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AgentsApiV1ConversationsGetResponseV1ConversationsGet$ = exports.AgentsApiV1ConversationsGetResponseV1ConversationsGet$outboundSchema = exports.AgentsApiV1ConversationsGetResponseV1ConversationsGet$inboundSchema = exports.AgentsApiV1ConversationsGetRequest$ = exports.AgentsApiV1ConversationsGetRequest$outboundSchema = exports.AgentsApiV1ConversationsGetRequest$inboundSchema = void 0;
    exports.agentsApiV1ConversationsGetRequestToJSON = agentsApiV1ConversationsGetRequestToJSON;
    exports.agentsApiV1ConversationsGetRequestFromJSON = agentsApiV1ConversationsGetRequestFromJSON;
    exports.agentsApiV1ConversationsGetResponseV1ConversationsGetToJSON = agentsApiV1ConversationsGetResponseV1ConversationsGetToJSON;
    exports.agentsApiV1ConversationsGetResponseV1ConversationsGetFromJSON = agentsApiV1ConversationsGetResponseV1ConversationsGetFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var components = __importStar(require_components());
    exports.AgentsApiV1ConversationsGetRequest$inboundSchema = z4.object({
      conversation_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "conversation_id": "conversationId"
      });
    });
    exports.AgentsApiV1ConversationsGetRequest$outboundSchema = z4.object({
      conversationId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        conversationId: "conversation_id"
      });
    });
    var AgentsApiV1ConversationsGetRequest$;
    (function(AgentsApiV1ConversationsGetRequest$2) {
      AgentsApiV1ConversationsGetRequest$2.inboundSchema = exports.AgentsApiV1ConversationsGetRequest$inboundSchema;
      AgentsApiV1ConversationsGetRequest$2.outboundSchema = exports.AgentsApiV1ConversationsGetRequest$outboundSchema;
    })(AgentsApiV1ConversationsGetRequest$ || (exports.AgentsApiV1ConversationsGetRequest$ = AgentsApiV1ConversationsGetRequest$ = {}));
    function agentsApiV1ConversationsGetRequestToJSON(agentsApiV1ConversationsGetRequest) {
      return JSON.stringify(exports.AgentsApiV1ConversationsGetRequest$outboundSchema.parse(agentsApiV1ConversationsGetRequest));
    }
    function agentsApiV1ConversationsGetRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AgentsApiV1ConversationsGetRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AgentsApiV1ConversationsGetRequest' from JSON`);
    }
    exports.AgentsApiV1ConversationsGetResponseV1ConversationsGet$inboundSchema = z4.union([
      components.AgentConversation$inboundSchema,
      components.ModelConversation$inboundSchema
    ]);
    exports.AgentsApiV1ConversationsGetResponseV1ConversationsGet$outboundSchema = z4.union([
      components.AgentConversation$outboundSchema,
      components.ModelConversation$outboundSchema
    ]);
    var AgentsApiV1ConversationsGetResponseV1ConversationsGet$;
    (function(AgentsApiV1ConversationsGetResponseV1ConversationsGet$2) {
      AgentsApiV1ConversationsGetResponseV1ConversationsGet$2.inboundSchema = exports.AgentsApiV1ConversationsGetResponseV1ConversationsGet$inboundSchema;
      AgentsApiV1ConversationsGetResponseV1ConversationsGet$2.outboundSchema = exports.AgentsApiV1ConversationsGetResponseV1ConversationsGet$outboundSchema;
    })(AgentsApiV1ConversationsGetResponseV1ConversationsGet$ || (exports.AgentsApiV1ConversationsGetResponseV1ConversationsGet$ = AgentsApiV1ConversationsGetResponseV1ConversationsGet$ = {}));
    function agentsApiV1ConversationsGetResponseV1ConversationsGetToJSON(agentsApiV1ConversationsGetResponseV1ConversationsGet) {
      return JSON.stringify(exports.AgentsApiV1ConversationsGetResponseV1ConversationsGet$outboundSchema.parse(agentsApiV1ConversationsGetResponseV1ConversationsGet));
    }
    function agentsApiV1ConversationsGetResponseV1ConversationsGetFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AgentsApiV1ConversationsGetResponseV1ConversationsGet$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AgentsApiV1ConversationsGetResponseV1ConversationsGet' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/agentsapiv1conversationshistory.js
var require_agentsapiv1conversationshistory = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/agentsapiv1conversationshistory.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AgentsApiV1ConversationsHistoryRequest$ = exports.AgentsApiV1ConversationsHistoryRequest$outboundSchema = exports.AgentsApiV1ConversationsHistoryRequest$inboundSchema = void 0;
    exports.agentsApiV1ConversationsHistoryRequestToJSON = agentsApiV1ConversationsHistoryRequestToJSON;
    exports.agentsApiV1ConversationsHistoryRequestFromJSON = agentsApiV1ConversationsHistoryRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.AgentsApiV1ConversationsHistoryRequest$inboundSchema = z4.object({
      conversation_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "conversation_id": "conversationId"
      });
    });
    exports.AgentsApiV1ConversationsHistoryRequest$outboundSchema = z4.object({
      conversationId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        conversationId: "conversation_id"
      });
    });
    var AgentsApiV1ConversationsHistoryRequest$;
    (function(AgentsApiV1ConversationsHistoryRequest$2) {
      AgentsApiV1ConversationsHistoryRequest$2.inboundSchema = exports.AgentsApiV1ConversationsHistoryRequest$inboundSchema;
      AgentsApiV1ConversationsHistoryRequest$2.outboundSchema = exports.AgentsApiV1ConversationsHistoryRequest$outboundSchema;
    })(AgentsApiV1ConversationsHistoryRequest$ || (exports.AgentsApiV1ConversationsHistoryRequest$ = AgentsApiV1ConversationsHistoryRequest$ = {}));
    function agentsApiV1ConversationsHistoryRequestToJSON(agentsApiV1ConversationsHistoryRequest) {
      return JSON.stringify(exports.AgentsApiV1ConversationsHistoryRequest$outboundSchema.parse(agentsApiV1ConversationsHistoryRequest));
    }
    function agentsApiV1ConversationsHistoryRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AgentsApiV1ConversationsHistoryRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AgentsApiV1ConversationsHistoryRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/agentsapiv1conversationslist.js
var require_agentsapiv1conversationslist = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/agentsapiv1conversationslist.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ResponseBody$ = exports.ResponseBody$outboundSchema = exports.ResponseBody$inboundSchema = exports.AgentsApiV1ConversationsListRequest$ = exports.AgentsApiV1ConversationsListRequest$outboundSchema = exports.AgentsApiV1ConversationsListRequest$inboundSchema = void 0;
    exports.agentsApiV1ConversationsListRequestToJSON = agentsApiV1ConversationsListRequestToJSON;
    exports.agentsApiV1ConversationsListRequestFromJSON = agentsApiV1ConversationsListRequestFromJSON;
    exports.responseBodyToJSON = responseBodyToJSON;
    exports.responseBodyFromJSON = responseBodyFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var components = __importStar(require_components());
    exports.AgentsApiV1ConversationsListRequest$inboundSchema = z4.object({
      page: z4.number().int().default(0),
      page_size: z4.number().int().default(100)
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "page_size": "pageSize"
      });
    });
    exports.AgentsApiV1ConversationsListRequest$outboundSchema = z4.object({
      page: z4.number().int().default(0),
      pageSize: z4.number().int().default(100)
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        pageSize: "page_size"
      });
    });
    var AgentsApiV1ConversationsListRequest$;
    (function(AgentsApiV1ConversationsListRequest$2) {
      AgentsApiV1ConversationsListRequest$2.inboundSchema = exports.AgentsApiV1ConversationsListRequest$inboundSchema;
      AgentsApiV1ConversationsListRequest$2.outboundSchema = exports.AgentsApiV1ConversationsListRequest$outboundSchema;
    })(AgentsApiV1ConversationsListRequest$ || (exports.AgentsApiV1ConversationsListRequest$ = AgentsApiV1ConversationsListRequest$ = {}));
    function agentsApiV1ConversationsListRequestToJSON(agentsApiV1ConversationsListRequest) {
      return JSON.stringify(exports.AgentsApiV1ConversationsListRequest$outboundSchema.parse(agentsApiV1ConversationsListRequest));
    }
    function agentsApiV1ConversationsListRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AgentsApiV1ConversationsListRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AgentsApiV1ConversationsListRequest' from JSON`);
    }
    exports.ResponseBody$inboundSchema = z4.union([
      components.AgentConversation$inboundSchema,
      components.ModelConversation$inboundSchema
    ]);
    exports.ResponseBody$outboundSchema = z4.union([
      components.AgentConversation$outboundSchema,
      components.ModelConversation$outboundSchema
    ]);
    var ResponseBody$;
    (function(ResponseBody$2) {
      ResponseBody$2.inboundSchema = exports.ResponseBody$inboundSchema;
      ResponseBody$2.outboundSchema = exports.ResponseBody$outboundSchema;
    })(ResponseBody$ || (exports.ResponseBody$ = ResponseBody$ = {}));
    function responseBodyToJSON(responseBody) {
      return JSON.stringify(exports.ResponseBody$outboundSchema.parse(responseBody));
    }
    function responseBodyFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.ResponseBody$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'ResponseBody' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/agentsapiv1conversationsmessages.js
var require_agentsapiv1conversationsmessages = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/agentsapiv1conversationsmessages.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AgentsApiV1ConversationsMessagesRequest$ = exports.AgentsApiV1ConversationsMessagesRequest$outboundSchema = exports.AgentsApiV1ConversationsMessagesRequest$inboundSchema = void 0;
    exports.agentsApiV1ConversationsMessagesRequestToJSON = agentsApiV1ConversationsMessagesRequestToJSON;
    exports.agentsApiV1ConversationsMessagesRequestFromJSON = agentsApiV1ConversationsMessagesRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.AgentsApiV1ConversationsMessagesRequest$inboundSchema = z4.object({
      conversation_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "conversation_id": "conversationId"
      });
    });
    exports.AgentsApiV1ConversationsMessagesRequest$outboundSchema = z4.object({
      conversationId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        conversationId: "conversation_id"
      });
    });
    var AgentsApiV1ConversationsMessagesRequest$;
    (function(AgentsApiV1ConversationsMessagesRequest$2) {
      AgentsApiV1ConversationsMessagesRequest$2.inboundSchema = exports.AgentsApiV1ConversationsMessagesRequest$inboundSchema;
      AgentsApiV1ConversationsMessagesRequest$2.outboundSchema = exports.AgentsApiV1ConversationsMessagesRequest$outboundSchema;
    })(AgentsApiV1ConversationsMessagesRequest$ || (exports.AgentsApiV1ConversationsMessagesRequest$ = AgentsApiV1ConversationsMessagesRequest$ = {}));
    function agentsApiV1ConversationsMessagesRequestToJSON(agentsApiV1ConversationsMessagesRequest) {
      return JSON.stringify(exports.AgentsApiV1ConversationsMessagesRequest$outboundSchema.parse(agentsApiV1ConversationsMessagesRequest));
    }
    function agentsApiV1ConversationsMessagesRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AgentsApiV1ConversationsMessagesRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AgentsApiV1ConversationsMessagesRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/agentsapiv1conversationsrestart.js
var require_agentsapiv1conversationsrestart = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/agentsapiv1conversationsrestart.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AgentsApiV1ConversationsRestartRequest$ = exports.AgentsApiV1ConversationsRestartRequest$outboundSchema = exports.AgentsApiV1ConversationsRestartRequest$inboundSchema = void 0;
    exports.agentsApiV1ConversationsRestartRequestToJSON = agentsApiV1ConversationsRestartRequestToJSON;
    exports.agentsApiV1ConversationsRestartRequestFromJSON = agentsApiV1ConversationsRestartRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var components = __importStar(require_components());
    exports.AgentsApiV1ConversationsRestartRequest$inboundSchema = z4.object({
      conversation_id: z4.string(),
      ConversationRestartRequest: components.ConversationRestartRequest$inboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "conversation_id": "conversationId",
        "ConversationRestartRequest": "conversationRestartRequest"
      });
    });
    exports.AgentsApiV1ConversationsRestartRequest$outboundSchema = z4.object({
      conversationId: z4.string(),
      conversationRestartRequest: components.ConversationRestartRequest$outboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        conversationId: "conversation_id",
        conversationRestartRequest: "ConversationRestartRequest"
      });
    });
    var AgentsApiV1ConversationsRestartRequest$;
    (function(AgentsApiV1ConversationsRestartRequest$2) {
      AgentsApiV1ConversationsRestartRequest$2.inboundSchema = exports.AgentsApiV1ConversationsRestartRequest$inboundSchema;
      AgentsApiV1ConversationsRestartRequest$2.outboundSchema = exports.AgentsApiV1ConversationsRestartRequest$outboundSchema;
    })(AgentsApiV1ConversationsRestartRequest$ || (exports.AgentsApiV1ConversationsRestartRequest$ = AgentsApiV1ConversationsRestartRequest$ = {}));
    function agentsApiV1ConversationsRestartRequestToJSON(agentsApiV1ConversationsRestartRequest) {
      return JSON.stringify(exports.AgentsApiV1ConversationsRestartRequest$outboundSchema.parse(agentsApiV1ConversationsRestartRequest));
    }
    function agentsApiV1ConversationsRestartRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AgentsApiV1ConversationsRestartRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AgentsApiV1ConversationsRestartRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/agentsapiv1conversationsrestartstream.js
var require_agentsapiv1conversationsrestartstream = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/agentsapiv1conversationsrestartstream.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AgentsApiV1ConversationsRestartStreamRequest$ = exports.AgentsApiV1ConversationsRestartStreamRequest$outboundSchema = exports.AgentsApiV1ConversationsRestartStreamRequest$inboundSchema = void 0;
    exports.agentsApiV1ConversationsRestartStreamRequestToJSON = agentsApiV1ConversationsRestartStreamRequestToJSON;
    exports.agentsApiV1ConversationsRestartStreamRequestFromJSON = agentsApiV1ConversationsRestartStreamRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var components = __importStar(require_components());
    exports.AgentsApiV1ConversationsRestartStreamRequest$inboundSchema = z4.object({
      conversation_id: z4.string(),
      ConversationRestartStreamRequest: components.ConversationRestartStreamRequest$inboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "conversation_id": "conversationId",
        "ConversationRestartStreamRequest": "conversationRestartStreamRequest"
      });
    });
    exports.AgentsApiV1ConversationsRestartStreamRequest$outboundSchema = z4.object({
      conversationId: z4.string(),
      conversationRestartStreamRequest: components.ConversationRestartStreamRequest$outboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        conversationId: "conversation_id",
        conversationRestartStreamRequest: "ConversationRestartStreamRequest"
      });
    });
    var AgentsApiV1ConversationsRestartStreamRequest$;
    (function(AgentsApiV1ConversationsRestartStreamRequest$2) {
      AgentsApiV1ConversationsRestartStreamRequest$2.inboundSchema = exports.AgentsApiV1ConversationsRestartStreamRequest$inboundSchema;
      AgentsApiV1ConversationsRestartStreamRequest$2.outboundSchema = exports.AgentsApiV1ConversationsRestartStreamRequest$outboundSchema;
    })(AgentsApiV1ConversationsRestartStreamRequest$ || (exports.AgentsApiV1ConversationsRestartStreamRequest$ = AgentsApiV1ConversationsRestartStreamRequest$ = {}));
    function agentsApiV1ConversationsRestartStreamRequestToJSON(agentsApiV1ConversationsRestartStreamRequest) {
      return JSON.stringify(exports.AgentsApiV1ConversationsRestartStreamRequest$outboundSchema.parse(agentsApiV1ConversationsRestartStreamRequest));
    }
    function agentsApiV1ConversationsRestartStreamRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.AgentsApiV1ConversationsRestartStreamRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'AgentsApiV1ConversationsRestartStreamRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/deletemodelv1modelsmodeliddelete.js
var require_deletemodelv1modelsmodeliddelete = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/deletemodelv1modelsmodeliddelete.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeleteModelV1ModelsModelIdDeleteRequest$ = exports.DeleteModelV1ModelsModelIdDeleteRequest$outboundSchema = exports.DeleteModelV1ModelsModelIdDeleteRequest$inboundSchema = void 0;
    exports.deleteModelV1ModelsModelIdDeleteRequestToJSON = deleteModelV1ModelsModelIdDeleteRequestToJSON;
    exports.deleteModelV1ModelsModelIdDeleteRequestFromJSON = deleteModelV1ModelsModelIdDeleteRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.DeleteModelV1ModelsModelIdDeleteRequest$inboundSchema = z4.object({
      model_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "model_id": "modelId"
      });
    });
    exports.DeleteModelV1ModelsModelIdDeleteRequest$outboundSchema = z4.object({
      modelId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        modelId: "model_id"
      });
    });
    var DeleteModelV1ModelsModelIdDeleteRequest$;
    (function(DeleteModelV1ModelsModelIdDeleteRequest$2) {
      DeleteModelV1ModelsModelIdDeleteRequest$2.inboundSchema = exports.DeleteModelV1ModelsModelIdDeleteRequest$inboundSchema;
      DeleteModelV1ModelsModelIdDeleteRequest$2.outboundSchema = exports.DeleteModelV1ModelsModelIdDeleteRequest$outboundSchema;
    })(DeleteModelV1ModelsModelIdDeleteRequest$ || (exports.DeleteModelV1ModelsModelIdDeleteRequest$ = DeleteModelV1ModelsModelIdDeleteRequest$ = {}));
    function deleteModelV1ModelsModelIdDeleteRequestToJSON(deleteModelV1ModelsModelIdDeleteRequest) {
      return JSON.stringify(exports.DeleteModelV1ModelsModelIdDeleteRequest$outboundSchema.parse(deleteModelV1ModelsModelIdDeleteRequest));
    }
    function deleteModelV1ModelsModelIdDeleteRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.DeleteModelV1ModelsModelIdDeleteRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'DeleteModelV1ModelsModelIdDeleteRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/filesapiroutesdeletefile.js
var require_filesapiroutesdeletefile = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/filesapiroutesdeletefile.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FilesApiRoutesDeleteFileRequest$ = exports.FilesApiRoutesDeleteFileRequest$outboundSchema = exports.FilesApiRoutesDeleteFileRequest$inboundSchema = void 0;
    exports.filesApiRoutesDeleteFileRequestToJSON = filesApiRoutesDeleteFileRequestToJSON;
    exports.filesApiRoutesDeleteFileRequestFromJSON = filesApiRoutesDeleteFileRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.FilesApiRoutesDeleteFileRequest$inboundSchema = z4.object({
      file_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "file_id": "fileId"
      });
    });
    exports.FilesApiRoutesDeleteFileRequest$outboundSchema = z4.object({
      fileId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        fileId: "file_id"
      });
    });
    var FilesApiRoutesDeleteFileRequest$;
    (function(FilesApiRoutesDeleteFileRequest$2) {
      FilesApiRoutesDeleteFileRequest$2.inboundSchema = exports.FilesApiRoutesDeleteFileRequest$inboundSchema;
      FilesApiRoutesDeleteFileRequest$2.outboundSchema = exports.FilesApiRoutesDeleteFileRequest$outboundSchema;
    })(FilesApiRoutesDeleteFileRequest$ || (exports.FilesApiRoutesDeleteFileRequest$ = FilesApiRoutesDeleteFileRequest$ = {}));
    function filesApiRoutesDeleteFileRequestToJSON(filesApiRoutesDeleteFileRequest) {
      return JSON.stringify(exports.FilesApiRoutesDeleteFileRequest$outboundSchema.parse(filesApiRoutesDeleteFileRequest));
    }
    function filesApiRoutesDeleteFileRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.FilesApiRoutesDeleteFileRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'FilesApiRoutesDeleteFileRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/filesapiroutesdownloadfile.js
var require_filesapiroutesdownloadfile = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/filesapiroutesdownloadfile.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FilesApiRoutesDownloadFileRequest$ = exports.FilesApiRoutesDownloadFileRequest$outboundSchema = exports.FilesApiRoutesDownloadFileRequest$inboundSchema = void 0;
    exports.filesApiRoutesDownloadFileRequestToJSON = filesApiRoutesDownloadFileRequestToJSON;
    exports.filesApiRoutesDownloadFileRequestFromJSON = filesApiRoutesDownloadFileRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.FilesApiRoutesDownloadFileRequest$inboundSchema = z4.object({
      file_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "file_id": "fileId"
      });
    });
    exports.FilesApiRoutesDownloadFileRequest$outboundSchema = z4.object({
      fileId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        fileId: "file_id"
      });
    });
    var FilesApiRoutesDownloadFileRequest$;
    (function(FilesApiRoutesDownloadFileRequest$2) {
      FilesApiRoutesDownloadFileRequest$2.inboundSchema = exports.FilesApiRoutesDownloadFileRequest$inboundSchema;
      FilesApiRoutesDownloadFileRequest$2.outboundSchema = exports.FilesApiRoutesDownloadFileRequest$outboundSchema;
    })(FilesApiRoutesDownloadFileRequest$ || (exports.FilesApiRoutesDownloadFileRequest$ = FilesApiRoutesDownloadFileRequest$ = {}));
    function filesApiRoutesDownloadFileRequestToJSON(filesApiRoutesDownloadFileRequest) {
      return JSON.stringify(exports.FilesApiRoutesDownloadFileRequest$outboundSchema.parse(filesApiRoutesDownloadFileRequest));
    }
    function filesApiRoutesDownloadFileRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.FilesApiRoutesDownloadFileRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'FilesApiRoutesDownloadFileRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/filesapiroutesgetsignedurl.js
var require_filesapiroutesgetsignedurl = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/filesapiroutesgetsignedurl.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FilesApiRoutesGetSignedUrlRequest$ = exports.FilesApiRoutesGetSignedUrlRequest$outboundSchema = exports.FilesApiRoutesGetSignedUrlRequest$inboundSchema = void 0;
    exports.filesApiRoutesGetSignedUrlRequestToJSON = filesApiRoutesGetSignedUrlRequestToJSON;
    exports.filesApiRoutesGetSignedUrlRequestFromJSON = filesApiRoutesGetSignedUrlRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.FilesApiRoutesGetSignedUrlRequest$inboundSchema = z4.object({
      file_id: z4.string(),
      expiry: z4.number().int().default(24)
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "file_id": "fileId"
      });
    });
    exports.FilesApiRoutesGetSignedUrlRequest$outboundSchema = z4.object({
      fileId: z4.string(),
      expiry: z4.number().int().default(24)
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        fileId: "file_id"
      });
    });
    var FilesApiRoutesGetSignedUrlRequest$;
    (function(FilesApiRoutesGetSignedUrlRequest$2) {
      FilesApiRoutesGetSignedUrlRequest$2.inboundSchema = exports.FilesApiRoutesGetSignedUrlRequest$inboundSchema;
      FilesApiRoutesGetSignedUrlRequest$2.outboundSchema = exports.FilesApiRoutesGetSignedUrlRequest$outboundSchema;
    })(FilesApiRoutesGetSignedUrlRequest$ || (exports.FilesApiRoutesGetSignedUrlRequest$ = FilesApiRoutesGetSignedUrlRequest$ = {}));
    function filesApiRoutesGetSignedUrlRequestToJSON(filesApiRoutesGetSignedUrlRequest) {
      return JSON.stringify(exports.FilesApiRoutesGetSignedUrlRequest$outboundSchema.parse(filesApiRoutesGetSignedUrlRequest));
    }
    function filesApiRoutesGetSignedUrlRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.FilesApiRoutesGetSignedUrlRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'FilesApiRoutesGetSignedUrlRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/filesapirouteslistfiles.js
var require_filesapirouteslistfiles = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/filesapirouteslistfiles.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FilesApiRoutesListFilesRequest$ = exports.FilesApiRoutesListFilesRequest$outboundSchema = exports.FilesApiRoutesListFilesRequest$inboundSchema = void 0;
    exports.filesApiRoutesListFilesRequestToJSON = filesApiRoutesListFilesRequestToJSON;
    exports.filesApiRoutesListFilesRequestFromJSON = filesApiRoutesListFilesRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var components = __importStar(require_components());
    exports.FilesApiRoutesListFilesRequest$inboundSchema = z4.object({
      page: z4.number().int().default(0),
      page_size: z4.number().int().default(100),
      sample_type: z4.nullable(z4.array(components.SampleType$inboundSchema)).optional(),
      source: z4.nullable(z4.array(components.Source$inboundSchema)).optional(),
      search: z4.nullable(z4.string()).optional(),
      purpose: z4.nullable(components.FilePurpose$inboundSchema).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "page_size": "pageSize",
        "sample_type": "sampleType"
      });
    });
    exports.FilesApiRoutesListFilesRequest$outboundSchema = z4.object({
      page: z4.number().int().default(0),
      pageSize: z4.number().int().default(100),
      sampleType: z4.nullable(z4.array(components.SampleType$outboundSchema)).optional(),
      source: z4.nullable(z4.array(components.Source$outboundSchema)).optional(),
      search: z4.nullable(z4.string()).optional(),
      purpose: z4.nullable(components.FilePurpose$outboundSchema).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        pageSize: "page_size",
        sampleType: "sample_type"
      });
    });
    var FilesApiRoutesListFilesRequest$;
    (function(FilesApiRoutesListFilesRequest$2) {
      FilesApiRoutesListFilesRequest$2.inboundSchema = exports.FilesApiRoutesListFilesRequest$inboundSchema;
      FilesApiRoutesListFilesRequest$2.outboundSchema = exports.FilesApiRoutesListFilesRequest$outboundSchema;
    })(FilesApiRoutesListFilesRequest$ || (exports.FilesApiRoutesListFilesRequest$ = FilesApiRoutesListFilesRequest$ = {}));
    function filesApiRoutesListFilesRequestToJSON(filesApiRoutesListFilesRequest) {
      return JSON.stringify(exports.FilesApiRoutesListFilesRequest$outboundSchema.parse(filesApiRoutesListFilesRequest));
    }
    function filesApiRoutesListFilesRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.FilesApiRoutesListFilesRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'FilesApiRoutesListFilesRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/filesapiroutesretrievefile.js
var require_filesapiroutesretrievefile = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/filesapiroutesretrievefile.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FilesApiRoutesRetrieveFileRequest$ = exports.FilesApiRoutesRetrieveFileRequest$outboundSchema = exports.FilesApiRoutesRetrieveFileRequest$inboundSchema = void 0;
    exports.filesApiRoutesRetrieveFileRequestToJSON = filesApiRoutesRetrieveFileRequestToJSON;
    exports.filesApiRoutesRetrieveFileRequestFromJSON = filesApiRoutesRetrieveFileRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.FilesApiRoutesRetrieveFileRequest$inboundSchema = z4.object({
      file_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "file_id": "fileId"
      });
    });
    exports.FilesApiRoutesRetrieveFileRequest$outboundSchema = z4.object({
      fileId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        fileId: "file_id"
      });
    });
    var FilesApiRoutesRetrieveFileRequest$;
    (function(FilesApiRoutesRetrieveFileRequest$2) {
      FilesApiRoutesRetrieveFileRequest$2.inboundSchema = exports.FilesApiRoutesRetrieveFileRequest$inboundSchema;
      FilesApiRoutesRetrieveFileRequest$2.outboundSchema = exports.FilesApiRoutesRetrieveFileRequest$outboundSchema;
    })(FilesApiRoutesRetrieveFileRequest$ || (exports.FilesApiRoutesRetrieveFileRequest$ = FilesApiRoutesRetrieveFileRequest$ = {}));
    function filesApiRoutesRetrieveFileRequestToJSON(filesApiRoutesRetrieveFileRequest) {
      return JSON.stringify(exports.FilesApiRoutesRetrieveFileRequest$outboundSchema.parse(filesApiRoutesRetrieveFileRequest));
    }
    function filesApiRoutesRetrieveFileRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.FilesApiRoutesRetrieveFileRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'FilesApiRoutesRetrieveFileRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/filesapiroutesuploadfile.js
var require_filesapiroutesuploadfile = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/filesapiroutesuploadfile.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FilesApiRoutesUploadFileMultiPartBodyParams$ = exports.FilesApiRoutesUploadFileMultiPartBodyParams$outboundSchema = exports.FilesApiRoutesUploadFileMultiPartBodyParams$inboundSchema = void 0;
    exports.filesApiRoutesUploadFileMultiPartBodyParamsToJSON = filesApiRoutesUploadFileMultiPartBodyParamsToJSON;
    exports.filesApiRoutesUploadFileMultiPartBodyParamsFromJSON = filesApiRoutesUploadFileMultiPartBodyParamsFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var blobs_js_1 = require_blobs();
    var components = __importStar(require_components());
    exports.FilesApiRoutesUploadFileMultiPartBodyParams$inboundSchema = z4.object({
      file: components.FileT$inboundSchema,
      purpose: components.FilePurpose$inboundSchema.optional()
    });
    exports.FilesApiRoutesUploadFileMultiPartBodyParams$outboundSchema = z4.object({
      file: components.FileT$outboundSchema.or(blobs_js_1.blobLikeSchema),
      purpose: components.FilePurpose$outboundSchema.optional()
    });
    var FilesApiRoutesUploadFileMultiPartBodyParams$;
    (function(FilesApiRoutesUploadFileMultiPartBodyParams$2) {
      FilesApiRoutesUploadFileMultiPartBodyParams$2.inboundSchema = exports.FilesApiRoutesUploadFileMultiPartBodyParams$inboundSchema;
      FilesApiRoutesUploadFileMultiPartBodyParams$2.outboundSchema = exports.FilesApiRoutesUploadFileMultiPartBodyParams$outboundSchema;
    })(FilesApiRoutesUploadFileMultiPartBodyParams$ || (exports.FilesApiRoutesUploadFileMultiPartBodyParams$ = FilesApiRoutesUploadFileMultiPartBodyParams$ = {}));
    function filesApiRoutesUploadFileMultiPartBodyParamsToJSON(filesApiRoutesUploadFileMultiPartBodyParams) {
      return JSON.stringify(exports.FilesApiRoutesUploadFileMultiPartBodyParams$outboundSchema.parse(filesApiRoutesUploadFileMultiPartBodyParams));
    }
    function filesApiRoutesUploadFileMultiPartBodyParamsFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.FilesApiRoutesUploadFileMultiPartBodyParams$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'FilesApiRoutesUploadFileMultiPartBodyParams' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/jobsapiroutesbatchcancelbatchjob.js
var require_jobsapiroutesbatchcancelbatchjob = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/jobsapiroutesbatchcancelbatchjob.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JobsApiRoutesBatchCancelBatchJobRequest$ = exports.JobsApiRoutesBatchCancelBatchJobRequest$outboundSchema = exports.JobsApiRoutesBatchCancelBatchJobRequest$inboundSchema = void 0;
    exports.jobsApiRoutesBatchCancelBatchJobRequestToJSON = jobsApiRoutesBatchCancelBatchJobRequestToJSON;
    exports.jobsApiRoutesBatchCancelBatchJobRequestFromJSON = jobsApiRoutesBatchCancelBatchJobRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.JobsApiRoutesBatchCancelBatchJobRequest$inboundSchema = z4.object({
      job_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "job_id": "jobId"
      });
    });
    exports.JobsApiRoutesBatchCancelBatchJobRequest$outboundSchema = z4.object({
      jobId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        jobId: "job_id"
      });
    });
    var JobsApiRoutesBatchCancelBatchJobRequest$;
    (function(JobsApiRoutesBatchCancelBatchJobRequest$2) {
      JobsApiRoutesBatchCancelBatchJobRequest$2.inboundSchema = exports.JobsApiRoutesBatchCancelBatchJobRequest$inboundSchema;
      JobsApiRoutesBatchCancelBatchJobRequest$2.outboundSchema = exports.JobsApiRoutesBatchCancelBatchJobRequest$outboundSchema;
    })(JobsApiRoutesBatchCancelBatchJobRequest$ || (exports.JobsApiRoutesBatchCancelBatchJobRequest$ = JobsApiRoutesBatchCancelBatchJobRequest$ = {}));
    function jobsApiRoutesBatchCancelBatchJobRequestToJSON(jobsApiRoutesBatchCancelBatchJobRequest) {
      return JSON.stringify(exports.JobsApiRoutesBatchCancelBatchJobRequest$outboundSchema.parse(jobsApiRoutesBatchCancelBatchJobRequest));
    }
    function jobsApiRoutesBatchCancelBatchJobRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.JobsApiRoutesBatchCancelBatchJobRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'JobsApiRoutesBatchCancelBatchJobRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/jobsapiroutesbatchgetbatchjob.js
var require_jobsapiroutesbatchgetbatchjob = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/jobsapiroutesbatchgetbatchjob.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JobsApiRoutesBatchGetBatchJobRequest$ = exports.JobsApiRoutesBatchGetBatchJobRequest$outboundSchema = exports.JobsApiRoutesBatchGetBatchJobRequest$inboundSchema = void 0;
    exports.jobsApiRoutesBatchGetBatchJobRequestToJSON = jobsApiRoutesBatchGetBatchJobRequestToJSON;
    exports.jobsApiRoutesBatchGetBatchJobRequestFromJSON = jobsApiRoutesBatchGetBatchJobRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.JobsApiRoutesBatchGetBatchJobRequest$inboundSchema = z4.object({
      job_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "job_id": "jobId"
      });
    });
    exports.JobsApiRoutesBatchGetBatchJobRequest$outboundSchema = z4.object({
      jobId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        jobId: "job_id"
      });
    });
    var JobsApiRoutesBatchGetBatchJobRequest$;
    (function(JobsApiRoutesBatchGetBatchJobRequest$2) {
      JobsApiRoutesBatchGetBatchJobRequest$2.inboundSchema = exports.JobsApiRoutesBatchGetBatchJobRequest$inboundSchema;
      JobsApiRoutesBatchGetBatchJobRequest$2.outboundSchema = exports.JobsApiRoutesBatchGetBatchJobRequest$outboundSchema;
    })(JobsApiRoutesBatchGetBatchJobRequest$ || (exports.JobsApiRoutesBatchGetBatchJobRequest$ = JobsApiRoutesBatchGetBatchJobRequest$ = {}));
    function jobsApiRoutesBatchGetBatchJobRequestToJSON(jobsApiRoutesBatchGetBatchJobRequest) {
      return JSON.stringify(exports.JobsApiRoutesBatchGetBatchJobRequest$outboundSchema.parse(jobsApiRoutesBatchGetBatchJobRequest));
    }
    function jobsApiRoutesBatchGetBatchJobRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.JobsApiRoutesBatchGetBatchJobRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'JobsApiRoutesBatchGetBatchJobRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/jobsapiroutesbatchgetbatchjobs.js
var require_jobsapiroutesbatchgetbatchjobs = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/jobsapiroutesbatchgetbatchjobs.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JobsApiRoutesBatchGetBatchJobsRequest$ = exports.JobsApiRoutesBatchGetBatchJobsRequest$outboundSchema = exports.JobsApiRoutesBatchGetBatchJobsRequest$inboundSchema = void 0;
    exports.jobsApiRoutesBatchGetBatchJobsRequestToJSON = jobsApiRoutesBatchGetBatchJobsRequestToJSON;
    exports.jobsApiRoutesBatchGetBatchJobsRequestFromJSON = jobsApiRoutesBatchGetBatchJobsRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var components = __importStar(require_components());
    exports.JobsApiRoutesBatchGetBatchJobsRequest$inboundSchema = z4.object({
      page: z4.number().int().default(0),
      page_size: z4.number().int().default(100),
      model: z4.nullable(z4.string()).optional(),
      agent_id: z4.nullable(z4.string()).optional(),
      metadata: z4.nullable(z4.record(z4.any())).optional(),
      created_after: z4.nullable(z4.string().datetime({ offset: true }).transform((v2) => new Date(v2))).optional(),
      created_by_me: z4.boolean().default(false),
      status: z4.nullable(z4.array(components.BatchJobStatus$inboundSchema)).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "page_size": "pageSize",
        "agent_id": "agentId",
        "created_after": "createdAfter",
        "created_by_me": "createdByMe"
      });
    });
    exports.JobsApiRoutesBatchGetBatchJobsRequest$outboundSchema = z4.object({
      page: z4.number().int().default(0),
      pageSize: z4.number().int().default(100),
      model: z4.nullable(z4.string()).optional(),
      agentId: z4.nullable(z4.string()).optional(),
      metadata: z4.nullable(z4.record(z4.any())).optional(),
      createdAfter: z4.nullable(z4.date().transform((v2) => v2.toISOString())).optional(),
      createdByMe: z4.boolean().default(false),
      status: z4.nullable(z4.array(components.BatchJobStatus$outboundSchema)).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        pageSize: "page_size",
        agentId: "agent_id",
        createdAfter: "created_after",
        createdByMe: "created_by_me"
      });
    });
    var JobsApiRoutesBatchGetBatchJobsRequest$;
    (function(JobsApiRoutesBatchGetBatchJobsRequest$2) {
      JobsApiRoutesBatchGetBatchJobsRequest$2.inboundSchema = exports.JobsApiRoutesBatchGetBatchJobsRequest$inboundSchema;
      JobsApiRoutesBatchGetBatchJobsRequest$2.outboundSchema = exports.JobsApiRoutesBatchGetBatchJobsRequest$outboundSchema;
    })(JobsApiRoutesBatchGetBatchJobsRequest$ || (exports.JobsApiRoutesBatchGetBatchJobsRequest$ = JobsApiRoutesBatchGetBatchJobsRequest$ = {}));
    function jobsApiRoutesBatchGetBatchJobsRequestToJSON(jobsApiRoutesBatchGetBatchJobsRequest) {
      return JSON.stringify(exports.JobsApiRoutesBatchGetBatchJobsRequest$outboundSchema.parse(jobsApiRoutesBatchGetBatchJobsRequest));
    }
    function jobsApiRoutesBatchGetBatchJobsRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.JobsApiRoutesBatchGetBatchJobsRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'JobsApiRoutesBatchGetBatchJobsRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/jobsapiroutesfinetuningarchivefinetunedmodel.js
var require_jobsapiroutesfinetuningarchivefinetunedmodel = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/jobsapiroutesfinetuningarchivefinetunedmodel.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$ = exports.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$outboundSchema = exports.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$inboundSchema = void 0;
    exports.jobsApiRoutesFineTuningArchiveFineTunedModelRequestToJSON = jobsApiRoutesFineTuningArchiveFineTunedModelRequestToJSON;
    exports.jobsApiRoutesFineTuningArchiveFineTunedModelRequestFromJSON = jobsApiRoutesFineTuningArchiveFineTunedModelRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$inboundSchema = z4.object({
      model_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "model_id": "modelId"
      });
    });
    exports.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$outboundSchema = z4.object({
      modelId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        modelId: "model_id"
      });
    });
    var JobsApiRoutesFineTuningArchiveFineTunedModelRequest$;
    (function(JobsApiRoutesFineTuningArchiveFineTunedModelRequest$2) {
      JobsApiRoutesFineTuningArchiveFineTunedModelRequest$2.inboundSchema = exports.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$inboundSchema;
      JobsApiRoutesFineTuningArchiveFineTunedModelRequest$2.outboundSchema = exports.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$outboundSchema;
    })(JobsApiRoutesFineTuningArchiveFineTunedModelRequest$ || (exports.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$ = JobsApiRoutesFineTuningArchiveFineTunedModelRequest$ = {}));
    function jobsApiRoutesFineTuningArchiveFineTunedModelRequestToJSON(jobsApiRoutesFineTuningArchiveFineTunedModelRequest) {
      return JSON.stringify(exports.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$outboundSchema.parse(jobsApiRoutesFineTuningArchiveFineTunedModelRequest));
    }
    function jobsApiRoutesFineTuningArchiveFineTunedModelRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'JobsApiRoutesFineTuningArchiveFineTunedModelRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/jobsapiroutesfinetuningcancelfinetuningjob.js
var require_jobsapiroutesfinetuningcancelfinetuningjob = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/jobsapiroutesfinetuningcancelfinetuningjob.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JobsApiRoutesFineTuningCancelFineTuningJobResponse$ = exports.JobsApiRoutesFineTuningCancelFineTuningJobResponse$outboundSchema = exports.JobsApiRoutesFineTuningCancelFineTuningJobResponse$inboundSchema = exports.JobsApiRoutesFineTuningCancelFineTuningJobRequest$ = exports.JobsApiRoutesFineTuningCancelFineTuningJobRequest$outboundSchema = exports.JobsApiRoutesFineTuningCancelFineTuningJobRequest$inboundSchema = void 0;
    exports.jobsApiRoutesFineTuningCancelFineTuningJobRequestToJSON = jobsApiRoutesFineTuningCancelFineTuningJobRequestToJSON;
    exports.jobsApiRoutesFineTuningCancelFineTuningJobRequestFromJSON = jobsApiRoutesFineTuningCancelFineTuningJobRequestFromJSON;
    exports.jobsApiRoutesFineTuningCancelFineTuningJobResponseToJSON = jobsApiRoutesFineTuningCancelFineTuningJobResponseToJSON;
    exports.jobsApiRoutesFineTuningCancelFineTuningJobResponseFromJSON = jobsApiRoutesFineTuningCancelFineTuningJobResponseFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var components = __importStar(require_components());
    exports.JobsApiRoutesFineTuningCancelFineTuningJobRequest$inboundSchema = z4.object({
      job_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "job_id": "jobId"
      });
    });
    exports.JobsApiRoutesFineTuningCancelFineTuningJobRequest$outboundSchema = z4.object({
      jobId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        jobId: "job_id"
      });
    });
    var JobsApiRoutesFineTuningCancelFineTuningJobRequest$;
    (function(JobsApiRoutesFineTuningCancelFineTuningJobRequest$2) {
      JobsApiRoutesFineTuningCancelFineTuningJobRequest$2.inboundSchema = exports.JobsApiRoutesFineTuningCancelFineTuningJobRequest$inboundSchema;
      JobsApiRoutesFineTuningCancelFineTuningJobRequest$2.outboundSchema = exports.JobsApiRoutesFineTuningCancelFineTuningJobRequest$outboundSchema;
    })(JobsApiRoutesFineTuningCancelFineTuningJobRequest$ || (exports.JobsApiRoutesFineTuningCancelFineTuningJobRequest$ = JobsApiRoutesFineTuningCancelFineTuningJobRequest$ = {}));
    function jobsApiRoutesFineTuningCancelFineTuningJobRequestToJSON(jobsApiRoutesFineTuningCancelFineTuningJobRequest) {
      return JSON.stringify(exports.JobsApiRoutesFineTuningCancelFineTuningJobRequest$outboundSchema.parse(jobsApiRoutesFineTuningCancelFineTuningJobRequest));
    }
    function jobsApiRoutesFineTuningCancelFineTuningJobRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.JobsApiRoutesFineTuningCancelFineTuningJobRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'JobsApiRoutesFineTuningCancelFineTuningJobRequest' from JSON`);
    }
    exports.JobsApiRoutesFineTuningCancelFineTuningJobResponse$inboundSchema = z4.union([
      components.ClassifierDetailedJobOut$inboundSchema.and(z4.object({ job_type: z4.literal("classifier") }).transform((v2) => ({
        jobType: v2.job_type
      }))),
      components.CompletionDetailedJobOut$inboundSchema.and(z4.object({ job_type: z4.literal("completion") }).transform((v2) => ({
        jobType: v2.job_type
      })))
    ]);
    exports.JobsApiRoutesFineTuningCancelFineTuningJobResponse$outboundSchema = z4.union([
      components.ClassifierDetailedJobOut$outboundSchema.and(z4.object({ jobType: z4.literal("classifier") }).transform((v2) => ({
        job_type: v2.jobType
      }))),
      components.CompletionDetailedJobOut$outboundSchema.and(z4.object({ jobType: z4.literal("completion") }).transform((v2) => ({
        job_type: v2.jobType
      })))
    ]);
    var JobsApiRoutesFineTuningCancelFineTuningJobResponse$;
    (function(JobsApiRoutesFineTuningCancelFineTuningJobResponse$2) {
      JobsApiRoutesFineTuningCancelFineTuningJobResponse$2.inboundSchema = exports.JobsApiRoutesFineTuningCancelFineTuningJobResponse$inboundSchema;
      JobsApiRoutesFineTuningCancelFineTuningJobResponse$2.outboundSchema = exports.JobsApiRoutesFineTuningCancelFineTuningJobResponse$outboundSchema;
    })(JobsApiRoutesFineTuningCancelFineTuningJobResponse$ || (exports.JobsApiRoutesFineTuningCancelFineTuningJobResponse$ = JobsApiRoutesFineTuningCancelFineTuningJobResponse$ = {}));
    function jobsApiRoutesFineTuningCancelFineTuningJobResponseToJSON(jobsApiRoutesFineTuningCancelFineTuningJobResponse) {
      return JSON.stringify(exports.JobsApiRoutesFineTuningCancelFineTuningJobResponse$outboundSchema.parse(jobsApiRoutesFineTuningCancelFineTuningJobResponse));
    }
    function jobsApiRoutesFineTuningCancelFineTuningJobResponseFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.JobsApiRoutesFineTuningCancelFineTuningJobResponse$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'JobsApiRoutesFineTuningCancelFineTuningJobResponse' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/jobsapiroutesfinetuningcreatefinetuningjob.js
var require_jobsapiroutesfinetuningcreatefinetuningjob = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/jobsapiroutesfinetuningcreatefinetuningjob.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JobsApiRoutesFineTuningCreateFineTuningJobResponse$ = exports.JobsApiRoutesFineTuningCreateFineTuningJobResponse$outboundSchema = exports.JobsApiRoutesFineTuningCreateFineTuningJobResponse$inboundSchema = exports.One$ = exports.One$outboundSchema = exports.One$inboundSchema = void 0;
    exports.oneToJSON = oneToJSON;
    exports.oneFromJSON = oneFromJSON;
    exports.jobsApiRoutesFineTuningCreateFineTuningJobResponseToJSON = jobsApiRoutesFineTuningCreateFineTuningJobResponseToJSON;
    exports.jobsApiRoutesFineTuningCreateFineTuningJobResponseFromJSON = jobsApiRoutesFineTuningCreateFineTuningJobResponseFromJSON;
    var z4 = __importStar(__require("zod"));
    var schemas_js_1 = require_schemas();
    var components = __importStar(require_components());
    exports.One$inboundSchema = z4.union([
      components.ClassifierJobOut$inboundSchema.and(z4.object({ job_type: z4.literal("classifier") }).transform((v2) => ({
        jobType: v2.job_type
      }))),
      components.CompletionJobOut$inboundSchema.and(z4.object({ job_type: z4.literal("completion") }).transform((v2) => ({
        jobType: v2.job_type
      })))
    ]);
    exports.One$outboundSchema = z4.union([
      components.ClassifierJobOut$outboundSchema.and(z4.object({ jobType: z4.literal("classifier") }).transform((v2) => ({
        job_type: v2.jobType
      }))),
      components.CompletionJobOut$outboundSchema.and(z4.object({ jobType: z4.literal("completion") }).transform((v2) => ({
        job_type: v2.jobType
      })))
    ]);
    var One$;
    (function(One$2) {
      One$2.inboundSchema = exports.One$inboundSchema;
      One$2.outboundSchema = exports.One$outboundSchema;
    })(One$ || (exports.One$ = One$ = {}));
    function oneToJSON(one) {
      return JSON.stringify(exports.One$outboundSchema.parse(one));
    }
    function oneFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.One$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'One' from JSON`);
    }
    exports.JobsApiRoutesFineTuningCreateFineTuningJobResponse$inboundSchema = z4.union([
      components.LegacyJobMetadataOut$inboundSchema,
      z4.union([
        components.ClassifierJobOut$inboundSchema.and(z4.object({ job_type: z4.literal("classifier") }).transform((v2) => ({
          jobType: v2.job_type
        }))),
        components.CompletionJobOut$inboundSchema.and(z4.object({ job_type: z4.literal("completion") }).transform((v2) => ({
          jobType: v2.job_type
        })))
      ])
    ]);
    exports.JobsApiRoutesFineTuningCreateFineTuningJobResponse$outboundSchema = z4.union([
      components.LegacyJobMetadataOut$outboundSchema,
      z4.union([
        components.ClassifierJobOut$outboundSchema.and(z4.object({ jobType: z4.literal("classifier") }).transform((v2) => ({
          job_type: v2.jobType
        }))),
        components.CompletionJobOut$outboundSchema.and(z4.object({ jobType: z4.literal("completion") }).transform((v2) => ({
          job_type: v2.jobType
        })))
      ])
    ]);
    var JobsApiRoutesFineTuningCreateFineTuningJobResponse$;
    (function(JobsApiRoutesFineTuningCreateFineTuningJobResponse$2) {
      JobsApiRoutesFineTuningCreateFineTuningJobResponse$2.inboundSchema = exports.JobsApiRoutesFineTuningCreateFineTuningJobResponse$inboundSchema;
      JobsApiRoutesFineTuningCreateFineTuningJobResponse$2.outboundSchema = exports.JobsApiRoutesFineTuningCreateFineTuningJobResponse$outboundSchema;
    })(JobsApiRoutesFineTuningCreateFineTuningJobResponse$ || (exports.JobsApiRoutesFineTuningCreateFineTuningJobResponse$ = JobsApiRoutesFineTuningCreateFineTuningJobResponse$ = {}));
    function jobsApiRoutesFineTuningCreateFineTuningJobResponseToJSON(jobsApiRoutesFineTuningCreateFineTuningJobResponse) {
      return JSON.stringify(exports.JobsApiRoutesFineTuningCreateFineTuningJobResponse$outboundSchema.parse(jobsApiRoutesFineTuningCreateFineTuningJobResponse));
    }
    function jobsApiRoutesFineTuningCreateFineTuningJobResponseFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.JobsApiRoutesFineTuningCreateFineTuningJobResponse$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'JobsApiRoutesFineTuningCreateFineTuningJobResponse' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/jobsapiroutesfinetuninggetfinetuningjob.js
var require_jobsapiroutesfinetuninggetfinetuningjob = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/jobsapiroutesfinetuninggetfinetuningjob.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JobsApiRoutesFineTuningGetFineTuningJobResponse$ = exports.JobsApiRoutesFineTuningGetFineTuningJobResponse$outboundSchema = exports.JobsApiRoutesFineTuningGetFineTuningJobResponse$inboundSchema = exports.JobsApiRoutesFineTuningGetFineTuningJobRequest$ = exports.JobsApiRoutesFineTuningGetFineTuningJobRequest$outboundSchema = exports.JobsApiRoutesFineTuningGetFineTuningJobRequest$inboundSchema = void 0;
    exports.jobsApiRoutesFineTuningGetFineTuningJobRequestToJSON = jobsApiRoutesFineTuningGetFineTuningJobRequestToJSON;
    exports.jobsApiRoutesFineTuningGetFineTuningJobRequestFromJSON = jobsApiRoutesFineTuningGetFineTuningJobRequestFromJSON;
    exports.jobsApiRoutesFineTuningGetFineTuningJobResponseToJSON = jobsApiRoutesFineTuningGetFineTuningJobResponseToJSON;
    exports.jobsApiRoutesFineTuningGetFineTuningJobResponseFromJSON = jobsApiRoutesFineTuningGetFineTuningJobResponseFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var components = __importStar(require_components());
    exports.JobsApiRoutesFineTuningGetFineTuningJobRequest$inboundSchema = z4.object({
      job_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "job_id": "jobId"
      });
    });
    exports.JobsApiRoutesFineTuningGetFineTuningJobRequest$outboundSchema = z4.object({
      jobId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        jobId: "job_id"
      });
    });
    var JobsApiRoutesFineTuningGetFineTuningJobRequest$;
    (function(JobsApiRoutesFineTuningGetFineTuningJobRequest$2) {
      JobsApiRoutesFineTuningGetFineTuningJobRequest$2.inboundSchema = exports.JobsApiRoutesFineTuningGetFineTuningJobRequest$inboundSchema;
      JobsApiRoutesFineTuningGetFineTuningJobRequest$2.outboundSchema = exports.JobsApiRoutesFineTuningGetFineTuningJobRequest$outboundSchema;
    })(JobsApiRoutesFineTuningGetFineTuningJobRequest$ || (exports.JobsApiRoutesFineTuningGetFineTuningJobRequest$ = JobsApiRoutesFineTuningGetFineTuningJobRequest$ = {}));
    function jobsApiRoutesFineTuningGetFineTuningJobRequestToJSON(jobsApiRoutesFineTuningGetFineTuningJobRequest) {
      return JSON.stringify(exports.JobsApiRoutesFineTuningGetFineTuningJobRequest$outboundSchema.parse(jobsApiRoutesFineTuningGetFineTuningJobRequest));
    }
    function jobsApiRoutesFineTuningGetFineTuningJobRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.JobsApiRoutesFineTuningGetFineTuningJobRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'JobsApiRoutesFineTuningGetFineTuningJobRequest' from JSON`);
    }
    exports.JobsApiRoutesFineTuningGetFineTuningJobResponse$inboundSchema = z4.union([
      components.ClassifierDetailedJobOut$inboundSchema.and(z4.object({ job_type: z4.literal("classifier") }).transform((v2) => ({
        jobType: v2.job_type
      }))),
      components.CompletionDetailedJobOut$inboundSchema.and(z4.object({ job_type: z4.literal("completion") }).transform((v2) => ({
        jobType: v2.job_type
      })))
    ]);
    exports.JobsApiRoutesFineTuningGetFineTuningJobResponse$outboundSchema = z4.union([
      components.ClassifierDetailedJobOut$outboundSchema.and(z4.object({ jobType: z4.literal("classifier") }).transform((v2) => ({
        job_type: v2.jobType
      }))),
      components.CompletionDetailedJobOut$outboundSchema.and(z4.object({ jobType: z4.literal("completion") }).transform((v2) => ({
        job_type: v2.jobType
      })))
    ]);
    var JobsApiRoutesFineTuningGetFineTuningJobResponse$;
    (function(JobsApiRoutesFineTuningGetFineTuningJobResponse$2) {
      JobsApiRoutesFineTuningGetFineTuningJobResponse$2.inboundSchema = exports.JobsApiRoutesFineTuningGetFineTuningJobResponse$inboundSchema;
      JobsApiRoutesFineTuningGetFineTuningJobResponse$2.outboundSchema = exports.JobsApiRoutesFineTuningGetFineTuningJobResponse$outboundSchema;
    })(JobsApiRoutesFineTuningGetFineTuningJobResponse$ || (exports.JobsApiRoutesFineTuningGetFineTuningJobResponse$ = JobsApiRoutesFineTuningGetFineTuningJobResponse$ = {}));
    function jobsApiRoutesFineTuningGetFineTuningJobResponseToJSON(jobsApiRoutesFineTuningGetFineTuningJobResponse) {
      return JSON.stringify(exports.JobsApiRoutesFineTuningGetFineTuningJobResponse$outboundSchema.parse(jobsApiRoutesFineTuningGetFineTuningJobResponse));
    }
    function jobsApiRoutesFineTuningGetFineTuningJobResponseFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.JobsApiRoutesFineTuningGetFineTuningJobResponse$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'JobsApiRoutesFineTuningGetFineTuningJobResponse' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/jobsapiroutesfinetuninggetfinetuningjobs.js
var require_jobsapiroutesfinetuninggetfinetuningjobs = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/jobsapiroutesfinetuninggetfinetuningjobs.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JobsApiRoutesFineTuningGetFineTuningJobsRequest$ = exports.JobsApiRoutesFineTuningGetFineTuningJobsRequest$outboundSchema = exports.JobsApiRoutesFineTuningGetFineTuningJobsRequest$inboundSchema = exports.Status$ = exports.Status$outboundSchema = exports.Status$inboundSchema = exports.Status = void 0;
    exports.jobsApiRoutesFineTuningGetFineTuningJobsRequestToJSON = jobsApiRoutesFineTuningGetFineTuningJobsRequestToJSON;
    exports.jobsApiRoutesFineTuningGetFineTuningJobsRequestFromJSON = jobsApiRoutesFineTuningGetFineTuningJobsRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.Status = {
      Queued: "QUEUED",
      Started: "STARTED",
      Validating: "VALIDATING",
      Validated: "VALIDATED",
      Running: "RUNNING",
      FailedValidation: "FAILED_VALIDATION",
      Failed: "FAILED",
      Success: "SUCCESS",
      Cancelled: "CANCELLED",
      CancellationRequested: "CANCELLATION_REQUESTED"
    };
    exports.Status$inboundSchema = z4.nativeEnum(exports.Status);
    exports.Status$outboundSchema = exports.Status$inboundSchema;
    var Status$;
    (function(Status$2) {
      Status$2.inboundSchema = exports.Status$inboundSchema;
      Status$2.outboundSchema = exports.Status$outboundSchema;
    })(Status$ || (exports.Status$ = Status$ = {}));
    exports.JobsApiRoutesFineTuningGetFineTuningJobsRequest$inboundSchema = z4.object({
      page: z4.number().int().default(0),
      page_size: z4.number().int().default(100),
      model: z4.nullable(z4.string()).optional(),
      created_after: z4.nullable(z4.string().datetime({ offset: true }).transform((v2) => new Date(v2))).optional(),
      created_before: z4.nullable(z4.string().datetime({ offset: true }).transform((v2) => new Date(v2))).optional(),
      created_by_me: z4.boolean().default(false),
      status: z4.nullable(exports.Status$inboundSchema).optional(),
      wandb_project: z4.nullable(z4.string()).optional(),
      wandb_name: z4.nullable(z4.string()).optional(),
      suffix: z4.nullable(z4.string()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "page_size": "pageSize",
        "created_after": "createdAfter",
        "created_before": "createdBefore",
        "created_by_me": "createdByMe",
        "wandb_project": "wandbProject",
        "wandb_name": "wandbName"
      });
    });
    exports.JobsApiRoutesFineTuningGetFineTuningJobsRequest$outboundSchema = z4.object({
      page: z4.number().int().default(0),
      pageSize: z4.number().int().default(100),
      model: z4.nullable(z4.string()).optional(),
      createdAfter: z4.nullable(z4.date().transform((v2) => v2.toISOString())).optional(),
      createdBefore: z4.nullable(z4.date().transform((v2) => v2.toISOString())).optional(),
      createdByMe: z4.boolean().default(false),
      status: z4.nullable(exports.Status$outboundSchema).optional(),
      wandbProject: z4.nullable(z4.string()).optional(),
      wandbName: z4.nullable(z4.string()).optional(),
      suffix: z4.nullable(z4.string()).optional()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        pageSize: "page_size",
        createdAfter: "created_after",
        createdBefore: "created_before",
        createdByMe: "created_by_me",
        wandbProject: "wandb_project",
        wandbName: "wandb_name"
      });
    });
    var JobsApiRoutesFineTuningGetFineTuningJobsRequest$;
    (function(JobsApiRoutesFineTuningGetFineTuningJobsRequest$2) {
      JobsApiRoutesFineTuningGetFineTuningJobsRequest$2.inboundSchema = exports.JobsApiRoutesFineTuningGetFineTuningJobsRequest$inboundSchema;
      JobsApiRoutesFineTuningGetFineTuningJobsRequest$2.outboundSchema = exports.JobsApiRoutesFineTuningGetFineTuningJobsRequest$outboundSchema;
    })(JobsApiRoutesFineTuningGetFineTuningJobsRequest$ || (exports.JobsApiRoutesFineTuningGetFineTuningJobsRequest$ = JobsApiRoutesFineTuningGetFineTuningJobsRequest$ = {}));
    function jobsApiRoutesFineTuningGetFineTuningJobsRequestToJSON(jobsApiRoutesFineTuningGetFineTuningJobsRequest) {
      return JSON.stringify(exports.JobsApiRoutesFineTuningGetFineTuningJobsRequest$outboundSchema.parse(jobsApiRoutesFineTuningGetFineTuningJobsRequest));
    }
    function jobsApiRoutesFineTuningGetFineTuningJobsRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.JobsApiRoutesFineTuningGetFineTuningJobsRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'JobsApiRoutesFineTuningGetFineTuningJobsRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/jobsapiroutesfinetuningstartfinetuningjob.js
var require_jobsapiroutesfinetuningstartfinetuningjob = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/jobsapiroutesfinetuningstartfinetuningjob.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JobsApiRoutesFineTuningStartFineTuningJobResponse$ = exports.JobsApiRoutesFineTuningStartFineTuningJobResponse$outboundSchema = exports.JobsApiRoutesFineTuningStartFineTuningJobResponse$inboundSchema = exports.JobsApiRoutesFineTuningStartFineTuningJobRequest$ = exports.JobsApiRoutesFineTuningStartFineTuningJobRequest$outboundSchema = exports.JobsApiRoutesFineTuningStartFineTuningJobRequest$inboundSchema = void 0;
    exports.jobsApiRoutesFineTuningStartFineTuningJobRequestToJSON = jobsApiRoutesFineTuningStartFineTuningJobRequestToJSON;
    exports.jobsApiRoutesFineTuningStartFineTuningJobRequestFromJSON = jobsApiRoutesFineTuningStartFineTuningJobRequestFromJSON;
    exports.jobsApiRoutesFineTuningStartFineTuningJobResponseToJSON = jobsApiRoutesFineTuningStartFineTuningJobResponseToJSON;
    exports.jobsApiRoutesFineTuningStartFineTuningJobResponseFromJSON = jobsApiRoutesFineTuningStartFineTuningJobResponseFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var components = __importStar(require_components());
    exports.JobsApiRoutesFineTuningStartFineTuningJobRequest$inboundSchema = z4.object({
      job_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "job_id": "jobId"
      });
    });
    exports.JobsApiRoutesFineTuningStartFineTuningJobRequest$outboundSchema = z4.object({
      jobId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        jobId: "job_id"
      });
    });
    var JobsApiRoutesFineTuningStartFineTuningJobRequest$;
    (function(JobsApiRoutesFineTuningStartFineTuningJobRequest$2) {
      JobsApiRoutesFineTuningStartFineTuningJobRequest$2.inboundSchema = exports.JobsApiRoutesFineTuningStartFineTuningJobRequest$inboundSchema;
      JobsApiRoutesFineTuningStartFineTuningJobRequest$2.outboundSchema = exports.JobsApiRoutesFineTuningStartFineTuningJobRequest$outboundSchema;
    })(JobsApiRoutesFineTuningStartFineTuningJobRequest$ || (exports.JobsApiRoutesFineTuningStartFineTuningJobRequest$ = JobsApiRoutesFineTuningStartFineTuningJobRequest$ = {}));
    function jobsApiRoutesFineTuningStartFineTuningJobRequestToJSON(jobsApiRoutesFineTuningStartFineTuningJobRequest) {
      return JSON.stringify(exports.JobsApiRoutesFineTuningStartFineTuningJobRequest$outboundSchema.parse(jobsApiRoutesFineTuningStartFineTuningJobRequest));
    }
    function jobsApiRoutesFineTuningStartFineTuningJobRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.JobsApiRoutesFineTuningStartFineTuningJobRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'JobsApiRoutesFineTuningStartFineTuningJobRequest' from JSON`);
    }
    exports.JobsApiRoutesFineTuningStartFineTuningJobResponse$inboundSchema = z4.union([
      components.ClassifierDetailedJobOut$inboundSchema.and(z4.object({ job_type: z4.literal("classifier") }).transform((v2) => ({
        jobType: v2.job_type
      }))),
      components.CompletionDetailedJobOut$inboundSchema.and(z4.object({ job_type: z4.literal("completion") }).transform((v2) => ({
        jobType: v2.job_type
      })))
    ]);
    exports.JobsApiRoutesFineTuningStartFineTuningJobResponse$outboundSchema = z4.union([
      components.ClassifierDetailedJobOut$outboundSchema.and(z4.object({ jobType: z4.literal("classifier") }).transform((v2) => ({
        job_type: v2.jobType
      }))),
      components.CompletionDetailedJobOut$outboundSchema.and(z4.object({ jobType: z4.literal("completion") }).transform((v2) => ({
        job_type: v2.jobType
      })))
    ]);
    var JobsApiRoutesFineTuningStartFineTuningJobResponse$;
    (function(JobsApiRoutesFineTuningStartFineTuningJobResponse$2) {
      JobsApiRoutesFineTuningStartFineTuningJobResponse$2.inboundSchema = exports.JobsApiRoutesFineTuningStartFineTuningJobResponse$inboundSchema;
      JobsApiRoutesFineTuningStartFineTuningJobResponse$2.outboundSchema = exports.JobsApiRoutesFineTuningStartFineTuningJobResponse$outboundSchema;
    })(JobsApiRoutesFineTuningStartFineTuningJobResponse$ || (exports.JobsApiRoutesFineTuningStartFineTuningJobResponse$ = JobsApiRoutesFineTuningStartFineTuningJobResponse$ = {}));
    function jobsApiRoutesFineTuningStartFineTuningJobResponseToJSON(jobsApiRoutesFineTuningStartFineTuningJobResponse) {
      return JSON.stringify(exports.JobsApiRoutesFineTuningStartFineTuningJobResponse$outboundSchema.parse(jobsApiRoutesFineTuningStartFineTuningJobResponse));
    }
    function jobsApiRoutesFineTuningStartFineTuningJobResponseFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.JobsApiRoutesFineTuningStartFineTuningJobResponse$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'JobsApiRoutesFineTuningStartFineTuningJobResponse' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/jobsapiroutesfinetuningunarchivefinetunedmodel.js
var require_jobsapiroutesfinetuningunarchivefinetunedmodel = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/jobsapiroutesfinetuningunarchivefinetunedmodel.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$ = exports.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$outboundSchema = exports.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$inboundSchema = void 0;
    exports.jobsApiRoutesFineTuningUnarchiveFineTunedModelRequestToJSON = jobsApiRoutesFineTuningUnarchiveFineTunedModelRequestToJSON;
    exports.jobsApiRoutesFineTuningUnarchiveFineTunedModelRequestFromJSON = jobsApiRoutesFineTuningUnarchiveFineTunedModelRequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$inboundSchema = z4.object({
      model_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "model_id": "modelId"
      });
    });
    exports.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$outboundSchema = z4.object({
      modelId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        modelId: "model_id"
      });
    });
    var JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$;
    (function(JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$2) {
      JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$2.inboundSchema = exports.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$inboundSchema;
      JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$2.outboundSchema = exports.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$outboundSchema;
    })(JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$ || (exports.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$ = JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$ = {}));
    function jobsApiRoutesFineTuningUnarchiveFineTunedModelRequestToJSON(jobsApiRoutesFineTuningUnarchiveFineTunedModelRequest) {
      return JSON.stringify(exports.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$outboundSchema.parse(jobsApiRoutesFineTuningUnarchiveFineTunedModelRequest));
    }
    function jobsApiRoutesFineTuningUnarchiveFineTunedModelRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/jobsapiroutesfinetuningupdatefinetunedmodel.js
var require_jobsapiroutesfinetuningupdatefinetunedmodel = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/jobsapiroutesfinetuningupdatefinetunedmodel.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JobsApiRoutesFineTuningUpdateFineTunedModelResponse$ = exports.JobsApiRoutesFineTuningUpdateFineTunedModelResponse$outboundSchema = exports.JobsApiRoutesFineTuningUpdateFineTunedModelResponse$inboundSchema = exports.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$ = exports.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$outboundSchema = exports.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$inboundSchema = void 0;
    exports.jobsApiRoutesFineTuningUpdateFineTunedModelRequestToJSON = jobsApiRoutesFineTuningUpdateFineTunedModelRequestToJSON;
    exports.jobsApiRoutesFineTuningUpdateFineTunedModelRequestFromJSON = jobsApiRoutesFineTuningUpdateFineTunedModelRequestFromJSON;
    exports.jobsApiRoutesFineTuningUpdateFineTunedModelResponseToJSON = jobsApiRoutesFineTuningUpdateFineTunedModelResponseToJSON;
    exports.jobsApiRoutesFineTuningUpdateFineTunedModelResponseFromJSON = jobsApiRoutesFineTuningUpdateFineTunedModelResponseFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var components = __importStar(require_components());
    exports.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$inboundSchema = z4.object({
      model_id: z4.string(),
      UpdateFTModelIn: components.UpdateFTModelIn$inboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "model_id": "modelId",
        "UpdateFTModelIn": "updateFTModelIn"
      });
    });
    exports.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$outboundSchema = z4.object({
      modelId: z4.string(),
      updateFTModelIn: components.UpdateFTModelIn$outboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        modelId: "model_id",
        updateFTModelIn: "UpdateFTModelIn"
      });
    });
    var JobsApiRoutesFineTuningUpdateFineTunedModelRequest$;
    (function(JobsApiRoutesFineTuningUpdateFineTunedModelRequest$2) {
      JobsApiRoutesFineTuningUpdateFineTunedModelRequest$2.inboundSchema = exports.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$inboundSchema;
      JobsApiRoutesFineTuningUpdateFineTunedModelRequest$2.outboundSchema = exports.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$outboundSchema;
    })(JobsApiRoutesFineTuningUpdateFineTunedModelRequest$ || (exports.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$ = JobsApiRoutesFineTuningUpdateFineTunedModelRequest$ = {}));
    function jobsApiRoutesFineTuningUpdateFineTunedModelRequestToJSON(jobsApiRoutesFineTuningUpdateFineTunedModelRequest) {
      return JSON.stringify(exports.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$outboundSchema.parse(jobsApiRoutesFineTuningUpdateFineTunedModelRequest));
    }
    function jobsApiRoutesFineTuningUpdateFineTunedModelRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'JobsApiRoutesFineTuningUpdateFineTunedModelRequest' from JSON`);
    }
    exports.JobsApiRoutesFineTuningUpdateFineTunedModelResponse$inboundSchema = z4.union([
      components.CompletionFTModelOut$inboundSchema.and(z4.object({ model_type: z4.literal("completion") }).transform((v2) => ({
        modelType: v2.model_type
      }))),
      components.ClassifierFTModelOut$inboundSchema.and(z4.object({ model_type: z4.literal("classifier") }).transform((v2) => ({
        modelType: v2.model_type
      })))
    ]);
    exports.JobsApiRoutesFineTuningUpdateFineTunedModelResponse$outboundSchema = z4.union([
      components.CompletionFTModelOut$outboundSchema.and(z4.object({ modelType: z4.literal("completion") }).transform((v2) => ({
        model_type: v2.modelType
      }))),
      components.ClassifierFTModelOut$outboundSchema.and(z4.object({ modelType: z4.literal("classifier") }).transform((v2) => ({
        model_type: v2.modelType
      })))
    ]);
    var JobsApiRoutesFineTuningUpdateFineTunedModelResponse$;
    (function(JobsApiRoutesFineTuningUpdateFineTunedModelResponse$2) {
      JobsApiRoutesFineTuningUpdateFineTunedModelResponse$2.inboundSchema = exports.JobsApiRoutesFineTuningUpdateFineTunedModelResponse$inboundSchema;
      JobsApiRoutesFineTuningUpdateFineTunedModelResponse$2.outboundSchema = exports.JobsApiRoutesFineTuningUpdateFineTunedModelResponse$outboundSchema;
    })(JobsApiRoutesFineTuningUpdateFineTunedModelResponse$ || (exports.JobsApiRoutesFineTuningUpdateFineTunedModelResponse$ = JobsApiRoutesFineTuningUpdateFineTunedModelResponse$ = {}));
    function jobsApiRoutesFineTuningUpdateFineTunedModelResponseToJSON(jobsApiRoutesFineTuningUpdateFineTunedModelResponse) {
      return JSON.stringify(exports.JobsApiRoutesFineTuningUpdateFineTunedModelResponse$outboundSchema.parse(jobsApiRoutesFineTuningUpdateFineTunedModelResponse));
    }
    function jobsApiRoutesFineTuningUpdateFineTunedModelResponseFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.JobsApiRoutesFineTuningUpdateFineTunedModelResponse$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'JobsApiRoutesFineTuningUpdateFineTunedModelResponse' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/librariesdeletev1.js
var require_librariesdeletev1 = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/librariesdeletev1.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LibrariesDeleteV1Request$ = exports.LibrariesDeleteV1Request$outboundSchema = exports.LibrariesDeleteV1Request$inboundSchema = void 0;
    exports.librariesDeleteV1RequestToJSON = librariesDeleteV1RequestToJSON;
    exports.librariesDeleteV1RequestFromJSON = librariesDeleteV1RequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.LibrariesDeleteV1Request$inboundSchema = z4.object({
      library_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "library_id": "libraryId"
      });
    });
    exports.LibrariesDeleteV1Request$outboundSchema = z4.object({
      libraryId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        libraryId: "library_id"
      });
    });
    var LibrariesDeleteV1Request$;
    (function(LibrariesDeleteV1Request$2) {
      LibrariesDeleteV1Request$2.inboundSchema = exports.LibrariesDeleteV1Request$inboundSchema;
      LibrariesDeleteV1Request$2.outboundSchema = exports.LibrariesDeleteV1Request$outboundSchema;
    })(LibrariesDeleteV1Request$ || (exports.LibrariesDeleteV1Request$ = LibrariesDeleteV1Request$ = {}));
    function librariesDeleteV1RequestToJSON(librariesDeleteV1Request) {
      return JSON.stringify(exports.LibrariesDeleteV1Request$outboundSchema.parse(librariesDeleteV1Request));
    }
    function librariesDeleteV1RequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.LibrariesDeleteV1Request$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'LibrariesDeleteV1Request' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/librariesdocumentsdeletev1.js
var require_librariesdocumentsdeletev1 = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/librariesdocumentsdeletev1.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LibrariesDocumentsDeleteV1Request$ = exports.LibrariesDocumentsDeleteV1Request$outboundSchema = exports.LibrariesDocumentsDeleteV1Request$inboundSchema = void 0;
    exports.librariesDocumentsDeleteV1RequestToJSON = librariesDocumentsDeleteV1RequestToJSON;
    exports.librariesDocumentsDeleteV1RequestFromJSON = librariesDocumentsDeleteV1RequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.LibrariesDocumentsDeleteV1Request$inboundSchema = z4.object({
      library_id: z4.string(),
      document_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "library_id": "libraryId",
        "document_id": "documentId"
      });
    });
    exports.LibrariesDocumentsDeleteV1Request$outboundSchema = z4.object({
      libraryId: z4.string(),
      documentId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        libraryId: "library_id",
        documentId: "document_id"
      });
    });
    var LibrariesDocumentsDeleteV1Request$;
    (function(LibrariesDocumentsDeleteV1Request$2) {
      LibrariesDocumentsDeleteV1Request$2.inboundSchema = exports.LibrariesDocumentsDeleteV1Request$inboundSchema;
      LibrariesDocumentsDeleteV1Request$2.outboundSchema = exports.LibrariesDocumentsDeleteV1Request$outboundSchema;
    })(LibrariesDocumentsDeleteV1Request$ || (exports.LibrariesDocumentsDeleteV1Request$ = LibrariesDocumentsDeleteV1Request$ = {}));
    function librariesDocumentsDeleteV1RequestToJSON(librariesDocumentsDeleteV1Request) {
      return JSON.stringify(exports.LibrariesDocumentsDeleteV1Request$outboundSchema.parse(librariesDocumentsDeleteV1Request));
    }
    function librariesDocumentsDeleteV1RequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.LibrariesDocumentsDeleteV1Request$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'LibrariesDocumentsDeleteV1Request' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/librariesdocumentsgetextractedtextsignedurlv1.js
var require_librariesdocumentsgetextractedtextsignedurlv1 = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/librariesdocumentsgetextractedtextsignedurlv1.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LibrariesDocumentsGetExtractedTextSignedUrlV1Request$ = exports.LibrariesDocumentsGetExtractedTextSignedUrlV1Request$outboundSchema = exports.LibrariesDocumentsGetExtractedTextSignedUrlV1Request$inboundSchema = void 0;
    exports.librariesDocumentsGetExtractedTextSignedUrlV1RequestToJSON = librariesDocumentsGetExtractedTextSignedUrlV1RequestToJSON;
    exports.librariesDocumentsGetExtractedTextSignedUrlV1RequestFromJSON = librariesDocumentsGetExtractedTextSignedUrlV1RequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.LibrariesDocumentsGetExtractedTextSignedUrlV1Request$inboundSchema = z4.object({
      library_id: z4.string(),
      document_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "library_id": "libraryId",
        "document_id": "documentId"
      });
    });
    exports.LibrariesDocumentsGetExtractedTextSignedUrlV1Request$outboundSchema = z4.object({
      libraryId: z4.string(),
      documentId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        libraryId: "library_id",
        documentId: "document_id"
      });
    });
    var LibrariesDocumentsGetExtractedTextSignedUrlV1Request$;
    (function(LibrariesDocumentsGetExtractedTextSignedUrlV1Request$2) {
      LibrariesDocumentsGetExtractedTextSignedUrlV1Request$2.inboundSchema = exports.LibrariesDocumentsGetExtractedTextSignedUrlV1Request$inboundSchema;
      LibrariesDocumentsGetExtractedTextSignedUrlV1Request$2.outboundSchema = exports.LibrariesDocumentsGetExtractedTextSignedUrlV1Request$outboundSchema;
    })(LibrariesDocumentsGetExtractedTextSignedUrlV1Request$ || (exports.LibrariesDocumentsGetExtractedTextSignedUrlV1Request$ = LibrariesDocumentsGetExtractedTextSignedUrlV1Request$ = {}));
    function librariesDocumentsGetExtractedTextSignedUrlV1RequestToJSON(librariesDocumentsGetExtractedTextSignedUrlV1Request) {
      return JSON.stringify(exports.LibrariesDocumentsGetExtractedTextSignedUrlV1Request$outboundSchema.parse(librariesDocumentsGetExtractedTextSignedUrlV1Request));
    }
    function librariesDocumentsGetExtractedTextSignedUrlV1RequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.LibrariesDocumentsGetExtractedTextSignedUrlV1Request$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'LibrariesDocumentsGetExtractedTextSignedUrlV1Request' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/librariesdocumentsgetsignedurlv1.js
var require_librariesdocumentsgetsignedurlv1 = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/librariesdocumentsgetsignedurlv1.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LibrariesDocumentsGetSignedUrlV1Request$ = exports.LibrariesDocumentsGetSignedUrlV1Request$outboundSchema = exports.LibrariesDocumentsGetSignedUrlV1Request$inboundSchema = void 0;
    exports.librariesDocumentsGetSignedUrlV1RequestToJSON = librariesDocumentsGetSignedUrlV1RequestToJSON;
    exports.librariesDocumentsGetSignedUrlV1RequestFromJSON = librariesDocumentsGetSignedUrlV1RequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.LibrariesDocumentsGetSignedUrlV1Request$inboundSchema = z4.object({
      library_id: z4.string(),
      document_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "library_id": "libraryId",
        "document_id": "documentId"
      });
    });
    exports.LibrariesDocumentsGetSignedUrlV1Request$outboundSchema = z4.object({
      libraryId: z4.string(),
      documentId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        libraryId: "library_id",
        documentId: "document_id"
      });
    });
    var LibrariesDocumentsGetSignedUrlV1Request$;
    (function(LibrariesDocumentsGetSignedUrlV1Request$2) {
      LibrariesDocumentsGetSignedUrlV1Request$2.inboundSchema = exports.LibrariesDocumentsGetSignedUrlV1Request$inboundSchema;
      LibrariesDocumentsGetSignedUrlV1Request$2.outboundSchema = exports.LibrariesDocumentsGetSignedUrlV1Request$outboundSchema;
    })(LibrariesDocumentsGetSignedUrlV1Request$ || (exports.LibrariesDocumentsGetSignedUrlV1Request$ = LibrariesDocumentsGetSignedUrlV1Request$ = {}));
    function librariesDocumentsGetSignedUrlV1RequestToJSON(librariesDocumentsGetSignedUrlV1Request) {
      return JSON.stringify(exports.LibrariesDocumentsGetSignedUrlV1Request$outboundSchema.parse(librariesDocumentsGetSignedUrlV1Request));
    }
    function librariesDocumentsGetSignedUrlV1RequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.LibrariesDocumentsGetSignedUrlV1Request$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'LibrariesDocumentsGetSignedUrlV1Request' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/librariesdocumentsgetstatusv1.js
var require_librariesdocumentsgetstatusv1 = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/librariesdocumentsgetstatusv1.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LibrariesDocumentsGetStatusV1Request$ = exports.LibrariesDocumentsGetStatusV1Request$outboundSchema = exports.LibrariesDocumentsGetStatusV1Request$inboundSchema = void 0;
    exports.librariesDocumentsGetStatusV1RequestToJSON = librariesDocumentsGetStatusV1RequestToJSON;
    exports.librariesDocumentsGetStatusV1RequestFromJSON = librariesDocumentsGetStatusV1RequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.LibrariesDocumentsGetStatusV1Request$inboundSchema = z4.object({
      library_id: z4.string(),
      document_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "library_id": "libraryId",
        "document_id": "documentId"
      });
    });
    exports.LibrariesDocumentsGetStatusV1Request$outboundSchema = z4.object({
      libraryId: z4.string(),
      documentId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        libraryId: "library_id",
        documentId: "document_id"
      });
    });
    var LibrariesDocumentsGetStatusV1Request$;
    (function(LibrariesDocumentsGetStatusV1Request$2) {
      LibrariesDocumentsGetStatusV1Request$2.inboundSchema = exports.LibrariesDocumentsGetStatusV1Request$inboundSchema;
      LibrariesDocumentsGetStatusV1Request$2.outboundSchema = exports.LibrariesDocumentsGetStatusV1Request$outboundSchema;
    })(LibrariesDocumentsGetStatusV1Request$ || (exports.LibrariesDocumentsGetStatusV1Request$ = LibrariesDocumentsGetStatusV1Request$ = {}));
    function librariesDocumentsGetStatusV1RequestToJSON(librariesDocumentsGetStatusV1Request) {
      return JSON.stringify(exports.LibrariesDocumentsGetStatusV1Request$outboundSchema.parse(librariesDocumentsGetStatusV1Request));
    }
    function librariesDocumentsGetStatusV1RequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.LibrariesDocumentsGetStatusV1Request$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'LibrariesDocumentsGetStatusV1Request' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/librariesdocumentsgettextcontentv1.js
var require_librariesdocumentsgettextcontentv1 = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/librariesdocumentsgettextcontentv1.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LibrariesDocumentsGetTextContentV1Request$ = exports.LibrariesDocumentsGetTextContentV1Request$outboundSchema = exports.LibrariesDocumentsGetTextContentV1Request$inboundSchema = void 0;
    exports.librariesDocumentsGetTextContentV1RequestToJSON = librariesDocumentsGetTextContentV1RequestToJSON;
    exports.librariesDocumentsGetTextContentV1RequestFromJSON = librariesDocumentsGetTextContentV1RequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.LibrariesDocumentsGetTextContentV1Request$inboundSchema = z4.object({
      library_id: z4.string(),
      document_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "library_id": "libraryId",
        "document_id": "documentId"
      });
    });
    exports.LibrariesDocumentsGetTextContentV1Request$outboundSchema = z4.object({
      libraryId: z4.string(),
      documentId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        libraryId: "library_id",
        documentId: "document_id"
      });
    });
    var LibrariesDocumentsGetTextContentV1Request$;
    (function(LibrariesDocumentsGetTextContentV1Request$2) {
      LibrariesDocumentsGetTextContentV1Request$2.inboundSchema = exports.LibrariesDocumentsGetTextContentV1Request$inboundSchema;
      LibrariesDocumentsGetTextContentV1Request$2.outboundSchema = exports.LibrariesDocumentsGetTextContentV1Request$outboundSchema;
    })(LibrariesDocumentsGetTextContentV1Request$ || (exports.LibrariesDocumentsGetTextContentV1Request$ = LibrariesDocumentsGetTextContentV1Request$ = {}));
    function librariesDocumentsGetTextContentV1RequestToJSON(librariesDocumentsGetTextContentV1Request) {
      return JSON.stringify(exports.LibrariesDocumentsGetTextContentV1Request$outboundSchema.parse(librariesDocumentsGetTextContentV1Request));
    }
    function librariesDocumentsGetTextContentV1RequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.LibrariesDocumentsGetTextContentV1Request$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'LibrariesDocumentsGetTextContentV1Request' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/librariesdocumentsgetv1.js
var require_librariesdocumentsgetv1 = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/librariesdocumentsgetv1.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LibrariesDocumentsGetV1Request$ = exports.LibrariesDocumentsGetV1Request$outboundSchema = exports.LibrariesDocumentsGetV1Request$inboundSchema = void 0;
    exports.librariesDocumentsGetV1RequestToJSON = librariesDocumentsGetV1RequestToJSON;
    exports.librariesDocumentsGetV1RequestFromJSON = librariesDocumentsGetV1RequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.LibrariesDocumentsGetV1Request$inboundSchema = z4.object({
      library_id: z4.string(),
      document_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "library_id": "libraryId",
        "document_id": "documentId"
      });
    });
    exports.LibrariesDocumentsGetV1Request$outboundSchema = z4.object({
      libraryId: z4.string(),
      documentId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        libraryId: "library_id",
        documentId: "document_id"
      });
    });
    var LibrariesDocumentsGetV1Request$;
    (function(LibrariesDocumentsGetV1Request$2) {
      LibrariesDocumentsGetV1Request$2.inboundSchema = exports.LibrariesDocumentsGetV1Request$inboundSchema;
      LibrariesDocumentsGetV1Request$2.outboundSchema = exports.LibrariesDocumentsGetV1Request$outboundSchema;
    })(LibrariesDocumentsGetV1Request$ || (exports.LibrariesDocumentsGetV1Request$ = LibrariesDocumentsGetV1Request$ = {}));
    function librariesDocumentsGetV1RequestToJSON(librariesDocumentsGetV1Request) {
      return JSON.stringify(exports.LibrariesDocumentsGetV1Request$outboundSchema.parse(librariesDocumentsGetV1Request));
    }
    function librariesDocumentsGetV1RequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.LibrariesDocumentsGetV1Request$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'LibrariesDocumentsGetV1Request' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/librariesdocumentslistv1.js
var require_librariesdocumentslistv1 = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/librariesdocumentslistv1.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LibrariesDocumentsListV1Request$ = exports.LibrariesDocumentsListV1Request$outboundSchema = exports.LibrariesDocumentsListV1Request$inboundSchema = void 0;
    exports.librariesDocumentsListV1RequestToJSON = librariesDocumentsListV1RequestToJSON;
    exports.librariesDocumentsListV1RequestFromJSON = librariesDocumentsListV1RequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.LibrariesDocumentsListV1Request$inboundSchema = z4.object({
      library_id: z4.string(),
      search: z4.nullable(z4.string()).optional(),
      page_size: z4.number().int().default(100),
      page: z4.number().int().default(0),
      sort_by: z4.string().default("created_at"),
      sort_order: z4.string().default("desc")
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "library_id": "libraryId",
        "page_size": "pageSize",
        "sort_by": "sortBy",
        "sort_order": "sortOrder"
      });
    });
    exports.LibrariesDocumentsListV1Request$outboundSchema = z4.object({
      libraryId: z4.string(),
      search: z4.nullable(z4.string()).optional(),
      pageSize: z4.number().int().default(100),
      page: z4.number().int().default(0),
      sortBy: z4.string().default("created_at"),
      sortOrder: z4.string().default("desc")
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        libraryId: "library_id",
        pageSize: "page_size",
        sortBy: "sort_by",
        sortOrder: "sort_order"
      });
    });
    var LibrariesDocumentsListV1Request$;
    (function(LibrariesDocumentsListV1Request$2) {
      LibrariesDocumentsListV1Request$2.inboundSchema = exports.LibrariesDocumentsListV1Request$inboundSchema;
      LibrariesDocumentsListV1Request$2.outboundSchema = exports.LibrariesDocumentsListV1Request$outboundSchema;
    })(LibrariesDocumentsListV1Request$ || (exports.LibrariesDocumentsListV1Request$ = LibrariesDocumentsListV1Request$ = {}));
    function librariesDocumentsListV1RequestToJSON(librariesDocumentsListV1Request) {
      return JSON.stringify(exports.LibrariesDocumentsListV1Request$outboundSchema.parse(librariesDocumentsListV1Request));
    }
    function librariesDocumentsListV1RequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.LibrariesDocumentsListV1Request$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'LibrariesDocumentsListV1Request' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/librariesdocumentsreprocessv1.js
var require_librariesdocumentsreprocessv1 = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/librariesdocumentsreprocessv1.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LibrariesDocumentsReprocessV1Request$ = exports.LibrariesDocumentsReprocessV1Request$outboundSchema = exports.LibrariesDocumentsReprocessV1Request$inboundSchema = void 0;
    exports.librariesDocumentsReprocessV1RequestToJSON = librariesDocumentsReprocessV1RequestToJSON;
    exports.librariesDocumentsReprocessV1RequestFromJSON = librariesDocumentsReprocessV1RequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.LibrariesDocumentsReprocessV1Request$inboundSchema = z4.object({
      library_id: z4.string(),
      document_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "library_id": "libraryId",
        "document_id": "documentId"
      });
    });
    exports.LibrariesDocumentsReprocessV1Request$outboundSchema = z4.object({
      libraryId: z4.string(),
      documentId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        libraryId: "library_id",
        documentId: "document_id"
      });
    });
    var LibrariesDocumentsReprocessV1Request$;
    (function(LibrariesDocumentsReprocessV1Request$2) {
      LibrariesDocumentsReprocessV1Request$2.inboundSchema = exports.LibrariesDocumentsReprocessV1Request$inboundSchema;
      LibrariesDocumentsReprocessV1Request$2.outboundSchema = exports.LibrariesDocumentsReprocessV1Request$outboundSchema;
    })(LibrariesDocumentsReprocessV1Request$ || (exports.LibrariesDocumentsReprocessV1Request$ = LibrariesDocumentsReprocessV1Request$ = {}));
    function librariesDocumentsReprocessV1RequestToJSON(librariesDocumentsReprocessV1Request) {
      return JSON.stringify(exports.LibrariesDocumentsReprocessV1Request$outboundSchema.parse(librariesDocumentsReprocessV1Request));
    }
    function librariesDocumentsReprocessV1RequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.LibrariesDocumentsReprocessV1Request$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'LibrariesDocumentsReprocessV1Request' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/librariesdocumentsupdatev1.js
var require_librariesdocumentsupdatev1 = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/librariesdocumentsupdatev1.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LibrariesDocumentsUpdateV1Request$ = exports.LibrariesDocumentsUpdateV1Request$outboundSchema = exports.LibrariesDocumentsUpdateV1Request$inboundSchema = void 0;
    exports.librariesDocumentsUpdateV1RequestToJSON = librariesDocumentsUpdateV1RequestToJSON;
    exports.librariesDocumentsUpdateV1RequestFromJSON = librariesDocumentsUpdateV1RequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var components = __importStar(require_components());
    exports.LibrariesDocumentsUpdateV1Request$inboundSchema = z4.object({
      library_id: z4.string(),
      document_id: z4.string(),
      DocumentUpdateIn: components.DocumentUpdateIn$inboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "library_id": "libraryId",
        "document_id": "documentId",
        "DocumentUpdateIn": "documentUpdateIn"
      });
    });
    exports.LibrariesDocumentsUpdateV1Request$outboundSchema = z4.object({
      libraryId: z4.string(),
      documentId: z4.string(),
      documentUpdateIn: components.DocumentUpdateIn$outboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        libraryId: "library_id",
        documentId: "document_id",
        documentUpdateIn: "DocumentUpdateIn"
      });
    });
    var LibrariesDocumentsUpdateV1Request$;
    (function(LibrariesDocumentsUpdateV1Request$2) {
      LibrariesDocumentsUpdateV1Request$2.inboundSchema = exports.LibrariesDocumentsUpdateV1Request$inboundSchema;
      LibrariesDocumentsUpdateV1Request$2.outboundSchema = exports.LibrariesDocumentsUpdateV1Request$outboundSchema;
    })(LibrariesDocumentsUpdateV1Request$ || (exports.LibrariesDocumentsUpdateV1Request$ = LibrariesDocumentsUpdateV1Request$ = {}));
    function librariesDocumentsUpdateV1RequestToJSON(librariesDocumentsUpdateV1Request) {
      return JSON.stringify(exports.LibrariesDocumentsUpdateV1Request$outboundSchema.parse(librariesDocumentsUpdateV1Request));
    }
    function librariesDocumentsUpdateV1RequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.LibrariesDocumentsUpdateV1Request$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'LibrariesDocumentsUpdateV1Request' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/librariesdocumentsuploadv1.js
var require_librariesdocumentsuploadv1 = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/librariesdocumentsuploadv1.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LibrariesDocumentsUploadV1Request$ = exports.LibrariesDocumentsUploadV1Request$outboundSchema = exports.LibrariesDocumentsUploadV1Request$inboundSchema = exports.LibrariesDocumentsUploadV1DocumentUpload$ = exports.LibrariesDocumentsUploadV1DocumentUpload$outboundSchema = exports.LibrariesDocumentsUploadV1DocumentUpload$inboundSchema = void 0;
    exports.librariesDocumentsUploadV1DocumentUploadToJSON = librariesDocumentsUploadV1DocumentUploadToJSON;
    exports.librariesDocumentsUploadV1DocumentUploadFromJSON = librariesDocumentsUploadV1DocumentUploadFromJSON;
    exports.librariesDocumentsUploadV1RequestToJSON = librariesDocumentsUploadV1RequestToJSON;
    exports.librariesDocumentsUploadV1RequestFromJSON = librariesDocumentsUploadV1RequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var blobs_js_1 = require_blobs();
    var components = __importStar(require_components());
    exports.LibrariesDocumentsUploadV1DocumentUpload$inboundSchema = z4.object({
      file: components.FileT$inboundSchema
    });
    exports.LibrariesDocumentsUploadV1DocumentUpload$outboundSchema = z4.object({
      file: components.FileT$outboundSchema.or(blobs_js_1.blobLikeSchema)
    });
    var LibrariesDocumentsUploadV1DocumentUpload$;
    (function(LibrariesDocumentsUploadV1DocumentUpload$2) {
      LibrariesDocumentsUploadV1DocumentUpload$2.inboundSchema = exports.LibrariesDocumentsUploadV1DocumentUpload$inboundSchema;
      LibrariesDocumentsUploadV1DocumentUpload$2.outboundSchema = exports.LibrariesDocumentsUploadV1DocumentUpload$outboundSchema;
    })(LibrariesDocumentsUploadV1DocumentUpload$ || (exports.LibrariesDocumentsUploadV1DocumentUpload$ = LibrariesDocumentsUploadV1DocumentUpload$ = {}));
    function librariesDocumentsUploadV1DocumentUploadToJSON(librariesDocumentsUploadV1DocumentUpload) {
      return JSON.stringify(exports.LibrariesDocumentsUploadV1DocumentUpload$outboundSchema.parse(librariesDocumentsUploadV1DocumentUpload));
    }
    function librariesDocumentsUploadV1DocumentUploadFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.LibrariesDocumentsUploadV1DocumentUpload$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'LibrariesDocumentsUploadV1DocumentUpload' from JSON`);
    }
    exports.LibrariesDocumentsUploadV1Request$inboundSchema = z4.object({
      library_id: z4.string(),
      RequestBody: z4.lazy(() => exports.LibrariesDocumentsUploadV1DocumentUpload$inboundSchema)
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "library_id": "libraryId",
        "RequestBody": "requestBody"
      });
    });
    exports.LibrariesDocumentsUploadV1Request$outboundSchema = z4.object({
      libraryId: z4.string(),
      requestBody: z4.lazy(() => exports.LibrariesDocumentsUploadV1DocumentUpload$outboundSchema)
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        libraryId: "library_id",
        requestBody: "RequestBody"
      });
    });
    var LibrariesDocumentsUploadV1Request$;
    (function(LibrariesDocumentsUploadV1Request$2) {
      LibrariesDocumentsUploadV1Request$2.inboundSchema = exports.LibrariesDocumentsUploadV1Request$inboundSchema;
      LibrariesDocumentsUploadV1Request$2.outboundSchema = exports.LibrariesDocumentsUploadV1Request$outboundSchema;
    })(LibrariesDocumentsUploadV1Request$ || (exports.LibrariesDocumentsUploadV1Request$ = LibrariesDocumentsUploadV1Request$ = {}));
    function librariesDocumentsUploadV1RequestToJSON(librariesDocumentsUploadV1Request) {
      return JSON.stringify(exports.LibrariesDocumentsUploadV1Request$outboundSchema.parse(librariesDocumentsUploadV1Request));
    }
    function librariesDocumentsUploadV1RequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.LibrariesDocumentsUploadV1Request$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'LibrariesDocumentsUploadV1Request' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/librariesgetv1.js
var require_librariesgetv1 = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/librariesgetv1.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LibrariesGetV1Request$ = exports.LibrariesGetV1Request$outboundSchema = exports.LibrariesGetV1Request$inboundSchema = void 0;
    exports.librariesGetV1RequestToJSON = librariesGetV1RequestToJSON;
    exports.librariesGetV1RequestFromJSON = librariesGetV1RequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.LibrariesGetV1Request$inboundSchema = z4.object({
      library_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "library_id": "libraryId"
      });
    });
    exports.LibrariesGetV1Request$outboundSchema = z4.object({
      libraryId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        libraryId: "library_id"
      });
    });
    var LibrariesGetV1Request$;
    (function(LibrariesGetV1Request$2) {
      LibrariesGetV1Request$2.inboundSchema = exports.LibrariesGetV1Request$inboundSchema;
      LibrariesGetV1Request$2.outboundSchema = exports.LibrariesGetV1Request$outboundSchema;
    })(LibrariesGetV1Request$ || (exports.LibrariesGetV1Request$ = LibrariesGetV1Request$ = {}));
    function librariesGetV1RequestToJSON(librariesGetV1Request) {
      return JSON.stringify(exports.LibrariesGetV1Request$outboundSchema.parse(librariesGetV1Request));
    }
    function librariesGetV1RequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.LibrariesGetV1Request$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'LibrariesGetV1Request' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/librariessharecreatev1.js
var require_librariessharecreatev1 = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/librariessharecreatev1.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LibrariesShareCreateV1Request$ = exports.LibrariesShareCreateV1Request$outboundSchema = exports.LibrariesShareCreateV1Request$inboundSchema = void 0;
    exports.librariesShareCreateV1RequestToJSON = librariesShareCreateV1RequestToJSON;
    exports.librariesShareCreateV1RequestFromJSON = librariesShareCreateV1RequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var components = __importStar(require_components());
    exports.LibrariesShareCreateV1Request$inboundSchema = z4.object({
      library_id: z4.string(),
      SharingIn: components.SharingIn$inboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "library_id": "libraryId",
        "SharingIn": "sharingIn"
      });
    });
    exports.LibrariesShareCreateV1Request$outboundSchema = z4.object({
      libraryId: z4.string(),
      sharingIn: components.SharingIn$outboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        libraryId: "library_id",
        sharingIn: "SharingIn"
      });
    });
    var LibrariesShareCreateV1Request$;
    (function(LibrariesShareCreateV1Request$2) {
      LibrariesShareCreateV1Request$2.inboundSchema = exports.LibrariesShareCreateV1Request$inboundSchema;
      LibrariesShareCreateV1Request$2.outboundSchema = exports.LibrariesShareCreateV1Request$outboundSchema;
    })(LibrariesShareCreateV1Request$ || (exports.LibrariesShareCreateV1Request$ = LibrariesShareCreateV1Request$ = {}));
    function librariesShareCreateV1RequestToJSON(librariesShareCreateV1Request) {
      return JSON.stringify(exports.LibrariesShareCreateV1Request$outboundSchema.parse(librariesShareCreateV1Request));
    }
    function librariesShareCreateV1RequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.LibrariesShareCreateV1Request$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'LibrariesShareCreateV1Request' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/librariessharedeletev1.js
var require_librariessharedeletev1 = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/librariessharedeletev1.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LibrariesShareDeleteV1Request$ = exports.LibrariesShareDeleteV1Request$outboundSchema = exports.LibrariesShareDeleteV1Request$inboundSchema = void 0;
    exports.librariesShareDeleteV1RequestToJSON = librariesShareDeleteV1RequestToJSON;
    exports.librariesShareDeleteV1RequestFromJSON = librariesShareDeleteV1RequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var components = __importStar(require_components());
    exports.LibrariesShareDeleteV1Request$inboundSchema = z4.object({
      library_id: z4.string(),
      SharingDelete: components.SharingDelete$inboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "library_id": "libraryId",
        "SharingDelete": "sharingDelete"
      });
    });
    exports.LibrariesShareDeleteV1Request$outboundSchema = z4.object({
      libraryId: z4.string(),
      sharingDelete: components.SharingDelete$outboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        libraryId: "library_id",
        sharingDelete: "SharingDelete"
      });
    });
    var LibrariesShareDeleteV1Request$;
    (function(LibrariesShareDeleteV1Request$2) {
      LibrariesShareDeleteV1Request$2.inboundSchema = exports.LibrariesShareDeleteV1Request$inboundSchema;
      LibrariesShareDeleteV1Request$2.outboundSchema = exports.LibrariesShareDeleteV1Request$outboundSchema;
    })(LibrariesShareDeleteV1Request$ || (exports.LibrariesShareDeleteV1Request$ = LibrariesShareDeleteV1Request$ = {}));
    function librariesShareDeleteV1RequestToJSON(librariesShareDeleteV1Request) {
      return JSON.stringify(exports.LibrariesShareDeleteV1Request$outboundSchema.parse(librariesShareDeleteV1Request));
    }
    function librariesShareDeleteV1RequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.LibrariesShareDeleteV1Request$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'LibrariesShareDeleteV1Request' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/librariessharelistv1.js
var require_librariessharelistv1 = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/librariessharelistv1.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LibrariesShareListV1Request$ = exports.LibrariesShareListV1Request$outboundSchema = exports.LibrariesShareListV1Request$inboundSchema = void 0;
    exports.librariesShareListV1RequestToJSON = librariesShareListV1RequestToJSON;
    exports.librariesShareListV1RequestFromJSON = librariesShareListV1RequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    exports.LibrariesShareListV1Request$inboundSchema = z4.object({
      library_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "library_id": "libraryId"
      });
    });
    exports.LibrariesShareListV1Request$outboundSchema = z4.object({
      libraryId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        libraryId: "library_id"
      });
    });
    var LibrariesShareListV1Request$;
    (function(LibrariesShareListV1Request$2) {
      LibrariesShareListV1Request$2.inboundSchema = exports.LibrariesShareListV1Request$inboundSchema;
      LibrariesShareListV1Request$2.outboundSchema = exports.LibrariesShareListV1Request$outboundSchema;
    })(LibrariesShareListV1Request$ || (exports.LibrariesShareListV1Request$ = LibrariesShareListV1Request$ = {}));
    function librariesShareListV1RequestToJSON(librariesShareListV1Request) {
      return JSON.stringify(exports.LibrariesShareListV1Request$outboundSchema.parse(librariesShareListV1Request));
    }
    function librariesShareListV1RequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.LibrariesShareListV1Request$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'LibrariesShareListV1Request' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/librariesupdatev1.js
var require_librariesupdatev1 = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/librariesupdatev1.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LibrariesUpdateV1Request$ = exports.LibrariesUpdateV1Request$outboundSchema = exports.LibrariesUpdateV1Request$inboundSchema = void 0;
    exports.librariesUpdateV1RequestToJSON = librariesUpdateV1RequestToJSON;
    exports.librariesUpdateV1RequestFromJSON = librariesUpdateV1RequestFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var components = __importStar(require_components());
    exports.LibrariesUpdateV1Request$inboundSchema = z4.object({
      library_id: z4.string(),
      LibraryInUpdate: components.LibraryInUpdate$inboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "library_id": "libraryId",
        "LibraryInUpdate": "libraryInUpdate"
      });
    });
    exports.LibrariesUpdateV1Request$outboundSchema = z4.object({
      libraryId: z4.string(),
      libraryInUpdate: components.LibraryInUpdate$outboundSchema
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        libraryId: "library_id",
        libraryInUpdate: "LibraryInUpdate"
      });
    });
    var LibrariesUpdateV1Request$;
    (function(LibrariesUpdateV1Request$2) {
      LibrariesUpdateV1Request$2.inboundSchema = exports.LibrariesUpdateV1Request$inboundSchema;
      LibrariesUpdateV1Request$2.outboundSchema = exports.LibrariesUpdateV1Request$outboundSchema;
    })(LibrariesUpdateV1Request$ || (exports.LibrariesUpdateV1Request$ = LibrariesUpdateV1Request$ = {}));
    function librariesUpdateV1RequestToJSON(librariesUpdateV1Request) {
      return JSON.stringify(exports.LibrariesUpdateV1Request$outboundSchema.parse(librariesUpdateV1Request));
    }
    function librariesUpdateV1RequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.LibrariesUpdateV1Request$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'LibrariesUpdateV1Request' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/retrievemodelv1modelsmodelidget.js
var require_retrievemodelv1modelsmodelidget = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/retrievemodelv1modelsmodelidget.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$ = exports.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$outboundSchema = exports.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$inboundSchema = exports.RetrieveModelV1ModelsModelIdGetRequest$ = exports.RetrieveModelV1ModelsModelIdGetRequest$outboundSchema = exports.RetrieveModelV1ModelsModelIdGetRequest$inboundSchema = void 0;
    exports.retrieveModelV1ModelsModelIdGetRequestToJSON = retrieveModelV1ModelsModelIdGetRequestToJSON;
    exports.retrieveModelV1ModelsModelIdGetRequestFromJSON = retrieveModelV1ModelsModelIdGetRequestFromJSON;
    exports.retrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGetToJSON = retrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGetToJSON;
    exports.retrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGetFromJSON = retrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGetFromJSON;
    var z4 = __importStar(__require("zod"));
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var components = __importStar(require_components());
    exports.RetrieveModelV1ModelsModelIdGetRequest$inboundSchema = z4.object({
      model_id: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        "model_id": "modelId"
      });
    });
    exports.RetrieveModelV1ModelsModelIdGetRequest$outboundSchema = z4.object({
      modelId: z4.string()
    }).transform((v2) => {
      return (0, primitives_js_1.remap)(v2, {
        modelId: "model_id"
      });
    });
    var RetrieveModelV1ModelsModelIdGetRequest$;
    (function(RetrieveModelV1ModelsModelIdGetRequest$2) {
      RetrieveModelV1ModelsModelIdGetRequest$2.inboundSchema = exports.RetrieveModelV1ModelsModelIdGetRequest$inboundSchema;
      RetrieveModelV1ModelsModelIdGetRequest$2.outboundSchema = exports.RetrieveModelV1ModelsModelIdGetRequest$outboundSchema;
    })(RetrieveModelV1ModelsModelIdGetRequest$ || (exports.RetrieveModelV1ModelsModelIdGetRequest$ = RetrieveModelV1ModelsModelIdGetRequest$ = {}));
    function retrieveModelV1ModelsModelIdGetRequestToJSON(retrieveModelV1ModelsModelIdGetRequest) {
      return JSON.stringify(exports.RetrieveModelV1ModelsModelIdGetRequest$outboundSchema.parse(retrieveModelV1ModelsModelIdGetRequest));
    }
    function retrieveModelV1ModelsModelIdGetRequestFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.RetrieveModelV1ModelsModelIdGetRequest$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'RetrieveModelV1ModelsModelIdGetRequest' from JSON`);
    }
    exports.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$inboundSchema = z4.union([
      components.BaseModelCard$inboundSchema.and(z4.object({ type: z4.literal("base") }).transform((v2) => ({
        type: v2.type
      }))),
      components.FTModelCard$inboundSchema.and(z4.object({ type: z4.literal("fine-tuned") }).transform((v2) => ({
        type: v2.type
      })))
    ]);
    exports.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$outboundSchema = z4.union([
      components.BaseModelCard$outboundSchema.and(z4.object({ type: z4.literal("base") }).transform((v2) => ({
        type: v2.type
      }))),
      components.FTModelCard$outboundSchema.and(z4.object({ type: z4.literal("fine-tuned") }).transform((v2) => ({
        type: v2.type
      })))
    ]);
    var RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$;
    (function(RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$2) {
      RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$2.inboundSchema = exports.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$inboundSchema;
      RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$2.outboundSchema = exports.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$outboundSchema;
    })(RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$ || (exports.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$ = RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$ = {}));
    function retrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGetToJSON(retrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet) {
      return JSON.stringify(exports.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$outboundSchema.parse(retrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet));
    }
    function retrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGetFromJSON(jsonString) {
      return (0, schemas_js_1.safeParse)(jsonString, (x2) => exports.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$inboundSchema.parse(JSON.parse(x2)), `Failed to parse 'RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet' from JSON`);
    }
  }
});

// ../node_modules/@mistralai/mistralai/models/operations/index.js
var require_operations = __commonJS({
  "../node_modules/@mistralai/mistralai/models/operations/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_agentsapiv1agentsget(), exports);
    __exportStar(require_agentsapiv1agentslist(), exports);
    __exportStar(require_agentsapiv1agentsupdate(), exports);
    __exportStar(require_agentsapiv1agentsupdateversion(), exports);
    __exportStar(require_agentsapiv1conversationsappend(), exports);
    __exportStar(require_agentsapiv1conversationsappendstream(), exports);
    __exportStar(require_agentsapiv1conversationsget(), exports);
    __exportStar(require_agentsapiv1conversationshistory(), exports);
    __exportStar(require_agentsapiv1conversationslist(), exports);
    __exportStar(require_agentsapiv1conversationsmessages(), exports);
    __exportStar(require_agentsapiv1conversationsrestart(), exports);
    __exportStar(require_agentsapiv1conversationsrestartstream(), exports);
    __exportStar(require_deletemodelv1modelsmodeliddelete(), exports);
    __exportStar(require_filesapiroutesdeletefile(), exports);
    __exportStar(require_filesapiroutesdownloadfile(), exports);
    __exportStar(require_filesapiroutesgetsignedurl(), exports);
    __exportStar(require_filesapirouteslistfiles(), exports);
    __exportStar(require_filesapiroutesretrievefile(), exports);
    __exportStar(require_filesapiroutesuploadfile(), exports);
    __exportStar(require_jobsapiroutesbatchcancelbatchjob(), exports);
    __exportStar(require_jobsapiroutesbatchgetbatchjob(), exports);
    __exportStar(require_jobsapiroutesbatchgetbatchjobs(), exports);
    __exportStar(require_jobsapiroutesfinetuningarchivefinetunedmodel(), exports);
    __exportStar(require_jobsapiroutesfinetuningcancelfinetuningjob(), exports);
    __exportStar(require_jobsapiroutesfinetuningcreatefinetuningjob(), exports);
    __exportStar(require_jobsapiroutesfinetuninggetfinetuningjob(), exports);
    __exportStar(require_jobsapiroutesfinetuninggetfinetuningjobs(), exports);
    __exportStar(require_jobsapiroutesfinetuningstartfinetuningjob(), exports);
    __exportStar(require_jobsapiroutesfinetuningunarchivefinetunedmodel(), exports);
    __exportStar(require_jobsapiroutesfinetuningupdatefinetunedmodel(), exports);
    __exportStar(require_librariesdeletev1(), exports);
    __exportStar(require_librariesdocumentsdeletev1(), exports);
    __exportStar(require_librariesdocumentsgetextractedtextsignedurlv1(), exports);
    __exportStar(require_librariesdocumentsgetsignedurlv1(), exports);
    __exportStar(require_librariesdocumentsgetstatusv1(), exports);
    __exportStar(require_librariesdocumentsgettextcontentv1(), exports);
    __exportStar(require_librariesdocumentsgetv1(), exports);
    __exportStar(require_librariesdocumentslistv1(), exports);
    __exportStar(require_librariesdocumentsreprocessv1(), exports);
    __exportStar(require_librariesdocumentsupdatev1(), exports);
    __exportStar(require_librariesdocumentsuploadv1(), exports);
    __exportStar(require_librariesgetv1(), exports);
    __exportStar(require_librariessharecreatev1(), exports);
    __exportStar(require_librariessharedeletev1(), exports);
    __exportStar(require_librariessharelistv1(), exports);
    __exportStar(require_librariesupdatev1(), exports);
    __exportStar(require_retrievemodelv1modelsmodelidget(), exports);
  }
});

// ../node_modules/@mistralai/mistralai/funcs/batchJobsCancel.js
var require_batchJobsCancel = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/batchJobsCancel.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.batchJobsCancel = batchJobsCancel;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function batchJobsCancel(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.JobsApiRoutesBatchCancelBatchJobRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const pathParams = {
        job_id: (0, encodings_js_1.encodeSimple)("job_id", payload.job_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/batch/jobs/{job_id}/cancel")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "jobs_api_routes_batch_cancel_batch_job",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const [result] = await M2.match(M2.json(200, components.BatchJobOut$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response);
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/batchJobsCreate.js
var require_batchJobsCreate = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/batchJobsCreate.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.batchJobsCreate = batchJobsCreate;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var async_js_1 = require_async();
    function batchJobsCreate(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => components.BatchJobIn$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = (0, encodings_js_1.encodeJSON)("body", payload, { explode: true });
      const path2 = (0, url_js_1.pathToFunc)("/v1/batch/jobs")();
      const headers = new Headers((0, primitives_js_1.compactMap)({
        "Content-Type": "application/json",
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "jobs_api_routes_batch_create_batch_job",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const [result] = await M2.match(M2.json(200, components.BatchJobOut$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response);
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/batchJobsGet.js
var require_batchJobsGet = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/batchJobsGet.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.batchJobsGet = batchJobsGet;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function batchJobsGet(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.JobsApiRoutesBatchGetBatchJobRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const pathParams = {
        job_id: (0, encodings_js_1.encodeSimple)("job_id", payload.job_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/batch/jobs/{job_id}")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "jobs_api_routes_batch_get_batch_job",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "GET",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const [result] = await M2.match(M2.json(200, components.BatchJobOut$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response);
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/batchJobsList.js
var require_batchJobsList = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/batchJobsList.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.batchJobsList = batchJobsList;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function batchJobsList(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.JobsApiRoutesBatchGetBatchJobsRequest$outboundSchema.optional().parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const path2 = (0, url_js_1.pathToFunc)("/v1/batch/jobs")();
      const query = (0, encodings_js_1.encodeFormQuery)({
        "agent_id": payload?.agent_id,
        "created_after": payload?.created_after,
        "created_by_me": payload?.created_by_me,
        "metadata": payload?.metadata,
        "model": payload?.model,
        "page": payload?.page,
        "page_size": payload?.page_size,
        "status": payload?.status
      });
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "jobs_api_routes_batch_get_batch_jobs",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "GET",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        query,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const [result] = await M2.match(M2.json(200, components.BatchJobsOut$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response);
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/sdk/mistraljobs.js
var require_mistraljobs = __commonJS({
  "../node_modules/@mistralai/mistralai/sdk/mistraljobs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MistralJobs = void 0;
    var batchJobsCancel_js_1 = require_batchJobsCancel();
    var batchJobsCreate_js_1 = require_batchJobsCreate();
    var batchJobsGet_js_1 = require_batchJobsGet();
    var batchJobsList_js_1 = require_batchJobsList();
    var sdks_js_1 = require_sdks();
    var fp_js_1 = require_fp();
    var MistralJobs = class extends sdks_js_1.ClientSDK {
      /**
       * Get Batch Jobs
       *
       * @remarks
       * Get a list of batch jobs for your organization and user.
       */
      async list(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, batchJobsList_js_1.batchJobsList)(this, request, options));
      }
      /**
       * Create Batch Job
       *
       * @remarks
       * Create a new batch job, it will be queued for processing.
       */
      async create(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, batchJobsCreate_js_1.batchJobsCreate)(this, request, options));
      }
      /**
       * Get Batch Job
       *
       * @remarks
       * Get a batch job details by its UUID.
       */
      async get(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, batchJobsGet_js_1.batchJobsGet)(this, request, options));
      }
      /**
       * Cancel Batch Job
       *
       * @remarks
       * Request the cancellation of a batch job.
       */
      async cancel(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, batchJobsCancel_js_1.batchJobsCancel)(this, request, options));
      }
    };
    exports.MistralJobs = MistralJobs;
  }
});

// ../node_modules/@mistralai/mistralai/sdk/batch.js
var require_batch = __commonJS({
  "../node_modules/@mistralai/mistralai/sdk/batch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Batch = void 0;
    var sdks_js_1 = require_sdks();
    var mistraljobs_js_1 = require_mistraljobs();
    var Batch = class extends sdks_js_1.ClientSDK {
      get jobs() {
        return this._jobs ?? (this._jobs = new mistraljobs_js_1.MistralJobs(this._options));
      }
    };
    exports.Batch = Batch;
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaConversationsAppend.js
var require_betaConversationsAppend = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaConversationsAppend.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaConversationsAppend = betaConversationsAppend;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function betaConversationsAppend(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.AgentsApiV1ConversationsAppendRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = (0, encodings_js_1.encodeJSON)("body", payload.ConversationAppendRequest, {
        explode: true
      });
      const pathParams = {
        conversation_id: (0, encodings_js_1.encodeSimple)("conversation_id", payload.conversation_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/conversations/{conversation_id}")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        "Content-Type": "application/json",
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "agents_api_v1_conversations_append",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.ConversationResponse$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaConversationsAppendStream.js
var require_betaConversationsAppendStream = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaConversationsAppendStream.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaConversationsAppendStream = betaConversationsAppendStream;
    var z4 = __importStar(__require("zod"));
    var encodings_js_1 = require_encodings();
    var event_streams_js_1 = require_event_streams();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function betaConversationsAppendStream(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.AgentsApiV1ConversationsAppendStreamRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = (0, encodings_js_1.encodeJSON)("body", payload.ConversationAppendStreamRequest, {
        explode: true
      });
      const pathParams = {
        conversation_id: (0, encodings_js_1.encodeSimple)("conversation_id", payload.conversation_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/conversations/{conversation_id}#stream")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        "Content-Type": "application/json",
        Accept: "text/event-stream"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "agents_api_v1_conversations_append_stream",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.sse(200, z4.instanceof(ReadableStream).transform((stream) => {
        return new event_streams_js_1.EventStream({
          stream,
          decoder(rawEvent) {
            const schema = components.ConversationEvents$inboundSchema;
            return schema.parse(rawEvent);
          }
        });
      })), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaConversationsGet.js
var require_betaConversationsGet = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaConversationsGet.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaConversationsGet = betaConversationsGet;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var errors = __importStar(require_errors());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function betaConversationsGet(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.AgentsApiV1ConversationsGetRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const pathParams = {
        conversation_id: (0, encodings_js_1.encodeSimple)("conversation_id", payload.conversation_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/conversations/{conversation_id}")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "agents_api_v1_conversations_get",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "GET",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, operations.AgentsApiV1ConversationsGetResponseV1ConversationsGet$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaConversationsGetHistory.js
var require_betaConversationsGetHistory = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaConversationsGetHistory.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaConversationsGetHistory = betaConversationsGetHistory;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function betaConversationsGetHistory(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.AgentsApiV1ConversationsHistoryRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const pathParams = {
        conversation_id: (0, encodings_js_1.encodeSimple)("conversation_id", payload.conversation_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/conversations/{conversation_id}/history")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "agents_api_v1_conversations_history",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "GET",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.ConversationHistory$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaConversationsGetMessages.js
var require_betaConversationsGetMessages = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaConversationsGetMessages.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaConversationsGetMessages = betaConversationsGetMessages;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function betaConversationsGetMessages(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.AgentsApiV1ConversationsMessagesRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const pathParams = {
        conversation_id: (0, encodings_js_1.encodeSimple)("conversation_id", payload.conversation_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/conversations/{conversation_id}/messages")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "agents_api_v1_conversations_messages",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "GET",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.ConversationMessages$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaConversationsList.js
var require_betaConversationsList = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaConversationsList.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaConversationsList = betaConversationsList;
    var z4 = __importStar(__require("zod"));
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var errors = __importStar(require_errors());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function betaConversationsList(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.AgentsApiV1ConversationsListRequest$outboundSchema.optional().parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const path2 = (0, url_js_1.pathToFunc)("/v1/conversations")();
      const query = (0, encodings_js_1.encodeFormQuery)({
        "page": payload?.page,
        "page_size": payload?.page_size
      });
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "agents_api_v1_conversations_list",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "GET",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        query,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, z4.array(operations.ResponseBody$inboundSchema)), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaConversationsRestart.js
var require_betaConversationsRestart = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaConversationsRestart.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaConversationsRestart = betaConversationsRestart;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function betaConversationsRestart(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.AgentsApiV1ConversationsRestartRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = (0, encodings_js_1.encodeJSON)("body", payload.ConversationRestartRequest, {
        explode: true
      });
      const pathParams = {
        conversation_id: (0, encodings_js_1.encodeSimple)("conversation_id", payload.conversation_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/conversations/{conversation_id}/restart")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        "Content-Type": "application/json",
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "agents_api_v1_conversations_restart",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.ConversationResponse$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaConversationsRestartStream.js
var require_betaConversationsRestartStream = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaConversationsRestartStream.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaConversationsRestartStream = betaConversationsRestartStream;
    var z4 = __importStar(__require("zod"));
    var encodings_js_1 = require_encodings();
    var event_streams_js_1 = require_event_streams();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function betaConversationsRestartStream(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.AgentsApiV1ConversationsRestartStreamRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = (0, encodings_js_1.encodeJSON)("body", payload.ConversationRestartStreamRequest, {
        explode: true
      });
      const pathParams = {
        conversation_id: (0, encodings_js_1.encodeSimple)("conversation_id", payload.conversation_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/conversations/{conversation_id}/restart#stream")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        "Content-Type": "application/json",
        Accept: "text/event-stream"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "agents_api_v1_conversations_restart_stream",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.sse(200, z4.instanceof(ReadableStream).transform((stream) => {
        return new event_streams_js_1.EventStream({
          stream,
          decoder(rawEvent) {
            const schema = components.ConversationEvents$inboundSchema;
            return schema.parse(rawEvent);
          }
        });
      })), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaConversationsStart.js
var require_betaConversationsStart = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaConversationsStart.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaConversationsStart = betaConversationsStart;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var async_js_1 = require_async();
    function betaConversationsStart(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => components.ConversationRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = (0, encodings_js_1.encodeJSON)("body", payload, { explode: true });
      const path2 = (0, url_js_1.pathToFunc)("/v1/conversations")();
      const headers = new Headers((0, primitives_js_1.compactMap)({
        "Content-Type": "application/json",
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "agents_api_v1_conversations_start",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.ConversationResponse$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaConversationsStartStream.js
var require_betaConversationsStartStream = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaConversationsStartStream.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaConversationsStartStream = betaConversationsStartStream;
    var z4 = __importStar(__require("zod"));
    var encodings_js_1 = require_encodings();
    var event_streams_js_1 = require_event_streams();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var async_js_1 = require_async();
    function betaConversationsStartStream(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => components.ConversationStreamRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = (0, encodings_js_1.encodeJSON)("body", payload, { explode: true });
      const path2 = (0, url_js_1.pathToFunc)("/v1/conversations#stream")();
      const headers = new Headers((0, primitives_js_1.compactMap)({
        "Content-Type": "application/json",
        Accept: "text/event-stream"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "agents_api_v1_conversations_start_stream",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.sse(200, z4.instanceof(ReadableStream).transform((stream) => {
        return new event_streams_js_1.EventStream({
          stream,
          decoder(rawEvent) {
            const schema = components.ConversationEvents$inboundSchema;
            return schema.parse(rawEvent);
          }
        });
      })), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/sdk/conversations.js
var require_conversations = __commonJS({
  "../node_modules/@mistralai/mistralai/sdk/conversations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Conversations = void 0;
    var betaConversationsAppend_js_1 = require_betaConversationsAppend();
    var betaConversationsAppendStream_js_1 = require_betaConversationsAppendStream();
    var betaConversationsGet_js_1 = require_betaConversationsGet();
    var betaConversationsGetHistory_js_1 = require_betaConversationsGetHistory();
    var betaConversationsGetMessages_js_1 = require_betaConversationsGetMessages();
    var betaConversationsList_js_1 = require_betaConversationsList();
    var betaConversationsRestart_js_1 = require_betaConversationsRestart();
    var betaConversationsRestartStream_js_1 = require_betaConversationsRestartStream();
    var betaConversationsStart_js_1 = require_betaConversationsStart();
    var betaConversationsStartStream_js_1 = require_betaConversationsStartStream();
    var sdks_js_1 = require_sdks();
    var fp_js_1 = require_fp();
    var Conversations = class extends sdks_js_1.ClientSDK {
      /**
       * Create a conversation and append entries to it.
       *
       * @remarks
       * Create a new conversation, using a base model or an agent and append entries. Completion and tool executions are run and the response is appended to the conversation.Use the returned conversation_id to continue the conversation.
       */
      async start(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaConversationsStart_js_1.betaConversationsStart)(this, request, options));
      }
      /**
       * List all created conversations.
       *
       * @remarks
       * Retrieve a list of conversation entities sorted by creation time.
       */
      async list(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaConversationsList_js_1.betaConversationsList)(this, request, options));
      }
      /**
       * Retrieve a conversation information.
       *
       * @remarks
       * Given a conversation_id retrieve a conversation entity with its attributes.
       */
      async get(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaConversationsGet_js_1.betaConversationsGet)(this, request, options));
      }
      /**
       * Append new entries to an existing conversation.
       *
       * @remarks
       * Run completion on the history of the conversation and the user entries. Return the new created entries.
       */
      async append(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaConversationsAppend_js_1.betaConversationsAppend)(this, request, options));
      }
      /**
       * Retrieve all entries in a conversation.
       *
       * @remarks
       * Given a conversation_id retrieve all the entries belonging to that conversation. The entries are sorted in the order they were appended, those can be messages, connectors or function_call.
       */
      async getHistory(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaConversationsGetHistory_js_1.betaConversationsGetHistory)(this, request, options));
      }
      /**
       * Retrieve all messages in a conversation.
       *
       * @remarks
       * Given a conversation_id retrieve all the messages belonging to that conversation. This is similar to retrieving all entries except we filter the messages only.
       */
      async getMessages(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaConversationsGetMessages_js_1.betaConversationsGetMessages)(this, request, options));
      }
      /**
       * Restart a conversation starting from a given entry.
       *
       * @remarks
       * Given a conversation_id and an id, recreate a conversation from this point and run completion. A new conversation is returned with the new entries returned.
       */
      async restart(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaConversationsRestart_js_1.betaConversationsRestart)(this, request, options));
      }
      /**
       * Create a conversation and append entries to it.
       *
       * @remarks
       * Create a new conversation, using a base model or an agent and append entries. Completion and tool executions are run and the response is appended to the conversation.Use the returned conversation_id to continue the conversation.
       */
      async startStream(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaConversationsStartStream_js_1.betaConversationsStartStream)(this, request, options));
      }
      /**
       * Append new entries to an existing conversation.
       *
       * @remarks
       * Run completion on the history of the conversation and the user entries. Return the new created entries.
       */
      async appendStream(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaConversationsAppendStream_js_1.betaConversationsAppendStream)(this, request, options));
      }
      /**
       * Restart a conversation starting from a given entry.
       *
       * @remarks
       * Given a conversation_id and an id, recreate a conversation from this point and run completion. A new conversation is returned with the new entries returned.
       */
      async restartStream(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaConversationsRestartStream_js_1.betaConversationsRestartStream)(this, request, options));
      }
    };
    exports.Conversations = Conversations;
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaLibrariesCreate.js
var require_betaLibrariesCreate = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaLibrariesCreate.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaLibrariesCreate = betaLibrariesCreate;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var async_js_1 = require_async();
    function betaLibrariesCreate(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => components.LibraryIn$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = (0, encodings_js_1.encodeJSON)("body", payload, { explode: true });
      const path2 = (0, url_js_1.pathToFunc)("/v1/libraries")();
      const headers = new Headers((0, primitives_js_1.compactMap)({
        "Content-Type": "application/json",
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "libraries_create_v1",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(201, components.LibraryOut$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaLibrariesDelete.js
var require_betaLibrariesDelete = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaLibrariesDelete.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaLibrariesDelete = betaLibrariesDelete;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function betaLibrariesDelete(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.LibrariesDeleteV1Request$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const pathParams = {
        library_id: (0, encodings_js_1.encodeSimple)("library_id", payload.library_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/libraries/{library_id}")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "libraries_delete_v1",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "DELETE",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.LibraryOut$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaLibrariesGet.js
var require_betaLibrariesGet = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaLibrariesGet.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaLibrariesGet = betaLibrariesGet;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function betaLibrariesGet(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.LibrariesGetV1Request$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const pathParams = {
        library_id: (0, encodings_js_1.encodeSimple)("library_id", payload.library_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/libraries/{library_id}")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "libraries_get_v1",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "GET",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.LibraryOut$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaLibrariesList.js
var require_betaLibrariesList = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaLibrariesList.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaLibrariesList = betaLibrariesList;
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var async_js_1 = require_async();
    function betaLibrariesList(client, options) {
      return new async_js_1.APIPromise($do(client, options));
    }
    async function $do(client, options) {
      const path2 = (0, url_js_1.pathToFunc)("/v1/libraries")();
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "libraries_list_v1",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "GET",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const [result] = await M2.match(M2.json(200, components.ListLibraryOut$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response);
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaLibrariesUpdate.js
var require_betaLibrariesUpdate = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaLibrariesUpdate.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaLibrariesUpdate = betaLibrariesUpdate;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function betaLibrariesUpdate(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.LibrariesUpdateV1Request$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = (0, encodings_js_1.encodeJSON)("body", payload.LibraryInUpdate, { explode: true });
      const pathParams = {
        library_id: (0, encodings_js_1.encodeSimple)("library_id", payload.library_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/libraries/{library_id}")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        "Content-Type": "application/json",
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "libraries_update_v1",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "PUT",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.LibraryOut$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaLibrariesAccessesDelete.js
var require_betaLibrariesAccessesDelete = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaLibrariesAccessesDelete.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaLibrariesAccessesDelete = betaLibrariesAccessesDelete;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function betaLibrariesAccessesDelete(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.LibrariesShareDeleteV1Request$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = (0, encodings_js_1.encodeJSON)("body", payload.SharingDelete, { explode: true });
      const pathParams = {
        library_id: (0, encodings_js_1.encodeSimple)("library_id", payload.library_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/libraries/{library_id}/share")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        "Content-Type": "application/json",
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "libraries_share_delete_v1",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "DELETE",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.SharingOut$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaLibrariesAccessesList.js
var require_betaLibrariesAccessesList = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaLibrariesAccessesList.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaLibrariesAccessesList = betaLibrariesAccessesList;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function betaLibrariesAccessesList(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.LibrariesShareListV1Request$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const pathParams = {
        library_id: (0, encodings_js_1.encodeSimple)("library_id", payload.library_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/libraries/{library_id}/share")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "libraries_share_list_v1",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "GET",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.ListSharingOut$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaLibrariesAccessesUpdateOrCreate.js
var require_betaLibrariesAccessesUpdateOrCreate = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaLibrariesAccessesUpdateOrCreate.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaLibrariesAccessesUpdateOrCreate = betaLibrariesAccessesUpdateOrCreate;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function betaLibrariesAccessesUpdateOrCreate(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.LibrariesShareCreateV1Request$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = (0, encodings_js_1.encodeJSON)("body", payload.SharingIn, { explode: true });
      const pathParams = {
        library_id: (0, encodings_js_1.encodeSimple)("library_id", payload.library_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/libraries/{library_id}/share")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        "Content-Type": "application/json",
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "libraries_share_create_v1",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "PUT",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.SharingOut$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/sdk/accesses.js
var require_accesses = __commonJS({
  "../node_modules/@mistralai/mistralai/sdk/accesses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Accesses = void 0;
    var betaLibrariesAccessesDelete_js_1 = require_betaLibrariesAccessesDelete();
    var betaLibrariesAccessesList_js_1 = require_betaLibrariesAccessesList();
    var betaLibrariesAccessesUpdateOrCreate_js_1 = require_betaLibrariesAccessesUpdateOrCreate();
    var sdks_js_1 = require_sdks();
    var fp_js_1 = require_fp();
    var Accesses = class extends sdks_js_1.ClientSDK {
      /**
       * List all of the access to this library.
       *
       * @remarks
       * Given a library, list all of the Entity that have access and to what level.
       */
      async list(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaLibrariesAccessesList_js_1.betaLibrariesAccessesList)(this, request, options));
      }
      /**
       * Create or update an access level.
       *
       * @remarks
       * Given a library id, you can create or update the access level of an entity. You have to be owner of the library to share a library. An owner cannot change their own role. A library cannot be shared outside of the organization.
       */
      async updateOrCreate(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaLibrariesAccessesUpdateOrCreate_js_1.betaLibrariesAccessesUpdateOrCreate)(this, request, options));
      }
      /**
       * Delete an access level.
       *
       * @remarks
       * Given a library id, you can delete the access level of an entity. An owner cannot delete it's own access. You have to be the owner of the library to delete an acces other than yours.
       */
      async delete(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaLibrariesAccessesDelete_js_1.betaLibrariesAccessesDelete)(this, request, options));
      }
    };
    exports.Accesses = Accesses;
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaLibrariesDocumentsDelete.js
var require_betaLibrariesDocumentsDelete = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaLibrariesDocumentsDelete.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaLibrariesDocumentsDelete = betaLibrariesDocumentsDelete;
    var z4 = __importStar(__require("zod"));
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var errors = __importStar(require_errors());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function betaLibrariesDocumentsDelete(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.LibrariesDocumentsDeleteV1Request$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const pathParams = {
        document_id: (0, encodings_js_1.encodeSimple)("document_id", payload.document_id, {
          explode: false,
          charEncoding: "percent"
        }),
        library_id: (0, encodings_js_1.encodeSimple)("library_id", payload.library_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/libraries/{library_id}/documents/{document_id}")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "libraries_documents_delete_v1",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "DELETE",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.nil(204, z4.void()), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaLibrariesDocumentsExtractedTextSignedUrl.js
var require_betaLibrariesDocumentsExtractedTextSignedUrl = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaLibrariesDocumentsExtractedTextSignedUrl.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaLibrariesDocumentsExtractedTextSignedUrl = betaLibrariesDocumentsExtractedTextSignedUrl;
    var z4 = __importStar(__require("zod"));
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var errors = __importStar(require_errors());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function betaLibrariesDocumentsExtractedTextSignedUrl(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.LibrariesDocumentsGetExtractedTextSignedUrlV1Request$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const pathParams = {
        document_id: (0, encodings_js_1.encodeSimple)("document_id", payload.document_id, {
          explode: false,
          charEncoding: "percent"
        }),
        library_id: (0, encodings_js_1.encodeSimple)("library_id", payload.library_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/libraries/{library_id}/documents/{document_id}/extracted-text-signed-url")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "libraries_documents_get_extracted_text_signed_url_v1",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "GET",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, z4.string()), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaLibrariesDocumentsGet.js
var require_betaLibrariesDocumentsGet = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaLibrariesDocumentsGet.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaLibrariesDocumentsGet = betaLibrariesDocumentsGet;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function betaLibrariesDocumentsGet(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.LibrariesDocumentsGetV1Request$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const pathParams = {
        document_id: (0, encodings_js_1.encodeSimple)("document_id", payload.document_id, {
          explode: false,
          charEncoding: "percent"
        }),
        library_id: (0, encodings_js_1.encodeSimple)("library_id", payload.library_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/libraries/{library_id}/documents/{document_id}")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "libraries_documents_get_v1",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "GET",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.DocumentOut$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaLibrariesDocumentsGetSignedUrl.js
var require_betaLibrariesDocumentsGetSignedUrl = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaLibrariesDocumentsGetSignedUrl.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaLibrariesDocumentsGetSignedUrl = betaLibrariesDocumentsGetSignedUrl;
    var z4 = __importStar(__require("zod"));
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var errors = __importStar(require_errors());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function betaLibrariesDocumentsGetSignedUrl(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.LibrariesDocumentsGetSignedUrlV1Request$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const pathParams = {
        document_id: (0, encodings_js_1.encodeSimple)("document_id", payload.document_id, {
          explode: false,
          charEncoding: "percent"
        }),
        library_id: (0, encodings_js_1.encodeSimple)("library_id", payload.library_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/libraries/{library_id}/documents/{document_id}/signed-url")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "libraries_documents_get_signed_url_v1",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "GET",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, z4.string()), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaLibrariesDocumentsList.js
var require_betaLibrariesDocumentsList = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaLibrariesDocumentsList.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaLibrariesDocumentsList = betaLibrariesDocumentsList;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function betaLibrariesDocumentsList(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.LibrariesDocumentsListV1Request$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const pathParams = {
        library_id: (0, encodings_js_1.encodeSimple)("library_id", payload.library_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/libraries/{library_id}/documents")(pathParams);
      const query = (0, encodings_js_1.encodeFormQuery)({
        "page": payload.page,
        "page_size": payload.page_size,
        "search": payload.search,
        "sort_by": payload.sort_by,
        "sort_order": payload.sort_order
      });
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "libraries_documents_list_v1",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "GET",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        query,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.ListDocumentOut$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaLibrariesDocumentsReprocess.js
var require_betaLibrariesDocumentsReprocess = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaLibrariesDocumentsReprocess.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaLibrariesDocumentsReprocess = betaLibrariesDocumentsReprocess;
    var z4 = __importStar(__require("zod"));
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var errors = __importStar(require_errors());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function betaLibrariesDocumentsReprocess(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.LibrariesDocumentsReprocessV1Request$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const pathParams = {
        document_id: (0, encodings_js_1.encodeSimple)("document_id", payload.document_id, {
          explode: false,
          charEncoding: "percent"
        }),
        library_id: (0, encodings_js_1.encodeSimple)("library_id", payload.library_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/libraries/{library_id}/documents/{document_id}/reprocess")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "libraries_documents_reprocess_v1",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.nil(204, z4.void()), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaLibrariesDocumentsStatus.js
var require_betaLibrariesDocumentsStatus = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaLibrariesDocumentsStatus.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaLibrariesDocumentsStatus = betaLibrariesDocumentsStatus;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function betaLibrariesDocumentsStatus(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.LibrariesDocumentsGetStatusV1Request$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const pathParams = {
        document_id: (0, encodings_js_1.encodeSimple)("document_id", payload.document_id, {
          explode: false,
          charEncoding: "percent"
        }),
        library_id: (0, encodings_js_1.encodeSimple)("library_id", payload.library_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/libraries/{library_id}/documents/{document_id}/status")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "libraries_documents_get_status_v1",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "GET",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.ProcessingStatusOut$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaLibrariesDocumentsTextContent.js
var require_betaLibrariesDocumentsTextContent = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaLibrariesDocumentsTextContent.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaLibrariesDocumentsTextContent = betaLibrariesDocumentsTextContent;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function betaLibrariesDocumentsTextContent(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.LibrariesDocumentsGetTextContentV1Request$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const pathParams = {
        document_id: (0, encodings_js_1.encodeSimple)("document_id", payload.document_id, {
          explode: false,
          charEncoding: "percent"
        }),
        library_id: (0, encodings_js_1.encodeSimple)("library_id", payload.library_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/libraries/{library_id}/documents/{document_id}/text_content")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "libraries_documents_get_text_content_v1",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "GET",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.DocumentTextContent$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaLibrariesDocumentsUpdate.js
var require_betaLibrariesDocumentsUpdate = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaLibrariesDocumentsUpdate.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaLibrariesDocumentsUpdate = betaLibrariesDocumentsUpdate;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function betaLibrariesDocumentsUpdate(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.LibrariesDocumentsUpdateV1Request$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = (0, encodings_js_1.encodeJSON)("body", payload.DocumentUpdateIn, { explode: true });
      const pathParams = {
        document_id: (0, encodings_js_1.encodeSimple)("document_id", payload.document_id, {
          explode: false,
          charEncoding: "percent"
        }),
        library_id: (0, encodings_js_1.encodeSimple)("library_id", payload.library_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/libraries/{library_id}/documents/{document_id}")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        "Content-Type": "application/json",
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "libraries_documents_update_v1",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "PUT",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.DocumentOut$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaLibrariesDocumentsUpload.js
var require_betaLibrariesDocumentsUpload = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaLibrariesDocumentsUpload.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaLibrariesDocumentsUpload = betaLibrariesDocumentsUpload;
    var encodings_js_1 = require_encodings();
    var files_js_1 = require_files();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    var blobs_js_1 = require_blobs();
    var streams_js_1 = require_streams();
    function betaLibrariesDocumentsUpload(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.LibrariesDocumentsUploadV1Request$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = new FormData();
      if ((0, blobs_js_1.isBlobLike)(payload.RequestBody.file)) {
        (0, encodings_js_1.appendForm)(body, "file", payload.RequestBody.file);
      } else if ((0, streams_js_1.isReadableStream)(payload.RequestBody.file.content)) {
        const buffer = await (0, files_js_1.readableStreamToArrayBuffer)(payload.RequestBody.file.content);
        const blob = new Blob([buffer], { type: "application/octet-stream" });
        (0, encodings_js_1.appendForm)(body, "file", blob);
      } else {
        (0, encodings_js_1.appendForm)(body, "file", new Blob([payload.RequestBody.file.content], {
          type: "application/octet-stream"
        }), payload.RequestBody.file.fileName);
      }
      const pathParams = {
        library_id: (0, encodings_js_1.encodeSimple)("library_id", payload.library_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/libraries/{library_id}/documents")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "libraries_documents_upload_v1",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json([200, 201], components.DocumentOut$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/sdk/documents.js
var require_documents = __commonJS({
  "../node_modules/@mistralai/mistralai/sdk/documents.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Documents = void 0;
    var betaLibrariesDocumentsDelete_js_1 = require_betaLibrariesDocumentsDelete();
    var betaLibrariesDocumentsExtractedTextSignedUrl_js_1 = require_betaLibrariesDocumentsExtractedTextSignedUrl();
    var betaLibrariesDocumentsGet_js_1 = require_betaLibrariesDocumentsGet();
    var betaLibrariesDocumentsGetSignedUrl_js_1 = require_betaLibrariesDocumentsGetSignedUrl();
    var betaLibrariesDocumentsList_js_1 = require_betaLibrariesDocumentsList();
    var betaLibrariesDocumentsReprocess_js_1 = require_betaLibrariesDocumentsReprocess();
    var betaLibrariesDocumentsStatus_js_1 = require_betaLibrariesDocumentsStatus();
    var betaLibrariesDocumentsTextContent_js_1 = require_betaLibrariesDocumentsTextContent();
    var betaLibrariesDocumentsUpdate_js_1 = require_betaLibrariesDocumentsUpdate();
    var betaLibrariesDocumentsUpload_js_1 = require_betaLibrariesDocumentsUpload();
    var sdks_js_1 = require_sdks();
    var fp_js_1 = require_fp();
    var Documents = class extends sdks_js_1.ClientSDK {
      /**
       * List document in a given library.
       *
       * @remarks
       * Given a library, lists the document that have been uploaded to that library.
       */
      async list(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaLibrariesDocumentsList_js_1.betaLibrariesDocumentsList)(this, request, options));
      }
      /**
       * Upload a new document.
       *
       * @remarks
       * Given a library, upload a new document to that library. It is queued for processing, it status will change it has been processed. The processing has to be completed in order be discoverable for the library search
       */
      async upload(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaLibrariesDocumentsUpload_js_1.betaLibrariesDocumentsUpload)(this, request, options));
      }
      /**
       * Retrieve the metadata of a specific document.
       *
       * @remarks
       * Given a library and a document in this library, you can retrieve the metadata of that document.
       */
      async get(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaLibrariesDocumentsGet_js_1.betaLibrariesDocumentsGet)(this, request, options));
      }
      /**
       * Update the metadata of a specific document.
       *
       * @remarks
       * Given a library and a document in that library, update the name of that document.
       */
      async update(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaLibrariesDocumentsUpdate_js_1.betaLibrariesDocumentsUpdate)(this, request, options));
      }
      /**
       * Delete a document.
       *
       * @remarks
       * Given a library and a document in that library, delete that document. The document will be deleted from the library and the search index.
       */
      async delete(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaLibrariesDocumentsDelete_js_1.betaLibrariesDocumentsDelete)(this, request, options));
      }
      /**
       * Retrieve the text content of a specific document.
       *
       * @remarks
       * Given a library and a document in that library, you can retrieve the text content of that document if it exists. For documents like pdf, docx and pptx the text content results from our processing using Mistral OCR.
       */
      async textContent(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaLibrariesDocumentsTextContent_js_1.betaLibrariesDocumentsTextContent)(this, request, options));
      }
      /**
       * Retrieve the processing status of a specific document.
       *
       * @remarks
       * Given a library and a document in that library, retrieve the processing status of that document.
       */
      async status(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaLibrariesDocumentsStatus_js_1.betaLibrariesDocumentsStatus)(this, request, options));
      }
      /**
       * Retrieve the signed URL of a specific document.
       *
       * @remarks
       * Given a library and a document in that library, retrieve the signed URL of a specific document.The url will expire after 30 minutes and can be accessed by anyone with the link.
       */
      async getSignedUrl(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaLibrariesDocumentsGetSignedUrl_js_1.betaLibrariesDocumentsGetSignedUrl)(this, request, options));
      }
      /**
       * Retrieve the signed URL of text extracted from a given document.
       *
       * @remarks
       * Given a library and a document in that library, retrieve the signed URL of text extracted. For documents that are sent to the OCR this returns the result of the OCR queries.
       */
      async extractedTextSignedUrl(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaLibrariesDocumentsExtractedTextSignedUrl_js_1.betaLibrariesDocumentsExtractedTextSignedUrl)(this, request, options));
      }
      /**
       * Reprocess a document.
       *
       * @remarks
       * Given a library and a document in that library, reprocess that document, it will be billed again.
       */
      async reprocess(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaLibrariesDocumentsReprocess_js_1.betaLibrariesDocumentsReprocess)(this, request, options));
      }
    };
    exports.Documents = Documents;
  }
});

// ../node_modules/@mistralai/mistralai/sdk/libraries.js
var require_libraries = __commonJS({
  "../node_modules/@mistralai/mistralai/sdk/libraries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Libraries = void 0;
    var betaLibrariesCreate_js_1 = require_betaLibrariesCreate();
    var betaLibrariesDelete_js_1 = require_betaLibrariesDelete();
    var betaLibrariesGet_js_1 = require_betaLibrariesGet();
    var betaLibrariesList_js_1 = require_betaLibrariesList();
    var betaLibrariesUpdate_js_1 = require_betaLibrariesUpdate();
    var sdks_js_1 = require_sdks();
    var fp_js_1 = require_fp();
    var accesses_js_1 = require_accesses();
    var documents_js_1 = require_documents();
    var Libraries = class extends sdks_js_1.ClientSDK {
      get documents() {
        return this._documents ?? (this._documents = new documents_js_1.Documents(this._options));
      }
      get accesses() {
        return this._accesses ?? (this._accesses = new accesses_js_1.Accesses(this._options));
      }
      /**
       * List all libraries you have access to.
       *
       * @remarks
       * List all libraries that you have created or have been shared with you.
       */
      async list(options) {
        return (0, fp_js_1.unwrapAsync)((0, betaLibrariesList_js_1.betaLibrariesList)(this, options));
      }
      /**
       * Create a new Library.
       *
       * @remarks
       * Create a new Library, you will be marked as the owner and only you will have the possibility to share it with others. When first created this will only be accessible by you.
       */
      async create(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaLibrariesCreate_js_1.betaLibrariesCreate)(this, request, options));
      }
      /**
       * Detailed information about a specific Library.
       *
       * @remarks
       * Given a library id, details information about that Library.
       */
      async get(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaLibrariesGet_js_1.betaLibrariesGet)(this, request, options));
      }
      /**
       * Delete a library and all of it's document.
       *
       * @remarks
       * Given a library id, deletes it together with all documents that have been uploaded to that library.
       */
      async delete(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaLibrariesDelete_js_1.betaLibrariesDelete)(this, request, options));
      }
      /**
       * Update a library.
       *
       * @remarks
       * Given a library id, you can update the name and description.
       */
      async update(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaLibrariesUpdate_js_1.betaLibrariesUpdate)(this, request, options));
      }
    };
    exports.Libraries = Libraries;
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaAgentsCreate.js
var require_betaAgentsCreate = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaAgentsCreate.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaAgentsCreate = betaAgentsCreate;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var async_js_1 = require_async();
    function betaAgentsCreate(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => components.AgentCreationRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = (0, encodings_js_1.encodeJSON)("body", payload, { explode: true });
      const path2 = (0, url_js_1.pathToFunc)("/v1/agents")();
      const headers = new Headers((0, primitives_js_1.compactMap)({
        "Content-Type": "application/json",
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "agents_api_v1_agents_create",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.Agent$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaAgentsGet.js
var require_betaAgentsGet = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaAgentsGet.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaAgentsGet = betaAgentsGet;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function betaAgentsGet(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.AgentsApiV1AgentsGetRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const pathParams = {
        agent_id: (0, encodings_js_1.encodeSimple)("agent_id", payload.agent_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/agents/{agent_id}")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "agents_api_v1_agents_get",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "GET",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.Agent$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaAgentsList.js
var require_betaAgentsList = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaAgentsList.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaAgentsList = betaAgentsList;
    var z4 = __importStar(__require("zod"));
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function betaAgentsList(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.AgentsApiV1AgentsListRequest$outboundSchema.optional().parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const path2 = (0, url_js_1.pathToFunc)("/v1/agents")();
      const query = (0, encodings_js_1.encodeFormQuery)({
        "page": payload?.page,
        "page_size": payload?.page_size
      });
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "agents_api_v1_agents_list",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "GET",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        query,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, z4.array(components.Agent$inboundSchema)), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaAgentsUpdate.js
var require_betaAgentsUpdate = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaAgentsUpdate.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaAgentsUpdate = betaAgentsUpdate;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function betaAgentsUpdate(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.AgentsApiV1AgentsUpdateRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = (0, encodings_js_1.encodeJSON)("body", payload.AgentUpdateRequest, {
        explode: true
      });
      const pathParams = {
        agent_id: (0, encodings_js_1.encodeSimple)("agent_id", payload.agent_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/agents/{agent_id}")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        "Content-Type": "application/json",
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "agents_api_v1_agents_update",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "PATCH",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.Agent$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/betaAgentsUpdateVersion.js
var require_betaAgentsUpdateVersion = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/betaAgentsUpdateVersion.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.betaAgentsUpdateVersion = betaAgentsUpdateVersion;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function betaAgentsUpdateVersion(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.AgentsApiV1AgentsUpdateVersionRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const pathParams = {
        agent_id: (0, encodings_js_1.encodeSimple)("agent_id", payload.agent_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/agents/{agent_id}/version")(pathParams);
      const query = (0, encodings_js_1.encodeFormQuery)({
        "version": payload.version
      });
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "agents_api_v1_agents_update_version",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "PATCH",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        query,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.Agent$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/sdk/mistralagents.js
var require_mistralagents = __commonJS({
  "../node_modules/@mistralai/mistralai/sdk/mistralagents.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MistralAgents = void 0;
    var betaAgentsCreate_js_1 = require_betaAgentsCreate();
    var betaAgentsGet_js_1 = require_betaAgentsGet();
    var betaAgentsList_js_1 = require_betaAgentsList();
    var betaAgentsUpdate_js_1 = require_betaAgentsUpdate();
    var betaAgentsUpdateVersion_js_1 = require_betaAgentsUpdateVersion();
    var sdks_js_1 = require_sdks();
    var fp_js_1 = require_fp();
    var MistralAgents = class extends sdks_js_1.ClientSDK {
      /**
       * Create a agent that can be used within a conversation.
       *
       * @remarks
       * Create a new agent giving it instructions, tools, description. The agent is then available to be used as a regular assistant in a conversation or as part of an agent pool from which it can be used.
       */
      async create(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaAgentsCreate_js_1.betaAgentsCreate)(this, request, options));
      }
      /**
       * List agent entities.
       *
       * @remarks
       * Retrieve a list of agent entities sorted by creation time.
       */
      async list(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaAgentsList_js_1.betaAgentsList)(this, request, options));
      }
      /**
       * Retrieve an agent entity.
       *
       * @remarks
       * Given an agent retrieve an agent entity with its attributes.
       */
      async get(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaAgentsGet_js_1.betaAgentsGet)(this, request, options));
      }
      /**
       * Update an agent entity.
       *
       * @remarks
       * Update an agent attributes and create a new version.
       */
      async update(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaAgentsUpdate_js_1.betaAgentsUpdate)(this, request, options));
      }
      /**
       * Update an agent version.
       *
       * @remarks
       * Switch the version of an agent.
       */
      async updateVersion(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, betaAgentsUpdateVersion_js_1.betaAgentsUpdateVersion)(this, request, options));
      }
    };
    exports.MistralAgents = MistralAgents;
  }
});

// ../node_modules/@mistralai/mistralai/sdk/beta.js
var require_beta = __commonJS({
  "../node_modules/@mistralai/mistralai/sdk/beta.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Beta = void 0;
    var sdks_js_1 = require_sdks();
    var conversations_js_1 = require_conversations();
    var libraries_js_1 = require_libraries();
    var mistralagents_js_1 = require_mistralagents();
    var Beta2 = class extends sdks_js_1.ClientSDK {
      get conversations() {
        return this._conversations ?? (this._conversations = new conversations_js_1.Conversations(this._options));
      }
      get agents() {
        return this._agents ?? (this._agents = new mistralagents_js_1.MistralAgents(this._options));
      }
      get libraries() {
        return this._libraries ?? (this._libraries = new libraries_js_1.Libraries(this._options));
      }
    };
    exports.Beta = Beta2;
  }
});

// ../node_modules/@mistralai/mistralai/funcs/chatComplete.js
var require_chatComplete = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/chatComplete.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.chatComplete = chatComplete;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var async_js_1 = require_async();
    function chatComplete(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => components.ChatCompletionRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = (0, encodings_js_1.encodeJSON)("body", payload, { explode: true });
      const path2 = (0, url_js_1.pathToFunc)("/v1/chat/completions")();
      const headers = new Headers((0, primitives_js_1.compactMap)({
        "Content-Type": "application/json",
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "chat_completion_v1_chat_completions_post",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.ChatCompletionResponse$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/chatStream.js
var require_chatStream = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/chatStream.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.chatStream = chatStream;
    var z4 = __importStar(__require("zod"));
    var encodings_js_1 = require_encodings();
    var event_streams_js_1 = require_event_streams();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var async_js_1 = require_async();
    function chatStream(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => components.ChatCompletionStreamRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = (0, encodings_js_1.encodeJSON)("body", payload, { explode: true });
      const path2 = (0, url_js_1.pathToFunc)("/v1/chat/completions#stream")();
      const headers = new Headers((0, primitives_js_1.compactMap)({
        "Content-Type": "application/json",
        Accept: "text/event-stream"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "stream_chat",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.sse(200, z4.instanceof(ReadableStream).transform((stream) => {
        return new event_streams_js_1.EventStream({
          stream,
          decoder(rawEvent) {
            const schema = components.CompletionEvent$inboundSchema;
            return schema.parse(rawEvent);
          }
        });
      }), { sseSentinel: "[DONE]" }), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/Options.js
var require_Options = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/Options.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDefaultOptions = exports.defaultOptions = exports.jsonDescription = exports.ignoreOverride = void 0;
    exports.ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
    var jsonDescription = (jsonSchema, def) => {
      if (def.description) {
        try {
          return {
            ...jsonSchema,
            ...JSON.parse(def.description)
          };
        } catch {
        }
      }
      return jsonSchema;
    };
    exports.jsonDescription = jsonDescription;
    exports.defaultOptions = {
      name: void 0,
      $refStrategy: "root",
      basePath: ["#"],
      effectStrategy: "input",
      pipeStrategy: "all",
      dateStrategy: "format:date-time",
      mapStrategy: "entries",
      removeAdditionalStrategy: "passthrough",
      allowedAdditionalProperties: true,
      rejectedAdditionalProperties: false,
      definitionPath: "definitions",
      target: "jsonSchema7",
      strictUnions: false,
      definitions: {},
      errorMessages: false,
      markdownDescription: false,
      patternStrategy: "escape",
      applyRegexFlags: false,
      emailStrategy: "format:email",
      base64Strategy: "contentEncoding:base64",
      nameStrategy: "ref",
      openAiAnyTypeName: "OpenAiAnyType"
    };
    var getDefaultOptions2 = (options) => typeof options === "string" ? {
      ...exports.defaultOptions,
      name: options
    } : {
      ...exports.defaultOptions,
      ...options
    };
    exports.getDefaultOptions = getDefaultOptions2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/Refs.js
var require_Refs = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/Refs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRefs = void 0;
    var Options_js_1 = require_Options();
    var getRefs2 = (options) => {
      const _options = (0, Options_js_1.getDefaultOptions)(options);
      const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
      return {
        ..._options,
        flags: { hasReferencedOpenAiAnyType: false },
        currentPath,
        propertyPath: void 0,
        seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [
          def._def,
          {
            def: def._def,
            path: [..._options.basePath, _options.definitionPath, name],
            // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
            jsonSchema: void 0
          }
        ]))
      };
    };
    exports.getRefs = getRefs2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/errorMessages.js
var require_errorMessages = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/errorMessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setResponseValueAndErrors = exports.addErrorMessage = void 0;
    function addErrorMessage2(res, key, errorMessage, refs) {
      if (!refs?.errorMessages)
        return;
      if (errorMessage) {
        res.errorMessage = {
          ...res.errorMessage,
          [key]: errorMessage
        };
      }
    }
    exports.addErrorMessage = addErrorMessage2;
    function setResponseValueAndErrors2(res, key, value, errorMessage, refs) {
      res[key] = value;
      addErrorMessage2(res, key, errorMessage, refs);
    }
    exports.setResponseValueAndErrors = setResponseValueAndErrors2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/getRelativePath.js
var require_getRelativePath = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/getRelativePath.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRelativePath = void 0;
    var getRelativePath2 = (pathA, pathB) => {
      let i2 = 0;
      for (; i2 < pathA.length && i2 < pathB.length; i2++) {
        if (pathA[i2] !== pathB[i2])
          break;
      }
      return [(pathA.length - i2).toString(), ...pathB.slice(i2)].join("/");
    };
    exports.getRelativePath = getRelativePath2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parsers/any.js
var require_any = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parsers/any.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAnyDef = void 0;
    var getRelativePath_js_1 = require_getRelativePath();
    function parseAnyDef2(refs) {
      if (refs.target !== "openAi") {
        return {};
      }
      const anyDefinitionPath = [
        ...refs.basePath,
        refs.definitionPath,
        refs.openAiAnyTypeName
      ];
      refs.flags.hasReferencedOpenAiAnyType = true;
      return {
        $ref: refs.$refStrategy === "relative" ? (0, getRelativePath_js_1.getRelativePath)(anyDefinitionPath, refs.currentPath) : anyDefinitionPath.join("/")
      };
    }
    exports.parseAnyDef = parseAnyDef2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parsers/array.js
var require_array = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parsers/array.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseArrayDef = void 0;
    var zod_1 = __require("zod");
    var errorMessages_js_1 = require_errorMessages();
    var parseDef_js_1 = require_parseDef();
    function parseArrayDef2(def, refs) {
      const res = {
        type: "array"
      };
      if (def.type?._def && def.type?._def?.typeName !== zod_1.ZodFirstPartyTypeKind.ZodAny) {
        res.items = (0, parseDef_js_1.parseDef)(def.type._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items"]
        });
      }
      if (def.minLength) {
        (0, errorMessages_js_1.setResponseValueAndErrors)(res, "minItems", def.minLength.value, def.minLength.message, refs);
      }
      if (def.maxLength) {
        (0, errorMessages_js_1.setResponseValueAndErrors)(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
      }
      if (def.exactLength) {
        (0, errorMessages_js_1.setResponseValueAndErrors)(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
        (0, errorMessages_js_1.setResponseValueAndErrors)(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
      }
      return res;
    }
    exports.parseArrayDef = parseArrayDef2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parsers/bigint.js
var require_bigint = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parsers/bigint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseBigintDef = void 0;
    var errorMessages_js_1 = require_errorMessages();
    function parseBigintDef2(def, refs) {
      const res = {
        type: "integer",
        format: "int64"
      };
      if (!def.checks)
        return res;
      for (const check of def.checks) {
        switch (check.kind) {
          case "min":
            if (refs.target === "jsonSchema7") {
              if (check.inclusive) {
                (0, errorMessages_js_1.setResponseValueAndErrors)(res, "minimum", check.value, check.message, refs);
              } else {
                (0, errorMessages_js_1.setResponseValueAndErrors)(res, "exclusiveMinimum", check.value, check.message, refs);
              }
            } else {
              if (!check.inclusive) {
                res.exclusiveMinimum = true;
              }
              (0, errorMessages_js_1.setResponseValueAndErrors)(res, "minimum", check.value, check.message, refs);
            }
            break;
          case "max":
            if (refs.target === "jsonSchema7") {
              if (check.inclusive) {
                (0, errorMessages_js_1.setResponseValueAndErrors)(res, "maximum", check.value, check.message, refs);
              } else {
                (0, errorMessages_js_1.setResponseValueAndErrors)(res, "exclusiveMaximum", check.value, check.message, refs);
              }
            } else {
              if (!check.inclusive) {
                res.exclusiveMaximum = true;
              }
              (0, errorMessages_js_1.setResponseValueAndErrors)(res, "maximum", check.value, check.message, refs);
            }
            break;
          case "multipleOf":
            (0, errorMessages_js_1.setResponseValueAndErrors)(res, "multipleOf", check.value, check.message, refs);
            break;
        }
      }
      return res;
    }
    exports.parseBigintDef = parseBigintDef2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parsers/boolean.js
var require_boolean = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parsers/boolean.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseBooleanDef = void 0;
    function parseBooleanDef2() {
      return {
        type: "boolean"
      };
    }
    exports.parseBooleanDef = parseBooleanDef2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parsers/branded.js
var require_branded = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parsers/branded.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseBrandedDef = void 0;
    var parseDef_js_1 = require_parseDef();
    function parseBrandedDef2(_def, refs) {
      return (0, parseDef_js_1.parseDef)(_def.type._def, refs);
    }
    exports.parseBrandedDef = parseBrandedDef2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parsers/catch.js
var require_catch = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parsers/catch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseCatchDef = void 0;
    var parseDef_js_1 = require_parseDef();
    var parseCatchDef2 = (def, refs) => {
      return (0, parseDef_js_1.parseDef)(def.innerType._def, refs);
    };
    exports.parseCatchDef = parseCatchDef2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parsers/date.js
var require_date = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parsers/date.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseDateDef = void 0;
    var errorMessages_js_1 = require_errorMessages();
    function parseDateDef2(def, refs, overrideDateStrategy) {
      const strategy = overrideDateStrategy ?? refs.dateStrategy;
      if (Array.isArray(strategy)) {
        return {
          anyOf: strategy.map((item, i2) => parseDateDef2(def, refs, item))
        };
      }
      switch (strategy) {
        case "string":
        case "format:date-time":
          return {
            type: "string",
            format: "date-time"
          };
        case "format:date":
          return {
            type: "string",
            format: "date"
          };
        case "integer":
          return integerDateParser2(def, refs);
      }
    }
    exports.parseDateDef = parseDateDef2;
    var integerDateParser2 = (def, refs) => {
      const res = {
        type: "integer",
        format: "unix-time"
      };
      if (refs.target === "openApi3") {
        return res;
      }
      for (const check of def.checks) {
        switch (check.kind) {
          case "min":
            (0, errorMessages_js_1.setResponseValueAndErrors)(
              res,
              "minimum",
              check.value,
              // This is in milliseconds
              check.message,
              refs
            );
            break;
          case "max":
            (0, errorMessages_js_1.setResponseValueAndErrors)(
              res,
              "maximum",
              check.value,
              // This is in milliseconds
              check.message,
              refs
            );
            break;
        }
      }
      return res;
    };
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parsers/default.js
var require_default = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parsers/default.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseDefaultDef = void 0;
    var parseDef_js_1 = require_parseDef();
    function parseDefaultDef2(_def, refs) {
      return {
        ...(0, parseDef_js_1.parseDef)(_def.innerType._def, refs),
        default: _def.defaultValue()
      };
    }
    exports.parseDefaultDef = parseDefaultDef2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parsers/effects.js
var require_effects = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parsers/effects.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseEffectsDef = void 0;
    var parseDef_js_1 = require_parseDef();
    var any_js_1 = require_any();
    function parseEffectsDef2(_def, refs) {
      return refs.effectStrategy === "input" ? (0, parseDef_js_1.parseDef)(_def.schema._def, refs) : (0, any_js_1.parseAnyDef)(refs);
    }
    exports.parseEffectsDef = parseEffectsDef2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parsers/enum.js
var require_enum = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parsers/enum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseEnumDef = void 0;
    function parseEnumDef2(def) {
      return {
        type: "string",
        enum: Array.from(def.values)
      };
    }
    exports.parseEnumDef = parseEnumDef2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parsers/intersection.js
var require_intersection = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parsers/intersection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseIntersectionDef = void 0;
    var parseDef_js_1 = require_parseDef();
    var isJsonSchema7AllOfType2 = (type) => {
      if ("type" in type && type.type === "string")
        return false;
      return "allOf" in type;
    };
    function parseIntersectionDef2(def, refs) {
      const allOf = [
        (0, parseDef_js_1.parseDef)(def.left._def, {
          ...refs,
          currentPath: [...refs.currentPath, "allOf", "0"]
        }),
        (0, parseDef_js_1.parseDef)(def.right._def, {
          ...refs,
          currentPath: [...refs.currentPath, "allOf", "1"]
        })
      ].filter((x2) => !!x2);
      let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
      const mergedAllOf = [];
      allOf.forEach((schema) => {
        if (isJsonSchema7AllOfType2(schema)) {
          mergedAllOf.push(...schema.allOf);
          if (schema.unevaluatedProperties === void 0) {
            unevaluatedProperties = void 0;
          }
        } else {
          let nestedSchema = schema;
          if ("additionalProperties" in schema && schema.additionalProperties === false) {
            const { additionalProperties, ...rest } = schema;
            nestedSchema = rest;
          } else {
            unevaluatedProperties = void 0;
          }
          mergedAllOf.push(nestedSchema);
        }
      });
      return mergedAllOf.length ? {
        allOf: mergedAllOf,
        ...unevaluatedProperties
      } : void 0;
    }
    exports.parseIntersectionDef = parseIntersectionDef2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parsers/literal.js
var require_literal = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parsers/literal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseLiteralDef = void 0;
    function parseLiteralDef2(def, refs) {
      const parsedType = typeof def.value;
      if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
        return {
          type: Array.isArray(def.value) ? "array" : "object"
        };
      }
      if (refs.target === "openApi3") {
        return {
          type: parsedType === "bigint" ? "integer" : parsedType,
          enum: [def.value]
        };
      }
      return {
        type: parsedType === "bigint" ? "integer" : parsedType,
        const: def.value
      };
    }
    exports.parseLiteralDef = parseLiteralDef2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parsers/string.js
var require_string = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parsers/string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseStringDef = exports.zodPatterns = void 0;
    var errorMessages_js_1 = require_errorMessages();
    var emojiRegex2 = void 0;
    exports.zodPatterns = {
      /**
       * `c` was changed to `[cC]` to replicate /i flag
       */
      cuid: /^[cC][^\s-]{8,}$/,
      cuid2: /^[0-9a-z]+$/,
      ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
      /**
       * `a-z` was added to replicate /i flag
       */
      email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
      /**
       * Constructed a valid Unicode RegExp
       *
       * Lazily instantiate since this type of regex isn't supported
       * in all envs (e.g. React Native).
       *
       * See:
       * https://github.com/colinhacks/zod/issues/2433
       * Fix in Zod:
       * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
       */
      emoji: () => {
        if (emojiRegex2 === void 0) {
          emojiRegex2 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
        }
        return emojiRegex2;
      },
      /**
       * Unused
       */
      uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
      /**
       * Unused
       */
      ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
      ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
      /**
       * Unused
       */
      ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
      ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
      base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
      base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
      nanoid: /^[a-zA-Z0-9_-]{21}$/,
      jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
    };
    function parseStringDef2(def, refs) {
      const res = {
        type: "string"
      };
      if (def.checks) {
        for (const check of def.checks) {
          switch (check.kind) {
            case "min":
              (0, errorMessages_js_1.setResponseValueAndErrors)(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
              break;
            case "max":
              (0, errorMessages_js_1.setResponseValueAndErrors)(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
              break;
            case "email":
              switch (refs.emailStrategy) {
                case "format:email":
                  addFormat2(res, "email", check.message, refs);
                  break;
                case "format:idn-email":
                  addFormat2(res, "idn-email", check.message, refs);
                  break;
                case "pattern:zod":
                  addPattern2(res, exports.zodPatterns.email, check.message, refs);
                  break;
              }
              break;
            case "url":
              addFormat2(res, "uri", check.message, refs);
              break;
            case "uuid":
              addFormat2(res, "uuid", check.message, refs);
              break;
            case "regex":
              addPattern2(res, check.regex, check.message, refs);
              break;
            case "cuid":
              addPattern2(res, exports.zodPatterns.cuid, check.message, refs);
              break;
            case "cuid2":
              addPattern2(res, exports.zodPatterns.cuid2, check.message, refs);
              break;
            case "startsWith":
              addPattern2(res, RegExp(`^${escapeLiteralCheckValue2(check.value, refs)}`), check.message, refs);
              break;
            case "endsWith":
              addPattern2(res, RegExp(`${escapeLiteralCheckValue2(check.value, refs)}$`), check.message, refs);
              break;
            case "datetime":
              addFormat2(res, "date-time", check.message, refs);
              break;
            case "date":
              addFormat2(res, "date", check.message, refs);
              break;
            case "time":
              addFormat2(res, "time", check.message, refs);
              break;
            case "duration":
              addFormat2(res, "duration", check.message, refs);
              break;
            case "length":
              (0, errorMessages_js_1.setResponseValueAndErrors)(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
              (0, errorMessages_js_1.setResponseValueAndErrors)(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
              break;
            case "includes": {
              addPattern2(res, RegExp(escapeLiteralCheckValue2(check.value, refs)), check.message, refs);
              break;
            }
            case "ip": {
              if (check.version !== "v6") {
                addFormat2(res, "ipv4", check.message, refs);
              }
              if (check.version !== "v4") {
                addFormat2(res, "ipv6", check.message, refs);
              }
              break;
            }
            case "base64url":
              addPattern2(res, exports.zodPatterns.base64url, check.message, refs);
              break;
            case "jwt":
              addPattern2(res, exports.zodPatterns.jwt, check.message, refs);
              break;
            case "cidr": {
              if (check.version !== "v6") {
                addPattern2(res, exports.zodPatterns.ipv4Cidr, check.message, refs);
              }
              if (check.version !== "v4") {
                addPattern2(res, exports.zodPatterns.ipv6Cidr, check.message, refs);
              }
              break;
            }
            case "emoji":
              addPattern2(res, exports.zodPatterns.emoji(), check.message, refs);
              break;
            case "ulid": {
              addPattern2(res, exports.zodPatterns.ulid, check.message, refs);
              break;
            }
            case "base64": {
              switch (refs.base64Strategy) {
                case "format:binary": {
                  addFormat2(res, "binary", check.message, refs);
                  break;
                }
                case "contentEncoding:base64": {
                  (0, errorMessages_js_1.setResponseValueAndErrors)(res, "contentEncoding", "base64", check.message, refs);
                  break;
                }
                case "pattern:zod": {
                  addPattern2(res, exports.zodPatterns.base64, check.message, refs);
                  break;
                }
              }
              break;
            }
            case "nanoid": {
              addPattern2(res, exports.zodPatterns.nanoid, check.message, refs);
            }
            case "toLowerCase":
            case "toUpperCase":
            case "trim":
              break;
            default:
              /* @__PURE__ */ ((_2) => {
              })(check);
          }
        }
      }
      return res;
    }
    exports.parseStringDef = parseStringDef2;
    function escapeLiteralCheckValue2(literal, refs) {
      return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric2(literal) : literal;
    }
    var ALPHA_NUMERIC2 = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
    function escapeNonAlphaNumeric2(source) {
      let result = "";
      for (let i2 = 0; i2 < source.length; i2++) {
        if (!ALPHA_NUMERIC2.has(source[i2])) {
          result += "\\";
        }
        result += source[i2];
      }
      return result;
    }
    function addFormat2(schema, value, message, refs) {
      if (schema.format || schema.anyOf?.some((x2) => x2.format)) {
        if (!schema.anyOf) {
          schema.anyOf = [];
        }
        if (schema.format) {
          schema.anyOf.push({
            format: schema.format,
            ...schema.errorMessage && refs.errorMessages && {
              errorMessage: { format: schema.errorMessage.format }
            }
          });
          delete schema.format;
          if (schema.errorMessage) {
            delete schema.errorMessage.format;
            if (Object.keys(schema.errorMessage).length === 0) {
              delete schema.errorMessage;
            }
          }
        }
        schema.anyOf.push({
          format: value,
          ...message && refs.errorMessages && { errorMessage: { format: message } }
        });
      } else {
        (0, errorMessages_js_1.setResponseValueAndErrors)(schema, "format", value, message, refs);
      }
    }
    function addPattern2(schema, regex, message, refs) {
      if (schema.pattern || schema.allOf?.some((x2) => x2.pattern)) {
        if (!schema.allOf) {
          schema.allOf = [];
        }
        if (schema.pattern) {
          schema.allOf.push({
            pattern: schema.pattern,
            ...schema.errorMessage && refs.errorMessages && {
              errorMessage: { pattern: schema.errorMessage.pattern }
            }
          });
          delete schema.pattern;
          if (schema.errorMessage) {
            delete schema.errorMessage.pattern;
            if (Object.keys(schema.errorMessage).length === 0) {
              delete schema.errorMessage;
            }
          }
        }
        schema.allOf.push({
          pattern: stringifyRegExpWithFlags2(regex, refs),
          ...message && refs.errorMessages && { errorMessage: { pattern: message } }
        });
      } else {
        (0, errorMessages_js_1.setResponseValueAndErrors)(schema, "pattern", stringifyRegExpWithFlags2(regex, refs), message, refs);
      }
    }
    function stringifyRegExpWithFlags2(regex, refs) {
      if (!refs.applyRegexFlags || !regex.flags) {
        return regex.source;
      }
      const flags = {
        i: regex.flags.includes("i"),
        m: regex.flags.includes("m"),
        s: regex.flags.includes("s")
        // `.` matches newlines
      };
      const source = flags.i ? regex.source.toLowerCase() : regex.source;
      let pattern = "";
      let isEscaped = false;
      let inCharGroup = false;
      let inCharRange = false;
      for (let i2 = 0; i2 < source.length; i2++) {
        if (isEscaped) {
          pattern += source[i2];
          isEscaped = false;
          continue;
        }
        if (flags.i) {
          if (inCharGroup) {
            if (source[i2].match(/[a-z]/)) {
              if (inCharRange) {
                pattern += source[i2];
                pattern += `${source[i2 - 2]}-${source[i2]}`.toUpperCase();
                inCharRange = false;
              } else if (source[i2 + 1] === "-" && source[i2 + 2]?.match(/[a-z]/)) {
                pattern += source[i2];
                inCharRange = true;
              } else {
                pattern += `${source[i2]}${source[i2].toUpperCase()}`;
              }
              continue;
            }
          } else if (source[i2].match(/[a-z]/)) {
            pattern += `[${source[i2]}${source[i2].toUpperCase()}]`;
            continue;
          }
        }
        if (flags.m) {
          if (source[i2] === "^") {
            pattern += `(^|(?<=[\r
]))`;
            continue;
          } else if (source[i2] === "$") {
            pattern += `($|(?=[\r
]))`;
            continue;
          }
        }
        if (flags.s && source[i2] === ".") {
          pattern += inCharGroup ? `${source[i2]}\r
` : `[${source[i2]}\r
]`;
          continue;
        }
        pattern += source[i2];
        if (source[i2] === "\\") {
          isEscaped = true;
        } else if (inCharGroup && source[i2] === "]") {
          inCharGroup = false;
        } else if (!inCharGroup && source[i2] === "[") {
          inCharGroup = true;
        }
      }
      try {
        new RegExp(pattern);
      } catch {
        console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
        return regex.source;
      }
      return pattern;
    }
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parsers/record.js
var require_record = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parsers/record.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseRecordDef = void 0;
    var zod_1 = __require("zod");
    var parseDef_js_1 = require_parseDef();
    var string_js_1 = require_string();
    var branded_js_1 = require_branded();
    var any_js_1 = require_any();
    function parseRecordDef2(def, refs) {
      if (refs.target === "openAi") {
        console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
      }
      if (refs.target === "openApi3" && def.keyType?._def.typeName === zod_1.ZodFirstPartyTypeKind.ZodEnum) {
        return {
          type: "object",
          required: def.keyType._def.values,
          properties: def.keyType._def.values.reduce((acc, key) => ({
            ...acc,
            [key]: (0, parseDef_js_1.parseDef)(def.valueType._def, {
              ...refs,
              currentPath: [...refs.currentPath, "properties", key]
            }) ?? (0, any_js_1.parseAnyDef)(refs)
          }), {}),
          additionalProperties: refs.rejectedAdditionalProperties
        };
      }
      const schema = {
        type: "object",
        additionalProperties: (0, parseDef_js_1.parseDef)(def.valueType._def, {
          ...refs,
          currentPath: [...refs.currentPath, "additionalProperties"]
        }) ?? refs.allowedAdditionalProperties
      };
      if (refs.target === "openApi3") {
        return schema;
      }
      if (def.keyType?._def.typeName === zod_1.ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {
        const { type, ...keyType } = (0, string_js_1.parseStringDef)(def.keyType._def, refs);
        return {
          ...schema,
          propertyNames: keyType
        };
      } else if (def.keyType?._def.typeName === zod_1.ZodFirstPartyTypeKind.ZodEnum) {
        return {
          ...schema,
          propertyNames: {
            enum: def.keyType._def.values
          }
        };
      } else if (def.keyType?._def.typeName === zod_1.ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === zod_1.ZodFirstPartyTypeKind.ZodString && def.keyType._def.type._def.checks?.length) {
        const { type, ...keyType } = (0, branded_js_1.parseBrandedDef)(def.keyType._def, refs);
        return {
          ...schema,
          propertyNames: keyType
        };
      }
      return schema;
    }
    exports.parseRecordDef = parseRecordDef2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parsers/map.js
var require_map = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parsers/map.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseMapDef = void 0;
    var parseDef_js_1 = require_parseDef();
    var record_js_1 = require_record();
    var any_js_1 = require_any();
    function parseMapDef2(def, refs) {
      if (refs.mapStrategy === "record") {
        return (0, record_js_1.parseRecordDef)(def, refs);
      }
      const keys = (0, parseDef_js_1.parseDef)(def.keyType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", "items", "0"]
      }) || (0, any_js_1.parseAnyDef)(refs);
      const values = (0, parseDef_js_1.parseDef)(def.valueType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", "items", "1"]
      }) || (0, any_js_1.parseAnyDef)(refs);
      return {
        type: "array",
        maxItems: 125,
        items: {
          type: "array",
          items: [keys, values],
          minItems: 2,
          maxItems: 2
        }
      };
    }
    exports.parseMapDef = parseMapDef2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parsers/nativeEnum.js
var require_nativeEnum = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parsers/nativeEnum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseNativeEnumDef = void 0;
    function parseNativeEnumDef2(def) {
      const object = def.values;
      const actualKeys = Object.keys(def.values).filter((key) => {
        return typeof object[object[key]] !== "number";
      });
      const actualValues = actualKeys.map((key) => object[key]);
      const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
      return {
        type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
        enum: actualValues
      };
    }
    exports.parseNativeEnumDef = parseNativeEnumDef2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parsers/never.js
var require_never = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parsers/never.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseNeverDef = void 0;
    var any_js_1 = require_any();
    function parseNeverDef2(refs) {
      return refs.target === "openAi" ? void 0 : {
        not: (0, any_js_1.parseAnyDef)({
          ...refs,
          currentPath: [...refs.currentPath, "not"]
        })
      };
    }
    exports.parseNeverDef = parseNeverDef2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parsers/null.js
var require_null = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parsers/null.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseNullDef = void 0;
    function parseNullDef2(refs) {
      return refs.target === "openApi3" ? {
        enum: ["null"],
        nullable: true
      } : {
        type: "null"
      };
    }
    exports.parseNullDef = parseNullDef2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parsers/union.js
var require_union = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parsers/union.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseUnionDef = exports.primitiveMappings = void 0;
    var parseDef_js_1 = require_parseDef();
    exports.primitiveMappings = {
      ZodString: "string",
      ZodNumber: "number",
      ZodBigInt: "integer",
      ZodBoolean: "boolean",
      ZodNull: "null"
    };
    function parseUnionDef2(def, refs) {
      if (refs.target === "openApi3")
        return asAnyOf2(def, refs);
      const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
      if (options.every((x2) => x2._def.typeName in exports.primitiveMappings && (!x2._def.checks || !x2._def.checks.length))) {
        const types2 = options.reduce((types3, x2) => {
          const type = exports.primitiveMappings[x2._def.typeName];
          return type && !types3.includes(type) ? [...types3, type] : types3;
        }, []);
        return {
          type: types2.length > 1 ? types2 : types2[0]
        };
      } else if (options.every((x2) => x2._def.typeName === "ZodLiteral" && !x2.description)) {
        const types2 = options.reduce((acc, x2) => {
          const type = typeof x2._def.value;
          switch (type) {
            case "string":
            case "number":
            case "boolean":
              return [...acc, type];
            case "bigint":
              return [...acc, "integer"];
            case "object":
              if (x2._def.value === null)
                return [...acc, "null"];
            case "symbol":
            case "undefined":
            case "function":
            default:
              return acc;
          }
        }, []);
        if (types2.length === options.length) {
          const uniqueTypes = types2.filter((x2, i2, a2) => a2.indexOf(x2) === i2);
          return {
            type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
            enum: options.reduce((acc, x2) => {
              return acc.includes(x2._def.value) ? acc : [...acc, x2._def.value];
            }, [])
          };
        }
      } else if (options.every((x2) => x2._def.typeName === "ZodEnum")) {
        return {
          type: "string",
          enum: options.reduce((acc, x2) => [
            ...acc,
            ...x2._def.values.filter((x3) => !acc.includes(x3))
          ], [])
        };
      }
      return asAnyOf2(def, refs);
    }
    exports.parseUnionDef = parseUnionDef2;
    var asAnyOf2 = (def, refs) => {
      const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x2, i2) => (0, parseDef_js_1.parseDef)(x2._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", `${i2}`]
      })).filter((x2) => !!x2 && (!refs.strictUnions || typeof x2 === "object" && Object.keys(x2).length > 0));
      return anyOf.length ? { anyOf } : void 0;
    };
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parsers/nullable.js
var require_nullable = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parsers/nullable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseNullableDef = void 0;
    var parseDef_js_1 = require_parseDef();
    var union_js_1 = require_union();
    function parseNullableDef2(def, refs) {
      if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
        if (refs.target === "openApi3") {
          return {
            type: union_js_1.primitiveMappings[def.innerType._def.typeName],
            nullable: true
          };
        }
        return {
          type: [
            union_js_1.primitiveMappings[def.innerType._def.typeName],
            "null"
          ]
        };
      }
      if (refs.target === "openApi3") {
        const base2 = (0, parseDef_js_1.parseDef)(def.innerType._def, {
          ...refs,
          currentPath: [...refs.currentPath]
        });
        if (base2 && "$ref" in base2)
          return { allOf: [base2], nullable: true };
        return base2 && { ...base2, nullable: true };
      }
      const base = (0, parseDef_js_1.parseDef)(def.innerType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", "0"]
      });
      return base && { anyOf: [base, { type: "null" }] };
    }
    exports.parseNullableDef = parseNullableDef2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parsers/number.js
var require_number = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parsers/number.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseNumberDef = void 0;
    var errorMessages_js_1 = require_errorMessages();
    function parseNumberDef2(def, refs) {
      const res = {
        type: "number"
      };
      if (!def.checks)
        return res;
      for (const check of def.checks) {
        switch (check.kind) {
          case "int":
            res.type = "integer";
            (0, errorMessages_js_1.addErrorMessage)(res, "type", check.message, refs);
            break;
          case "min":
            if (refs.target === "jsonSchema7") {
              if (check.inclusive) {
                (0, errorMessages_js_1.setResponseValueAndErrors)(res, "minimum", check.value, check.message, refs);
              } else {
                (0, errorMessages_js_1.setResponseValueAndErrors)(res, "exclusiveMinimum", check.value, check.message, refs);
              }
            } else {
              if (!check.inclusive) {
                res.exclusiveMinimum = true;
              }
              (0, errorMessages_js_1.setResponseValueAndErrors)(res, "minimum", check.value, check.message, refs);
            }
            break;
          case "max":
            if (refs.target === "jsonSchema7") {
              if (check.inclusive) {
                (0, errorMessages_js_1.setResponseValueAndErrors)(res, "maximum", check.value, check.message, refs);
              } else {
                (0, errorMessages_js_1.setResponseValueAndErrors)(res, "exclusiveMaximum", check.value, check.message, refs);
              }
            } else {
              if (!check.inclusive) {
                res.exclusiveMaximum = true;
              }
              (0, errorMessages_js_1.setResponseValueAndErrors)(res, "maximum", check.value, check.message, refs);
            }
            break;
          case "multipleOf":
            (0, errorMessages_js_1.setResponseValueAndErrors)(res, "multipleOf", check.value, check.message, refs);
            break;
        }
      }
      return res;
    }
    exports.parseNumberDef = parseNumberDef2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parsers/object.js
var require_object = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parsers/object.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseObjectDef = void 0;
    var parseDef_js_1 = require_parseDef();
    function parseObjectDef2(def, refs) {
      const forceOptionalIntoNullable = refs.target === "openAi";
      const result = {
        type: "object",
        properties: {}
      };
      const required = [];
      const shape = def.shape();
      for (const propName in shape) {
        let propDef = shape[propName];
        if (propDef === void 0 || propDef._def === void 0) {
          continue;
        }
        let propOptional = safeIsOptional2(propDef);
        if (propOptional && forceOptionalIntoNullable) {
          if (propDef._def.typeName === "ZodOptional") {
            propDef = propDef._def.innerType;
          }
          if (!propDef.isNullable()) {
            propDef = propDef.nullable();
          }
          propOptional = false;
        }
        const parsedDef = (0, parseDef_js_1.parseDef)(propDef._def, {
          ...refs,
          currentPath: [...refs.currentPath, "properties", propName],
          propertyPath: [...refs.currentPath, "properties", propName]
        });
        if (parsedDef === void 0) {
          continue;
        }
        result.properties[propName] = parsedDef;
        if (!propOptional) {
          required.push(propName);
        }
      }
      if (required.length) {
        result.required = required;
      }
      const additionalProperties = decideAdditionalProperties2(def, refs);
      if (additionalProperties !== void 0) {
        result.additionalProperties = additionalProperties;
      }
      return result;
    }
    exports.parseObjectDef = parseObjectDef2;
    function decideAdditionalProperties2(def, refs) {
      if (def.catchall._def.typeName !== "ZodNever") {
        return (0, parseDef_js_1.parseDef)(def.catchall._def, {
          ...refs,
          currentPath: [...refs.currentPath, "additionalProperties"]
        });
      }
      switch (def.unknownKeys) {
        case "passthrough":
          return refs.allowedAdditionalProperties;
        case "strict":
          return refs.rejectedAdditionalProperties;
        case "strip":
          return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
      }
    }
    function safeIsOptional2(schema) {
      try {
        return schema.isOptional();
      } catch {
        return true;
      }
    }
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parsers/optional.js
var require_optional = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parsers/optional.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseOptionalDef = void 0;
    var parseDef_js_1 = require_parseDef();
    var any_js_1 = require_any();
    var parseOptionalDef2 = (def, refs) => {
      if (refs.currentPath.toString() === refs.propertyPath?.toString()) {
        return (0, parseDef_js_1.parseDef)(def.innerType._def, refs);
      }
      const innerSchema = (0, parseDef_js_1.parseDef)(def.innerType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", "1"]
      });
      return innerSchema ? {
        anyOf: [
          {
            not: (0, any_js_1.parseAnyDef)(refs)
          },
          innerSchema
        ]
      } : (0, any_js_1.parseAnyDef)(refs);
    };
    exports.parseOptionalDef = parseOptionalDef2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parsers/pipeline.js
var require_pipeline = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parsers/pipeline.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parsePipelineDef = void 0;
    var parseDef_js_1 = require_parseDef();
    var parsePipelineDef2 = (def, refs) => {
      if (refs.pipeStrategy === "input") {
        return (0, parseDef_js_1.parseDef)(def.in._def, refs);
      } else if (refs.pipeStrategy === "output") {
        return (0, parseDef_js_1.parseDef)(def.out._def, refs);
      }
      const a2 = (0, parseDef_js_1.parseDef)(def.in._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", "0"]
      });
      const b2 = (0, parseDef_js_1.parseDef)(def.out._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", a2 ? "1" : "0"]
      });
      return {
        allOf: [a2, b2].filter((x2) => x2 !== void 0)
      };
    };
    exports.parsePipelineDef = parsePipelineDef2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parsers/promise.js
var require_promise = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parsers/promise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parsePromiseDef = void 0;
    var parseDef_js_1 = require_parseDef();
    function parsePromiseDef2(def, refs) {
      return (0, parseDef_js_1.parseDef)(def.type._def, refs);
    }
    exports.parsePromiseDef = parsePromiseDef2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parsers/set.js
var require_set = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parsers/set.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseSetDef = void 0;
    var errorMessages_js_1 = require_errorMessages();
    var parseDef_js_1 = require_parseDef();
    function parseSetDef2(def, refs) {
      const items = (0, parseDef_js_1.parseDef)(def.valueType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items"]
      });
      const schema = {
        type: "array",
        uniqueItems: true,
        items
      };
      if (def.minSize) {
        (0, errorMessages_js_1.setResponseValueAndErrors)(schema, "minItems", def.minSize.value, def.minSize.message, refs);
      }
      if (def.maxSize) {
        (0, errorMessages_js_1.setResponseValueAndErrors)(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
      }
      return schema;
    }
    exports.parseSetDef = parseSetDef2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parsers/tuple.js
var require_tuple = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parsers/tuple.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTupleDef = void 0;
    var parseDef_js_1 = require_parseDef();
    function parseTupleDef2(def, refs) {
      if (def.rest) {
        return {
          type: "array",
          minItems: def.items.length,
          items: def.items.map((x2, i2) => (0, parseDef_js_1.parseDef)(x2._def, {
            ...refs,
            currentPath: [...refs.currentPath, "items", `${i2}`]
          })).reduce((acc, x2) => x2 === void 0 ? acc : [...acc, x2], []),
          additionalItems: (0, parseDef_js_1.parseDef)(def.rest._def, {
            ...refs,
            currentPath: [...refs.currentPath, "additionalItems"]
          })
        };
      } else {
        return {
          type: "array",
          minItems: def.items.length,
          maxItems: def.items.length,
          items: def.items.map((x2, i2) => (0, parseDef_js_1.parseDef)(x2._def, {
            ...refs,
            currentPath: [...refs.currentPath, "items", `${i2}`]
          })).reduce((acc, x2) => x2 === void 0 ? acc : [...acc, x2], [])
        };
      }
    }
    exports.parseTupleDef = parseTupleDef2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parsers/undefined.js
var require_undefined = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parsers/undefined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseUndefinedDef = void 0;
    var any_js_1 = require_any();
    function parseUndefinedDef2(refs) {
      return {
        not: (0, any_js_1.parseAnyDef)(refs)
      };
    }
    exports.parseUndefinedDef = parseUndefinedDef2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parsers/unknown.js
var require_unknown = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parsers/unknown.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseUnknownDef = void 0;
    var any_js_1 = require_any();
    function parseUnknownDef2(refs) {
      return (0, any_js_1.parseAnyDef)(refs);
    }
    exports.parseUnknownDef = parseUnknownDef2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parsers/readonly.js
var require_readonly = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parsers/readonly.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseReadonlyDef = void 0;
    var parseDef_js_1 = require_parseDef();
    var parseReadonlyDef2 = (def, refs) => {
      return (0, parseDef_js_1.parseDef)(def.innerType._def, refs);
    };
    exports.parseReadonlyDef = parseReadonlyDef2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/selectParser.js
var require_selectParser = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/selectParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.selectParser = void 0;
    var zod_1 = __require("zod");
    var any_js_1 = require_any();
    var array_js_1 = require_array();
    var bigint_js_1 = require_bigint();
    var boolean_js_1 = require_boolean();
    var branded_js_1 = require_branded();
    var catch_js_1 = require_catch();
    var date_js_1 = require_date();
    var default_js_1 = require_default();
    var effects_js_1 = require_effects();
    var enum_js_1 = require_enum();
    var intersection_js_1 = require_intersection();
    var literal_js_1 = require_literal();
    var map_js_1 = require_map();
    var nativeEnum_js_1 = require_nativeEnum();
    var never_js_1 = require_never();
    var null_js_1 = require_null();
    var nullable_js_1 = require_nullable();
    var number_js_1 = require_number();
    var object_js_1 = require_object();
    var optional_js_1 = require_optional();
    var pipeline_js_1 = require_pipeline();
    var promise_js_1 = require_promise();
    var record_js_1 = require_record();
    var set_js_1 = require_set();
    var string_js_1 = require_string();
    var tuple_js_1 = require_tuple();
    var undefined_js_1 = require_undefined();
    var union_js_1 = require_union();
    var unknown_js_1 = require_unknown();
    var readonly_js_1 = require_readonly();
    var selectParser2 = (def, typeName, refs) => {
      switch (typeName) {
        case zod_1.ZodFirstPartyTypeKind.ZodString:
          return (0, string_js_1.parseStringDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodNumber:
          return (0, number_js_1.parseNumberDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodObject:
          return (0, object_js_1.parseObjectDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodBigInt:
          return (0, bigint_js_1.parseBigintDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodBoolean:
          return (0, boolean_js_1.parseBooleanDef)();
        case zod_1.ZodFirstPartyTypeKind.ZodDate:
          return (0, date_js_1.parseDateDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodUndefined:
          return (0, undefined_js_1.parseUndefinedDef)(refs);
        case zod_1.ZodFirstPartyTypeKind.ZodNull:
          return (0, null_js_1.parseNullDef)(refs);
        case zod_1.ZodFirstPartyTypeKind.ZodArray:
          return (0, array_js_1.parseArrayDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodUnion:
        case zod_1.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
          return (0, union_js_1.parseUnionDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodIntersection:
          return (0, intersection_js_1.parseIntersectionDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodTuple:
          return (0, tuple_js_1.parseTupleDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodRecord:
          return (0, record_js_1.parseRecordDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodLiteral:
          return (0, literal_js_1.parseLiteralDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodEnum:
          return (0, enum_js_1.parseEnumDef)(def);
        case zod_1.ZodFirstPartyTypeKind.ZodNativeEnum:
          return (0, nativeEnum_js_1.parseNativeEnumDef)(def);
        case zod_1.ZodFirstPartyTypeKind.ZodNullable:
          return (0, nullable_js_1.parseNullableDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodOptional:
          return (0, optional_js_1.parseOptionalDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodMap:
          return (0, map_js_1.parseMapDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodSet:
          return (0, set_js_1.parseSetDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodLazy:
          return () => def.getter()._def;
        case zod_1.ZodFirstPartyTypeKind.ZodPromise:
          return (0, promise_js_1.parsePromiseDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodNaN:
        case zod_1.ZodFirstPartyTypeKind.ZodNever:
          return (0, never_js_1.parseNeverDef)(refs);
        case zod_1.ZodFirstPartyTypeKind.ZodEffects:
          return (0, effects_js_1.parseEffectsDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodAny:
          return (0, any_js_1.parseAnyDef)(refs);
        case zod_1.ZodFirstPartyTypeKind.ZodUnknown:
          return (0, unknown_js_1.parseUnknownDef)(refs);
        case zod_1.ZodFirstPartyTypeKind.ZodDefault:
          return (0, default_js_1.parseDefaultDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodBranded:
          return (0, branded_js_1.parseBrandedDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodReadonly:
          return (0, readonly_js_1.parseReadonlyDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodCatch:
          return (0, catch_js_1.parseCatchDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodPipeline:
          return (0, pipeline_js_1.parsePipelineDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodFunction:
        case zod_1.ZodFirstPartyTypeKind.ZodVoid:
        case zod_1.ZodFirstPartyTypeKind.ZodSymbol:
          return void 0;
        default:
          return /* @__PURE__ */ ((_2) => void 0)(typeName);
      }
    };
    exports.selectParser = selectParser2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parseDef.js
var require_parseDef = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parseDef.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseDef = void 0;
    var Options_js_1 = require_Options();
    var selectParser_js_1 = require_selectParser();
    var getRelativePath_js_1 = require_getRelativePath();
    var any_js_1 = require_any();
    function parseDef2(def, refs, forceResolution = false) {
      const seenItem = refs.seen.get(def);
      if (refs.override) {
        const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
        if (overrideResult !== Options_js_1.ignoreOverride) {
          return overrideResult;
        }
      }
      if (seenItem && !forceResolution) {
        const seenSchema = get$ref2(seenItem, refs);
        if (seenSchema !== void 0) {
          return seenSchema;
        }
      }
      const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
      refs.seen.set(def, newItem);
      const jsonSchemaOrGetter = (0, selectParser_js_1.selectParser)(def, def.typeName, refs);
      const jsonSchema = typeof jsonSchemaOrGetter === "function" ? parseDef2(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
      if (jsonSchema) {
        addMeta2(def, refs, jsonSchema);
      }
      if (refs.postProcess) {
        const postProcessResult = refs.postProcess(jsonSchema, def, refs);
        newItem.jsonSchema = jsonSchema;
        return postProcessResult;
      }
      newItem.jsonSchema = jsonSchema;
      return jsonSchema;
    }
    exports.parseDef = parseDef2;
    var get$ref2 = (item, refs) => {
      switch (refs.$refStrategy) {
        case "root":
          return { $ref: item.path.join("/") };
        case "relative":
          return { $ref: (0, getRelativePath_js_1.getRelativePath)(refs.currentPath, item.path) };
        case "none":
        case "seen": {
          if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
            console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
            return (0, any_js_1.parseAnyDef)(refs);
          }
          return refs.$refStrategy === "seen" ? (0, any_js_1.parseAnyDef)(refs) : void 0;
        }
      }
    };
    var addMeta2 = (def, refs, jsonSchema) => {
      if (def.description) {
        jsonSchema.description = def.description;
        if (refs.markdownDescription) {
          jsonSchema.markdownDescription = def.description;
        }
      }
      return jsonSchema;
    };
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/parseTypes.js
var require_parseTypes = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/parseTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/zodToJsonSchema.js
var require_zodToJsonSchema = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/zodToJsonSchema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zodToJsonSchema = void 0;
    var parseDef_js_1 = require_parseDef();
    var Refs_js_1 = require_Refs();
    var any_js_1 = require_any();
    var zodToJsonSchema2 = (schema, options) => {
      const refs = (0, Refs_js_1.getRefs)(options);
      let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name2, schema2]) => ({
        ...acc,
        [name2]: (0, parseDef_js_1.parseDef)(schema2._def, {
          ...refs,
          currentPath: [...refs.basePath, refs.definitionPath, name2]
        }, true) ?? (0, any_js_1.parseAnyDef)(refs)
      }), {}) : void 0;
      const name = typeof options === "string" ? options : options?.nameStrategy === "title" ? void 0 : options?.name;
      const main = (0, parseDef_js_1.parseDef)(schema._def, name === void 0 ? refs : {
        ...refs,
        currentPath: [...refs.basePath, refs.definitionPath, name]
      }, false) ?? (0, any_js_1.parseAnyDef)(refs);
      const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
      if (title !== void 0) {
        main.title = title;
      }
      if (refs.flags.hasReferencedOpenAiAnyType) {
        if (!definitions) {
          definitions = {};
        }
        if (!definitions[refs.openAiAnyTypeName]) {
          definitions[refs.openAiAnyTypeName] = {
            // Skipping "object" as no properties can be defined and additionalProperties must be "false"
            type: ["string", "number", "integer", "boolean", "array", "null"],
            items: {
              $ref: refs.$refStrategy === "relative" ? "1" : [
                ...refs.basePath,
                refs.definitionPath,
                refs.openAiAnyTypeName
              ].join("/")
            }
          };
        }
      }
      const combined = name === void 0 ? definitions ? {
        ...main,
        [refs.definitionPath]: definitions
      } : main : {
        $ref: [
          ...refs.$refStrategy === "relative" ? [] : refs.basePath,
          refs.definitionPath,
          name
        ].join("/"),
        [refs.definitionPath]: {
          ...definitions,
          [name]: main
        }
      };
      if (refs.target === "jsonSchema7") {
        combined.$schema = "http://json-schema.org/draft-07/schema#";
      } else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") {
        combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
      }
      if (refs.target === "openAi" && ("anyOf" in combined || "oneOf" in combined || "allOf" in combined || "type" in combined && Array.isArray(combined.type))) {
        console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
      }
      return combined;
    };
    exports.zodToJsonSchema = zodToJsonSchema2;
  }
});

// ../node_modules/zod-to-json-schema/dist/cjs/index.js
var require_cjs = __commonJS({
  "../node_modules/zod-to-json-schema/dist/cjs/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_Options(), exports);
    __exportStar(require_Refs(), exports);
    __exportStar(require_errorMessages(), exports);
    __exportStar(require_getRelativePath(), exports);
    __exportStar(require_parseDef(), exports);
    __exportStar(require_parseTypes(), exports);
    __exportStar(require_any(), exports);
    __exportStar(require_array(), exports);
    __exportStar(require_bigint(), exports);
    __exportStar(require_boolean(), exports);
    __exportStar(require_branded(), exports);
    __exportStar(require_catch(), exports);
    __exportStar(require_date(), exports);
    __exportStar(require_default(), exports);
    __exportStar(require_effects(), exports);
    __exportStar(require_enum(), exports);
    __exportStar(require_intersection(), exports);
    __exportStar(require_literal(), exports);
    __exportStar(require_map(), exports);
    __exportStar(require_nativeEnum(), exports);
    __exportStar(require_never(), exports);
    __exportStar(require_null(), exports);
    __exportStar(require_nullable(), exports);
    __exportStar(require_number(), exports);
    __exportStar(require_object(), exports);
    __exportStar(require_optional(), exports);
    __exportStar(require_pipeline(), exports);
    __exportStar(require_promise(), exports);
    __exportStar(require_readonly(), exports);
    __exportStar(require_record(), exports);
    __exportStar(require_set(), exports);
    __exportStar(require_string(), exports);
    __exportStar(require_tuple(), exports);
    __exportStar(require_undefined(), exports);
    __exportStar(require_union(), exports);
    __exportStar(require_unknown(), exports);
    __exportStar(require_selectParser(), exports);
    __exportStar(require_zodToJsonSchema(), exports);
    var zodToJsonSchema_js_1 = require_zodToJsonSchema();
    exports.default = zodToJsonSchema_js_1.zodToJsonSchema;
  }
});

// ../node_modules/@mistralai/mistralai/extra/structChat.js
var require_structChat = __commonJS({
  "../node_modules/@mistralai/mistralai/extra/structChat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.transformToChatCompletionRequest = transformToChatCompletionRequest;
    exports.convertToParsedChatCompletionResponse = convertToParsedChatCompletionResponse;
    exports.responseFormatFromZodObject = responseFormatFromZodObject;
    var zod_to_json_schema_1 = require_cjs();
    function transformToChatCompletionRequest(parsedRequest) {
      const { responseFormat, ...rest } = parsedRequest;
      const transformedResponseFormat = responseFormatFromZodObject(responseFormat);
      return {
        ...rest,
        responseFormat: transformedResponseFormat
      };
    }
    function convertToParsedChatCompletionResponse(response, responseFormat) {
      if (response.choices === void 0 || response.choices.length === 0) {
        return {
          ...response,
          choices: response.choices === void 0 ? void 0 : []
        };
      }
      const parsedChoices = [];
      for (const _choice of response.choices) {
        if (_choice.message === null || typeof _choice.message === "undefined") {
          parsedChoices.push({ ..._choice, message: void 0 });
        } else {
          if (_choice.message.content !== null && typeof _choice.message.content !== "undefined" && !Array.isArray(_choice.message.content)) {
            parsedChoices.push({
              ..._choice,
              message: {
                ..._choice.message,
                parsed: responseFormat.safeParse(JSON.parse(_choice.message.content)).data
              }
            });
          }
        }
      }
      return {
        ...response,
        choices: parsedChoices
      };
    }
    function responseFormatFromZodObject(responseFormat) {
      const responseJsonSchema = (0, zod_to_json_schema_1.zodToJsonSchema)(responseFormat);
      const placeholderName = "placeholderName";
      return {
        type: "json_schema",
        jsonSchema: {
          name: placeholderName,
          schemaDefinition: responseJsonSchema,
          strict: true
        }
      };
    }
  }
});

// ../node_modules/@mistralai/mistralai/sdk/chat.js
var require_chat = __commonJS({
  "../node_modules/@mistralai/mistralai/sdk/chat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Chat = void 0;
    var chatComplete_js_1 = require_chatComplete();
    var chatStream_js_1 = require_chatStream();
    var sdks_js_1 = require_sdks();
    var fp_js_1 = require_fp();
    var structChat_js_1 = require_structChat();
    var Chat3 = class extends sdks_js_1.ClientSDK {
      // #region sdk-class-body
      /**
       * Chat Completion with the response parsed in the same format as the input requestFormat.
       *
       * @remarks
       * The response will be parsed back to the initial Zod object passed in the requestFormat field.
       */
      async parse(request, options) {
        const ccr_request = (0, structChat_js_1.transformToChatCompletionRequest)(request);
        const response = await (0, fp_js_1.unwrapAsync)((0, chatComplete_js_1.chatComplete)(this, ccr_request, options));
        const parsed_response = (0, structChat_js_1.convertToParsedChatCompletionResponse)(response, request.responseFormat);
        return parsed_response;
      }
      /**
       * Stream chat completion with a parsed request input.
       *
       * @remarks
       * Unlike the .parse method, this method will return a stream of events containing the JSON response. It will not be parsed back to the initial Zod object.
       * If you need to parse the stream, see the examples/src/async_structured_outputs.ts file.
       */
      async parseStream(request, options) {
        const ccr_request = (0, structChat_js_1.transformToChatCompletionRequest)(request);
        return (0, fp_js_1.unwrapAsync)((0, chatStream_js_1.chatStream)(this, ccr_request, options));
      }
      // #endregion sdk-class-body
      /**
       * Chat Completion
       */
      async complete(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, chatComplete_js_1.chatComplete)(this, request, options));
      }
      /**
       * Stream chat completion
       *
       * @remarks
       * Mistral AI provides the ability to stream responses back to a client in order to allow partial results for certain requests. Tokens will be sent as data-only server-sent events as they become available, with the stream terminated by a data: [DONE] message. Otherwise, the server will hold the request open until the timeout or until completion, with the response containing the full result as JSON.
       */
      async stream(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, chatStream_js_1.chatStream)(this, request, options));
      }
    };
    exports.Chat = Chat3;
  }
});

// ../node_modules/@mistralai/mistralai/funcs/classifiersClassify.js
var require_classifiersClassify = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/classifiersClassify.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.classifiersClassify = classifiersClassify;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var async_js_1 = require_async();
    function classifiersClassify(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => components.ClassificationRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = (0, encodings_js_1.encodeJSON)("body", payload, { explode: true });
      const path2 = (0, url_js_1.pathToFunc)("/v1/classifications")();
      const headers = new Headers((0, primitives_js_1.compactMap)({
        "Content-Type": "application/json",
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "classifications_v1_classifications_post",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.ClassificationResponse$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/classifiersClassifyChat.js
var require_classifiersClassifyChat = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/classifiersClassifyChat.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.classifiersClassifyChat = classifiersClassifyChat;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var async_js_1 = require_async();
    function classifiersClassifyChat(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => components.ChatClassificationRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = (0, encodings_js_1.encodeJSON)("body", payload, { explode: true });
      const path2 = (0, url_js_1.pathToFunc)("/v1/chat/classifications")();
      const headers = new Headers((0, primitives_js_1.compactMap)({
        "Content-Type": "application/json",
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "chat_classifications_v1_chat_classifications_post",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.ClassificationResponse$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/classifiersModerate.js
var require_classifiersModerate = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/classifiersModerate.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.classifiersModerate = classifiersModerate;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var async_js_1 = require_async();
    function classifiersModerate(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => components.ClassificationRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = (0, encodings_js_1.encodeJSON)("body", payload, { explode: true });
      const path2 = (0, url_js_1.pathToFunc)("/v1/moderations")();
      const headers = new Headers((0, primitives_js_1.compactMap)({
        "Content-Type": "application/json",
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "moderations_v1_moderations_post",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.ModerationResponse$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/classifiersModerateChat.js
var require_classifiersModerateChat = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/classifiersModerateChat.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.classifiersModerateChat = classifiersModerateChat;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var async_js_1 = require_async();
    function classifiersModerateChat(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => components.ChatModerationRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = (0, encodings_js_1.encodeJSON)("body", payload, { explode: true });
      const path2 = (0, url_js_1.pathToFunc)("/v1/chat/moderations")();
      const headers = new Headers((0, primitives_js_1.compactMap)({
        "Content-Type": "application/json",
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "chat_moderations_v1_chat_moderations_post",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.ModerationResponse$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/sdk/classifiers.js
var require_classifiers = __commonJS({
  "../node_modules/@mistralai/mistralai/sdk/classifiers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Classifiers = void 0;
    var classifiersClassify_js_1 = require_classifiersClassify();
    var classifiersClassifyChat_js_1 = require_classifiersClassifyChat();
    var classifiersModerate_js_1 = require_classifiersModerate();
    var classifiersModerateChat_js_1 = require_classifiersModerateChat();
    var sdks_js_1 = require_sdks();
    var fp_js_1 = require_fp();
    var Classifiers = class extends sdks_js_1.ClientSDK {
      /**
       * Moderations
       */
      async moderate(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, classifiersModerate_js_1.classifiersModerate)(this, request, options));
      }
      /**
       * Chat Moderations
       */
      async moderateChat(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, classifiersModerateChat_js_1.classifiersModerateChat)(this, request, options));
      }
      /**
       * Classifications
       */
      async classify(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, classifiersClassify_js_1.classifiersClassify)(this, request, options));
      }
      /**
       * Chat Classifications
       */
      async classifyChat(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, classifiersClassifyChat_js_1.classifiersClassifyChat)(this, request, options));
      }
    };
    exports.Classifiers = Classifiers;
  }
});

// ../node_modules/@mistralai/mistralai/funcs/embeddingsCreate.js
var require_embeddingsCreate = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/embeddingsCreate.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.embeddingsCreate = embeddingsCreate;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var async_js_1 = require_async();
    function embeddingsCreate(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => components.EmbeddingRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = (0, encodings_js_1.encodeJSON)("body", payload, { explode: true });
      const path2 = (0, url_js_1.pathToFunc)("/v1/embeddings")();
      const headers = new Headers((0, primitives_js_1.compactMap)({
        "Content-Type": "application/json",
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "embeddings_v1_embeddings_post",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.EmbeddingResponse$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/sdk/embeddings.js
var require_embeddings = __commonJS({
  "../node_modules/@mistralai/mistralai/sdk/embeddings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Embeddings = void 0;
    var embeddingsCreate_js_1 = require_embeddingsCreate();
    var sdks_js_1 = require_sdks();
    var fp_js_1 = require_fp();
    var Embeddings2 = class extends sdks_js_1.ClientSDK {
      /**
       * Embeddings
       *
       * @remarks
       * Embeddings
       */
      async create(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, embeddingsCreate_js_1.embeddingsCreate)(this, request, options));
      }
    };
    exports.Embeddings = Embeddings2;
  }
});

// ../node_modules/@mistralai/mistralai/funcs/filesDelete.js
var require_filesDelete = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/filesDelete.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filesDelete = filesDelete;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function filesDelete(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.FilesApiRoutesDeleteFileRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const pathParams = {
        file_id: (0, encodings_js_1.encodeSimple)("file_id", payload.file_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/files/{file_id}")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "files_api_routes_delete_file",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "DELETE",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const [result] = await M2.match(M2.json(200, components.DeleteFileOut$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response);
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/filesDownload.js
var require_filesDownload = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/filesDownload.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filesDownload = filesDownload;
    var z4 = __importStar(__require("zod"));
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function filesDownload(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.FilesApiRoutesDownloadFileRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const pathParams = {
        file_id: (0, encodings_js_1.encodeSimple)("file_id", payload.file_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/files/{file_id}/content")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/octet-stream"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "files_api_routes_download_file",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "GET",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const [result] = await M2.match(M2.stream(200, z4.instanceof(ReadableStream)), M2.fail("4XX"), M2.fail("5XX"))(response);
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/filesGetSignedUrl.js
var require_filesGetSignedUrl = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/filesGetSignedUrl.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filesGetSignedUrl = filesGetSignedUrl;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function filesGetSignedUrl(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.FilesApiRoutesGetSignedUrlRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const pathParams = {
        file_id: (0, encodings_js_1.encodeSimple)("file_id", payload.file_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/files/{file_id}/url")(pathParams);
      const query = (0, encodings_js_1.encodeFormQuery)({
        "expiry": payload.expiry
      });
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "files_api_routes_get_signed_url",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "GET",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        query,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const [result] = await M2.match(M2.json(200, components.FileSignedURL$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response);
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/filesList.js
var require_filesList = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/filesList.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filesList = filesList;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function filesList(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.FilesApiRoutesListFilesRequest$outboundSchema.optional().parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const path2 = (0, url_js_1.pathToFunc)("/v1/files")();
      const query = (0, encodings_js_1.encodeFormQuery)({
        "page": payload?.page,
        "page_size": payload?.page_size,
        "purpose": payload?.purpose,
        "sample_type": payload?.sample_type,
        "search": payload?.search,
        "source": payload?.source
      });
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "files_api_routes_list_files",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "GET",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        query,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const [result] = await M2.match(M2.json(200, components.ListFilesOut$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response);
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/filesRetrieve.js
var require_filesRetrieve = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/filesRetrieve.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filesRetrieve = filesRetrieve;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function filesRetrieve(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.FilesApiRoutesRetrieveFileRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const pathParams = {
        file_id: (0, encodings_js_1.encodeSimple)("file_id", payload.file_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/files/{file_id}")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "files_api_routes_retrieve_file",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "GET",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const [result] = await M2.match(M2.json(200, components.RetrieveFileOut$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response);
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/filesUpload.js
var require_filesUpload = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/filesUpload.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filesUpload = filesUpload;
    var encodings_js_1 = require_encodings();
    var files_js_1 = require_files();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    var blobs_js_1 = require_blobs();
    var streams_js_1 = require_streams();
    function filesUpload(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.FilesApiRoutesUploadFileMultiPartBodyParams$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = new FormData();
      if ((0, blobs_js_1.isBlobLike)(payload.file)) {
        (0, encodings_js_1.appendForm)(body, "file", payload.file);
      } else if ((0, streams_js_1.isReadableStream)(payload.file.content)) {
        const buffer = await (0, files_js_1.readableStreamToArrayBuffer)(payload.file.content);
        const blob = new Blob([buffer], { type: "application/octet-stream" });
        (0, encodings_js_1.appendForm)(body, "file", blob);
      } else {
        (0, encodings_js_1.appendForm)(body, "file", new Blob([payload.file.content], { type: "application/octet-stream" }), payload.file.fileName);
      }
      if (payload.purpose !== void 0) {
        (0, encodings_js_1.appendForm)(body, "purpose", payload.purpose);
      }
      const path2 = (0, url_js_1.pathToFunc)("/v1/files")();
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "files_api_routes_upload_file",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const [result] = await M2.match(M2.json(200, components.UploadFileOut$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response);
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/sdk/files.js
var require_files2 = __commonJS({
  "../node_modules/@mistralai/mistralai/sdk/files.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Files = void 0;
    var filesDelete_js_1 = require_filesDelete();
    var filesDownload_js_1 = require_filesDownload();
    var filesGetSignedUrl_js_1 = require_filesGetSignedUrl();
    var filesList_js_1 = require_filesList();
    var filesRetrieve_js_1 = require_filesRetrieve();
    var filesUpload_js_1 = require_filesUpload();
    var sdks_js_1 = require_sdks();
    var fp_js_1 = require_fp();
    var Files3 = class extends sdks_js_1.ClientSDK {
      /**
       * Upload File
       *
       * @remarks
       * Upload a file that can be used across various endpoints.
       *
       * The size of individual files can be a maximum of 512 MB. The Fine-tuning API only supports .jsonl files.
       *
       * Please contact us if you need to increase these storage limits.
       */
      async upload(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, filesUpload_js_1.filesUpload)(this, request, options));
      }
      /**
       * List Files
       *
       * @remarks
       * Returns a list of files that belong to the user's organization.
       */
      async list(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, filesList_js_1.filesList)(this, request, options));
      }
      /**
       * Retrieve File
       *
       * @remarks
       * Returns information about a specific file.
       */
      async retrieve(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, filesRetrieve_js_1.filesRetrieve)(this, request, options));
      }
      /**
       * Delete File
       *
       * @remarks
       * Delete a file.
       */
      async delete(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, filesDelete_js_1.filesDelete)(this, request, options));
      }
      /**
       * Download File
       *
       * @remarks
       * Download a file
       */
      async download(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, filesDownload_js_1.filesDownload)(this, request, options));
      }
      /**
       * Get Signed Url
       */
      async getSignedUrl(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, filesGetSignedUrl_js_1.filesGetSignedUrl)(this, request, options));
      }
    };
    exports.Files = Files3;
  }
});

// ../node_modules/@mistralai/mistralai/funcs/fimComplete.js
var require_fimComplete = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/fimComplete.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fimComplete = fimComplete;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var async_js_1 = require_async();
    function fimComplete(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => components.FIMCompletionRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = (0, encodings_js_1.encodeJSON)("body", payload, { explode: true });
      const path2 = (0, url_js_1.pathToFunc)("/v1/fim/completions")();
      const headers = new Headers((0, primitives_js_1.compactMap)({
        "Content-Type": "application/json",
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "fim_completion_v1_fim_completions_post",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.FIMCompletionResponse$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/fimStream.js
var require_fimStream = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/fimStream.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fimStream = fimStream;
    var z4 = __importStar(__require("zod"));
    var encodings_js_1 = require_encodings();
    var event_streams_js_1 = require_event_streams();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var async_js_1 = require_async();
    function fimStream(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => components.FIMCompletionStreamRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = (0, encodings_js_1.encodeJSON)("body", payload, { explode: true });
      const path2 = (0, url_js_1.pathToFunc)("/v1/fim/completions#stream")();
      const headers = new Headers((0, primitives_js_1.compactMap)({
        "Content-Type": "application/json",
        Accept: "text/event-stream"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "stream_fim",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.sse(200, z4.instanceof(ReadableStream).transform((stream) => {
        return new event_streams_js_1.EventStream({
          stream,
          decoder(rawEvent) {
            const schema = components.CompletionEvent$inboundSchema;
            return schema.parse(rawEvent);
          }
        });
      }), { sseSentinel: "[DONE]" }), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/sdk/fim.js
var require_fim = __commonJS({
  "../node_modules/@mistralai/mistralai/sdk/fim.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Fim = void 0;
    var fimComplete_js_1 = require_fimComplete();
    var fimStream_js_1 = require_fimStream();
    var sdks_js_1 = require_sdks();
    var fp_js_1 = require_fp();
    var Fim = class extends sdks_js_1.ClientSDK {
      /**
       * Fim Completion
       *
       * @remarks
       * FIM completion.
       */
      async complete(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, fimComplete_js_1.fimComplete)(this, request, options));
      }
      /**
       * Stream fim completion
       *
       * @remarks
       * Mistral AI provides the ability to stream responses back to a client in order to allow partial results for certain requests. Tokens will be sent as data-only server-sent events as they become available, with the stream terminated by a data: [DONE] message. Otherwise, the server will hold the request open until the timeout or until completion, with the response containing the full result as JSON.
       */
      async stream(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, fimStream_js_1.fimStream)(this, request, options));
      }
    };
    exports.Fim = Fim;
  }
});

// ../node_modules/@mistralai/mistralai/funcs/fineTuningJobsCancel.js
var require_fineTuningJobsCancel = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/fineTuningJobsCancel.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fineTuningJobsCancel = fineTuningJobsCancel;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function fineTuningJobsCancel(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.JobsApiRoutesFineTuningCancelFineTuningJobRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const pathParams = {
        job_id: (0, encodings_js_1.encodeSimple)("job_id", payload.job_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/fine_tuning/jobs/{job_id}/cancel")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "jobs_api_routes_fine_tuning_cancel_fine_tuning_job",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const [result] = await M2.match(M2.json(200, operations.JobsApiRoutesFineTuningCancelFineTuningJobResponse$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response);
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/fineTuningJobsCreate.js
var require_fineTuningJobsCreate = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/fineTuningJobsCreate.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fineTuningJobsCreate = fineTuningJobsCreate;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function fineTuningJobsCreate(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => components.JobIn$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = (0, encodings_js_1.encodeJSON)("body", payload, { explode: true });
      const path2 = (0, url_js_1.pathToFunc)("/v1/fine_tuning/jobs")();
      const headers = new Headers((0, primitives_js_1.compactMap)({
        "Content-Type": "application/json",
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "jobs_api_routes_fine_tuning_create_fine_tuning_job",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const [result] = await M2.match(M2.json(200, operations.JobsApiRoutesFineTuningCreateFineTuningJobResponse$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response);
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/fineTuningJobsGet.js
var require_fineTuningJobsGet = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/fineTuningJobsGet.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fineTuningJobsGet = fineTuningJobsGet;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function fineTuningJobsGet(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.JobsApiRoutesFineTuningGetFineTuningJobRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const pathParams = {
        job_id: (0, encodings_js_1.encodeSimple)("job_id", payload.job_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/fine_tuning/jobs/{job_id}")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "jobs_api_routes_fine_tuning_get_fine_tuning_job",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "GET",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const [result] = await M2.match(M2.json(200, operations.JobsApiRoutesFineTuningGetFineTuningJobResponse$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response);
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/fineTuningJobsList.js
var require_fineTuningJobsList = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/fineTuningJobsList.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fineTuningJobsList = fineTuningJobsList;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function fineTuningJobsList(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.JobsApiRoutesFineTuningGetFineTuningJobsRequest$outboundSchema.optional().parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const path2 = (0, url_js_1.pathToFunc)("/v1/fine_tuning/jobs")();
      const query = (0, encodings_js_1.encodeFormQuery)({
        "created_after": payload?.created_after,
        "created_before": payload?.created_before,
        "created_by_me": payload?.created_by_me,
        "model": payload?.model,
        "page": payload?.page,
        "page_size": payload?.page_size,
        "status": payload?.status,
        "suffix": payload?.suffix,
        "wandb_name": payload?.wandb_name,
        "wandb_project": payload?.wandb_project
      });
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "jobs_api_routes_fine_tuning_get_fine_tuning_jobs",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "GET",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        query,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const [result] = await M2.match(M2.json(200, components.JobsOut$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response);
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/fineTuningJobsStart.js
var require_fineTuningJobsStart = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/fineTuningJobsStart.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fineTuningJobsStart = fineTuningJobsStart;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function fineTuningJobsStart(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.JobsApiRoutesFineTuningStartFineTuningJobRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const pathParams = {
        job_id: (0, encodings_js_1.encodeSimple)("job_id", payload.job_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/fine_tuning/jobs/{job_id}/start")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "jobs_api_routes_fine_tuning_start_fine_tuning_job",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const [result] = await M2.match(M2.json(200, operations.JobsApiRoutesFineTuningStartFineTuningJobResponse$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response);
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/sdk/jobs.js
var require_jobs = __commonJS({
  "../node_modules/@mistralai/mistralai/sdk/jobs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Jobs = void 0;
    var fineTuningJobsCancel_js_1 = require_fineTuningJobsCancel();
    var fineTuningJobsCreate_js_1 = require_fineTuningJobsCreate();
    var fineTuningJobsGet_js_1 = require_fineTuningJobsGet();
    var fineTuningJobsList_js_1 = require_fineTuningJobsList();
    var fineTuningJobsStart_js_1 = require_fineTuningJobsStart();
    var sdks_js_1 = require_sdks();
    var fp_js_1 = require_fp();
    var Jobs = class extends sdks_js_1.ClientSDK {
      /**
       * Get Fine Tuning Jobs
       *
       * @remarks
       * Get a list of fine-tuning jobs for your organization and user.
       */
      async list(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, fineTuningJobsList_js_1.fineTuningJobsList)(this, request, options));
      }
      /**
       * Create Fine Tuning Job
       *
       * @remarks
       * Create a new fine-tuning job, it will be queued for processing.
       */
      async create(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, fineTuningJobsCreate_js_1.fineTuningJobsCreate)(this, request, options));
      }
      /**
       * Get Fine Tuning Job
       *
       * @remarks
       * Get a fine-tuned job details by its UUID.
       */
      async get(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, fineTuningJobsGet_js_1.fineTuningJobsGet)(this, request, options));
      }
      /**
       * Cancel Fine Tuning Job
       *
       * @remarks
       * Request the cancellation of a fine tuning job.
       */
      async cancel(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, fineTuningJobsCancel_js_1.fineTuningJobsCancel)(this, request, options));
      }
      /**
       * Start Fine Tuning Job
       *
       * @remarks
       * Request the start of a validated fine tuning job.
       */
      async start(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, fineTuningJobsStart_js_1.fineTuningJobsStart)(this, request, options));
      }
    };
    exports.Jobs = Jobs;
  }
});

// ../node_modules/@mistralai/mistralai/sdk/finetuning.js
var require_finetuning = __commonJS({
  "../node_modules/@mistralai/mistralai/sdk/finetuning.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FineTuning = void 0;
    var sdks_js_1 = require_sdks();
    var jobs_js_1 = require_jobs();
    var FineTuning = class extends sdks_js_1.ClientSDK {
      get jobs() {
        return this._jobs ?? (this._jobs = new jobs_js_1.Jobs(this._options));
      }
    };
    exports.FineTuning = FineTuning;
  }
});

// ../node_modules/@mistralai/mistralai/funcs/modelsArchive.js
var require_modelsArchive = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/modelsArchive.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.modelsArchive = modelsArchive;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function modelsArchive(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.JobsApiRoutesFineTuningArchiveFineTunedModelRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const pathParams = {
        model_id: (0, encodings_js_1.encodeSimple)("model_id", payload.model_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/fine_tuning/models/{model_id}/archive")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "jobs_api_routes_fine_tuning_archive_fine_tuned_model",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const [result] = await M2.match(M2.json(200, components.ArchiveFTModelOut$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response);
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/modelsDelete.js
var require_modelsDelete = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/modelsDelete.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.modelsDelete = modelsDelete;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function modelsDelete(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.DeleteModelV1ModelsModelIdDeleteRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const pathParams = {
        model_id: (0, encodings_js_1.encodeSimple)("model_id", payload.model_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/models/{model_id}")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "delete_model_v1_models__model_id__delete",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "DELETE",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.DeleteModelOut$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/modelsList.js
var require_modelsList = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/modelsList.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.modelsList = modelsList;
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var async_js_1 = require_async();
    function modelsList(client, options) {
      return new async_js_1.APIPromise($do(client, options));
    }
    async function $do(client, options) {
      const path2 = (0, url_js_1.pathToFunc)("/v1/models")();
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "list_models_v1_models_get",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "GET",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.ModelList$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/modelsRetrieve.js
var require_modelsRetrieve = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/modelsRetrieve.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.modelsRetrieve = modelsRetrieve;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var errors = __importStar(require_errors());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function modelsRetrieve(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.RetrieveModelV1ModelsModelIdGetRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const pathParams = {
        model_id: (0, encodings_js_1.encodeSimple)("model_id", payload.model_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/models/{model_id}")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "retrieve_model_v1_models__model_id__get",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "GET",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, operations.RetrieveModelV1ModelsModelIdGetResponseRetrieveModelV1ModelsModelIdGet$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/modelsUnarchive.js
var require_modelsUnarchive = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/modelsUnarchive.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.modelsUnarchive = modelsUnarchive;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function modelsUnarchive(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.JobsApiRoutesFineTuningUnarchiveFineTunedModelRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = null;
      const pathParams = {
        model_id: (0, encodings_js_1.encodeSimple)("model_id", payload.model_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/fine_tuning/models/{model_id}/archive")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "jobs_api_routes_fine_tuning_unarchive_fine_tuned_model",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "DELETE",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const [result] = await M2.match(M2.json(200, components.UnarchiveFTModelOut$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response);
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/funcs/modelsUpdate.js
var require_modelsUpdate = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/modelsUpdate.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.modelsUpdate = modelsUpdate;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var operations = __importStar(require_operations());
    var async_js_1 = require_async();
    function modelsUpdate(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => operations.JobsApiRoutesFineTuningUpdateFineTunedModelRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = (0, encodings_js_1.encodeJSON)("body", payload.UpdateFTModelIn, { explode: true });
      const pathParams = {
        model_id: (0, encodings_js_1.encodeSimple)("model_id", payload.model_id, {
          explode: false,
          charEncoding: "percent"
        })
      };
      const path2 = (0, url_js_1.pathToFunc)("/v1/fine_tuning/models/{model_id}")(pathParams);
      const headers = new Headers((0, primitives_js_1.compactMap)({
        "Content-Type": "application/json",
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "jobs_api_routes_fine_tuning_update_fine_tuned_model",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "PATCH",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const [result] = await M2.match(M2.json(200, operations.JobsApiRoutesFineTuningUpdateFineTunedModelResponse$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response);
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/sdk/models.js
var require_models = __commonJS({
  "../node_modules/@mistralai/mistralai/sdk/models.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Models = void 0;
    var modelsArchive_js_1 = require_modelsArchive();
    var modelsDelete_js_1 = require_modelsDelete();
    var modelsList_js_1 = require_modelsList();
    var modelsRetrieve_js_1 = require_modelsRetrieve();
    var modelsUnarchive_js_1 = require_modelsUnarchive();
    var modelsUpdate_js_1 = require_modelsUpdate();
    var sdks_js_1 = require_sdks();
    var fp_js_1 = require_fp();
    var Models5 = class extends sdks_js_1.ClientSDK {
      /**
       * List Models
       *
       * @remarks
       * List all models available to the user.
       */
      async list(options) {
        return (0, fp_js_1.unwrapAsync)((0, modelsList_js_1.modelsList)(this, options));
      }
      /**
       * Retrieve Model
       *
       * @remarks
       * Retrieve information about a model.
       */
      async retrieve(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, modelsRetrieve_js_1.modelsRetrieve)(this, request, options));
      }
      /**
       * Delete Model
       *
       * @remarks
       * Delete a fine-tuned model.
       */
      async delete(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, modelsDelete_js_1.modelsDelete)(this, request, options));
      }
      /**
       * Update Fine Tuned Model
       *
       * @remarks
       * Update a model name or description.
       */
      async update(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, modelsUpdate_js_1.modelsUpdate)(this, request, options));
      }
      /**
       * Archive Fine Tuned Model
       *
       * @remarks
       * Archive a fine-tuned model.
       */
      async archive(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, modelsArchive_js_1.modelsArchive)(this, request, options));
      }
      /**
       * Unarchive Fine Tuned Model
       *
       * @remarks
       * Un-archive a fine-tuned model.
       */
      async unarchive(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, modelsUnarchive_js_1.modelsUnarchive)(this, request, options));
      }
    };
    exports.Models = Models5;
  }
});

// ../node_modules/@mistralai/mistralai/funcs/ocrProcess.js
var require_ocrProcess = __commonJS({
  "../node_modules/@mistralai/mistralai/funcs/ocrProcess.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ocrProcess = ocrProcess;
    var encodings_js_1 = require_encodings();
    var M2 = __importStar(require_matchers());
    var primitives_js_1 = require_primitives();
    var schemas_js_1 = require_schemas();
    var security_js_1 = require_security();
    var url_js_1 = require_url();
    var components = __importStar(require_components());
    var errors = __importStar(require_errors());
    var async_js_1 = require_async();
    function ocrProcess(client, request, options) {
      return new async_js_1.APIPromise($do(client, request, options));
    }
    async function $do(client, request, options) {
      const parsed = (0, schemas_js_1.safeParse)(request, (value) => components.OCRRequest$outboundSchema.parse(value), "Input validation failed");
      if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
      }
      const payload = parsed.value;
      const body = (0, encodings_js_1.encodeJSON)("body", payload, { explode: true });
      const path2 = (0, url_js_1.pathToFunc)("/v1/ocr")();
      const headers = new Headers((0, primitives_js_1.compactMap)({
        "Content-Type": "application/json",
        Accept: "application/json"
      }));
      const secConfig = await (0, security_js_1.extractSecurity)(client._options.apiKey);
      const securityInput = secConfig == null ? {} : { apiKey: secConfig };
      const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
      const context = {
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "ocr_v1_ocr_post",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.apiKey,
        retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
      };
      const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        baseURL: options?.serverURL,
        path: path2,
        headers,
        body,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
      }, options);
      if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
      }
      const req = requestRes.value;
      const doResult = await client._do(req, {
        context,
        errorCodes: ["422", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes
      });
      if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
      }
      const response = doResult.value;
      const responseFields = {
        HttpMeta: { Response: response, Request: req }
      };
      const [result] = await M2.match(M2.json(200, components.OCRResponse$inboundSchema), M2.jsonErr(422, errors.HTTPValidationError$inboundSchema), M2.fail("4XX"), M2.fail("5XX"))(response, { extraFields: responseFields });
      if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
      }
      return [result, { status: "complete", request: req, response }];
    }
  }
});

// ../node_modules/@mistralai/mistralai/sdk/ocr.js
var require_ocr = __commonJS({
  "../node_modules/@mistralai/mistralai/sdk/ocr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Ocr = void 0;
    var ocrProcess_js_1 = require_ocrProcess();
    var sdks_js_1 = require_sdks();
    var fp_js_1 = require_fp();
    var Ocr = class extends sdks_js_1.ClientSDK {
      /**
       * OCR
       */
      async process(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, ocrProcess_js_1.ocrProcess)(this, request, options));
      }
    };
    exports.Ocr = Ocr;
  }
});

// ../node_modules/@mistralai/mistralai/sdk/sdk.js
var require_sdk = __commonJS({
  "../node_modules/@mistralai/mistralai/sdk/sdk.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Mistral = void 0;
    var sdks_js_1 = require_sdks();
    var agents_js_1 = require_agents();
    var audio_js_1 = require_audio();
    var batch_js_1 = require_batch();
    var beta_js_1 = require_beta();
    var chat_js_1 = require_chat();
    var classifiers_js_1 = require_classifiers();
    var embeddings_js_1 = require_embeddings();
    var files_js_1 = require_files2();
    var fim_js_1 = require_fim();
    var finetuning_js_1 = require_finetuning();
    var models_js_1 = require_models();
    var ocr_js_1 = require_ocr();
    var Mistral2 = class extends sdks_js_1.ClientSDK {
      get models() {
        return this._models ?? (this._models = new models_js_1.Models(this._options));
      }
      get beta() {
        return this._beta ?? (this._beta = new beta_js_1.Beta(this._options));
      }
      get files() {
        return this._files ?? (this._files = new files_js_1.Files(this._options));
      }
      get fineTuning() {
        return this._fineTuning ?? (this._fineTuning = new finetuning_js_1.FineTuning(this._options));
      }
      get batch() {
        return this._batch ?? (this._batch = new batch_js_1.Batch(this._options));
      }
      get chat() {
        return this._chat ?? (this._chat = new chat_js_1.Chat(this._options));
      }
      get fim() {
        return this._fim ?? (this._fim = new fim_js_1.Fim(this._options));
      }
      get agents() {
        return this._agents ?? (this._agents = new agents_js_1.Agents(this._options));
      }
      get embeddings() {
        return this._embeddings ?? (this._embeddings = new embeddings_js_1.Embeddings(this._options));
      }
      get classifiers() {
        return this._classifiers ?? (this._classifiers = new classifiers_js_1.Classifiers(this._options));
      }
      get ocr() {
        return this._ocr ?? (this._ocr = new ocr_js_1.Ocr(this._options));
      }
      get audio() {
        return this._audio ?? (this._audio = new audio_js_1.Audio(this._options));
      }
    };
    exports.Mistral = Mistral2;
  }
});

// ../node_modules/@mistralai/mistralai/index.js
var require_mistralai = __commonJS({
  "../node_modules/@mistralai/mistralai/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
    };
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.files = void 0;
    __exportStar(require_config(), exports);
    exports.files = __importStar(require_files());
    __exportStar(require_sdk(), exports);
  }
});

// src/agent/impl/QiCodeAgent.ts
import { create } from "@qi/base";

// src/prompt/impl/LangChainPromptHandler.ts
import { AIMessage, HumanMessage, SystemMessage } from "@langchain/core/messages";
import { ChatPromptTemplate, MessagesPlaceholder } from "@langchain/core/prompts";
var LangChainPromptHandler = class {
  baseHandler;
  templates = /* @__PURE__ */ new Map();
  constructor(baseHandler) {
    this.baseHandler = baseHandler;
    this.initializeTemplates();
  }
  /**
   * Initialize the handler with configuration (delegates to base handler)
   */
  async initialize(configPath, schemaPath) {
    return await this.baseHandler.initialize(configPath, schemaPath);
  }
  /**
   * Complete prompt with proper LangChain context integration
   */
  async completeWithContext(prompt, context, options = {}) {
    try {
      const templateType = options.templateType || "default";
      const template = this.templates.get(templateType);
      if (!template) {
        console.warn(`Template ${templateType} not found, falling back to base handler`);
        return await this.baseHandler.complete(prompt, options);
      }
      const conversationHistory = this.convertContextMessages([...context.messages]);
      const templateVariables = {
        domain: options.domain || "software development",
        context_type: context.type || "general",
        conversation_history: conversationHistory,
        current_input: prompt,
        ...this.extractAdditionalVariables(options)
      };
      const messages = await template.formatMessages(templateVariables);
      const formattedPrompt = this.messagesToString(messages);
      const result = await this.baseHandler.complete(formattedPrompt, options);
      if (result.success && typeof result === "object") {
        result.templateMetadata = {
          templateType,
          messageCount: messages.length,
          hasConversationHistory: conversationHistory.length > 0,
          formattedPromptLength: formattedPrompt.length
        };
      }
      return result;
    } catch (error) {
      console.error("LangChain template processing failed:", error);
      return await this.baseHandler.complete(prompt, options);
    }
  }
  /**
   * Create conversation-aware prompt using default template
   */
  async completeWithHistory(prompt, conversationHistory, options = {}) {
    const template = this.templates.get("default");
    if (!template) {
      return await this.baseHandler.complete(prompt, options);
    }
    try {
      const messages = await template.formatMessages({
        domain: options.domain || "general assistance",
        context_type: "conversation",
        conversation_history: this.convertContextMessages(conversationHistory),
        current_input: prompt
      });
      const formattedPrompt = this.messagesToString(messages);
      return await this.baseHandler.complete(formattedPrompt, options);
    } catch (error) {
      console.error("History-aware prompting failed:", error);
      return await this.baseHandler.complete(prompt, options);
    }
  }
  /**
   * Standard prompt completion (delegates to base handler)
   */
  async complete(prompt, options) {
    return this.baseHandler.complete(prompt, options);
  }
  /**
   * Get available providers (delegates to base handler)
   */
  async getAvailableProviders() {
    return this.baseHandler.getAvailableProviders();
  }
  /**
   * Validate provider (delegates to base handler)
   */
  async validateProvider(providerId) {
    return this.baseHandler.validateProvider(providerId);
  }
  /**
   * Get available template types
   */
  getAvailableTemplates() {
    return Array.from(this.templates.keys());
  }
  /**
   * Add custom template
   */
  addTemplate(name, template) {
    this.templates.set(name, template);
  }
  // Private methods
  /**
   * Initialize built-in templates
   */
  initializeTemplates() {
    this.templates.set(
      "default",
      ChatPromptTemplate.fromMessages([
        [
          "system",
          "You are a helpful AI assistant specialized in {domain}. Current context: {context_type}"
        ],
        new MessagesPlaceholder("conversation_history"),
        ["user", "{current_input}"]
      ])
    );
    this.templates.set(
      "coding",
      ChatPromptTemplate.fromMessages([
        [
          "system",
          "You are an expert software developer and coding assistant specialized in {domain}. You provide clear, practical advice and code examples. Current session context: {context_type}"
        ],
        new MessagesPlaceholder("conversation_history"),
        ["user", "{current_input}"]
      ])
    );
    this.templates.set(
      "problem-solving",
      ChatPromptTemplate.fromMessages([
        [
          "system",
          "You are a problem-solving assistant. Analyze the situation step by step, consider multiple approaches, and provide clear solutions. Domain: {domain}, Context: {context_type}"
        ],
        new MessagesPlaceholder("conversation_history"),
        ["user", "Problem to solve: {current_input}"]
      ])
    );
    this.templates.set(
      "educational",
      ChatPromptTemplate.fromMessages([
        [
          "system",
          "You are a patient and knowledgeable teacher specializing in {domain}. Break down complex concepts into understandable parts and provide examples. Context: {context_type}"
        ],
        new MessagesPlaceholder("conversation_history"),
        ["user", "I'd like to learn about: {current_input}"]
      ])
    );
    this.templates.set(
      "debugging",
      ChatPromptTemplate.fromMessages([
        [
          "system",
          "You are a debugging expert in {domain}. Help identify issues, provide systematic troubleshooting steps, and suggest fixes. Context: {context_type}"
        ],
        new MessagesPlaceholder("conversation_history"),
        ["user", "Debug this issue: {current_input}"]
      ])
    );
  }
  /**
   * Convert context messages to LangChain Message objects
   */
  convertContextMessages(contextMessages) {
    return contextMessages.map((msg) => {
      switch (msg.role) {
        case "user":
          return new HumanMessage({
            content: msg.content,
            additional_kwargs: {
              timestamp: msg.timestamp.toISOString(),
              id: msg.id,
              metadata: Object.fromEntries(msg.metadata || /* @__PURE__ */ new Map())
            }
          });
        case "assistant":
          return new AIMessage({
            content: msg.content,
            additional_kwargs: {
              timestamp: msg.timestamp.toISOString(),
              id: msg.id,
              metadata: Object.fromEntries(msg.metadata || /* @__PURE__ */ new Map())
            }
          });
        case "system":
          return new SystemMessage({
            content: msg.content,
            additional_kwargs: {
              timestamp: msg.timestamp.toISOString(),
              id: msg.id,
              metadata: Object.fromEntries(msg.metadata || /* @__PURE__ */ new Map())
            }
          });
        default:
          return new HumanMessage({
            content: msg.content,
            additional_kwargs: {
              timestamp: msg.timestamp.toISOString(),
              id: msg.id,
              role: msg.role,
              metadata: Object.fromEntries(msg.metadata || /* @__PURE__ */ new Map())
            }
          });
      }
    });
  }
  /**
   * Convert LangChain messages back to string format
   * TODO: Remove this when multi-llm-ts supports Message objects directly
   */
  messagesToString(messages) {
    return messages.map((msg) => {
      let role;
      if (msg instanceof SystemMessage) {
        role = "system";
      } else if (msg instanceof HumanMessage) {
        role = "user";
      } else if (msg instanceof AIMessage) {
        role = "assistant";
      } else {
        role = "unknown";
      }
      return `${role}: ${msg.content}`;
    }).join("\n\n");
  }
  /**
   * Extract additional template variables from options
   */
  extractAdditionalVariables(options) {
    const variables = {};
    if (typeof options === "object") {
      Object.keys(options).forEach((key) => {
        if (key.startsWith("template_")) {
          variables[key.replace("template_", "")] = options[key];
        }
      });
    }
    return variables;
  }
};

// src/context/utils/ContextAwarePrompting.ts
var ContextAwarePromptHandler = class {
  constructor(baseHandler, contextManager) {
    this.baseHandler = baseHandler;
    this.contextManager = contextManager;
    this.langChainHandler = new LangChainPromptHandler(baseHandler);
  }
  langChainHandler;
  /**
   * Execute prompt with context continuation using LangChain templates
   */
  async completeWithContext(prompt, options = {}, contextId, includeHistory = true) {
    try {
      const context = this.contextManager.getConversationContext(contextId);
      if (!context) {
        return await this.baseHandler.complete(prompt, options);
      }
      let result;
      if (includeHistory && context.messages.length > 0) {
        const templateOptions = {
          ...options,
          templateType: this.selectTemplateType(prompt, options),
          domain: options.domain || this.inferDomain(prompt, context)
        };
        result = await this.langChainHandler.completeWithContext(prompt, context, templateOptions);
      } else {
        result = await this.baseHandler.complete(prompt, options);
      }
      if (result.success) {
        this.contextManager.addMessageToContext(contextId, {
          id: `msg_${Date.now()}_user`,
          role: "user",
          content: prompt,
          timestamp: /* @__PURE__ */ new Date(),
          metadata: /* @__PURE__ */ new Map([
            ["enhanced", includeHistory.toString()],
            ["usedLangChain", (includeHistory && context.messages.length > 0).toString()],
            ["templateType", result.templateMetadata?.templateType || "none"]
          ])
        });
        this.contextManager.addMessageToContext(contextId, {
          id: `msg_${Date.now()}_assistant`,
          role: "assistant",
          content: result.data,
          timestamp: /* @__PURE__ */ new Date(),
          metadata: /* @__PURE__ */ new Map([
            ["contextId", contextId],
            ["messageCount", result.templateMetadata?.messageCount?.toString() || "0"],
            [
              "hadHistory",
              result.templateMetadata?.hasConversationHistory?.toString() || "false"
            ]
          ])
        });
      }
      return result;
    } catch (error) {
      console.error("Context-aware prompting failed:", error);
      try {
        return await this.baseHandler.complete(prompt, options);
      } catch (_fallbackError) {
        return {
          success: false,
          error: `Context-aware prompting failed: ${error instanceof Error ? error.message : String(error)}`
        };
      }
    }
  }
  /**
   * Create isolated context for sub-conversation
   */
  async createSubConversation(parentContextId, task, timeLimit = 3e5) {
    const subContext = this.contextManager.createConversationContext("sub-agent", parentContextId);
    this.contextManager.addMessageToContext(subContext.id, {
      id: `msg_${Date.now()}_system`,
      role: "system",
      content: `Sub-conversation started for task: ${task}`,
      timestamp: /* @__PURE__ */ new Date(),
      metadata: /* @__PURE__ */ new Map([
        ["task", task],
        ["parentContext", parentContextId],
        ["timeLimit", timeLimit.toString()]
      ])
    });
    return subContext.id;
  }
  /**
   * Continue conversation in existing context
   */
  async continueConversation(contextId, prompt, options = {}) {
    return this.completeWithContext(prompt, options, contextId, true);
  }
  /**
   * Get conversation summary for context
   */
  async getConversationSummary(contextId, maxMessages = 10) {
    const context = this.contextManager.getConversationContext(contextId);
    if (!context || context.messages.length === 0) {
      return "No conversation history available.";
    }
    const recentMessages = context.messages.slice(-maxMessages);
    let summary = `Conversation Summary (${recentMessages.length} messages):

`;
    for (const message of recentMessages) {
      const timestamp = message.timestamp.toLocaleString();
      const content = message.content.length > 100 ? `${message.content.substring(0, 100)}...` : message.content;
      summary += `[${timestamp}] ${message.role}: ${content}
`;
    }
    return summary;
  }
  /**
   * Select appropriate template based on prompt content and options
   */
  selectTemplateType(prompt, options) {
    if (options && typeof options === "object" && "templateType" in options) {
      return options.templateType || "default";
    }
    const lowerPrompt = prompt.toLowerCase();
    if (lowerPrompt.includes("code") || lowerPrompt.includes("function") || lowerPrompt.includes("class") || lowerPrompt.includes("debug") || lowerPrompt.includes("implementation") || lowerPrompt.includes("typescript") || lowerPrompt.includes("javascript") || lowerPrompt.includes("programming")) {
      return "coding";
    }
    if (lowerPrompt.includes("problem") || lowerPrompt.includes("issue") || lowerPrompt.includes("error") || lowerPrompt.includes("fix") || lowerPrompt.includes("solve") || lowerPrompt.includes("troubleshoot")) {
      return "problem-solving";
    }
    if (lowerPrompt.includes("explain") || lowerPrompt.includes("learn") || lowerPrompt.includes("understand") || lowerPrompt.includes("what is") || lowerPrompt.includes("how does") || lowerPrompt.includes("teach me")) {
      return "educational";
    }
    if (lowerPrompt.includes("debug") || lowerPrompt.includes("why") || lowerPrompt.includes("not working") || lowerPrompt.includes("failing")) {
      return "debugging";
    }
    return "default";
  }
  /**
   * Infer domain from prompt and conversation context
   */
  inferDomain(prompt, context) {
    const recentMessages = context.messages.slice(-3);
    const allText = `${prompt} ${recentMessages.map((m2) => m2.content).join(" ")}`.toLowerCase();
    if (allText.includes("typescript") || allText.includes("javascript") || allText.includes("node.js")) {
      return "TypeScript/JavaScript";
    }
    if (allText.includes("python") || allText.includes("django") || allText.includes("flask")) {
      return "Python";
    }
    if (allText.includes("java") || allText.includes("spring") || allText.includes("maven")) {
      return "Java";
    }
    if (allText.includes("react") || allText.includes("vue") || allText.includes("angular")) {
      return "Frontend Development";
    }
    if (allText.includes("database") || allText.includes("sql") || allText.includes("mongodb")) {
      return "Database Development";
    }
    if (allText.includes("devops") || allText.includes("docker") || allText.includes("kubernetes")) {
      return "DevOps";
    }
    return "software development";
  }
  /**
   * Transfer context between conversations
   */
  async transferContext(fromContextId, toContextId, includeMessages = true) {
    try {
      const fromContext = this.contextManager.getConversationContext(fromContextId);
      const toContext = this.contextManager.getConversationContext(toContextId);
      if (!fromContext || !toContext) {
        return false;
      }
      if (includeMessages) {
        for (const message of fromContext.messages) {
          this.contextManager.addMessageToContext(toContextId, {
            ...message,
            id: `transferred_${message.id}`,
            metadata: new Map([
              ...message.metadata || /* @__PURE__ */ new Map(),
              ["transferredFrom", fromContextId],
              ["transferredAt", (/* @__PURE__ */ new Date()).toISOString()]
            ])
          });
        }
      }
      this.contextManager.addMessageToContext(toContextId, {
        id: `transfer_${Date.now()}`,
        role: "system",
        content: `Context transferred from ${fromContextId}`,
        timestamp: /* @__PURE__ */ new Date(),
        metadata: /* @__PURE__ */ new Map([
          ["transferType", "context-transfer"],
          ["sourceContext", fromContextId]
        ])
      });
      return true;
    } catch (error) {
      console.error("Context transfer failed:", error);
      return false;
    }
  }
};
function createContextAwarePromptHandler(baseHandler, contextManager) {
  return new ContextAwarePromptHandler(baseHandler, contextManager);
}

// src/agent/impl/QiCodeAgent.ts
var QiCodeAgent = class {
  stateManager;
  contextManager;
  classifier;
  commandHandler;
  promptHandler;
  contextAwarePromptHandler;
  // Will be initialized in initialize()
  workflowEngine;
  workflowExtractor;
  // Session to context mapping for context continuation
  sessionContextMap = /* @__PURE__ */ new Map();
  config;
  isInitialized = false;
  startTime;
  requestCount = 0;
  totalResponseTime = 0;
  lastActivity;
  constructor(stateManager, contextManager, config, dependencies = {}) {
    this.stateManager = stateManager;
    this.contextManager = contextManager;
    this.config = config;
    this.classifier = dependencies.classifier;
    this.commandHandler = dependencies.commandHandler;
    this.promptHandler = dependencies.promptHandler;
    this.workflowEngine = dependencies.workflowEngine;
    this.workflowExtractor = dependencies.workflowExtractor;
  }
  async initialize() {
    if (this.isInitialized) {
      return;
    }
    this.startTime = /* @__PURE__ */ new Date();
    await this.contextManager.initialize();
    if (this.promptHandler) {
      this.contextAwarePromptHandler = createContextAwarePromptHandler(
        this.promptHandler,
        this.contextManager
      );
    }
    this.isInitialized = true;
  }
  async process(request) {
    if (!this.isInitialized) {
      throw new Error("Agent not initialized. Call initialize() first.");
    }
    const startTime = Date.now();
    this.requestCount++;
    this.lastActivity = /* @__PURE__ */ new Date();
    try {
      if (this.isStateCommand(request.input)) {
        const response2 = await this.handleStateCommand(request.input);
        const executionTime2 = Date.now() - startTime;
        this.totalResponseTime += executionTime2;
        return {
          ...response2,
          executionTime: executionTime2
        };
      }
      if (!this.classifier) {
        throw new Error("Classifier not available");
      }
      const classification = await this.classifier.classify(request.input);
      let response;
      switch (classification.type) {
        case "command":
          response = await this.handleCommand(request, classification);
          break;
        case "prompt":
          response = await this.handlePrompt(request, classification);
          break;
        case "workflow":
          response = await this.handleWorkflow(request, classification);
          break;
        default:
          throw new Error(`Unknown classification type: ${classification.type}`);
      }
      const executionTime = Date.now() - startTime;
      this.totalResponseTime += executionTime;
      return {
        ...response,
        executionTime,
        metadata: new Map([
          ...Array.from(response.metadata.entries()),
          [
            "classification",
            JSON.stringify({
              type: classification.type,
              confidence: classification.confidence,
              method: classification.method
            })
          ],
          ["agentProcessingTime", executionTime.toString()]
        ])
      };
    } catch (error) {
      const executionTime = Date.now() - startTime;
      this.totalResponseTime += executionTime;
      return {
        content: `Agent processing failed: ${error instanceof Error ? error.message : String(error)}`,
        type: "command",
        // Default type for errors
        confidence: 0,
        executionTime,
        metadata: /* @__PURE__ */ new Map([
          ["error", error instanceof Error ? error.message : String(error)],
          ["errorType", "agent-processing-error"]
        ]),
        success: false,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
  async *stream(request) {
    if (!this.isInitialized) {
      yield {
        type: "error",
        content: "Agent not initialized. Call initialize() first.",
        isComplete: true,
        metadata: /* @__PURE__ */ new Map([
          ["errorCode", "AGENT_NOT_INITIALIZED"],
          ["errorType", "validation"]
        ])
      };
      return;
    }
    try {
      yield {
        type: "classification",
        content: "Classifying input...",
        isComplete: false
      };
      if (!this.classifier) {
        yield {
          type: "error",
          content: "Classifier not available",
          isComplete: true,
          metadata: /* @__PURE__ */ new Map([
            ["errorCode", "CLASSIFIER_NOT_AVAILABLE"],
            ["errorType", "system"]
          ])
        };
        return;
      }
      const classification = await this.classifier.classify(request.input);
      yield {
        type: "classification",
        content: `Classified as: ${classification.type} (${(classification.confidence * 100).toFixed(1)}% confidence)`,
        isComplete: true,
        metadata: /* @__PURE__ */ new Map([["classification", classification]])
      };
      yield {
        type: "processing",
        content: `Processing ${classification.type}...`,
        isComplete: false
      };
      const response = await this.process(request);
      yield {
        type: "result",
        content: response.content,
        isComplete: true,
        metadata: response.metadata
      };
    } catch (error) {
      yield {
        type: "error",
        content: `Stream processing failed: ${error instanceof Error ? error.message : String(error)}`,
        isComplete: true,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
  getStatus() {
    return {
      isInitialized: this.isInitialized,
      domain: this.config.domain,
      uptime: this.startTime ? Date.now() - this.startTime.getTime() : 0,
      requestsProcessed: this.requestCount,
      averageResponseTime: this.requestCount > 0 ? this.totalResponseTime / this.requestCount : 0,
      lastActivity: this.lastActivity
    };
  }
  async shutdown() {
    await this.contextManager.shutdown();
    this.sessionContextMap.clear();
    this.isInitialized = false;
  }
  // Private routing methods
  async handleCommand(request, classification) {
    if (!this.config.enableCommands) {
      return this.createDisabledResponse("command", "Command processing is disabled");
    }
    if (!this.commandHandler) {
      return this.createErrorResponse("command", "Command handler not available");
    }
    const commandRequest = {
      commandName: this.extractCommandName(request.input),
      parameters: this.extractCommandParameters(request.input),
      rawInput: request.input,
      context: request.context.environmentContext
    };
    const result = await this.commandHandler.executeCommand(commandRequest);
    return {
      content: result.content,
      type: "command",
      confidence: classification.confidence,
      executionTime: 0,
      // Will be set by main process method
      metadata: new Map([
        ...Array.from(result.metadata.entries()),
        ["commandName", result.commandName],
        ["commandStatus", result.status]
      ]),
      success: result.success,
      error: result.error
    };
  }
  async handlePrompt(request, classification) {
    if (!this.config.enablePrompts) {
      return this.createDisabledResponse("prompt", "Prompt processing is disabled");
    }
    if (!this.promptHandler) {
      return this.createErrorResponse("prompt", "Prompt handler not available");
    }
    try {
      const promptOptions = this.extractPromptOptions(request.context);
      let result;
      if (this.contextAwarePromptHandler) {
        const sessionId = request.context.sessionId;
        let contextId = this.sessionContextMap.get(sessionId);
        if (!contextId) {
          const newContext = this.contextManager.createConversationContext("main");
          contextId = newContext.id;
          this.sessionContextMap.set(sessionId, contextId);
        }
        const existingContext = this.contextManager.getConversationContext(contextId);
        if (!existingContext) {
          const newContext = this.contextManager.createConversationContext("main");
          contextId = newContext.id;
          this.sessionContextMap.set(sessionId, contextId);
        }
        result = await this.contextAwarePromptHandler.completeWithContext(
          request.input,
          promptOptions,
          contextId,
          true
          // Include conversation history
        );
      } else {
        result = await this.promptHandler.complete(request.input, promptOptions);
        this.stateManager.addConversationEntry({
          type: "user_input",
          content: request.input,
          metadata: /* @__PURE__ */ new Map([["inputType", "prompt"]])
        });
        if (result.success) {
          this.stateManager.addConversationEntry({
            type: "agent_response",
            content: result.data,
            metadata: /* @__PURE__ */ new Map([["responseType", "prompt"]])
          });
        }
      }
      if (result.success) {
        return {
          content: result.data,
          type: "prompt",
          confidence: classification.confidence,
          executionTime: 0,
          // Will be set by main process method
          metadata: /* @__PURE__ */ new Map([
            ["promptOptions", JSON.stringify(promptOptions)],
            ["provider", promptOptions.provider || "default"],
            ["contextAware", this.contextAwarePromptHandler ? "true" : "false"]
          ]),
          success: true
        };
      } else {
        return this.createErrorResponse(
          "prompt",
          result.error
        );
      }
    } catch (error) {
      return this.createErrorResponse(
        "prompt",
        `Prompt processing failed: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
  async handleWorkflow(_request, _classification) {
    if (!this.config.enableWorkflows) {
      return this.createDisabledResponse("workflow", "Workflow processing is disabled");
    }
    if (!this.workflowExtractor || !this.workflowEngine) {
      return this.createErrorResponse("workflow", "Workflow components not available");
    }
    return this.createErrorResponse(
      "workflow",
      "Workflow processing not implemented - design incomplete. See TODO above for required design decisions."
    );
  }
  // State Management Methods
  isStateCommand(input) {
    const trimmed = input.trim().toLowerCase();
    const stateCommands = ["/model", "/status", "/config", "/mode", "/session"];
    return stateCommands.some((cmd) => trimmed.startsWith(cmd));
  }
  async handleStateCommand(input) {
    const _trimmed = input.trim().toLowerCase();
    const parts = input.trim().split(/\s+/);
    const command = parts[0].toLowerCase();
    const args = parts.slice(1);
    try {
      if (command === "/model") {
        return this.handleModelCommand(args);
      } else if (command === "/status") {
        return this.handleStatusCommand();
      } else if (command === "/config") {
        return this.handleConfigCommand(args);
      } else if (command === "/mode") {
        return this.handleModeCommand(args);
      } else if (command === "/session") {
        return this.handleSessionCommand(args);
      } else {
        return {
          content: `Unknown state command: ${command}`,
          type: "command",
          confidence: 0,
          executionTime: 0,
          metadata: /* @__PURE__ */ new Map([["error", "unknown-state-command"]]),
          success: false,
          error: `Unknown state command: ${command}`
        };
      }
    } catch (error) {
      return {
        content: `State command error: ${error instanceof Error ? error.message : String(error)}`,
        type: "command",
        confidence: 0,
        executionTime: 0,
        metadata: /* @__PURE__ */ new Map([["error", "state-command-error"]]),
        success: false,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
  handleModelCommand(args) {
    if (args.length === 0) {
      const currentModel = this.stateManager.getCurrentModel();
      const currentModelInfo = this.stateManager.getModelInfo(currentModel);
      const availableModels = this.stateManager.getAvailableModels();
      let content = `\u{1F4CB} Current Model: ${currentModel}`;
      if (currentModelInfo) {
        content += ` (${currentModelInfo.name})`;
      }
      content += "\n\nAvailable Models:";
      for (const model of availableModels) {
        const status = model.available ? "\u2705" : "\u274C";
        content += `
  ${status} ${model.id} - ${model.name}`;
        if (model.description) {
          content += ` - ${model.description}`;
        }
      }
      return {
        content,
        type: "command",
        confidence: 1,
        executionTime: 0,
        metadata: /* @__PURE__ */ new Map([
          ["currentModel", currentModel],
          ["availableModels", availableModels.length.toString()]
        ]),
        success: true
      };
    } else {
      const modelId = args[0];
      try {
        this.stateManager.setCurrentModel(modelId);
        const modelInfo = this.stateManager.getModelInfo(modelId);
        const content = `\u2705 Model changed to: ${modelId}${modelInfo ? ` (${modelInfo.name})` : ""}`;
        return {
          content,
          type: "command",
          confidence: 1,
          executionTime: 0,
          metadata: /* @__PURE__ */ new Map([["newModel", modelId]]),
          success: true
        };
      } catch (error) {
        return {
          content: `\u274C Failed to change model: ${error instanceof Error ? error.message : String(error)}`,
          type: "command",
          confidence: 0,
          executionTime: 0,
          metadata: /* @__PURE__ */ new Map([["error", "model-change-failed"]]),
          success: false,
          error: error instanceof Error ? error.message : String(error)
        };
      }
    }
  }
  handleStatusCommand() {
    const state = this.stateManager.getState();
    const currentModelInfo = this.stateManager.getModelInfo(state.currentModel);
    let content = "\u{1F4CA} Agent Status:\n";
    content += `  Model: ${state.currentModel}`;
    if (currentModelInfo) {
      content += ` (${currentModelInfo.name})`;
    }
    content += `
  Mode: ${state.currentMode}`;
    content += `
  Session: ${state.session.id}`;
    content += `
  Conversation History: ${state.session.conversationHistory.length} entries`;
    content += `
  Requests Processed: ${this.requestCount}`;
    content += `
  Average Response Time: ${this.requestCount > 0 ? Math.round(this.totalResponseTime / this.requestCount) : 0}ms`;
    if (this.lastActivity) {
      content += `
  Last Activity: ${this.lastActivity.toISOString()}`;
    }
    return {
      content,
      type: "command",
      confidence: 1,
      executionTime: 0,
      metadata: /* @__PURE__ */ new Map([
        ["model", state.currentModel],
        ["mode", state.currentMode],
        ["sessionId", state.session.id],
        ["historyLength", state.session.conversationHistory.length.toString()]
      ]),
      success: true
    };
  }
  handleConfigCommand(_args) {
    const config = this.stateManager.getConfig();
    let content = "\u2699\uFE0F Configuration:\n";
    content += `  Version: ${config.version}
`;
    content += `  Default Model: ${config.defaultModel}
`;
    content += `  Debug Mode: ${config.enableDebugMode ? "enabled" : "disabled"}
`;
    content += `  Max History: ${config.maxHistorySize}
`;
    content += `  Session Timeout: ${Math.round(config.sessionTimeout / 6e4)}min
`;
    content += `  Available Models: ${config.availableModels.join(", ")}`;
    return {
      content,
      type: "command",
      confidence: 1,
      executionTime: 0,
      metadata: /* @__PURE__ */ new Map([
        ["version", config.version],
        ["debugMode", config.enableDebugMode.toString()]
      ]),
      success: true
    };
  }
  handleModeCommand(args) {
    if (args.length === 0) {
      const currentMode = this.stateManager.getCurrentMode();
      return {
        content: `\u{1F4CD} Current Mode: ${currentMode}

Available modes: ready, planning, editing, executing, error`,
        type: "command",
        confidence: 1,
        executionTime: 0,
        metadata: /* @__PURE__ */ new Map([["currentMode", currentMode]]),
        success: true
      };
    } else {
      const mode = args[0];
      const validModes = ["ready", "planning", "editing", "executing", "error"];
      if (validModes.includes(mode)) {
        this.stateManager.setCurrentMode(mode);
        return {
          content: `\u2705 Mode changed to: ${mode}`,
          type: "command",
          confidence: 1,
          executionTime: 0,
          metadata: /* @__PURE__ */ new Map([["newMode", mode]]),
          success: true
        };
      } else {
        return {
          content: `\u274C Invalid mode: ${mode}
Available modes: ${validModes.join(", ")}`,
          type: "command",
          confidence: 0,
          executionTime: 0,
          metadata: /* @__PURE__ */ new Map([["error", "invalid-mode"]]),
          success: false,
          error: `Invalid mode: ${mode}`
        };
      }
    }
  }
  handleSessionCommand(_args) {
    const session = this.stateManager.getCurrentSession();
    let content = "\u{1F4BE} Session Information:\n";
    content += `  ID: ${session.id}
`;
    content += `  Created: ${session.createdAt.toISOString()}
`;
    content += `  Last Active: ${session.lastActiveAt.toISOString()}
`;
    content += `  Conversation History: ${session.conversationHistory.length} entries`;
    if (session.conversationHistory.length > 0) {
      content += "\n\nRecent entries:";
      const recent = session.conversationHistory.slice(-3);
      for (const entry of recent) {
        content += `
  ${entry.timestamp.toLocaleTimeString()} [${entry.type}]: ${entry.content.substring(0, 50)}${entry.content.length > 50 ? "..." : ""}`;
      }
    }
    return {
      content,
      type: "command",
      confidence: 1,
      executionTime: 0,
      metadata: /* @__PURE__ */ new Map([
        ["sessionId", session.id],
        ["historyLength", session.conversationHistory.length.toString()]
      ]),
      success: true
    };
  }
  // Helper methods
  createDisabledResponse(type, message) {
    return {
      content: message,
      type,
      confidence: 0,
      executionTime: 0,
      metadata: /* @__PURE__ */ new Map([["disabled", true]]),
      success: false,
      error: message
    };
  }
  createErrorResponse(type, message) {
    return {
      content: message,
      type,
      confidence: 0,
      executionTime: 0,
      metadata: /* @__PURE__ */ new Map([["errorType", "component-unavailable"]]),
      success: false,
      error: message
    };
  }
  extractCommandName(input) {
    const trimmed = input.trim();
    if (trimmed.startsWith("/")) {
      return trimmed.slice(1).split(" ")[0];
    }
    return "";
  }
  extractCommandParameters(input) {
    const trimmed = input.trim();
    if (trimmed.startsWith("/")) {
      const parts = trimmed.slice(1).split(" ").slice(1);
      const params = /* @__PURE__ */ new Map();
      parts.forEach((part, index) => {
        params.set(index.toString(), part);
      });
      return params;
    }
    return /* @__PURE__ */ new Map();
  }
  extractPromptOptions(context) {
    const currentModel = this.stateManager.getCurrentModel();
    const config = this.stateManager.getConfig();
    const llmConfig = context.environmentContext?.get("llmConfig");
    return {
      provider: "ollama",
      // Default provider since not in AppConfig
      model: currentModel || config.defaultModel,
      temperature: llmConfig?.temperature || 0.7,
      maxTokens: llmConfig?.maxTokens || 2048
    };
  }
};

// src/agent/PromptAppOrchestrator.ts
import { EventEmitter } from "events";
import {
  createContextAwarePromptHandler as createContextAwarePromptHandler2
} from "@qi/agent/context/utils/ContextAwarePrompting";
import { create as create2 } from "@qi/base";
var createAgentError = (code, message, category, context = {}) => create2(code, message, category, context);
function parseInput(input) {
  const trimmed = input.trim();
  if (trimmed.startsWith("/")) {
    return {
      type: "command",
      raw: input,
      content: trimmed.slice(1)
      // Remove the leading `/`
    };
  }
  return {
    type: "prompt",
    raw: input,
    content: trimmed
  };
}
var PromptAppOrchestrator = class extends EventEmitter {
  stateManager;
  contextManager;
  commandHandler;
  promptHandler;
  contextAwarePromptHandler;
  // Session to context mapping for context continuation
  sessionContextMap = /* @__PURE__ */ new Map();
  // Cancellation support
  abortController;
  isProcessing = false;
  config;
  isInitialized = false;
  startTime;
  requestCount = 0;
  totalResponseTime = 0;
  lastActivity;
  constructor(stateManager, contextManager, config, dependencies = {}) {
    super();
    this.stateManager = stateManager;
    this.contextManager = contextManager;
    this.config = config;
    this.commandHandler = dependencies.commandHandler;
    this.promptHandler = dependencies.promptHandler;
    this.setupCLIEventHandlers();
  }
  /**
   * Set up handlers for CLI events (app-specific event-driven communication)
   */
  setupCLIEventHandlers() {
    this.on("modelChangeRequested", this.handleModelChangeRequest.bind(this));
    this.on("modeChangeRequested", this.handleModeChangeRequest.bind(this));
    this.on("promptRequested", this.handlePromptRequest.bind(this));
    this.on("statusRequested", this.handleStatusRequest.bind(this));
    this.on("cancelRequested", this.handleCancelRequest.bind(this));
  }
  async initialize() {
    if (this.isInitialized) {
      return;
    }
    this.startTime = /* @__PURE__ */ new Date();
    await this.contextManager.initialize();
    if (this.promptHandler) {
      this.contextAwarePromptHandler = createContextAwarePromptHandler2(
        this.promptHandler,
        this.contextManager
      );
    }
    this.isInitialized = true;
  }
  async process(request) {
    if (!this.isInitialized) {
      throw new Error("PromptApp not initialized. Call initialize() first.");
    }
    const startTime = Date.now();
    this.requestCount++;
    this.lastActivity = /* @__PURE__ */ new Date();
    this.isProcessing = true;
    this.abortController = new AbortController();
    try {
      this.emit("progress", { phase: "parsing", progress: 0.1, details: "Analyzing input..." });
      this.emit("message", { content: "Processing request...", type: "status" });
      this.emit("processInput", request.input);
      const parsed = parseInput(request.input);
      if (this.abortController?.signal.aborted) {
        throw new Error("Request was cancelled");
      }
      this.emit("progress", {
        phase: "routing",
        progress: 0.2,
        details: `Routing to ${parsed.type} handler...`
      });
      let response;
      switch (parsed.type) {
        case "command":
          this.emit("progress", {
            phase: "command_processing",
            progress: 0.3,
            details: "Executing command..."
          });
          response = await this.handleCommand(request, parsed.content);
          break;
        case "prompt":
          this.emit("progress", {
            phase: "llm_processing",
            progress: 0.3,
            details: "Sending to LLM..."
          });
          response = await this.handlePrompt(request, parsed.content);
          break;
        default:
          throw new Error(`Unknown input type: ${parsed.type}`);
      }
      if (this.abortController?.signal.aborted) {
        throw new Error("Request was cancelled during processing");
      }
      this.emit("progress", {
        phase: "completing",
        progress: 0.9,
        details: "Finalizing response..."
      });
      const executionTime = Date.now() - startTime;
      this.totalResponseTime += executionTime;
      const finalResponse = {
        ...response,
        executionTime,
        metadata: new Map([
          ...Array.from(response.metadata.entries()),
          ["inputType", parsed.type],
          ["parser", "2-category"],
          ["orchestrator", "PromptApp"]
        ])
      };
      this.emit("complete", { result: finalResponse });
      return finalResponse;
    } catch (error) {
      const executionTime = Date.now() - startTime;
      this.totalResponseTime += executionTime;
      const wasCancelled = error instanceof Error && error.message.includes("cancelled");
      if (wasCancelled) {
        this.emit("cancelled", { reason: "user_requested" });
        this.emit("message", { content: "Request was cancelled", type: "error" });
      } else {
        const qiError = error instanceof Error ? createAgentError("PROCESSING_FAILED", error.message, "SYSTEM") : createAgentError("UNKNOWN_ERROR", String(error), "SYSTEM");
        this.emit("error", { error: qiError, context: "process" });
        this.emit("message", {
          content: `Error: ${error instanceof Error ? error.message : String(error)}`,
          type: "error"
        });
      }
      return {
        content: `Processing failed: ${error instanceof Error ? error.message : String(error)}`,
        type: "prompt",
        confidence: 0,
        executionTime,
        metadata: /* @__PURE__ */ new Map([
          ["error", error instanceof Error ? error.message : String(error)],
          ["cancelled", wasCancelled.toString()],
          ["orchestrator", "PromptApp"]
        ]),
        success: false,
        error: error instanceof Error ? error.message : String(error)
      };
    } finally {
      this.isProcessing = false;
      this.abortController = void 0;
    }
  }
  /**
   * Cancel the current request if one is in progress
   */
  cancel() {
    if (this.isProcessing && this.abortController) {
      this.abortController.abort();
      this.emit("cancelled", { reason: "user_requested" });
    }
  }
  /**
   * Check if a request is currently being processed
   */
  isCurrentlyProcessing() {
    return this.isProcessing;
  }
  async *stream(request) {
    const parsed = parseInput(request.input);
    yield {
      type: "classification",
      content: `Parsed as ${parsed.type}`,
      isComplete: false,
      metadata: /* @__PURE__ */ new Map([
        ["inputType", parsed.type],
        ["parser", "2-category"]
      ])
    };
    yield {
      type: "processing",
      content: `Processing ${parsed.type}...`,
      isComplete: false
    };
    try {
      const response = await this.process(request);
      yield {
        type: "result",
        content: response.content,
        isComplete: true,
        metadata: response.metadata
      };
    } catch (error) {
      yield {
        type: "error",
        content: `Stream processing failed: ${error instanceof Error ? error.message : String(error)}`,
        isComplete: true,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
  getStatus() {
    return {
      isInitialized: this.isInitialized,
      domain: this.config.domain,
      uptime: this.startTime ? Date.now() - this.startTime.getTime() : 0,
      requestsProcessed: this.requestCount,
      averageResponseTime: this.requestCount > 0 ? this.totalResponseTime / this.requestCount : 0,
      lastActivity: this.lastActivity
    };
  }
  async shutdown() {
    await this.contextManager.shutdown();
    this.sessionContextMap.clear();
    this.isInitialized = false;
  }
  // Private routing methods
  async handleCommand(request, commandContent) {
    if (!this.config.enableCommands) {
      return this.createDisabledResponse("command", "Command processing is disabled");
    }
    if (!this.commandHandler) {
      return this.createErrorResponse("command", "Command handler not available");
    }
    const parts = commandContent.trim().split(/\s+/);
    const commandName = parts[0];
    const parameters = /* @__PURE__ */ new Map();
    for (let i2 = 1; i2 < parts.length; i2++) {
      parameters.set(`arg${i2}`, parts[i2]);
    }
    if (commandName === "status" || commandName === "s") {
      return await this.handleStatusCommand();
    }
    if (commandName === "maxTokens" || commandName === "maxtokens" || commandName === "tokens") {
      return await this.handleMaxTokensCommand(parts.slice(1));
    }
    const commandRequest = {
      commandName,
      parameters,
      rawInput: request.input,
      context: request.context.environmentContext
    };
    const result = await this.commandHandler.executeCommand(commandRequest);
    return {
      content: result.content,
      type: "command",
      confidence: 1,
      // Commands are deterministic
      executionTime: 0,
      // Will be set by main process method
      metadata: new Map([
        ...Array.from(result.metadata.entries()),
        ["commandName", result.commandName],
        ["commandStatus", result.status]
      ]),
      success: result.success,
      error: result.error
    };
  }
  async handlePrompt(request, promptContent) {
    if (!this.config.enablePrompts) {
      return this.createDisabledResponse("prompt", "Prompt processing is disabled");
    }
    if (!this.promptHandler) {
      return this.createErrorResponse("prompt", "Prompt handler not available");
    }
    try {
      const promptOptions = this.extractPromptOptions(request.context);
      let result;
      if (this.contextAwarePromptHandler) {
        const sessionId = request.context.sessionId;
        let contextId = this.sessionContextMap.get(sessionId);
        if (!contextId) {
          const newContext = this.contextManager.createConversationContext("main");
          contextId = newContext.id;
          this.sessionContextMap.set(sessionId, contextId);
        }
        const existingContext = this.contextManager.getConversationContext(contextId);
        if (!existingContext) {
          const newContext = this.contextManager.createConversationContext("main");
          contextId = newContext.id;
          this.sessionContextMap.set(sessionId, contextId);
        }
        result = await this.contextAwarePromptHandler.completeWithContext(
          promptContent,
          promptOptions,
          contextId,
          true
          // Include conversation history
        );
      } else {
        result = await this.promptHandler.complete(promptContent, promptOptions);
        this.stateManager.addConversationEntry({
          type: "user_input",
          content: promptContent,
          metadata: /* @__PURE__ */ new Map([["inputType", "prompt"]])
        });
        if (result.success) {
          this.stateManager.addConversationEntry({
            type: "agent_response",
            content: result.data,
            metadata: /* @__PURE__ */ new Map([["responseType", "prompt"]])
          });
        }
      }
      if (result.success) {
        return {
          content: result.data,
          type: "prompt",
          confidence: 0.95,
          // High confidence for successful prompts
          executionTime: 0,
          // Will be set by main process method
          metadata: /* @__PURE__ */ new Map([
            ["promptOptions", JSON.stringify(promptOptions)],
            ["provider", promptOptions.provider || "default"],
            ["contextAware", this.contextAwarePromptHandler ? "true" : "false"]
          ]),
          success: true
        };
      } else {
        return this.createErrorResponse("prompt", result.error);
      }
    } catch (error) {
      return this.createErrorResponse(
        "prompt",
        `Prompt processing failed: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
  // Helper methods (same as QiCodeAgent)
  createDisabledResponse(type, message) {
    return {
      content: message,
      type,
      confidence: 0,
      executionTime: 0,
      metadata: /* @__PURE__ */ new Map([["status", "disabled"]]),
      success: false,
      error: message
    };
  }
  createErrorResponse(type, message) {
    return {
      content: `Error: ${message}`,
      type,
      confidence: 0,
      executionTime: 0,
      metadata: /* @__PURE__ */ new Map([["status", "error"]]),
      success: false,
      error: message
    };
  }
  extractPromptOptions(_context) {
    const currentModel = this.stateManager.getCurrentModel();
    const promptConfig = this.stateManager.getPromptConfig();
    return {
      provider: promptConfig?.provider || "ollama",
      model: currentModel || "qwen3:8b",
      temperature: promptConfig?.temperature || 0.1,
      maxTokens: promptConfig?.maxTokens || 1e3
    };
  }
  async handleStatusCommand() {
    const promptConfig = this.stateManager.getPromptConfig();
    const currentModel = promptConfig?.model || this.stateManager.getCurrentModel();
    const availableModels = this.stateManager.getAvailablePromptModels();
    let statusContent = "\u{1F4CA} Status:\n";
    statusContent += `Provider: ${promptConfig?.provider || "ollama"}
`;
    statusContent += `Model: ${currentModel || "qwen3:0.6b"}
`;
    statusContent += `Temperature: ${promptConfig?.temperature || 0.1}
`;
    statusContent += `Max Tokens: ${promptConfig?.maxTokens || 1e3}
`;
    if (availableModels.length > 0) {
      statusContent += `
Available Models: ${availableModels.join(", ")}`;
    }
    const orchestratorStatus = this.getStatus();
    statusContent += `

Session: ${orchestratorStatus.requestsProcessed} requests processed`;
    if (orchestratorStatus.lastActivity) {
      const timeSince = Math.floor((Date.now() - orchestratorStatus.lastActivity.getTime()) / 1e3);
      statusContent += `, last active ${timeSince}s ago`;
    }
    return {
      content: statusContent,
      type: "command",
      confidence: 1,
      executionTime: 0,
      metadata: /* @__PURE__ */ new Map([
        ["commandName", "status"],
        ["provider", promptConfig?.provider || "ollama"],
        ["currentModel", currentModel || "qwen3:0.6b"]
      ]),
      success: true
    };
  }
  async handleMaxTokensCommand(args) {
    const promptConfig = this.stateManager.getPromptConfig();
    const currentMaxTokens = promptConfig?.maxTokens || 1e3;
    if (args.length === 0) {
      return {
        content: `Current max tokens: ${currentMaxTokens}

Use '/tokens <number>' to change (1-32768)`,
        type: "command",
        confidence: 1,
        executionTime: 0,
        metadata: /* @__PURE__ */ new Map([
          ["commandName", "maxTokens"],
          ["action", "view"],
          ["currentMaxTokens", currentMaxTokens.toString()]
        ]),
        success: true
      };
    }
    const newMaxTokens = parseInt(args[0], 10);
    if (Number.isNaN(newMaxTokens)) {
      return {
        content: `\u274C Invalid number: ${args[0]}
Use a number between 1 and 32768`,
        type: "command",
        confidence: 0,
        executionTime: 0,
        metadata: /* @__PURE__ */ new Map([
          ["commandName", "maxTokens"],
          ["action", "set"],
          ["error", "invalid_number"]
        ]),
        success: false,
        error: "Invalid number"
      };
    }
    try {
      this.stateManager.updatePromptMaxTokens(newMaxTokens);
      return {
        content: `\u2705 Max tokens updated: ${newMaxTokens} (was ${currentMaxTokens})`,
        type: "command",
        confidence: 1,
        executionTime: 0,
        metadata: /* @__PURE__ */ new Map([
          ["commandName", "maxTokens"],
          ["action", "set"],
          ["newMaxTokens", newMaxTokens.toString()],
          ["previousMaxTokens", currentMaxTokens.toString()]
        ]),
        success: true
      };
    } catch (error) {
      return {
        content: `\u274C Failed to update max tokens: ${error instanceof Error ? error.message : String(error)}`,
        type: "command",
        confidence: 0,
        executionTime: 0,
        metadata: /* @__PURE__ */ new Map([
          ["commandName", "maxTokens"],
          ["action", "set"],
          ["error", error instanceof Error ? error.message : String(error)]
        ]),
        success: false,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
  // ===========================================
  // CLI Event Handlers (Event-Driven Communication)
  // ===========================================
  /**
   * Handle model change requests from CLI
   */
  async handleModelChangeRequest(event) {
    const { modelName } = event;
    const currentModel = this.stateManager.getCurrentModel();
    try {
      const availableModels = this.stateManager.getAvailablePromptModels();
      if (availableModels.length > 0 && !availableModels.includes(modelName)) {
        this.emit("modelChanged", {
          type: "modelChanged",
          oldModel: currentModel,
          newModel: modelName,
          success: false,
          error: `Model '${modelName}' not available. Available: ${availableModels.join(", ")}`,
          timestamp: /* @__PURE__ */ new Date()
        });
        return;
      }
      this.stateManager.updatePromptModel(modelName);
      this.emit("modelChanged", {
        type: "modelChanged",
        oldModel: currentModel,
        newModel: modelName,
        success: true,
        timestamp: /* @__PURE__ */ new Date()
      });
    } catch (error) {
      this.emit("modelChanged", {
        type: "modelChanged",
        oldModel: currentModel,
        newModel: modelName,
        success: false,
        error: error instanceof Error ? error.message : String(error),
        timestamp: /* @__PURE__ */ new Date()
      });
    }
  }
  /**
   * Handle mode change requests from CLI
   * TODO: Implement proper CLI mode to App mode mapping
   * Reason: CLI modes (interactive/command/streaming) are UI behavior states,
   * while App modes (ready/planning/editing/executing/error) are workflow states.
   * Currently just acknowledging the request without proper state management.
   */
  async handleModeChangeRequest(event) {
    const { mode } = event;
    try {
      this.emit("modeChanged", {
        type: "modeChanged",
        oldMode: mode,
        // TODO: Get actual previous CLI mode
        newMode: mode,
        success: true,
        timestamp: /* @__PURE__ */ new Date()
      });
    } catch (_error) {
      this.emit("modeChanged", {
        type: "modeChanged",
        oldMode: mode,
        newMode: mode,
        success: false,
        timestamp: /* @__PURE__ */ new Date()
      });
    }
  }
  /**
   * Handle prompt requests from CLI
   */
  async handlePromptRequest(event) {
    const { prompt, context } = event;
    try {
      const agentRequest = {
        input: prompt,
        context: {
          sessionId: context?.sessionId || "cli-session",
          timestamp: /* @__PURE__ */ new Date(),
          source: "cli"
        }
      };
      await this.process(agentRequest);
    } catch (error) {
      this.emit("error", {
        type: "error",
        error: {
          code: "PROMPT_PROCESSING_FAILED",
          message: error instanceof Error ? error.message : String(error)
        },
        timestamp: /* @__PURE__ */ new Date()
      });
    }
  }
  /**
   * Handle status requests from CLI
   */
  async handleStatusRequest(_event) {
    try {
      const currentModel = this.stateManager.getCurrentModel();
      const currentMode = this.stateManager.getCurrentMode();
      const promptConfig = this.stateManager.getPromptConfig();
      const uptime = Math.floor(process.uptime());
      const _availableModels = this.stateManager.getAvailablePromptModels();
      this.emit("statusResponse", {
        type: "statusResponse",
        status: {
          model: currentModel,
          mode: currentMode,
          uptime,
          provider: promptConfig?.provider || "ollama",
          availableCommands: this.commandHandler?.getAvailableCommands().length || 0,
          memoryUsage: Math.round(process.memoryUsage().heapUsed / 1024 / 1024)
        },
        timestamp: /* @__PURE__ */ new Date()
      });
    } catch (error) {
      this.emit("error", {
        type: "error",
        error: {
          code: "STATUS_REQUEST_FAILED",
          message: error instanceof Error ? error.message : String(error)
        },
        timestamp: /* @__PURE__ */ new Date()
      });
    }
  }
  /**
   * Handle cancel requests from CLI
   */
  async handleCancelRequest(_event) {
    this.cancel();
  }
};

// src/agent/index.ts
function createAgent(stateManager, contextManager, config) {
  const agentConfig = {
    domain: config.domain,
    enableCommands: config.enableCommands ?? true,
    enablePrompts: config.enablePrompts ?? true,
    enableWorkflows: config.enableWorkflows ?? true,
    sessionPersistence: config.sessionPersistence ?? false
  };
  const dependencies = {
    classifier: config.classifier,
    commandHandler: config.commandHandler,
    promptHandler: config.promptHandler,
    workflowEngine: config.workflowEngine,
    workflowExtractor: config.workflowExtractor
  };
  return new QiCodeAgent(stateManager, contextManager, agentConfig, dependencies);
}
function createPromptApp(stateManager, contextManager, config) {
  const agentConfig = {
    domain: config.domain || "prompt-app",
    enableCommands: config.enableCommands ?? true,
    enablePrompts: config.enablePrompts ?? true,
    enableWorkflows: false,
    // PromptApp doesn't use workflows
    sessionPersistence: config.sessionPersistence ?? false
  };
  const dependencies = {
    commandHandler: config.commandHandler,
    promptHandler: config.promptHandler
  };
  return new PromptAppOrchestrator(stateManager, contextManager, agentConfig, dependencies);
}

// src/classifier/impl/input-classifier.ts
var InputClassifier = class {
  method;
  _totalClassifications = 0;
  _averageConfidence = 0;
  _averageProcessingTime = 0;
  _typeDistribution = /* @__PURE__ */ new Map();
  _methodUsage = /* @__PURE__ */ new Map();
  constructor(method) {
    this.method = method;
  }
  async classify(input, options) {
    const startTime = Date.now();
    const result = await this.method.classify(input, options?.context);
    this.updateStats(result, Date.now() - startTime);
    return result;
  }
  // Interface layer provides simple API only - no QiCore exposure
  // Interface implementation methods
  configure(config) {
    if (config.defaultMethod && config.defaultMethod !== this.method.getMethodName()) {
      console.warn(
        `Cannot change classification method from ${this.method.getMethodName()} to ${config.defaultMethod} after construction`
      );
    }
  }
  getSupportedTypes() {
    return ["command", "prompt", "workflow"];
  }
  getSupportedMethods() {
    return [this.method.getMethodName()];
  }
  getStats() {
    return {
      totalClassifications: this._totalClassifications,
      averageConfidence: this._averageConfidence,
      averageProcessingTime: this._averageProcessingTime,
      typeDistribution: new Map(this._typeDistribution),
      methodUsage: new Map(this._methodUsage)
    };
  }
  resetStats() {
    this._totalClassifications = 0;
    this._averageConfidence = 0;
    this._averageProcessingTime = 0;
    this._typeDistribution.clear();
    this._methodUsage.clear();
  }
  validateConfig(config) {
    return !!(config.defaultMethod && config.confidenceThreshold >= 0 && config.confidenceThreshold <= 1);
  }
  updateStats(result, processingTime) {
    this._totalClassifications++;
    const totalConfidence = this._averageConfidence * (this._totalClassifications - 1) + result.confidence;
    this._averageConfidence = totalConfidence / this._totalClassifications;
    const totalTime = this._averageProcessingTime * (this._totalClassifications - 1) + processingTime;
    this._averageProcessingTime = totalTime / this._totalClassifications;
    const currentCount = this._typeDistribution.get(result.type) || 0;
    this._typeDistribution.set(result.type, currentCount + 1);
    const currentMethodCount = this._methodUsage.get(result.method) || 0;
    this._methodUsage.set(result.method, currentMethodCount + 1);
  }
};

// src/classifier/impl/langchain-function-calling.ts
import {
  failure as failure2,
  fromAsyncTryCatch,
  match,
  success as success2
} from "@qi/base";

// src/classifier/schema-registry.ts
import { create as create3, failure, success } from "@qi/base";
import { z } from "zod";
var createSchemaRegistryError = (code, message, context = {}) => create3(code, message, "VALIDATION", context);
var ClassificationSchemaRegistry = class {
  schemas = /* @__PURE__ */ new Map();
  performanceMetrics = /* @__PURE__ */ new Map();
  constructor() {
    this.initializeBuiltinSchemas();
  }
  /**
   * Initialize built-in schemas based on research and best practices
   */
  initializeBuiltinSchemas() {
    const currentTimestamp = (/* @__PURE__ */ new Date()).toISOString();
    const minimalSchema = z.object({
      type: z.enum(["prompt", "workflow"]).describe("Classification: prompt (single-step) or workflow (multi-step)"),
      confidence: z.number().min(0).max(1).describe("Confidence score from 0.0 to 1.0")
    });
    this.schemas.set("minimal", {
      schema: minimalSchema,
      metadata: {
        name: "minimal",
        complexity: "minimal",
        description: "Basic type and confidence only - optimized for speed",
        version: "1.0.0",
        recommended_for: ["development", "high-throughput", "simple-models"],
        performance_profile: {
          // No measured performance yet - will be populated through real usage
          total_uses: 0,
          successful_classifications: 0,
          total_latency_ms: 0,
          successful_parsing_attempts: 0,
          total_parsing_attempts: 0,
          // Conservative baseline estimates
          baseline_accuracy_estimate: 0.75,
          // Lower complexity typically means lower accuracy
          baseline_latency_estimate_ms: 200,
          // Simple schema should be fast
          baseline_parsing_reliability_estimate: 0.98
          // Simple schema is reliable to parse
        },
        created_at: currentTimestamp,
        last_updated: currentTimestamp
      }
    });
    const standardSchema = z.object({
      type: z.enum(["prompt", "workflow"]).describe(
        "Classification: prompt (single-step task) or workflow (multi-step orchestrated task)"
      ),
      confidence: z.number().min(0).max(1).describe("Confidence score from 0.0 to 1.0"),
      reasoning: z.string().describe("Brief explanation of why this classification was chosen")
    });
    this.schemas.set("standard", {
      schema: standardSchema,
      metadata: {
        name: "standard",
        complexity: "standard",
        description: "Type, confidence, and reasoning - good balance of accuracy and speed",
        version: "1.0.0",
        recommended_for: ["production", "general-purpose", "function-calling-models"],
        performance_profile: {
          // No measured performance yet - will be populated through real usage
          total_uses: 0,
          successful_classifications: 0,
          total_latency_ms: 0,
          successful_parsing_attempts: 0,
          total_parsing_attempts: 0,
          // Conservative baseline estimates
          baseline_accuracy_estimate: 0.85,
          // Standard complexity should have better accuracy
          baseline_latency_estimate_ms: 350,
          // Moderate latency for additional reasoning field
          baseline_parsing_reliability_estimate: 0.95
          // Good parsing reliability
        },
        created_at: currentTimestamp,
        last_updated: currentTimestamp
      }
    });
    const detailedSchema = z.object({
      type: z.enum(["prompt", "workflow"]).describe(
        "Classification: prompt (conversational/single-step) or workflow (complex/multi-step)"
      ),
      confidence: z.number().min(0).max(1).describe("Confidence score from 0.0 to 1.0"),
      reasoning: z.string().max(200).describe("Detailed explanation of classification decision"),
      indicators: z.array(z.string()).describe("Key indicators that led to this classification"),
      complexity_score: z.number().min(1).max(5).describe("Task complexity rating: 1=simple, 5=very complex")
    });
    this.schemas.set("detailed", {
      schema: detailedSchema,
      metadata: {
        name: "detailed",
        complexity: "detailed",
        description: "Comprehensive output with indicators and complexity scoring",
        version: "1.0.0",
        recommended_for: ["analysis", "debugging", "research", "high-accuracy-requirements"],
        performance_profile: {
          // No measured performance yet - will be populated through real usage
          total_uses: 0,
          successful_classifications: 0,
          total_latency_ms: 0,
          successful_parsing_attempts: 0,
          total_parsing_attempts: 0,
          // Conservative baseline estimates
          baseline_accuracy_estimate: 0.92,
          // Higher complexity should provide more accurate results
          baseline_latency_estimate_ms: 500,
          // More complex schema takes longer
          baseline_parsing_reliability_estimate: 0.88
          // Complex schemas may have more parsing issues
        },
        created_at: currentTimestamp,
        last_updated: currentTimestamp
      }
    });
    const optimizedSchema = z.object({
      type: z.enum(["prompt", "workflow"]).describe(
        "Classification: prompt (single-step request) or workflow (multi-step task requiring orchestration)"
      ),
      confidence: z.number().min(0).max(1).describe("Classification confidence from 0.0 to 1.0"),
      reasoning: z.string().min(10).max(100).describe("Concise reasoning for this classification"),
      task_steps: z.number().min(1).describe("Estimated number of steps required to complete this task")
    });
    this.schemas.set("optimized", {
      schema: optimizedSchema,
      metadata: {
        name: "optimized",
        complexity: "optimized",
        description: "Research-optimized schema balancing accuracy, speed, and reliability",
        version: "1.0.0",
        recommended_for: ["production", "recommended-default", "balanced-performance"],
        performance_profile: {
          // No measured performance yet - will be populated through real usage
          total_uses: 0,
          successful_classifications: 0,
          total_latency_ms: 0,
          successful_parsing_attempts: 0,
          total_parsing_attempts: 0,
          // Conservative baseline estimates
          baseline_accuracy_estimate: 0.89,
          // Balanced approach should provide good accuracy
          baseline_latency_estimate_ms: 320,
          // Optimized for speed while maintaining quality
          baseline_parsing_reliability_estimate: 0.94
          // Well-balanced schema should be reliable
        },
        created_at: currentTimestamp,
        last_updated: currentTimestamp
      }
    });
    const contextAwareSchema = z.object({
      type: z.enum(["prompt", "workflow"]).describe("prompt: direct question/request, workflow: requires multiple coordinated steps"),
      confidence: z.number().min(0).max(1).describe("Confidence score from 0.0 to 1.0"),
      reasoning: z.string().describe("Brief explanation of classification decision"),
      conversation_context: z.enum(["greeting", "question", "follow_up", "task_request", "multi_step"]).describe(
        "Context type: greeting/question/follow_up always prompt, task_request/multi_step may be workflow"
      ),
      step_count: z.number().min(1).describe("Estimated number of steps needed (1=prompt, 2+=workflow)"),
      requires_coordination: z.boolean().describe("Does this require coordinating multiple tools/services?")
    });
    this.schemas.set("context_aware", {
      schema: contextAwareSchema,
      metadata: {
        name: "context_aware",
        complexity: "detailed",
        description: "Context-aware schema focusing on conversation context and task complexity analysis",
        version: "1.0.0",
        recommended_for: ["workflow-detection-improvement", "research", "conversational-ai"],
        performance_profile: {
          // No measured performance yet - will be populated through real usage
          total_uses: 0,
          successful_classifications: 0,
          total_latency_ms: 0,
          successful_parsing_attempts: 0,
          total_parsing_attempts: 0,
          // Estimated performance based on research findings
          baseline_accuracy_estimate: 0.75,
          // Target: improve workflow detection from 30% to 60%+
          baseline_latency_estimate_ms: 450,
          // Slightly higher due to additional context analysis
          baseline_parsing_reliability_estimate: 0.92
          // Good structure but more complex fields
        },
        created_at: currentTimestamp,
        last_updated: currentTimestamp
      }
    });
  }
  /**
   * Get a schema by name
   */
  getSchema(name) {
    const entry = this.schemas.get(name);
    if (!entry) {
      return failure(
        createSchemaRegistryError("SCHEMA_NOT_FOUND", `Schema '${name}' not found in registry`, {
          schema_name: name,
          operation: "getSchema"
        })
      );
    }
    return success(entry);
  }
  /**
   * Get schema by complexity level
   */
  getSchemaByComplexity(complexity) {
    for (const [, entry] of this.schemas) {
      if (entry.metadata.complexity === complexity) {
        return success(entry);
      }
    }
    return failure(
      createSchemaRegistryError(
        "SCHEMA_COMPLEXITY_NOT_FOUND",
        `No schema found with complexity '${complexity}'`,
        { complexity, operation: "getSchemaByComplexity" }
      )
    );
  }
  /**
   * Select optimal schema based on criteria
   */
  selectOptimalSchema(criteria = {}) {
    const availableSchemas = Array.from(this.schemas.values());
    if (availableSchemas.length === 0) {
      return failure(
        createSchemaRegistryError("NO_SCHEMAS_AVAILABLE", "No schemas available in registry", {
          operation: "selectOptimalSchema"
        })
      );
    }
    let candidateSchemas = availableSchemas;
    if (criteria.use_case) {
      candidateSchemas = candidateSchemas.filter(
        (entry) => entry.metadata.recommended_for.includes(criteria.use_case)
      );
    }
    if (criteria.max_latency_ms) {
      candidateSchemas = candidateSchemas.filter((entry) => {
        const latency = entry.metadata.performance_profile.measured_latency_ms ?? entry.metadata.performance_profile.baseline_latency_estimate_ms;
        return latency <= criteria.max_latency_ms;
      });
    }
    if (criteria.min_accuracy_threshold) {
      candidateSchemas = candidateSchemas.filter((entry) => {
        const accuracy = entry.metadata.performance_profile.measured_accuracy ?? entry.metadata.performance_profile.baseline_accuracy_estimate;
        return accuracy >= criteria.min_accuracy_threshold;
      });
    }
    if (candidateSchemas.length === 0) {
      candidateSchemas = availableSchemas;
    }
    let selectedSchema;
    if (criteria.prioritize_speed) {
      selectedSchema = candidateSchemas.reduce((fastest, current) => {
        const currentLatency = current.metadata.performance_profile.measured_latency_ms ?? current.metadata.performance_profile.baseline_latency_estimate_ms;
        const fastestLatency = fastest.metadata.performance_profile.measured_latency_ms ?? fastest.metadata.performance_profile.baseline_latency_estimate_ms;
        return currentLatency < fastestLatency ? current : fastest;
      });
    } else if (criteria.prioritize_accuracy) {
      selectedSchema = candidateSchemas.reduce((mostAccurate, current) => {
        const currentAccuracy = current.metadata.performance_profile.measured_accuracy ?? current.metadata.performance_profile.baseline_accuracy_estimate;
        const mostAccurateAccuracy = mostAccurate.metadata.performance_profile.measured_accuracy ?? mostAccurate.metadata.performance_profile.baseline_accuracy_estimate;
        return currentAccuracy > mostAccurateAccuracy ? current : mostAccurate;
      });
    } else {
      selectedSchema = candidateSchemas.find((entry) => entry.metadata.name === "optimized") || candidateSchemas.find((entry) => entry.metadata.name === "standard") || candidateSchemas[0];
    }
    return success(selectedSchema);
  }
  /**
   * List all available schemas
   */
  listSchemas() {
    return Array.from(this.schemas.values());
  }
  /**
   * Register a new custom schema
   */
  registerSchema(name, schema, metadata) {
    if (this.schemas.has(name)) {
      return failure(
        createSchemaRegistryError(
          "SCHEMA_ALREADY_EXISTS",
          `Schema '${name}' already exists in registry`,
          { schema_name: name, operation: "registerSchema" }
        )
      );
    }
    const fullMetadata = {
      name,
      ...metadata
    };
    this.schemas.set(name, {
      schema,
      metadata: fullMetadata
    });
    return success(void 0);
  }
  /**
   * Update performance metrics for a schema
   */
  updatePerformanceMetrics(schemaName, metrics) {
    if (!this.schemas.has(schemaName)) {
      return failure(
        createSchemaRegistryError(
          "SCHEMA_NOT_FOUND",
          `Cannot update metrics for unknown schema '${schemaName}'`,
          { schema_name: schemaName, operation: "updatePerformanceMetrics" }
        )
      );
    }
    this.performanceMetrics.set(schemaName, {
      schema_name: schemaName,
      ...metrics
    });
    return success(void 0);
  }
  /**
   * Get performance metrics for a schema
   */
  getPerformanceMetrics(schemaName) {
    const metrics = this.performanceMetrics.get(schemaName);
    if (!metrics) {
      return failure(
        createSchemaRegistryError(
          "METRICS_NOT_FOUND",
          `No performance metrics found for schema '${schemaName}'`,
          { schema_name: schemaName, operation: "getPerformanceMetrics" }
        )
      );
    }
    return success(metrics);
  }
  /**
   * Track performance metrics for a schema usage
   */
  trackSchemaUsage(schemaName, latencyMs, classificationSuccess, parsingSuccess) {
    const schemaEntry = this.schemas.get(schemaName);
    if (!schemaEntry) {
      return failure(
        createSchemaRegistryError(
          "SCHEMA_NOT_FOUND",
          `Cannot track performance for unknown schema '${schemaName}'`,
          { schema_name: schemaName, operation: "trackSchemaUsage" }
        )
      );
    }
    const profile = schemaEntry.metadata.performance_profile;
    profile.total_uses++;
    profile.total_latency_ms += latencyMs;
    profile.total_parsing_attempts++;
    if (classificationSuccess) {
      profile.successful_classifications++;
    }
    if (parsingSuccess) {
      profile.successful_parsing_attempts++;
    }
    profile.measured_accuracy = profile.successful_classifications / profile.total_uses;
    profile.measured_latency_ms = Math.round(profile.total_latency_ms / profile.total_uses);
    profile.measured_parsing_reliability = profile.successful_parsing_attempts / profile.total_parsing_attempts;
    profile.last_measured = (/* @__PURE__ */ new Date()).toISOString();
    schemaEntry.metadata.last_updated = (/* @__PURE__ */ new Date()).toISOString();
    return success(void 0);
  }
  /**
   * Get effective performance metrics (measured if available, baseline otherwise)
   */
  getEffectivePerformanceMetrics(schemaName) {
    const schemaEntry = this.schemas.get(schemaName);
    if (!schemaEntry) {
      return failure(
        createSchemaRegistryError(
          "SCHEMA_NOT_FOUND",
          `Cannot get performance metrics for unknown schema '${schemaName}'`,
          { schema_name: schemaName, operation: "getEffectivePerformanceMetrics" }
        )
      );
    }
    const profile = schemaEntry.metadata.performance_profile;
    const isMeasured = profile.total_uses > 0;
    return success({
      accuracy: profile.measured_accuracy ?? profile.baseline_accuracy_estimate,
      latency_ms: profile.measured_latency_ms ?? profile.baseline_latency_estimate_ms,
      parsing_reliability: profile.measured_parsing_reliability ?? profile.baseline_parsing_reliability_estimate,
      is_measured: isMeasured
    });
  }
  /**
   * Get schema names by complexity
   */
  getSchemaNamesByComplexity() {
    const result = {
      minimal: [],
      standard: [],
      detailed: [],
      optimized: []
    };
    for (const [name, entry] of this.schemas) {
      result[entry.metadata.complexity].push(name);
    }
    return result;
  }
  /**
   * Export registry configuration for persistence
   */
  exportConfiguration() {
    const schemasConfig = {};
    for (const [name, entry] of this.schemas) {
      schemasConfig[name] = { metadata: entry.metadata };
    }
    const metricsConfig = {};
    for (const [name, metrics] of this.performanceMetrics) {
      metricsConfig[name] = metrics;
    }
    return {
      schemas: schemasConfig,
      performance_metrics: metricsConfig
    };
  }
};
var globalSchemaRegistry = new ClassificationSchemaRegistry();
function getClassificationSchema(name) {
  return globalSchemaRegistry.getSchema(name);
}
function selectOptimalClassificationSchema(criteria) {
  return globalSchemaRegistry.selectOptimalSchema(criteria);
}

// src/classifier/shared/error-types.ts
function createClassificationError(method, code, message, category, context = {}) {
  const { create: create6 } = __require("@qi/base");
  return create6(code, message, category, {
    operation: "classification",
    method,
    ...context
  });
}
function createRuleBasedError(code, message, category, context = {}) {
  return createClassificationError("rule-based", code, message, category, context);
}

// src/classifier/shared/provider-map.ts
var PROVIDER_MAP = {
  ollama: {
    baseUrl: "http://localhost:11434",
    llmClass: null,
    // Will be dynamically imported
    apiKeyEnv: "OLLAMA_API_KEY",
    modelPattern: /^(llama|qwen|mistral|codellama|phi|gemma|deepseek)[\d\w\-:.]*$/i,
    functionCallingSupported: true,
    endpointType: "ollama",
    displayName: "Ollama (Local)",
    configDefaults: {
      timeout: 3e4,
      keepAlive: "5m"
    }
  },
  openrouter: {
    baseUrl: "https://openrouter.ai/api/v1",
    llmClass: null,
    // Will be dynamically imported
    apiKeyEnv: "OPENROUTER_API_KEY",
    modelPattern: /^[\w-]+\/[\w\-.:]+$/,
    functionCallingSupported: true,
    endpointType: "openai-compatible",
    displayName: "OpenRouter",
    configDefaults: {
      timeout: 6e4
    }
  },
  openai: {
    baseUrl: "https://api.openai.com/v1",
    llmClass: null,
    // Will be dynamically imported
    apiKeyEnv: "OPENAI_API_KEY",
    modelPattern: /^(gpt-|o1-|text-|davinci|curie|babbage|ada)/i,
    functionCallingSupported: true,
    endpointType: "openai-compatible",
    displayName: "OpenAI",
    configDefaults: {
      timeout: 6e4
    }
  },
  anthropic: {
    baseUrl: "https://api.anthropic.com",
    llmClass: null,
    // Will be dynamically imported
    apiKeyEnv: "ANTHROPIC_API_KEY",
    modelPattern: /^(claude-|haiku|sonnet|opus)/i,
    functionCallingSupported: true,
    endpointType: "anthropic",
    displayName: "Anthropic",
    configDefaults: {
      timeout: 6e4
    }
  },
  together: {
    baseUrl: "https://api.together.xyz/v1",
    llmClass: null,
    // Will be dynamically imported
    apiKeyEnv: "TOGETHER_API_KEY",
    modelPattern: /^(meta-llama|mistralai|NousResearch|togethercomputer)[\w\-/]+$/i,
    functionCallingSupported: true,
    endpointType: "openai-compatible",
    displayName: "Together AI",
    configDefaults: {
      timeout: 6e4
    }
  },
  groq: {
    baseUrl: "https://api.groq.com/openai/v1",
    llmClass: null,
    // Will be dynamically imported
    apiKeyEnv: "GROQ_API_KEY",
    modelPattern: /^(llama-|mixtral-|gemma-)/i,
    functionCallingSupported: true,
    endpointType: "openai-compatible",
    displayName: "Groq",
    configDefaults: {
      timeout: 3e4
    }
  }
};
function detectProviderFromModel(modelId) {
  if (!modelId) return null;
  for (const [providerName, config] of Object.entries(PROVIDER_MAP)) {
    if (config.modelPattern.test(modelId)) {
      return {
        ...config,
        providerName
      };
    }
  }
  return null;
}
async function createLLMInstance(modelId, options = {}) {
  const providerConfig = detectProviderFromModel(modelId);
  if (!providerConfig) {
    throw new Error(
      `Unable to detect provider for model "${modelId}". Supported patterns: ${Object.entries(
        PROVIDER_MAP
      ).map(([name, config]) => `${name}: ${config.modelPattern}`).join(", ")}`
    );
  }
  const apiKey = options.apiKey || process.env[providerConfig.apiKeyEnv];
  if (providerConfig.endpointType !== "ollama" && !apiKey) {
    throw new Error(
      `API key required for ${providerConfig.displayName}. Set ${providerConfig.apiKeyEnv} environment variable or pass apiKey option.`
    );
  }
  const finalConfig = {
    model: providerConfig.transformModelName ? providerConfig.transformModelName(modelId) : modelId,
    baseUrl: options.baseUrl || providerConfig.baseUrl,
    temperature: options.temperature ?? 0.1,
    timeout: options.timeout ?? providerConfig.configDefaults?.timeout ?? 3e4,
    ...providerConfig.configDefaults,
    ...options
  };
  if (providerConfig.endpointType !== "ollama") {
    if (providerConfig.providerName === "openrouter") {
      finalConfig.openAIApiKey = apiKey;
    } else {
      finalConfig.apiKey = apiKey;
    }
  }
  let LLMClass;
  switch (providerConfig.endpointType) {
    case "ollama": {
      const { ChatOllama } = await import("@langchain/ollama");
      LLMClass = ChatOllama;
      break;
    }
    case "openai-compatible": {
      const { ChatOpenAI } = await import("@langchain/openai");
      LLMClass = ChatOpenAI;
      break;
    }
    case "anthropic": {
      const { ChatAnthropic } = await import("@langchain/anthropic");
      LLMClass = ChatAnthropic;
      break;
    }
    default:
      throw new Error(`Unsupported endpoint type: ${providerConfig.endpointType}`);
  }
  if (providerConfig.providerName === "openrouter") {
    return new LLMClass(finalConfig, {
      basePath: "https://openrouter.ai/api/v1",
      baseOptions: {
        headers: {
          "HTTP-Referer": "https://github.com/zzhang/qi-v2-agent",
          "X-Title": "Qi Classification Agent"
        }
      }
    });
  } else {
    return new LLMClass(finalConfig);
  }
}
function validateProviderAvailability(modelId) {
  const errors = [];
  const provider = detectProviderFromModel(modelId);
  if (!provider) {
    errors.push(`Model "${modelId}" does not match any known provider patterns`);
    return { isSupported: false, apiKeyAvailable: false, errors };
  }
  const apiKeyAvailable = provider.endpointType === "ollama" || !!process.env[provider.apiKeyEnv];
  if (!apiKeyAvailable && provider.endpointType !== "ollama") {
    errors.push(`Missing API key: ${provider.apiKeyEnv} environment variable not set`);
  }
  return {
    isSupported: true,
    provider,
    apiKeyAvailable,
    errors
  };
}
function debugProviderDetection(modelId) {
  const detected = detectProviderFromModel(modelId);
  const allProviderMatches = Object.entries(PROVIDER_MAP).map(([name, config]) => ({
    provider: name,
    pattern: config.modelPattern.toString(),
    matches: config.modelPattern.test(modelId)
  }));
  const apiKeysAvailable = Object.fromEntries(
    Object.entries(PROVIDER_MAP).map(([name, config]) => [
      name,
      config.endpointType === "ollama" || !!process.env[config.apiKeyEnv]
    ])
  );
  return {
    modelId,
    detectedProvider: detected?.providerName || null,
    allProviderMatches,
    apiKeysAvailable
  };
}

// src/classifier/impl/command-detection-utils.ts
var DEFAULT_COMMAND_CONFIG = {
  commandPrefix: "/",
  fileReferencePrefix: "@",
  extendedThinkingTriggers: ["think", "think harder", "think more", "reason", "analyze deeply"],
  conversationControlFlags: ["--continue", "--resume", "--new"]
};
function detectCommand(input, config = DEFAULT_COMMAND_CONFIG) {
  const trimmedInput = input.trim();
  if (trimmedInput.startsWith(config.commandPrefix)) {
    const commandName = extractCommandName(trimmedInput, config);
    const commandArgs = extractCommandArgs(trimmedInput, config);
    return {
      type: "command",
      confidence: 1,
      method: "rule-based",
      extractedData: /* @__PURE__ */ new Map([
        ["command", commandName],
        ["args", commandArgs],
        ["commandType", "slash"]
      ]),
      metadata: /* @__PURE__ */ new Map([
        ["commandName", commandName],
        ["commandType", "slash"],
        ["detectionStage", "command-detection"],
        ["detectedBy", "enhanced-command-detection"],
        ["timestamp", (/* @__PURE__ */ new Date()).toISOString()]
      ])
    };
  }
  for (const flag of config.conversationControlFlags) {
    if (trimmedInput.startsWith(flag)) {
      const args = trimmedInput.substring(flag.length).trim().split(/\s+/).filter((arg) => arg.length > 0);
      return {
        type: "command",
        confidence: 1,
        method: "rule-based",
        extractedData: /* @__PURE__ */ new Map([
          ["command", flag.substring(2)],
          // Remove -- prefix
          ["args", args],
          ["commandType", "conversation-control"]
        ]),
        metadata: /* @__PURE__ */ new Map([
          ["commandName", flag],
          ["commandType", "conversation-control"],
          ["detectionStage", "command-detection"],
          ["detectedBy", "enhanced-command-detection"],
          ["timestamp", (/* @__PURE__ */ new Date()).toISOString()]
        ])
      };
    }
  }
  const fileReferenceMatch = detectFileReference(trimmedInput, config);
  if (fileReferenceMatch) {
    return {
      type: "command",
      confidence: 0.9,
      // Slightly lower confidence as these might be part of larger requests
      method: "rule-based",
      extractedData: /* @__PURE__ */ new Map([
        ["command", "file-reference"],
        ["fileReferences", fileReferenceMatch.references],
        ["remainingText", fileReferenceMatch.remainingText],
        ["commandType", "file-reference"]
      ]),
      metadata: /* @__PURE__ */ new Map([
        ["commandType", "file-reference"],
        ["fileCount", fileReferenceMatch.references.length],
        ["detectionStage", "command-detection"],
        ["detectedBy", "enhanced-command-detection"],
        ["timestamp", (/* @__PURE__ */ new Date()).toISOString()]
      ])
    };
  }
  return null;
}
function extractCommandName(input, config = DEFAULT_COMMAND_CONFIG) {
  const prefix = config.commandPrefix.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const regex = new RegExp(`^${prefix}([a-zA-Z0-9_-]+)`);
  const match7 = input.match(regex);
  return match7 ? match7[1] : "unknown";
}
function extractCommandArgs(input, config = DEFAULT_COMMAND_CONFIG) {
  const prefix = config.commandPrefix.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const regex = new RegExp(`^${prefix}[a-zA-Z0-9_-]+\\s+(.*)$`);
  const match7 = input.match(regex);
  return match7 ? match7[1].split(/\s+/).filter((arg) => arg.length > 0) : [];
}
function detectFileReference(input, config = DEFAULT_COMMAND_CONFIG) {
  const fileReferenceRegex = new RegExp(`\\${config.fileReferencePrefix}([\\w\\-./]+)`, "g");
  const matches = Array.from(input.matchAll(fileReferenceRegex));
  if (matches.length === 0) {
    return null;
  }
  const references = matches.map((match7) => match7[1]);
  let remainingText = input;
  matches.forEach((match7) => {
    remainingText = remainingText.replace(match7[0], "").trim();
  });
  return {
    references,
    remainingText: remainingText.replace(/\s+/g, " ").trim()
  };
}

// src/classifier/impl/langchain-function-calling.ts
var createLangChainFunctionCallingError = (code, message, category, context = {}) => createClassificationError("langchain-function-calling", code, message, category, context);
var LangChainFunctionCallingClassificationMethod = class {
  llmWithStructuredOutput = null;
  config;
  initialized = false;
  selectedSchema = null;
  detectedProvider = null;
  constructor(config) {
    this.config = {
      modelId: "llama3.2:3b",
      // Default to Ollama model
      temperature: 0.1,
      timeout: 3e4,
      ...config
    };
  }
  async initializeLLM() {
    try {
      if (!this.config.modelId) {
        throw new Error("modelId is required for LangChain function calling method");
      }
      const modelId = this.config.modelId;
      const schemaResult = this.selectSchema();
      const selectedSchema = await match(
        async (schema) => schema,
        async (error) => {
          throw new Error(`Schema selection failed: ${error.message}`);
        },
        schemaResult
      );
      this.selectedSchema = selectedSchema;
      const validation = validateProviderAvailability(modelId);
      if (!validation.isSupported) {
        throw new Error(`Provider validation failed: ${validation.errors.join(", ")}`);
      }
      if (!validation.provider) {
        throw new Error("Provider detection failed: no provider found");
      }
      this.detectedProvider = validation.provider;
      if (this.config.enableProviderDebug) {
        const debug3 = debugProviderDetection(modelId);
        console.log("\u{1F50D} Provider Detection Debug:", JSON.stringify(debug3, null, 2));
      }
      const llm = await createLLMInstance(modelId, {
        baseUrl: this.config.baseUrl,
        // Override if provided
        apiKey: this.config.apiKey,
        // Override if provided
        temperature: this.config.temperature,
        timeout: this.config.timeout
      });
      const llmWithStructuredOutputMethod = llm.withStructuredOutput;
      if (llmWithStructuredOutputMethod && typeof llmWithStructuredOutputMethod === "function") {
        this.llmWithStructuredOutput = llmWithStructuredOutputMethod.call(
          llm,
          this.selectedSchema.schema,
          {
            name: this.selectedSchema.metadata.name,
            method: "functionCalling"
          }
        );
      } else {
        throw new Error("withStructuredOutput method not available on this LLM instance");
      }
    } catch (error) {
      throw new Error(
        `Failed to initialize LangChain function calling method: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
  /**
   * Select schema - explicit error propagation, NO FALLBACKS
   */
  selectSchema() {
    if (!this.config.schemaName) {
      return failure2(
        createLangChainFunctionCallingError(
          "NO_SCHEMA_SPECIFIED",
          "Schema name must be explicitly provided - no default schema allowed",
          "VALIDATION",
          { operation: "selectSchema" }
        )
      );
    }
    return globalSchemaRegistry.getSchema(this.config.schemaName);
  }
  async classify(input, context) {
    if (!this.initialized) {
      await this.initializeLLM();
      this.initialized = true;
    }
    const classificationResult = await fromAsyncTryCatch(
      async () => {
        return await this.classifyInternal(input, context);
      },
      (error) => createLangChainFunctionCallingError(
        "CLASSIFICATION_FAILED",
        `LangChain function calling classification failed: ${error instanceof Error ? error.message : String(error)}`,
        "SYSTEM",
        {
          error: String(error),
          method: "functionCalling",
          provider: this.detectedProvider?.providerName,
          model: this.config.modelId
        }
      )
    );
    return match(
      (result) => result,
      (error) => {
        throw new Error(`LangChain function calling method failed: ${error.message}`);
      },
      classificationResult
    );
  }
  async classifyInternal(input, context) {
    const startTime = Date.now();
    const validationResult = this.validateInput(input);
    const validatedInput = await match(
      async (input2) => input2,
      async (error) => {
        throw new Error(`Input validation failed: ${error.message}`);
      },
      validationResult
    );
    const commandResult = detectCommand(validatedInput);
    if (commandResult) {
      return {
        ...commandResult,
        method: "langchain-function-calling",
        metadata: new Map([
          ...Array.from(commandResult.metadata || []),
          ["optimizedBy", "command-detection-shortcut"],
          ["actualMethod", "rule-based-command-detection"],
          ["skipLLM", "true"],
          ["provider", this.detectedProvider?.providerName || "unknown"]
        ])
      };
    }
    const promptResult = this.buildPrompt(validatedInput, context);
    const prompt = await match(
      async (prompt2) => prompt2,
      async (error) => {
        throw new Error(`Prompt building failed: ${error.message}`);
      },
      promptResult
    );
    const llmResult = await this.performClassification(prompt);
    const llmOutput = await match(
      async (output) => output,
      async (error) => {
        throw new Error(`LLM classification failed: ${error.message}`);
      },
      llmResult
    );
    const processedResult = this.processResult(llmOutput, validatedInput);
    const finalResult = await match(
      async (result) => result,
      async (error) => {
        throw new Error(`Result processing failed: ${error.message}`);
      },
      processedResult
    );
    this.trackPerformance(startTime, true);
    return finalResult;
  }
  validateInput(input) {
    if (!input || typeof input !== "string") {
      return failure2(
        createLangChainFunctionCallingError(
          "INVALID_INPUT",
          "Input must be a non-empty string",
          "VALIDATION",
          { input: String(input) }
        )
      );
    }
    const trimmed = input.trim();
    if (trimmed.length === 0) {
      return failure2(
        createLangChainFunctionCallingError(
          "EMPTY_INPUT",
          "Input cannot be empty or only whitespace",
          "VALIDATION",
          { input }
        )
      );
    }
    if (trimmed.length > 1e4) {
      return failure2(
        createLangChainFunctionCallingError(
          "INPUT_TOO_LONG",
          "Input exceeds maximum length of 10,000 characters",
          "VALIDATION",
          { length: trimmed.length }
        )
      );
    }
    return success2(trimmed);
  }
  buildPrompt(input, context) {
    try {
      const contextStr = this.formatContext(context);
      const prompt = `Classify the following user input into one of two categories with high accuracy:

**Categories:**
1. **prompt** - Single-step requests, questions, or conversational inputs (e.g., "hi", "what is recursion?", "write a function", "explain this concept")  
2. **workflow** - Multi-step tasks requiring orchestration (e.g., "fix the bug in auth.js and run tests", "create a new feature with tests and documentation", "analyze this codebase and suggest improvements")

**Classification Rules:**
- Prompts are single-step requests, questions, or conversational inputs that can be answered directly
- Workflows involve multiple steps, file operations, testing, analysis, or complex task orchestration
- Look for indicators like: multiple actions, file references, testing requirements, "and then", coordination needs

**User Input:** "${input}"
${contextStr}

**Instructions:**
- Analyze the input carefully for complexity and multi-step indicators
- Consider whether this requires orchestration across multiple tools/steps
- Provide a confidence score based on how clear the classification is
- Give specific reasoning for your choice`;
      return success2(prompt);
    } catch (error) {
      return failure2(
        createLangChainFunctionCallingError(
          "PROMPT_BUILD_FAILED",
          `Failed to build classification prompt: ${error instanceof Error ? error.message : String(error)}`,
          "SYSTEM",
          { input, error: String(error) }
        )
      );
    }
  }
  performClassification(prompt) {
    return fromAsyncTryCatch(
      async () => {
        const startTime = Date.now();
        if (this.config.enableProviderDebug) {
          console.log("\u{1F50D} PROVIDER INFO:", {
            provider: this.detectedProvider?.providerName,
            model: this.config.modelId,
            endpointType: this.detectedProvider?.endpointType,
            baseUrl: this.detectedProvider?.baseUrl
          });
          console.log("\u{1F50D} PROMPT SENT:", `${prompt.substring(0, 200)}...`);
        }
        const rawResult = await this.llmWithStructuredOutput?.invoke(prompt);
        const result = this.extractStructuredOutput(rawResult);
        console.log("\u2705 LLM FUNCTION CALLING RESULT:", {
          type: result.type || "MISSING",
          confidence: result.confidence || "MISSING",
          reasoning: result.reasoning?.substring(0, 100) || "MISSING",
          fullResult: JSON.stringify(result, null, 2)
        });
        const endTime = Date.now();
        const duration = endTime - startTime;
        const debugResult = result;
        debugResult.__debug_timing = duration;
        debugResult.__debug_method = "functionCalling";
        debugResult.__debug_provider = this.detectedProvider?.providerName || "unknown";
        return result;
      },
      (error) => {
        console.log("\u{1F6A8} LLM INVOCATION FAILED:", {
          error: error instanceof Error ? error.message : String(error),
          stack: error instanceof Error ? error.stack?.split("\n").slice(0, 5) : void 0,
          provider: this.detectedProvider?.providerName,
          model: this.config.modelId,
          baseUrl: this.detectedProvider?.baseUrl
        });
        return createLangChainFunctionCallingError(
          "LLM_INVOCATION_FAILED",
          `LLM function calling invocation failed: ${error instanceof Error ? error.message : String(error)}`,
          "NETWORK",
          {
            error: String(error),
            method: "functionCalling",
            provider: this.detectedProvider?.providerName,
            baseUrl: this.detectedProvider?.baseUrl
          }
        );
      }
    );
  }
  processResult(result, originalInput) {
    try {
      if (!this.selectedSchema) {
        return failure2(
          createLangChainFunctionCallingError(
            "SCHEMA_NOT_SELECTED",
            "No schema selected for result processing",
            "SYSTEM"
          )
        );
      }
      if (!result.type || result.confidence === void 0) {
        return failure2(
          createLangChainFunctionCallingError(
            "INVALID_FUNCTION_RESULT",
            "Result missing required fields: type and confidence",
            "VALIDATION",
            { result: JSON.stringify(result) }
          )
        );
      }
      const metadata = /* @__PURE__ */ new Map([
        ["model", this.config.modelId || "unknown"],
        ["provider", this.detectedProvider?.providerName || "unknown"],
        ["provider_display_name", this.detectedProvider?.displayName || "Unknown"],
        ["endpoint_type", this.detectedProvider?.endpointType || "unknown"],
        ["method", "functionCalling"],
        ["timestamp", (/* @__PURE__ */ new Date()).toISOString()],
        ["input_length", originalInput.length.toString()],
        ["schema_used", this.selectedSchema.metadata.name],
        ["schema_complexity", this.selectedSchema.metadata.complexity]
      ]);
      const debugResult = result;
      if (debugResult.__debug_timing) {
        metadata.set("debug_timing_ms", debugResult.__debug_timing.toString());
      }
      if (debugResult.__debug_method) {
        metadata.set("debug_method", debugResult.__debug_method);
      }
      if (debugResult.__debug_provider) {
        metadata.set("debug_provider", debugResult.__debug_provider);
      }
      const extractedData = /* @__PURE__ */ new Map();
      if (result.indicators && Array.isArray(result.indicators)) {
        extractedData.set("indicators", result.indicators);
      }
      if (result.complexity_score !== void 0) {
        extractedData.set("complexity_score", result.complexity_score);
      }
      if (result.conversation_context !== void 0) {
        extractedData.set("conversation_context", result.conversation_context);
      }
      if (result.step_count !== void 0) {
        extractedData.set("step_count", result.step_count);
      }
      if (result.requires_coordination !== void 0) {
        extractedData.set("requires_coordination", result.requires_coordination);
      }
      const classificationResult = {
        type: result.type,
        confidence: typeof result.confidence === "number" ? result.confidence : parseFloat(result.confidence) || 0.5,
        method: "langchain-function-calling",
        reasoning: result.reasoning || "No reasoning provided",
        extractedData,
        metadata
      };
      return success2(classificationResult);
    } catch (error) {
      return failure2(
        createLangChainFunctionCallingError(
          "RESULT_PROCESSING_FAILED",
          `Failed to process function calling result: ${error instanceof Error ? error.message : String(error)}`,
          "SYSTEM",
          { error: String(error), result: JSON.stringify(result) }
        )
      );
    }
  }
  formatContext(context) {
    if (!context) return "";
    const parts = [];
    if (context.sessionId) parts.push(`Session: ${context.sessionId}`);
    if (context.previousInputs?.length) {
      parts.push(`Recent History: ${context.previousInputs.slice(-3).join(", ")}`);
    }
    return parts.length > 0 ? `**Context:** ${parts.join(" | ")}` : "";
  }
  /**
   * Extract structured output from LangChain result (handles AIMessageChunk)
   */
  extractStructuredOutput(rawResult) {
    const resultObj = rawResult;
    if (resultObj && typeof resultObj === "object" && resultObj.type && resultObj.confidence) {
      return resultObj;
    }
    if (resultObj?.tool_calls && Array.isArray(resultObj.tool_calls) && resultObj.tool_calls.length > 0) {
      const toolCall = resultObj.tool_calls[0];
      if (toolCall?.args) {
        return toolCall.args;
      }
    }
    if (resultObj?.content && typeof resultObj.content === "string") {
      try {
        const parsed = JSON.parse(resultObj.content);
        return parsed;
      } catch {
      }
    }
    return {
      type: "prompt",
      confidence: 0.5,
      reasoning: "Unable to extract structured output from LLM response"
    };
  }
  trackPerformance(startTime, success5) {
    if (!this.selectedSchema) return;
    const latencyMs = Date.now() - startTime;
    const trackingResult = globalSchemaRegistry.trackSchemaUsage(
      this.selectedSchema.metadata.name,
      latencyMs,
      success5,
      success5
      // For function calling, classification success == parsing success
    );
    match(
      () => {
      },
      // Success - do nothing
      (error) => console.warn(`Failed to track function calling performance: ${error.message}`),
      trackingResult
    );
  }
  // Interface implementation
  getMethodName() {
    return "langchain-function-calling";
  }
  getExpectedAccuracy() {
    if (this.selectedSchema) {
      return this.selectedSchema.metadata.performance_profile.measured_accuracy ?? this.selectedSchema.metadata.performance_profile.baseline_accuracy_estimate;
    }
    return 0.85;
  }
  getAverageLatency() {
    if (this.selectedSchema) {
      return this.selectedSchema.metadata.performance_profile.measured_latency_ms ?? this.selectedSchema.metadata.performance_profile.baseline_latency_estimate_ms;
    }
    return 7200;
  }
  async isAvailable() {
    try {
      if (!this.detectedProvider) {
        if (!this.config.modelId) {
          return false;
        }
        const validation = validateProviderAvailability(this.config.modelId);
        return validation.isSupported && validation.apiKeyAvailable;
      }
      if (this.detectedProvider.endpointType === "ollama") {
        const baseUrl = this.config.baseUrl || this.detectedProvider.baseUrl;
        const response = await fetch(`${baseUrl}/api/tags`, {
          method: "GET",
          signal: AbortSignal.timeout(5e3)
        });
        if (!response.ok) return false;
        const data = await response.json();
        return data.models?.some((model) => model.name === this.config.modelId) || false;
      }
      return !!process.env[this.detectedProvider.apiKeyEnv];
    } catch (_error) {
      return false;
    }
  }
};

// src/classifier/impl/ollama-native.ts
import { JsonOutputParser } from "@langchain/core/output_parsers";
import {
  failure as failure3,
  fromAsyncTryCatch as fromAsyncTryCatch2,
  success as success3
} from "@qi/base";
var createOllamaNativeClassificationError = (code, message, category, context = {}) => createClassificationError("ollama-native", code, message, category, context);
var OllamaNativeClassificationMethod = class {
  config;
  selectedSchema;
  jsonParser;
  promptTemplate;
  // Performance tracking
  totalClassifications = 0;
  successfulClassifications = 0;
  totalLatencyMs = 0;
  constructor(config = {}) {
    this.config = {
      baseUrl: config.baseUrl || "http://localhost:11434",
      modelId: config.modelId || "llama3.2:3b",
      temperature: config.temperature || 0.1,
      timeout: config.timeout || 3e4,
      // Default 30 seconds
      schemaName: config.schemaName || "minimal",
      schemaComplexity: config.schemaComplexity || "minimal"
    };
    this.jsonParser = new JsonOutputParser();
    const schemaResult = this.selectSchema();
    if (schemaResult.tag === "success") {
      this.selectedSchema = schemaResult.value;
    }
    this.promptTemplate = `Classify the following user input into one of two categories:

**Categories:**
1. **prompt** - Single questions, explanations, greetings, or direct requests that can be answered immediately
   Examples: "Hi", "What is recursion?", "Explain machine learning", "How does JavaScript work?", "Write a function"
   
2. **workflow** - Multi-step tasks requiring coordination of multiple actions or tools
   Examples: "Fix bug in auth.js AND run tests", "Create feature WITH validation AND tests", "Analyze codebase AND suggest improvements"

**Key Classification Rules:**
- **prompt**: Simple questions, explanations, single coding requests, greetings, concept explanations
- **workflow**: Contains coordinating words (AND, then, with), multiple file operations, testing + code changes, analysis + recommendations

**Important:** 
- Questions asking "what is X?" or "explain Y" are ALWAYS prompts, even if complex topics
- Only classify as workflow if there are genuinely multiple coordinated steps

**User Input:** "{{INPUT}}"
{{CONTEXT}}

Respond with valid JSON matching the required schema.`;
  }
  async classify(input, context) {
    const startTime = Date.now();
    this.totalClassifications++;
    try {
      const commandResult = detectCommand(input, {
        commandPrefix: "/",
        fileReferencePrefix: "",
        extendedThinkingTriggers: [],
        conversationControlFlags: []
      });
      if (commandResult !== null) {
        const duration2 = Date.now() - startTime;
        this.totalLatencyMs += duration2;
        this.successfulClassifications++;
        const metadata = new Map(commandResult.metadata);
        metadata.set("duration_ms", duration2.toString());
        metadata.set("provider", "ollama-native");
        return {
          ...commandResult,
          method: "ollama-native",
          metadata
        };
      }
      const classificationResult = await this.performOllamaClassification(input, context);
      if (classificationResult.tag === "failure") {
        const duration2 = Date.now() - startTime;
        this.totalLatencyMs += duration2;
        throw new Error(`Classification failed: ${classificationResult.error.message}`);
      }
      const duration = Date.now() - startTime;
      this.totalLatencyMs += duration;
      this.successfulClassifications++;
      return classificationResult.value;
    } catch (error) {
      const duration = Date.now() - startTime;
      this.totalLatencyMs += duration;
      throw new Error(
        `Ollama native classification failed: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
  getMethodName() {
    return "ollama-native";
  }
  getExpectedAccuracy() {
    return 0.9;
  }
  getAverageLatency() {
    return this.totalClassifications > 0 ? Math.round(this.totalLatencyMs / this.totalClassifications) : 0;
  }
  async isAvailable() {
    try {
      const response = await fetch(`${this.config.baseUrl}/api/tags`);
      if (!response.ok) return false;
      const data = await response.json();
      return data.models?.some((model) => model.name === this.config.modelId) || false;
    } catch {
      return false;
    }
  }
  // Private methods
  async performOllamaClassification(input, context) {
    return fromAsyncTryCatch2(
      async () => {
        const promptResult = this.buildPrompt(input, context);
        if (promptResult.tag === "failure") {
          throw new Error(`Prompt building failed: ${promptResult.error.message}`);
        }
        const prompt = promptResult.value;
        const jsonSchemaResult = this.createOllamaJsonSchema();
        if (jsonSchemaResult.tag === "failure") {
          throw new Error(`Schema creation failed: ${jsonSchemaResult.error.message}`);
        }
        const jsonSchema = jsonSchemaResult.value;
        const ollamaResponse = await this.callOllamaNativeAPI(prompt, jsonSchema);
        return await this.processOllamaResponse(ollamaResponse, input);
      },
      (error) => createOllamaNativeClassificationError(
        "CLASSIFICATION_FAILED",
        `Ollama native classification failed: ${error instanceof Error ? error.message : String(error)}`,
        "NETWORK",
        { error: String(error) }
      )
    );
  }
  selectSchema() {
    try {
      return globalSchemaRegistry.getSchema(this.config.schemaName || "minimal");
    } catch (error) {
      return failure3(
        createOllamaNativeClassificationError(
          "SCHEMA_SELECTION_FAILED",
          `Schema selection failed: ${error instanceof Error ? error.message : String(error)}`,
          "SYSTEM",
          { error: String(error) }
        )
      );
    }
  }
  buildPrompt(input, context) {
    try {
      const contextStr = this.formatContext(context);
      const prompt = this.promptTemplate.replace("{{INPUT}}", input).replace("{{CONTEXT}}", contextStr);
      return success3(prompt);
    } catch (error) {
      return failure3(
        createOllamaNativeClassificationError(
          "PROMPT_BUILD_FAILED",
          `Failed to build classification prompt: ${error instanceof Error ? error.message : String(error)}`,
          "SYSTEM",
          { input, error: String(error) }
        )
      );
    }
  }
  createOllamaJsonSchema() {
    if (!this.selectedSchema) {
      return failure3(
        createOllamaNativeClassificationError(
          "NO_SCHEMA_SELECTED",
          "Schema must be explicitly selected - no default schema available",
          "SYSTEM"
        )
      );
    }
    const schemaName = this.selectedSchema.metadata.name;
    if (schemaName === "minimal") {
      return success3({
        type: "object",
        properties: {
          type: {
            type: "string",
            enum: ["prompt", "workflow"],
            description: "Classification: prompt (single-step) or workflow (multi-step)"
          },
          confidence: {
            type: "number",
            minimum: 0,
            maximum: 1,
            description: "Confidence score from 0.0 to 1.0"
          }
        },
        required: ["type", "confidence"]
      });
    } else if (schemaName === "standard") {
      return success3({
        type: "object",
        properties: {
          type: {
            type: "string",
            enum: ["prompt", "workflow"],
            description: "Classification: prompt (single-step) or workflow (multi-step)"
          },
          confidence: {
            type: "number",
            minimum: 0,
            maximum: 1,
            description: "Confidence score from 0.0 to 1.0"
          },
          reasoning: {
            type: "string",
            description: "Brief explanation of the classification decision"
          }
        },
        required: ["type", "confidence", "reasoning"]
      });
    } else if (schemaName === "context_aware") {
      return success3({
        type: "object",
        properties: {
          type: {
            type: "string",
            enum: ["prompt", "workflow"],
            description: "prompt: direct question/request, workflow: requires multiple coordinated steps"
          },
          confidence: {
            type: "number",
            minimum: 0,
            maximum: 1,
            description: "Confidence score from 0.0 to 1.0"
          },
          reasoning: {
            type: "string",
            description: "Brief explanation of classification decision"
          },
          conversation_context: {
            type: "string",
            enum: ["greeting", "question", "follow_up", "task_request", "multi_step"],
            description: "Context type: greeting/question/follow_up always prompt, task_request/multi_step may be workflow"
          },
          step_count: {
            type: "integer",
            minimum: 1,
            description: "Estimated number of steps needed (1=prompt, 2+=workflow)"
          },
          requires_coordination: {
            type: "boolean",
            description: "Does this require coordinating multiple tools/services?"
          }
        },
        required: [
          "type",
          "confidence",
          "reasoning",
          "conversation_context",
          "step_count",
          "requires_coordination"
        ]
      });
    } else {
      return failure3(
        createOllamaNativeClassificationError(
          "UNSUPPORTED_SCHEMA",
          `Schema '${schemaName}' is not supported by ollama-native method. Supported schemas: minimal, standard, context_aware`,
          "SYSTEM",
          {
            requested_schema: schemaName,
            supported_schemas: ["minimal", "standard", "context_aware"]
          }
        )
      );
    }
  }
  async callOllamaNativeAPI(prompt, jsonSchema) {
    const requestBody = {
      model: this.config.modelId,
      prompt,
      format: jsonSchema,
      stream: false,
      options: {
        temperature: this.config.temperature,
        num_predict: 500
        // Limit response length for classification
      }
    };
    const controller = new AbortController();
    const timeoutMs = this.config.timeout || 3e4;
    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
    let lastError = null;
    for (let attempt = 1; attempt <= 3; attempt++) {
      try {
        const response = await fetch(`${this.config.baseUrl}/api/generate`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify(requestBody),
          signal: controller.signal
        });
        clearTimeout(timeoutId);
        if (!response.ok) {
          const errorText = await response.text().catch(() => "Unknown error");
          throw new Error(
            `Ollama API error: ${response.status} ${response.statusText} - ${errorText}`
          );
        }
        const result = await response.json();
        if (!result || typeof result.response !== "string") {
          throw new Error(`Invalid Ollama response structure: missing response field`);
        }
        return result;
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error));
        if (error instanceof Error && error.name === "AbortError") {
          clearTimeout(timeoutId);
          throw new Error(`Ollama API timeout after ${timeoutMs / 1e3} seconds`);
        }
        if (attempt < 3) {
          await new Promise((resolve) => setTimeout(resolve, 1e3 * attempt));
          console.warn(`Ollama API attempt ${attempt} failed, retrying...`, lastError.message);
        }
      }
    }
    clearTimeout(timeoutId);
    throw lastError || new Error("All retry attempts failed");
  }
  async processOllamaResponse(ollamaResponse, originalInput) {
    try {
      const parsedResult = await this.jsonParser.parse(ollamaResponse.response);
      if (!parsedResult || typeof parsedResult !== "object") {
        throw new Error("Response is not a valid object");
      }
      if (!parsedResult.type || !["prompt", "workflow", "command"].includes(parsedResult.type)) {
        throw new Error(
          `Invalid type field: ${parsedResult.type}. Must be 'prompt', 'workflow', or 'command'`
        );
      }
      let confidence = parsedResult.confidence;
      if (typeof confidence !== "number" || Number.isNaN(confidence)) {
        console.warn(`Invalid confidence value: ${confidence}, defaulting to 0.5`);
        confidence = 0.5;
      }
      confidence = Math.max(0, Math.min(1, confidence));
      const metadata = /* @__PURE__ */ new Map([
        ["model", this.config.modelId || "unknown"],
        ["provider", "ollama-native"],
        ["timestamp", (/* @__PURE__ */ new Date()).toISOString()],
        ["input_length", originalInput.length.toString()],
        ["schema_used", this.selectedSchema?.metadata.name || "minimal"],
        ["total_duration_ms", ollamaResponse.total_duration?.toString() || "0"],
        ["eval_duration_ms", ollamaResponse.eval_duration?.toString() || "0"],
        ["raw_response_length", ollamaResponse.response.length.toString()],
        ["response_preview", ollamaResponse.response.substring(0, 100)]
      ]);
      const extractedData = /* @__PURE__ */ new Map();
      if (parsedResult.indicators && Array.isArray(parsedResult.indicators)) {
        extractedData.set("indicators", parsedResult.indicators);
      }
      if (parsedResult.complexity_score !== void 0) {
        extractedData.set("complexity_score", parsedResult.complexity_score);
      }
      const classificationResult = {
        type: parsedResult.type,
        confidence,
        method: "ollama-native",
        reasoning: parsedResult.reasoning || "No reasoning provided",
        extractedData,
        metadata
      };
      return classificationResult;
    } catch (error) {
      throw new Error(
        `Failed to process Ollama response: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
  formatContext(context) {
    if (!context) return "";
    const contextParts = [];
    if (context.previousInputs && context.previousInputs.length > 0) {
      contextParts.push(`
**Previous Context:** ${context.previousInputs.slice(-3).join(", ")}`);
    }
    if (context.source) {
      contextParts.push(`**Source:** ${context.source}`);
    }
    return contextParts.length > 0 ? contextParts.join("\n") : "";
  }
};

// src/classifier/impl/rule-based.ts
import {
  failure as failure4,
  fromAsyncTryCatch as fromAsyncTryCatch3,
  match as match2,
  success as success4
} from "@qi/base";
var createRuleBasedClassificationError = (code, message, category, context = {}) => createRuleBasedError(code, message, category, context);
var RuleBasedClassificationMethod = class {
  config;
  // Performance tracking
  totalClassifications = 0;
  totalLatencyMs = 0;
  successfulClassifications = 0;
  performanceHistory = [];
  constructor(config = {}) {
    this.config = {
      commandPrefix: config.commandPrefix || "/",
      promptIndicators: config.promptIndicators || [
        "hi",
        "hello",
        "thanks",
        "what",
        "how",
        "why",
        "when",
        "can you",
        "could you",
        "please",
        "explain"
      ],
      workflowIndicators: config.workflowIndicators || [
        "fix",
        "create",
        "refactor",
        "implement",
        "debug",
        "analyze",
        "build",
        "design",
        "test",
        "deploy",
        "find",
        "search",
        "book",
        "reserve",
        "schedule",
        "add",
        "remove",
        "delete",
        "update",
        "change",
        "set",
        "configure",
        "install",
        "setup"
      ],
      confidenceThresholds: config.confidenceThresholds || /* @__PURE__ */ new Map([
        ["command", 1],
        ["prompt", 0.8],
        ["workflow", 0.7]
      ])
    };
  }
  async classify(input, context) {
    const classificationResult = await fromAsyncTryCatch3(
      async () => {
        return await this.classifyInternal(input, context);
      },
      (error) => createRuleBasedClassificationError(
        "RULE_CLASSIFICATION_FAILED",
        `Rule-based classification failed: ${error instanceof Error ? error.message : String(error)}`,
        "SYSTEM",
        { error: String(error), method: "rule-based" }
      )
    );
    return match2(
      (result) => result,
      (error) => {
        throw new Error(`RuleBased classification failed: ${error.message}`);
      },
      classificationResult
    );
  }
  async classifyInternal(input, context) {
    const startTime = Date.now();
    const validationResult = this.validateInputInternal(input);
    return match2(
      (validatedInput) => {
        const trimmedInput = validatedInput.trim();
        const commandResult = this.detectCommandInternal(trimmedInput, startTime);
        if (commandResult) {
          return commandResult;
        }
        const complexityAnalysis = this.analyzeComplexity(trimmedInput, context);
        if (complexityAnalysis.isSimplePrompt) {
          return this.createPromptResult(complexityAnalysis, startTime);
        }
        return this.createWorkflowResult(complexityAnalysis, startTime);
      },
      (error) => {
        throw new Error(error.message);
      },
      validationResult
    );
  }
  validateInputInternal(input) {
    if (!input || typeof input !== "string") {
      return failure4(
        createRuleBasedClassificationError(
          "INVALID_INPUT",
          "Input must be a non-empty string",
          "VALIDATION",
          { input: String(input), operation: "validation" }
        )
      );
    }
    const trimmed = input.trim();
    if (trimmed.length === 0) {
      return failure4(
        createRuleBasedClassificationError(
          "EMPTY_INPUT",
          "Input cannot be empty or only whitespace",
          "VALIDATION",
          { input, operation: "validation" }
        )
      );
    }
    if (trimmed.length > 1e4) {
      return failure4(
        createRuleBasedClassificationError(
          "INPUT_TOO_LONG",
          "Input exceeds maximum length of 10,000 characters",
          "VALIDATION",
          { length: trimmed.length, operation: "validation" }
        )
      );
    }
    return success4(trimmed);
  }
  detectCommandInternal(trimmedInput, startTime) {
    if (trimmedInput.startsWith(this.config.commandPrefix)) {
      return {
        type: "command",
        confidence: 1,
        method: "rule-based",
        reasoning: `Command detected with prefix "${this.config.commandPrefix}"`,
        extractedData: /* @__PURE__ */ new Map([
          ["commandPrefix", this.config.commandPrefix],
          ["command", trimmedInput]
        ]),
        metadata: /* @__PURE__ */ new Map([
          ["method", "rule-based-command-detection"],
          ["latency", (Date.now() - startTime).toString()]
        ])
      };
    }
    return null;
  }
  createPromptResult(complexityAnalysis, startTime) {
    const latency = this.trackPerformance(startTime, true);
    return {
      type: "prompt",
      confidence: complexityAnalysis.confidence,
      method: "rule-based",
      reasoning: `Simple prompt detected: ${complexityAnalysis.reasoning}`,
      extractedData: /* @__PURE__ */ new Map([
        ["promptType", complexityAnalysis.promptType],
        ["indicators", JSON.stringify(complexityAnalysis.promptIndicators)]
      ]),
      metadata: /* @__PURE__ */ new Map([
        ["method", "complexity-analysis"],
        ["analysis", JSON.stringify(complexityAnalysis)],
        ["latency", latency.toString()],
        ["performance_tracked", "true"]
      ])
    };
  }
  createWorkflowResult(complexityAnalysis, startTime) {
    const latency = this.trackPerformance(startTime, true);
    return {
      type: "workflow",
      confidence: complexityAnalysis.confidence,
      method: "rule-based",
      reasoning: `Complex workflow detected: ${complexityAnalysis.reasoning}`,
      extractedData: /* @__PURE__ */ new Map([
        ["workflowIndicators", JSON.stringify(complexityAnalysis.workflowIndicators)],
        ["complexity", complexityAnalysis.estimatedComplexity]
      ]),
      metadata: /* @__PURE__ */ new Map([
        ["method", "complexity-analysis"],
        ["analysis", JSON.stringify(complexityAnalysis)],
        ["latency", latency.toString()],
        ["performance_tracked", "true"]
      ])
    };
  }
  /**
   * Track performance metrics for classification
   */
  trackPerformance(startTime, success5) {
    const latency = Date.now() - startTime;
    this.totalClassifications++;
    this.totalLatencyMs += latency;
    if (success5) {
      this.successfulClassifications++;
    }
    this.performanceHistory.push({
      latency,
      success: success5,
      timestamp: Date.now()
    });
    if (this.performanceHistory.length > 100) {
      this.performanceHistory.shift();
    }
    return latency;
  }
  getMethodName() {
    return "rule-based";
  }
  getExpectedAccuracy() {
    if (this.totalClassifications === 0) {
      return 0.85;
    }
    return this.successfulClassifications / this.totalClassifications;
  }
  getAverageLatency() {
    if (this.totalClassifications === 0) {
      return 50;
    }
    return Math.round(this.totalLatencyMs / this.totalClassifications);
  }
  async isAvailable() {
    return true;
  }
  analyzeComplexity(input, _context) {
    const lowerInput = input.toLowerCase();
    const indicators = this.extractComplexityIndicators(input);
    if (this.isSimplePrompt(lowerInput, indicators)) {
      return {
        isSimplePrompt: true,
        confidence: this.calculatePromptConfidence(input, indicators),
        promptType: this.classifyPromptType(lowerInput),
        reasoning: "Detected greeting, question, or conversational marker",
        promptIndicators: indicators.promptSignals,
        workflowIndicators: [],
        estimatedComplexity: "low"
      };
    }
    return {
      isSimplePrompt: false,
      confidence: this.calculateWorkflowConfidence(input, indicators),
      promptType: "none",
      reasoning: "Detected action verbs, file references, or multi-step indicators",
      promptIndicators: [],
      workflowIndicators: indicators.workflowSignals,
      estimatedComplexity: this.estimateComplexity(indicators)
    };
  }
  isSimplePrompt(input, indicators) {
    const hasStrongPromptSignals = indicators.promptSignals.length >= 2;
    const isShortQuestion = indicators.questionWords.length > 0 && input.length < 30;
    const isConversational = /^(hi|hello|hey|thanks|thank you|ok|yes|no|sure)\b/i.test(
      input.trim()
    );
    if (hasStrongPromptSignals || isShortQuestion || isConversational) {
      return true;
    }
    const hasWorkflowSignals = indicators.workflowSignals.length > 0;
    const hasFileReferences = indicators.fileReferences.length > 0;
    const hasTechnicalTerms = indicators.technicalTerms.length > 0;
    const hasMultiStep = indicators.multiStepIndicators.length > 0;
    const isTaskOriented = /\b(find|search|book|reserve|get|show|list|add|remove|delete|update|change|set)\b/i.test(
      input
    );
    const isRequest2 = /\b(please|can you|could you|would you|i want|i need|help me)\b/i.test(input);
    if (hasWorkflowSignals || hasFileReferences || hasTechnicalTerms || hasMultiStep || isTaskOriented && isRequest2) {
      return false;
    }
    if (input.length < 20) {
      return true;
    }
    return false;
  }
  extractComplexityIndicators(input) {
    const lowerInput = input.toLowerCase();
    return {
      promptSignals: this.findMatches(lowerInput, this.config.promptIndicators),
      workflowSignals: this.findMatches(lowerInput, this.config.workflowIndicators),
      questionWords: this.findMatches(lowerInput, ["what", "how", "why", "when", "where", "who"]),
      fileReferences: this.findFileReferences(input),
      technicalTerms: this.findMatches(lowerInput, [
        "function",
        "class",
        "api",
        "database",
        "server",
        "test"
      ]),
      multiStepIndicators: this.findMatches(lowerInput, ["then", "after", "and", "also", "next"])
    };
  }
  findMatches(text, patterns) {
    return patterns.filter((pattern) => text.includes(pattern));
  }
  findFileReferences(input) {
    const matches = input.match(/\b\w+\.\w+\b/g) || [];
    return matches.filter((match7) => /\.(js|ts|py|java|cpp|html|css|json|yaml|md)$/i.test(match7));
  }
  calculatePromptConfidence(_input, indicators) {
    let confidence = 0.5;
    confidence += indicators.promptSignals.length * 0.2;
    confidence += indicators.questionWords.length * 0.15;
    confidence -= indicators.workflowSignals.length * 0.15;
    confidence -= indicators.fileReferences.length * 0.2;
    return Math.max(0.1, Math.min(0.95, confidence));
  }
  calculateWorkflowConfidence(_input, indicators) {
    let confidence = 0.5;
    confidence += indicators.workflowSignals.length * 0.2;
    confidence += indicators.fileReferences.length * 0.25;
    confidence += indicators.multiStepIndicators.length * 0.1;
    confidence -= indicators.promptSignals.length * 0.2;
    return Math.max(0.1, Math.min(0.95, confidence));
  }
  classifyPromptType(input) {
    if (this.config.promptIndicators.some(
      (indicator) => ["hi", "hello", "thanks"].includes(indicator) && input.includes(indicator)
    )) {
      return "greeting";
    }
    if (input.includes("what") || input.includes("how") || input.includes("why")) {
      return "question";
    }
    return "general";
  }
  estimateComplexity(indicators) {
    const signals = indicators.workflowSignals.length + indicators.fileReferences.length + indicators.multiStepIndicators.length;
    if (signals > 3) return "high";
    if (signals > 1) return "medium";
    return "low";
  }
};

// src/classifier/index.ts
function createClassifier(config = {}) {
  const method = new RuleBasedClassificationMethod({
    commandPrefix: "/",
    promptIndicators: ["hi", "hello", "what", "how", "why", "explain"],
    workflowIndicators: ["fix", "create", "refactor", "implement", "debug"],
    confidenceThreshold: 0.8,
    ...config
  });
  return new InputClassifier(method);
}
function createRuleBasedClassifier(config = {}) {
  const method = new RuleBasedClassificationMethod({
    commandPrefix: config.commandPrefix || "/",
    promptIndicators: config.promptIndicators || ["hi", "hello", "what", "how", "why", "explain"],
    workflowIndicators: config.workflowIndicators || [
      "fix",
      "create",
      "refactor",
      "implement",
      "debug"
    ],
    confidenceThresholds: /* @__PURE__ */ new Map([
      ["command", config.confidenceThreshold || 0.8],
      ["prompt", config.confidenceThreshold || 0.8],
      ["workflow", config.confidenceThreshold || 0.8]
    ])
  });
  return new InputClassifier(method);
}
function createOllamaNativeClassifier(config = {}) {
  const defaultConfig = {
    baseUrl: "http://localhost:11434",
    // Native Ollama endpoint
    modelId: "llama3.2:3b",
    temperature: 0.1,
    schemaName: "minimal",
    schemaComplexity: "minimal",
    ...config
  };
  return new OllamaNativeClassificationMethod(defaultConfig);
}
function createInputClassifier(config = {}) {
  const method = config.method || "ollama-native";
  switch (method) {
    case "rule-based": {
      const ruleMethod = new RuleBasedClassificationMethod({
        commandPrefix: config.commandPrefix || "/",
        promptIndicators: config.promptIndicators || [
          "hi",
          "hello",
          "what",
          "how",
          "why",
          "explain"
        ],
        workflowIndicators: config.workflowIndicators || [
          "fix",
          "create",
          "refactor",
          "implement",
          "debug"
        ],
        confidenceThresholds: /* @__PURE__ */ new Map([
          ["command", config.confidenceThreshold || 0.8],
          ["prompt", config.confidenceThreshold || 0.8],
          ["workflow", config.confidenceThreshold || 0.8]
        ])
      });
      return new InputClassifier(ruleMethod);
    }
    case "ollama-native": {
      const ollamaNativeMethod = createOllamaNativeClassifier({
        baseUrl: config.baseUrl,
        modelId: config.modelId,
        temperature: config.temperature,
        schemaName: config.schemaName
      });
      return new InputClassifier(ollamaNativeMethod);
    }
    case "langchain-function-calling": {
      const functionCallingMethod = new LangChainFunctionCallingClassificationMethod({
        baseUrl: config.baseUrl,
        modelId: config.modelId,
        apiKey: config.apiKey,
        temperature: config.temperature,
        timeout: config.timeout,
        schemaName: config.schemaName,
        schemaSelectionCriteria: config.schemaSelectionCriteria,
        enableProviderDebug: config.enableProviderDebug
      });
      return new InputClassifier(functionCallingMethod);
    }
    case "file-reference": {
      throw new Error("file-reference classification method has been moved to workflow system");
    }
    default:
      throw new Error(
        `Invalid classification method: "${method}". Valid methods are: rule-based, ollama-native, langchain-function-calling, file-reference`
      );
  }
}
function createFastClassifier(config = {}) {
  return createInputClassifier({ method: "rule-based", ...config });
}
function createAccurateClassifier(config = {}) {
  return createInputClassifier({ method: "ollama-native", ...config });
}
var createBasicClassifier = createRuleBasedClassifier;
var createCompleteClassifier = createInputClassifier;

// src/command/impl/CommandHandler.ts
import { exec } from "child_process";
import { promisify } from "util";
var execAsync = promisify(exec);
var BUILT_IN_COMMANDS = [
  {
    name: "help",
    description: "Show available commands and their usage",
    usage: "/help [command_name]",
    aliases: ["h", "?"],
    category: "system",
    parameters: [
      {
        name: "command",
        type: "string",
        required: false,
        description: "Specific command to get help for"
      }
    ]
  },
  {
    name: "status",
    description: "Show current application status",
    usage: "/status",
    aliases: ["info"],
    category: "system",
    parameters: []
  },
  {
    name: "clear",
    description: "Clear the screen",
    usage: "/clear",
    aliases: ["cls"],
    category: "ui",
    parameters: []
  },
  {
    name: "exit",
    description: "Exit the application",
    usage: "/exit",
    aliases: ["quit", "q"],
    category: "system",
    parameters: []
  },
  {
    name: "model",
    description: "Show or change the current LLM model",
    usage: "/model [model_name]",
    aliases: ["m"],
    category: "llm",
    parameters: [
      {
        name: "model_name",
        type: "string",
        required: false,
        description: "Model name to switch to"
      }
    ]
  },
  {
    name: "provider",
    description: "Show or change the current LLM provider",
    usage: "/provider [provider_name]",
    aliases: ["p"],
    category: "llm",
    parameters: [
      {
        name: "provider_name",
        type: "string",
        required: false,
        description: "Provider name to switch to"
      }
    ]
  }
];
var SAFE_SHELL_COMMANDS = /* @__PURE__ */ new Set([
  "ls",
  "dir",
  "pwd",
  "whoami",
  "date",
  "echo",
  "cat",
  "head",
  "tail",
  "grep",
  "find",
  "which",
  "man",
  "history",
  "ps",
  "top",
  "df",
  "du",
  "git",
  "npm",
  "bun",
  "node",
  "python",
  "pip"
]);
var CommandHandler = class {
  commandRegistry = /* @__PURE__ */ new Map();
  commandDefinitions = /* @__PURE__ */ new Map();
  aliasMap = /* @__PURE__ */ new Map();
  config;
  constructor(config = {}) {
    this.config = {
      enableBuiltInCommands: true,
      enableShellCommands: false,
      ...config
    };
    if (this.config.enableBuiltInCommands) {
      this.registerBuiltInCommands();
    }
    if (this.config.customCommands) {
      for (const [name, executor] of this.config.customCommands) {
        this.registerCommand(
          {
            name,
            description: `Custom command: ${name}`,
            usage: `/${name}`,
            category: "custom",
            parameters: []
          },
          executor
        );
      }
    }
  }
  async executeCommand(request) {
    const startTime = Date.now();
    try {
      const resolvedCommand = this.resolveCommandName(request.commandName);
      if (this.commandRegistry.has(resolvedCommand)) {
        const handler = this.commandRegistry.get(resolvedCommand);
        const result = await handler(request);
        return {
          ...result,
          metadata: new Map([...result.metadata, ["executionTime", Date.now() - startTime]])
        };
      }
      if (this.config.enableShellCommands && this.isSafeShellCommand(resolvedCommand)) {
        return await this.executeShellCommand(
          resolvedCommand,
          Array.from(request.parameters.values())
        );
      }
      return {
        status: "not_found",
        content: `Command not found: ${request.commandName}. Use /help to see available commands.`,
        success: false,
        output: "",
        commandName: request.commandName,
        metadata: /* @__PURE__ */ new Map([["executionTime", Date.now() - startTime]])
      };
    } catch (error) {
      return {
        status: "error",
        content: `Command execution failed: ${error instanceof Error ? error.message : String(error)}`,
        success: false,
        output: "",
        commandName: request.commandName,
        metadata: /* @__PURE__ */ new Map([["executionTime", Date.now() - startTime]])
      };
    }
  }
  getAvailableCommands() {
    return Array.from(this.commandDefinitions.values());
  }
  async validateCommand(commandName, _parameters) {
    const resolvedCommand = this.resolveCommandName(commandName);
    return this.commandRegistry.has(resolvedCommand);
  }
  registerCommand(definition, handler) {
    if (!definition.name || !/^[a-zA-Z][a-zA-Z0-9_-]*$/.test(definition.name)) {
      throw new Error(`Invalid command name: ${definition.name}`);
    }
    this.commandRegistry.set(definition.name, handler);
    this.commandDefinitions.set(definition.name, definition);
    if (definition.aliases) {
      for (const alias of definition.aliases) {
        this.aliasMap.set(alias, definition.name);
      }
    }
  }
  unregisterCommand(commandName) {
    this.commandRegistry.delete(commandName);
    const definition = this.commandDefinitions.get(commandName);
    this.commandDefinitions.delete(commandName);
    if (definition?.aliases) {
      for (const alias of definition.aliases) {
        this.aliasMap.delete(alias);
      }
    }
  }
  // Private methods
  registerBuiltInCommands() {
    this.registerCommand(
      BUILT_IN_COMMANDS.find((c2) => c2.name === "help"),
      async (request) => {
        const args = Array.from(request.parameters.values());
        if (args.length > 0) {
          const help = this.getCommandHelp(args[0]);
          return {
            status: "success",
            content: help || `No help available for command: ${args[0]}`,
            output: help || `No help available for command: ${args[0]}`,
            commandName: "help",
            success: true,
            metadata: /* @__PURE__ */ new Map()
          };
        }
        const commands = this.getAvailableCommands();
        let output = "Available commands:\n\n";
        for (const cmd of commands) {
          output += `  /${cmd.name} - ${cmd.description}
`;
        }
        output += "\nUse /help <command> for detailed usage information.";
        return {
          status: "success",
          content: output,
          output,
          commandName: "help",
          success: true,
          metadata: /* @__PURE__ */ new Map()
        };
      }
    );
    this.registerCommand(
      BUILT_IN_COMMANDS.find((c2) => c2.name === "status"),
      async (_request) => {
        const output = [
          `Commands Registered: ${this.commandRegistry.size}`,
          `Shell Commands: ${this.config.enableShellCommands ? "Enabled" : "Disabled"}`
        ].join("\\n");
        return {
          status: "success",
          content: output,
          output,
          commandName: "status",
          success: true,
          metadata: /* @__PURE__ */ new Map()
        };
      }
    );
    this.registerCommand(
      BUILT_IN_COMMANDS.find((c2) => c2.name === "clear"),
      async (_request) => {
        process.stdout.write("\\x1b[2J\\x1b[0f");
        return {
          status: "success",
          content: "Screen cleared",
          output: "",
          commandName: "clear",
          success: true,
          metadata: /* @__PURE__ */ new Map()
        };
      }
    );
    this.registerCommand(
      BUILT_IN_COMMANDS.find((c2) => c2.name === "exit"),
      async (_request) => {
        process.stdout.write("\\n\u{1F44B} Goodbye!\\n");
        setTimeout(() => {
          process.exit(0);
        }, 100);
        return {
          status: "success",
          content: "Exiting application...",
          output: "Exiting application...",
          commandName: "exit",
          success: true,
          metadata: /* @__PURE__ */ new Map()
        };
      }
    );
  }
  resolveCommandName(name) {
    return this.aliasMap.get(name) || name;
  }
  getCommandHelp(name) {
    const resolved = this.resolveCommandName(name);
    const definition = this.commandDefinitions.get(resolved);
    if (!definition) return null;
    let help = `${definition.name}: ${definition.description}\\n`;
    help += `Usage: ${definition.usage}`;
    if (definition.aliases?.length) {
      help += `\\nAliases: ${definition.aliases.join(", ")}`;
    }
    return help;
  }
  isSafeShellCommand(command) {
    return SAFE_SHELL_COMMANDS.has(command);
  }
  async executeShellCommand(command, args) {
    const startTime = Date.now();
    try {
      const sanitizedArgs = args.map((arg) => this.sanitizeShellArg(arg));
      const fullCommand = `${command} ${sanitizedArgs.join(" ")}`;
      const { stdout, stderr } = await execAsync(fullCommand, {
        timeout: 3e4,
        // 30 second timeout
        maxBuffer: 1024 * 1024
        // 1MB buffer
      });
      return {
        status: "success",
        content: stdout || stderr || "Command executed successfully",
        output: stdout || stderr || "Command executed successfully",
        commandName: command,
        success: true,
        metadata: /* @__PURE__ */ new Map([["executionTime", Date.now() - startTime]])
      };
    } catch (error) {
      return {
        status: "error",
        content: error.message || "Shell command execution failed",
        output: error.message || "Shell command execution failed",
        commandName: command,
        success: false,
        metadata: /* @__PURE__ */ new Map([
          ["executionTime", Date.now() - startTime],
          ["exitCode", error.code]
        ])
      };
    }
  }
  sanitizeShellArg(arg) {
    return arg.replace(/[;&|`$(){}[\\]]/g, "\\\\$&");
  }
};

// src/command/index.ts
function createCommandHandler(config) {
  return new CommandHandler(config);
}

// src/context/impl/ContextManager.ts
import { randomUUID } from "crypto";

// src/context/impl/SecurityBoundaryManager.ts
var SecurityBoundaryManager = class {
  contextRegistry = /* @__PURE__ */ new Map();
  violationCounts = /* @__PURE__ */ new Map();
  accessLog = [];
  registerContext(contextId, context) {
    this.contextRegistry.set(contextId, context);
    this.violationCounts.set(contextId, 0);
  }
  unregisterContext(contextId) {
    this.contextRegistry.delete(contextId);
    this.violationCounts.delete(contextId);
    const cutoff = new Date(Date.now() - 36e5);
    this.accessLog = this.accessLog.filter(
      (entry) => entry.contextId !== contextId && entry.timestamp > cutoff
    );
  }
  async validateAccess(contextId, operation) {
    const context = this.contextRegistry.get(contextId);
    if (!context) {
      this.logAccess(contextId, operation, false, "Context not found");
      return false;
    }
    if (/* @__PURE__ */ new Date() > context.expiresAt) {
      this.logAccess(contextId, operation, false, "Context expired");
      return false;
    }
    if (!context.allowedOperations.includes(operation)) {
      this.incrementViolation(contextId);
      this.logAccess(contextId, operation, false, "Operation not allowed");
      return false;
    }
    const validationResult = await this.validateSpecificOperation(context, operation);
    this.logAccess(contextId, operation, validationResult.allowed, validationResult.reason);
    if (!validationResult.allowed) {
      this.incrementViolation(contextId);
    }
    return validationResult.allowed;
  }
  enforcePathRestrictions(contextId, path2) {
    const context = this.contextRegistry.get(contextId);
    if (!context) {
      return false;
    }
    const normalizedPath = this.normalizePath(path2);
    const isAllowed = context.allowedPaths.some((allowedPath) => {
      const normalizedAllowed = this.normalizePath(allowedPath);
      return normalizedPath.startsWith(normalizedAllowed);
    });
    if (!isAllowed) {
      this.incrementViolation(contextId);
      this.logAccess(contextId, `path:${path2}`, false, "Path not in allowed paths");
    }
    return isAllowed;
  }
  enforceToolRestrictions(contextId, tool) {
    const context = this.contextRegistry.get(contextId);
    if (!context) {
      return false;
    }
    const toolRestricted = context.boundaries.some(
      (boundary) => boundary.startsWith("tool:") && boundary.includes(tool)
    );
    if (toolRestricted) {
      this.incrementViolation(contextId);
      this.logAccess(contextId, `tool:${tool}`, false, "Tool restricted by boundaries");
      return false;
    }
    return true;
  }
  enforceCommandRestrictions(contextId, command) {
    const context = this.contextRegistry.get(contextId);
    if (!context) {
      return false;
    }
    const commandRestricted = context.boundaries.some(
      (boundary) => boundary.startsWith("command:") && boundary.includes(command)
    );
    if (commandRestricted) {
      this.incrementViolation(contextId);
      this.logAccess(contextId, `command:${command}`, false, "Command restricted by boundaries");
      return false;
    }
    return true;
  }
  getViolationCount(contextId) {
    return this.violationCounts.get(contextId) || 0;
  }
  // Private helper methods
  async validateSpecificOperation(context, operation) {
    if (operation.startsWith("fs:")) {
      const path2 = operation.substring(3);
      const allowed = this.enforcePathRestrictions(context.id, path2);
      return { allowed, reason: allowed ? void 0 : "Path access denied" };
    }
    if (operation.startsWith("tool:")) {
      const tool = operation.substring(5);
      const allowed = this.enforceToolRestrictions(context.id, tool);
      return { allowed, reason: allowed ? void 0 : "Tool access denied" };
    }
    if (operation.startsWith("command:")) {
      const command = operation.substring(8);
      const allowed = this.enforceCommandRestrictions(context.id, command);
      return { allowed, reason: allowed ? void 0 : "Command access denied" };
    }
    if (operation.startsWith("network:")) {
      const networkAllowed = context.boundaries.includes("network:allowed");
      return {
        allowed: networkAllowed,
        reason: networkAllowed ? void 0 : "Network access denied"
      };
    }
    if (operation.startsWith("system:")) {
      const systemAllowed = context.boundaries.includes("system:allowed");
      return {
        allowed: systemAllowed,
        reason: systemAllowed ? void 0 : "System access denied"
      };
    }
    return { allowed: true };
  }
  normalizePath(path2) {
    return path2.replace(/\/+/g, "/").replace(/\/$/, "") || "/";
  }
  incrementViolation(contextId) {
    const current = this.violationCounts.get(contextId) || 0;
    this.violationCounts.set(contextId, current + 1);
  }
  logAccess(contextId, operation, allowed, reason) {
    this.accessLog.push({
      contextId,
      operation,
      allowed,
      timestamp: /* @__PURE__ */ new Date(),
      reason
    });
    if (this.accessLog.length > 1e3) {
      this.accessLog = this.accessLog.slice(-1e3);
    }
  }
  // Public access to logs for debugging/auditing
  getAccessLog(contextId) {
    if (contextId) {
      return this.accessLog.filter((entry) => entry.contextId === contextId);
    }
    return [...this.accessLog];
  }
};

// src/context/impl/ContextManager.ts
var ContextManager = class {
  applicationContext;
  conversationContexts = /* @__PURE__ */ new Map();
  isolatedContexts = /* @__PURE__ */ new Map();
  securityBoundaries;
  cleanupInterval;
  accessAuditLog = [];
  // Statistics tracking
  stats = {
    totalContextsCreated: 0,
    expiredContextsCleanedUp: 0,
    securityViolations: 0,
    startTime: Date.now()
  };
  constructor(initialAppContext) {
    this.applicationContext = { ...initialAppContext };
    this.securityBoundaries = new SecurityBoundaryManager();
  }
  async initialize() {
    this.cleanupInterval = setInterval(
      () => this.cleanupExpiredContexts(),
      6e4
      // Every minute
    );
  }
  async shutdown() {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = void 0;
    }
    for (const contextId of this.isolatedContexts.keys()) {
      this.terminateContext(contextId);
    }
    this.conversationContexts.clear();
    this.isolatedContexts.clear();
  }
  // Application Context Management
  getApplicationContext() {
    return {
      ...this.applicationContext,
      environment: new Map(this.applicationContext.environment),
      metadata: new Map(this.applicationContext.metadata)
    };
  }
  updateApplicationContext(updates) {
    this.applicationContext = {
      ...this.applicationContext,
      ...updates,
      // Preserve readonly maps with proper merging
      environment: updates.environment || this.applicationContext.environment,
      metadata: updates.metadata || this.applicationContext.metadata
    };
  }
  // Conversation Context Management
  createConversationContext(type, parentId) {
    const contextId = this.generateContextId();
    const now = /* @__PURE__ */ new Date();
    if (parentId && !this.conversationContexts.has(parentId)) {
      throw new Error(`Parent context ${parentId} not found`);
    }
    const context = {
      id: contextId,
      parentId,
      type,
      createdAt: now,
      expiresAt: type === "sub-agent" ? new Date(now.getTime() + 3e5) : (
        // 5 minutes for sub-agents
        void 0
      ),
      // Main contexts don't expire
      messages: [],
      restrictions: this.getDefaultRestrictions(type),
      allowedOperations: this.getAllowedOperations(type),
      metadata: /* @__PURE__ */ new Map()
    };
    this.conversationContexts.set(contextId, context);
    this.stats.totalContextsCreated++;
    return context;
  }
  getConversationContext(id) {
    const context = this.conversationContexts.get(id);
    if (!context) {
      return null;
    }
    return {
      ...context,
      messages: [...context.messages],
      restrictions: { ...context.restrictions },
      allowedOperations: [...context.allowedOperations],
      metadata: new Map(context.metadata)
    };
  }
  addMessageToContext(contextId, message) {
    const context = this.conversationContexts.get(contextId);
    if (!context) {
      throw new Error(`Context ${contextId} not found`);
    }
    const updatedContext = {
      ...context,
      messages: [...context.messages, message]
    };
    this.conversationContexts.set(contextId, updatedContext);
  }
  updateConversationContext(contextId, updates) {
    const context = this.conversationContexts.get(contextId);
    if (!context) {
      throw new Error(`Context ${contextId} not found`);
    }
    const updatedContext = {
      ...context,
      ...updates,
      // Preserve arrays and maps
      messages: updates.messages || context.messages,
      allowedOperations: updates.allowedOperations || context.allowedOperations,
      metadata: updates.metadata || context.metadata
    };
    this.conversationContexts.set(contextId, updatedContext);
  }
  // Isolated Context Management
  createIsolatedContext(config) {
    const contextId = this.generateContextId();
    const now = /* @__PURE__ */ new Date();
    if (!this.conversationContexts.has(config.parentContextId)) {
      throw new Error(`Parent context ${config.parentContextId} not found`);
    }
    const isolatedContext = {
      id: contextId,
      parentContextId: config.parentContextId,
      task: config.task,
      allowedOperations: this.filterOperationsBySpecialization(
        config.specialization,
        config.restrictions
      ),
      allowedPaths: [...config.restrictions.allowedPaths],
      timeLimit: config.timeLimit || 3e5,
      // 5 minutes default
      memoryLimit: config.memoryLimit || 100 * 1024 * 1024,
      // 100MB default
      boundaries: this.createSecurityBoundaries(config.restrictions),
      createdAt: now,
      expiresAt: new Date(now.getTime() + (config.timeLimit || 3e5))
    };
    this.isolatedContexts.set(contextId, isolatedContext);
    this.securityBoundaries.registerContext(contextId, isolatedContext);
    this.stats.totalContextsCreated++;
    return isolatedContext;
  }
  getIsolatedContext(id) {
    const context = this.isolatedContexts.get(id);
    if (!context) {
      return null;
    }
    return {
      ...context,
      allowedOperations: [...context.allowedOperations],
      allowedPaths: [...context.allowedPaths],
      boundaries: [...context.boundaries]
    };
  }
  async validateContextAccess(contextId, operation) {
    const context = this.isolatedContexts.get(contextId);
    if (!context) {
      this.auditContextAccess(contextId, operation, false, "Context not found");
      return false;
    }
    if (/* @__PURE__ */ new Date() > context.expiresAt) {
      this.terminateContext(contextId);
      this.auditContextAccess(contextId, operation, false, "Context expired");
      return false;
    }
    const allowed = await this.securityBoundaries.validateAccess(contextId, operation);
    this.auditContextAccess(contextId, operation, allowed);
    return allowed;
  }
  terminateContext(contextId) {
    this.conversationContexts.delete(contextId);
    this.isolatedContexts.delete(contextId);
    this.securityBoundaries.unregisterContext(contextId);
    const childContexts = this.getChildContexts(contextId);
    for (const childContext of childContexts) {
      this.terminateContext(childContext.id);
    }
  }
  // Context Lifecycle Management
  async cleanupExpiredContexts() {
    const now = /* @__PURE__ */ new Date();
    let cleaned = 0;
    for (const [contextId, context] of this.conversationContexts.entries()) {
      if (context.expiresAt && now > context.expiresAt) {
        this.terminateContext(contextId);
        cleaned++;
      }
    }
    for (const [contextId, context] of this.isolatedContexts.entries()) {
      if (now > context.expiresAt) {
        this.terminateContext(contextId);
        cleaned++;
      }
    }
    this.stats.expiredContextsCleanedUp += cleaned;
    return cleaned;
  }
  getActiveContexts() {
    return Array.from(this.conversationContexts.values()).map((context) => ({
      ...context,
      messages: [...context.messages],
      allowedOperations: [...context.allowedOperations],
      metadata: new Map(context.metadata)
    }));
  }
  getActiveIsolatedContexts() {
    return Array.from(this.isolatedContexts.values()).map((context) => ({
      ...context,
      allowedOperations: [...context.allowedOperations],
      allowedPaths: [...context.allowedPaths],
      boundaries: [...context.boundaries]
    }));
  }
  // Security and Boundary Enforcement
  async enforceSecurityBoundaries(contextId, operation) {
    return this.validateContextAccess(contextId, operation);
  }
  auditContextAccess(contextId, operation, result, reason) {
    const auditEntry = {
      contextId,
      operation,
      allowed: result,
      timestamp: /* @__PURE__ */ new Date(),
      reason
    };
    this.accessAuditLog.push(auditEntry);
    if (!result) {
      this.stats.securityViolations++;
    }
    if (this.accessAuditLog.length > 1e3) {
      this.accessAuditLog = this.accessAuditLog.slice(-1e3);
    }
  }
  getAccessAuditLog(contextId) {
    if (contextId) {
      return this.accessAuditLog.filter((entry) => entry.contextId === contextId);
    }
    return [...this.accessAuditLog];
  }
  // Context Hierarchy and Relations
  getChildContexts(parentId) {
    return Array.from(this.conversationContexts.values()).filter((context) => context.parentId === parentId).map((context) => ({
      ...context,
      messages: [...context.messages],
      allowedOperations: [...context.allowedOperations],
      metadata: new Map(context.metadata)
    }));
  }
  getContextHierarchy(contextId) {
    const hierarchy = [];
    let currentContext = this.conversationContexts.get(contextId);
    while (currentContext) {
      hierarchy.unshift(currentContext.id);
      if (currentContext.parentId) {
        currentContext = this.conversationContexts.get(currentContext.parentId);
      } else {
        break;
      }
    }
    return hierarchy;
  }
  // Utility Methods
  generateContextId() {
    return `ctx_${randomUUID()}`;
  }
  isContextActive(contextId) {
    const conversationContext = this.conversationContexts.get(contextId);
    if (conversationContext) {
      return !conversationContext.expiresAt || /* @__PURE__ */ new Date() <= conversationContext.expiresAt;
    }
    const isolatedContext = this.isolatedContexts.get(contextId);
    if (isolatedContext) {
      return /* @__PURE__ */ new Date() <= isolatedContext.expiresAt;
    }
    return false;
  }
  getContextStatistics() {
    return {
      totalContextsCreated: this.stats.totalContextsCreated,
      activeConversationContexts: this.conversationContexts.size,
      activeIsolatedContexts: this.isolatedContexts.size,
      expiredContextsCleanedUp: this.stats.expiredContextsCleanedUp,
      securityViolations: this.stats.securityViolations,
      memoryUsage: process.memoryUsage().heapUsed,
      uptime: Date.now() - this.stats.startTime
    };
  }
  // Private helper methods
  getDefaultRestrictions(type) {
    const baseRestrictions = {
      readOnlyMode: false,
      allowedPaths: [process.cwd()],
      blockedCommands: [],
      blockedTools: [],
      requireApproval: false,
      maxExecutionTime: 3e5,
      // 5 minutes
      maxMemoryUsage: 100 * 1024 * 1024,
      // 100MB
      networkAccess: false,
      systemAccess: false
    };
    switch (type) {
      case "main":
        return {
          ...baseRestrictions,
          networkAccess: true,
          systemAccess: true
        };
      case "sub-agent":
        return {
          ...baseRestrictions,
          readOnlyMode: true,
          requireApproval: true,
          maxExecutionTime: 18e4,
          // 3 minutes
          maxMemoryUsage: 50 * 1024 * 1024
          // 50MB
        };
      case "tool":
        return {
          ...baseRestrictions,
          readOnlyMode: true,
          maxExecutionTime: 6e4,
          // 1 minute
          maxMemoryUsage: 25 * 1024 * 1024
          // 25MB
        };
      default:
        return baseRestrictions;
    }
  }
  getAllowedOperations(type) {
    const baseOperations = ["read", "analyze", "generate"];
    switch (type) {
      case "main":
        return [...baseOperations, "write", "execute", "network", "system"];
      case "sub-agent":
        return [...baseOperations, "write"];
      case "tool":
        return [...baseOperations];
      default:
        return baseOperations;
    }
  }
  filterOperationsBySpecialization(specialization, restrictions) {
    const baseOperations = ["read", "analyze"];
    const specializationOperations = {
      general: [...baseOperations, "write", "generate"],
      "file-operations": [...baseOperations, "fs:read", "fs:write", "fs:list"],
      "code-analysis": [...baseOperations, "analyze:code", "generate:docs"],
      documentation: [...baseOperations, "write:docs", "generate:docs"],
      testing: [...baseOperations, "execute:tests", "generate:tests"],
      research: [...baseOperations, "network:search", "analyze:data"],
      "system-admin": [...baseOperations, "system:info", "system:monitor"]
    };
    let operations = specializationOperations[specialization] || baseOperations;
    if (restrictions.readOnlyMode) {
      operations = operations.filter((op) => !op.includes("write") && !op.includes("execute"));
    }
    if (!restrictions.networkAccess) {
      operations = operations.filter((op) => !op.includes("network"));
    }
    if (!restrictions.systemAccess) {
      operations = operations.filter((op) => !op.includes("system"));
    }
    return operations;
  }
  createSecurityBoundaries(restrictions) {
    const boundaries = [];
    if (restrictions.readOnlyMode) {
      boundaries.push("mode:readonly");
    }
    if (restrictions.networkAccess) {
      boundaries.push("network:allowed");
    }
    if (restrictions.systemAccess) {
      boundaries.push("system:allowed");
    }
    for (const tool of restrictions.blockedTools) {
      boundaries.push(`tool:blocked:${tool}`);
    }
    for (const command of restrictions.blockedCommands) {
      boundaries.push(`command:blocked:${command}`);
    }
    return boundaries;
  }
};

// src/context/index.ts
function createContextManager(initialAppContext) {
  return new ContextManager(initialAppContext);
}
function createDefaultAppContext() {
  return {
    sessionId: `session_${Date.now()}`,
    currentDirectory: process.cwd(),
    environment: /* @__PURE__ */ new Map([
      ["NODE_ENV", process.env.NODE_ENV || "development"],
      ["PWD", process.cwd()]
    ]),
    metadata: /* @__PURE__ */ new Map([
      ["version", "0.2.7"],
      ["platform", process.platform]
    ])
  };
}

// src/schemas/ClassificationSchemas.ts
import { z as z2 } from "zod";
var ThreeTypeSchema = z2.object({
  type: z2.enum(["command", "prompt", "workflow"]).describe(
    'command: System commands starting with "/", prompt: Single-step conversational requests or questions, workflow: Multi-step tasks requiring file operations or orchestration'
  ),
  confidence: z2.number().min(0).max(1).describe("Confidence score from 0.0 to 1.0"),
  reasoning: z2.string().max(200).describe("Brief explanation of the classification")
});
var SentimentSchema = z2.object({
  sentiment: z2.enum(["positive", "negative", "neutral"]).describe("Overall sentiment of the text"),
  confidence: z2.number().min(0).max(1).describe("Confidence score from 0.0 to 1.0"),
  intensity: z2.number().min(0).max(1).describe("Intensity of the sentiment from 0.0 to 1.0")
});
var IntentSchema = z2.object({
  intent: z2.string().describe("The identified intent or purpose"),
  confidence: z2.number().min(0).max(1).describe("Confidence score from 0.0 to 1.0"),
  entities: z2.array(
    z2.object({
      name: z2.string().describe("Entity name or type"),
      value: z2.string().describe("Entity value"),
      start: z2.number().optional().describe("Start position in text"),
      end: z2.number().optional().describe("End position in text")
    })
  ).describe("Extracted entities from the input")
});
var TopicSchema = z2.object({
  topic: z2.string().describe("Primary topic or category"),
  confidence: z2.number().min(0).max(1).describe("Confidence score from 0.0 to 1.0"),
  subtopics: z2.array(z2.string()).describe("Related subtopics or categories")
});
var ClassificationSchemas = {
  threeType: ThreeTypeSchema,
  sentiment: SentimentSchema,
  intent: IntentSchema,
  topic: TopicSchema
};

// src/prompt/impl/DefaultPromptHandler.ts
import { match as match3 } from "@qi/base";
var DefaultPromptHandler = class {
  manager;
  config = null;
  initialized = false;
  constructor(manager) {
    this.manager = manager;
  }
  /**
   * Initialize the handler with configuration
   */
  async initialize(configPath, schemaPath) {
    const configResult = await this.manager.loadConfig(configPath, schemaPath);
    return await match3(
      async (config) => {
        this.config = config;
        const initResult = await this.manager.initializeProviders(config);
        return match3(
          () => {
            this.initialized = true;
            return { success: true, data: "Handler initialized successfully" };
          },
          (error) => ({ success: false, error: error.message }),
          initResult
        );
      },
      async (error) => ({ success: false, error: error.message }),
      configResult
    );
  }
  async complete(prompt, options = {}) {
    if (!this.initialized || !this.config) {
      return { success: false, error: "Handler not initialized. Call initialize() first." };
    }
    const providerId = options.provider || this.config.llm.defaultProvider;
    const executionOptions = {
      providerId,
      model: options.model,
      temperature: options.temperature,
      maxTokens: options.maxTokens
    };
    const result = await this.manager.executePrompt(prompt, executionOptions);
    return match3(
      (data) => ({ success: true, data }),
      (error) => ({ success: false, error: error.message }),
      result
    );
  }
  async getAvailableProviders() {
    if (!this.initialized) {
      return [];
    }
    const statusResult = this.manager.getProviderStatus();
    return match3(
      (statusMap) => {
        return Object.entries(statusMap).map(([id, info]) => ({
          id,
          name: info.name,
          available: info.available,
          models: info.models
        }));
      },
      () => [],
      // Return empty array on error
      statusResult
    );
  }
  async validateProvider(providerId) {
    if (!this.initialized) {
      return false;
    }
    const availabilityResult = this.manager.isProviderAvailable(providerId);
    return match3(
      (available) => available,
      () => false,
      // Return false on error
      availabilityResult
    );
  }
};

// src/prompt/impl/QiCorePromptManager.ts
import {
  create as create4,
  Err,
  fromAsyncTryCatch as fromAsyncTryCatch4,
  match as match5,
  Ok,
  validationError
} from "@qi/base";
import { ConfigBuilder } from "@qi/core";

// ../node_modules/multi-llm-ts/dist/index.mjs
import { AzureOpenAI } from "openai";
import OpenAI from "openai";
import { zodResponseFormat } from "openai/helpers/zod";

// ../node_modules/@isaacs/balanced-match/dist/esm/index.js
var balanced = (a2, b2, str) => {
  const ma = a2 instanceof RegExp ? maybeMatch(a2, str) : a2;
  const mb = b2 instanceof RegExp ? maybeMatch(b2, str) : b2;
  const r2 = ma !== null && mb != null && range(ma, mb, str);
  return r2 && {
    start: r2[0],
    end: r2[1],
    pre: str.slice(0, r2[0]),
    body: str.slice(r2[0] + ma.length, r2[1]),
    post: str.slice(r2[1] + mb.length)
  };
};
var maybeMatch = (reg, str) => {
  const m2 = str.match(reg);
  return m2 ? m2[0] : null;
};
var range = (a2, b2, str) => {
  let begs, beg, left, right = void 0, result;
  let ai = str.indexOf(a2);
  let bi = str.indexOf(b2, ai + 1);
  let i2 = ai;
  if (ai >= 0 && bi > 0) {
    if (a2 === b2) {
      return [ai, bi];
    }
    begs = [];
    left = str.length;
    while (i2 >= 0 && !result) {
      if (i2 === ai) {
        begs.push(i2);
        ai = str.indexOf(a2, i2 + 1);
      } else if (begs.length === 1) {
        const r2 = begs.pop();
        if (r2 !== void 0)
          result = [r2, bi];
      } else {
        beg = begs.pop();
        if (beg !== void 0 && beg < left) {
          left = beg;
          right = bi;
        }
        bi = str.indexOf(b2, i2 + 1);
      }
      i2 = ai < bi && ai >= 0 ? ai : bi;
    }
    if (begs.length && right !== void 0) {
      result = [left, right];
    }
  }
  return result;
};

// ../node_modules/@isaacs/brace-expansion/dist/esm/index.js
var escSlash = "\0SLASH" + Math.random() + "\0";
var escOpen = "\0OPEN" + Math.random() + "\0";
var escClose = "\0CLOSE" + Math.random() + "\0";
var escComma = "\0COMMA" + Math.random() + "\0";
var escPeriod = "\0PERIOD" + Math.random() + "\0";
var escSlashPattern = new RegExp(escSlash, "g");
var escOpenPattern = new RegExp(escOpen, "g");
var escClosePattern = new RegExp(escClose, "g");
var escCommaPattern = new RegExp(escComma, "g");
var escPeriodPattern = new RegExp(escPeriod, "g");
var slashPattern = /\\\\/g;
var openPattern = /\\{/g;
var closePattern = /\\}/g;
var commaPattern = /\\,/g;
var periodPattern = /\\./g;
function numeric(str) {
  return !isNaN(str) ? parseInt(str, 10) : str.charCodeAt(0);
}
function escapeBraces(str) {
  return str.replace(slashPattern, escSlash).replace(openPattern, escOpen).replace(closePattern, escClose).replace(commaPattern, escComma).replace(periodPattern, escPeriod);
}
function unescapeBraces(str) {
  return str.replace(escSlashPattern, "\\").replace(escOpenPattern, "{").replace(escClosePattern, "}").replace(escCommaPattern, ",").replace(escPeriodPattern, ".");
}
function parseCommaParts(str) {
  if (!str) {
    return [""];
  }
  const parts = [];
  const m2 = balanced("{", "}", str);
  if (!m2) {
    return str.split(",");
  }
  const { pre, body, post } = m2;
  const p2 = pre.split(",");
  p2[p2.length - 1] += "{" + body + "}";
  const postParts = parseCommaParts(post);
  if (post.length) {
    ;
    p2[p2.length - 1] += postParts.shift();
    p2.push.apply(p2, postParts);
  }
  parts.push.apply(parts, p2);
  return parts;
}
function expand(str) {
  if (!str) {
    return [];
  }
  if (str.slice(0, 2) === "{}") {
    str = "\\{\\}" + str.slice(2);
  }
  return expand_(escapeBraces(str), true).map(unescapeBraces);
}
function embrace(str) {
  return "{" + str + "}";
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}
function lte(i2, y2) {
  return i2 <= y2;
}
function gte(i2, y2) {
  return i2 >= y2;
}
function expand_(str, isTop) {
  const expansions = [];
  const m2 = balanced("{", "}", str);
  if (!m2)
    return [str];
  const pre = m2.pre;
  const post = m2.post.length ? expand_(m2.post, false) : [""];
  if (/\$$/.test(m2.pre)) {
    for (let k2 = 0; k2 < post.length; k2++) {
      const expansion = pre + "{" + m2.body + "}" + post[k2];
      expansions.push(expansion);
    }
  } else {
    const isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m2.body);
    const isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m2.body);
    const isSequence = isNumericSequence || isAlphaSequence;
    const isOptions = m2.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m2.post.match(/,(?!,).*\}/)) {
        str = m2.pre + "{" + m2.body + escClose + m2.post;
        return expand_(str);
      }
      return [str];
    }
    let n2;
    if (isSequence) {
      n2 = m2.body.split(/\.\./);
    } else {
      n2 = parseCommaParts(m2.body);
      if (n2.length === 1 && n2[0] !== void 0) {
        n2 = expand_(n2[0], false).map(embrace);
        if (n2.length === 1) {
          return post.map((p2) => m2.pre + n2[0] + p2);
        }
      }
    }
    let N2;
    if (isSequence && n2[0] !== void 0 && n2[1] !== void 0) {
      const x2 = numeric(n2[0]);
      const y2 = numeric(n2[1]);
      const width = Math.max(n2[0].length, n2[1].length);
      let incr = n2.length === 3 && n2[2] !== void 0 ? Math.abs(numeric(n2[2])) : 1;
      let test = lte;
      const reverse = y2 < x2;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      const pad = n2.some(isPadded);
      N2 = [];
      for (let i2 = x2; test(i2, y2); i2 += incr) {
        let c2;
        if (isAlphaSequence) {
          c2 = String.fromCharCode(i2);
          if (c2 === "\\") {
            c2 = "";
          }
        } else {
          c2 = String(i2);
          if (pad) {
            const need = width - c2.length;
            if (need > 0) {
              const z4 = new Array(need + 1).join("0");
              if (i2 < 0) {
                c2 = "-" + z4 + c2.slice(1);
              } else {
                c2 = z4 + c2;
              }
            }
          }
        }
        N2.push(c2);
      }
    } else {
      N2 = [];
      for (let j2 = 0; j2 < n2.length; j2++) {
        N2.push.apply(N2, expand_(n2[j2], false));
      }
    }
    for (let j2 = 0; j2 < N2.length; j2++) {
      for (let k2 = 0; k2 < post.length; k2++) {
        const expansion = pre + N2[j2] + post[k2];
        if (!isTop || isSequence || expansion) {
          expansions.push(expansion);
        }
      }
    }
  }
  return expansions;
}

// ../node_modules/minimatch/dist/esm/assert-valid-pattern.js
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = (pattern) => {
  if (typeof pattern !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};

// ../node_modules/minimatch/dist/esm/brace-expressions.js
var posixClasses = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
  "[:alpha:]": ["\\p{L}\\p{Nl}", true],
  "[:ascii:]": ["\\x00-\\x7f", false],
  "[:blank:]": ["\\p{Zs}\\t", true],
  "[:cntrl:]": ["\\p{Cc}", true],
  "[:digit:]": ["\\p{Nd}", true],
  "[:graph:]": ["\\p{Z}\\p{C}", true, true],
  "[:lower:]": ["\\p{Ll}", true],
  "[:print:]": ["\\p{C}", true],
  "[:punct:]": ["\\p{P}", true],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
  "[:upper:]": ["\\p{Lu}", true],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
  "[:xdigit:]": ["A-Fa-f0-9", false]
};
var braceEscape = (s2) => s2.replace(/[[\]\\-]/g, "\\$&");
var regexpEscape = (s2) => s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var rangesToString = (ranges) => ranges.join("");
var parseClass = (glob, position) => {
  const pos = position;
  if (glob.charAt(pos) !== "[") {
    throw new Error("not in a brace expression");
  }
  const ranges = [];
  const negs = [];
  let i2 = pos + 1;
  let sawStart = false;
  let uflag = false;
  let escaping = false;
  let negate = false;
  let endPos = pos;
  let rangeStart = "";
  WHILE: while (i2 < glob.length) {
    const c2 = glob.charAt(i2);
    if ((c2 === "!" || c2 === "^") && i2 === pos + 1) {
      negate = true;
      i2++;
      continue;
    }
    if (c2 === "]" && sawStart && !escaping) {
      endPos = i2 + 1;
      break;
    }
    sawStart = true;
    if (c2 === "\\") {
      if (!escaping) {
        escaping = true;
        i2++;
        continue;
      }
    }
    if (c2 === "[" && !escaping) {
      for (const [cls, [unip, u2, neg]] of Object.entries(posixClasses)) {
        if (glob.startsWith(cls, i2)) {
          if (rangeStart) {
            return ["$.", false, glob.length - pos, true];
          }
          i2 += cls.length;
          if (neg)
            negs.push(unip);
          else
            ranges.push(unip);
          uflag = uflag || u2;
          continue WHILE;
        }
      }
    }
    escaping = false;
    if (rangeStart) {
      if (c2 > rangeStart) {
        ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c2));
      } else if (c2 === rangeStart) {
        ranges.push(braceEscape(c2));
      }
      rangeStart = "";
      i2++;
      continue;
    }
    if (glob.startsWith("-]", i2 + 1)) {
      ranges.push(braceEscape(c2 + "-"));
      i2 += 2;
      continue;
    }
    if (glob.startsWith("-", i2 + 1)) {
      rangeStart = c2;
      i2 += 2;
      continue;
    }
    ranges.push(braceEscape(c2));
    i2++;
  }
  if (endPos < i2) {
    return ["", false, 0, false];
  }
  if (!ranges.length && !negs.length) {
    return ["$.", false, glob.length - pos, true];
  }
  if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
    const r2 = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
    return [regexpEscape(r2), false, endPos - pos, false];
  }
  const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
  const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
  const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
  return [comb, uflag, endPos - pos, true];
};

// ../node_modules/minimatch/dist/esm/unescape.js
var unescape2 = (s2, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s2.replace(/\[([^\/\\])\]/g, "$1") : s2.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
};

// ../node_modules/minimatch/dist/esm/ast.js
var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
var isExtglobType = (c2) => types.has(c2);
var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
var startNoDot = "(?!\\.)";
var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
var justDots = /* @__PURE__ */ new Set(["..", "."]);
var reSpecials = new Set("().*{}+?[]^$\\!");
var regExpEscape = (s2) => s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var qmark = "[^/]";
var star = qmark + "*?";
var starNoEmpty = qmark + "+?";
var AST = class _AST {
  type;
  #root;
  #hasMagic;
  #uflag = false;
  #parts = [];
  #parent;
  #parentIndex;
  #negs;
  #filledNegs = false;
  #options;
  #toString;
  // set to true if it's an extglob with no children
  // (which really means one child of '')
  #emptyExt = false;
  constructor(type, parent, options = {}) {
    this.type = type;
    if (type)
      this.#hasMagic = true;
    this.#parent = parent;
    this.#root = this.#parent ? this.#parent.#root : this;
    this.#options = this.#root === this ? options : this.#root.#options;
    this.#negs = this.#root === this ? [] : this.#root.#negs;
    if (type === "!" && !this.#root.#filledNegs)
      this.#negs.push(this);
    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
  }
  get hasMagic() {
    if (this.#hasMagic !== void 0)
      return this.#hasMagic;
    for (const p2 of this.#parts) {
      if (typeof p2 === "string")
        continue;
      if (p2.type || p2.hasMagic)
        return this.#hasMagic = true;
    }
    return this.#hasMagic;
  }
  // reconstructs the pattern
  toString() {
    if (this.#toString !== void 0)
      return this.#toString;
    if (!this.type) {
      return this.#toString = this.#parts.map((p2) => String(p2)).join("");
    } else {
      return this.#toString = this.type + "(" + this.#parts.map((p2) => String(p2)).join("|") + ")";
    }
  }
  #fillNegs() {
    if (this !== this.#root)
      throw new Error("should only call on root");
    if (this.#filledNegs)
      return this;
    this.toString();
    this.#filledNegs = true;
    let n2;
    while (n2 = this.#negs.pop()) {
      if (n2.type !== "!")
        continue;
      let p2 = n2;
      let pp = p2.#parent;
      while (pp) {
        for (let i2 = p2.#parentIndex + 1; !pp.type && i2 < pp.#parts.length; i2++) {
          for (const part of n2.#parts) {
            if (typeof part === "string") {
              throw new Error("string part in extglob AST??");
            }
            part.copyIn(pp.#parts[i2]);
          }
        }
        p2 = pp;
        pp = p2.#parent;
      }
    }
    return this;
  }
  push(...parts) {
    for (const p2 of parts) {
      if (p2 === "")
        continue;
      if (typeof p2 !== "string" && !(p2 instanceof _AST && p2.#parent === this)) {
        throw new Error("invalid part: " + p2);
      }
      this.#parts.push(p2);
    }
  }
  toJSON() {
    const ret = this.type === null ? this.#parts.slice().map((p2) => typeof p2 === "string" ? p2 : p2.toJSON()) : [this.type, ...this.#parts.map((p2) => p2.toJSON())];
    if (this.isStart() && !this.type)
      ret.unshift([]);
    if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === "!")) {
      ret.push({});
    }
    return ret;
  }
  isStart() {
    if (this.#root === this)
      return true;
    if (!this.#parent?.isStart())
      return false;
    if (this.#parentIndex === 0)
      return true;
    const p2 = this.#parent;
    for (let i2 = 0; i2 < this.#parentIndex; i2++) {
      const pp = p2.#parts[i2];
      if (!(pp instanceof _AST && pp.type === "!")) {
        return false;
      }
    }
    return true;
  }
  isEnd() {
    if (this.#root === this)
      return true;
    if (this.#parent?.type === "!")
      return true;
    if (!this.#parent?.isEnd())
      return false;
    if (!this.type)
      return this.#parent?.isEnd();
    const pl = this.#parent ? this.#parent.#parts.length : 0;
    return this.#parentIndex === pl - 1;
  }
  copyIn(part) {
    if (typeof part === "string")
      this.push(part);
    else
      this.push(part.clone(this));
  }
  clone(parent) {
    const c2 = new _AST(this.type, parent);
    for (const p2 of this.#parts) {
      c2.copyIn(p2);
    }
    return c2;
  }
  static #parseAST(str, ast, pos, opt) {
    let escaping = false;
    let inBrace = false;
    let braceStart = -1;
    let braceNeg = false;
    if (ast.type === null) {
      let i3 = pos;
      let acc2 = "";
      while (i3 < str.length) {
        const c2 = str.charAt(i3++);
        if (escaping || c2 === "\\") {
          escaping = !escaping;
          acc2 += c2;
          continue;
        }
        if (inBrace) {
          if (i3 === braceStart + 1) {
            if (c2 === "^" || c2 === "!") {
              braceNeg = true;
            }
          } else if (c2 === "]" && !(i3 === braceStart + 2 && braceNeg)) {
            inBrace = false;
          }
          acc2 += c2;
          continue;
        } else if (c2 === "[") {
          inBrace = true;
          braceStart = i3;
          braceNeg = false;
          acc2 += c2;
          continue;
        }
        if (!opt.noext && isExtglobType(c2) && str.charAt(i3) === "(") {
          ast.push(acc2);
          acc2 = "";
          const ext2 = new _AST(c2, ast);
          i3 = _AST.#parseAST(str, ext2, i3, opt);
          ast.push(ext2);
          continue;
        }
        acc2 += c2;
      }
      ast.push(acc2);
      return i3;
    }
    let i2 = pos + 1;
    let part = new _AST(null, ast);
    const parts = [];
    let acc = "";
    while (i2 < str.length) {
      const c2 = str.charAt(i2++);
      if (escaping || c2 === "\\") {
        escaping = !escaping;
        acc += c2;
        continue;
      }
      if (inBrace) {
        if (i2 === braceStart + 1) {
          if (c2 === "^" || c2 === "!") {
            braceNeg = true;
          }
        } else if (c2 === "]" && !(i2 === braceStart + 2 && braceNeg)) {
          inBrace = false;
        }
        acc += c2;
        continue;
      } else if (c2 === "[") {
        inBrace = true;
        braceStart = i2;
        braceNeg = false;
        acc += c2;
        continue;
      }
      if (isExtglobType(c2) && str.charAt(i2) === "(") {
        part.push(acc);
        acc = "";
        const ext2 = new _AST(c2, part);
        part.push(ext2);
        i2 = _AST.#parseAST(str, ext2, i2, opt);
        continue;
      }
      if (c2 === "|") {
        part.push(acc);
        acc = "";
        parts.push(part);
        part = new _AST(null, ast);
        continue;
      }
      if (c2 === ")") {
        if (acc === "" && ast.#parts.length === 0) {
          ast.#emptyExt = true;
        }
        part.push(acc);
        acc = "";
        ast.push(...parts, part);
        return i2;
      }
      acc += c2;
    }
    ast.type = null;
    ast.#hasMagic = void 0;
    ast.#parts = [str.substring(pos - 1)];
    return i2;
  }
  static fromGlob(pattern, options = {}) {
    const ast = new _AST(null, void 0, options);
    _AST.#parseAST(pattern, ast, 0, options);
    return ast;
  }
  // returns the regular expression if there's magic, or the unescaped
  // string if not.
  toMMPattern() {
    if (this !== this.#root)
      return this.#root.toMMPattern();
    const glob = this.toString();
    const [re2, body, hasMagic, uflag] = this.toRegExpSource();
    const anyMagic = hasMagic || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();
    if (!anyMagic) {
      return body;
    }
    const flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
    return Object.assign(new RegExp(`^${re2}$`, flags), {
      _src: re2,
      _glob: glob
    });
  }
  get options() {
    return this.#options;
  }
  // returns the string match, the regexp source, whether there's magic
  // in the regexp (so a regular expression is required) and whether or
  // not the uflag is needed for the regular expression (for posix classes)
  // TODO: instead of injecting the start/end at this point, just return
  // the BODY of the regexp, along with the start/end portions suitable
  // for binding the start/end in either a joined full-path makeRe context
  // (where we bind to (^|/), or a standalone matchPart context (where
  // we bind to ^, and not /).  Otherwise slashes get duped!
  //
  // In part-matching mode, the start is:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: ^(?!\.\.?$)
  // - if dots allowed or not possible: ^
  // - if dots possible and not allowed: ^(?!\.)
  // end is:
  // - if not isEnd(): nothing
  // - else: $
  //
  // In full-path matching mode, we put the slash at the START of the
  // pattern, so start is:
  // - if first pattern: same as part-matching mode
  // - if not isStart(): nothing
  // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
  // - if dots allowed or not possible: /
  // - if dots possible and not allowed: /(?!\.)
  // end is:
  // - if last pattern, same as part-matching mode
  // - else nothing
  //
  // Always put the (?:$|/) on negated tails, though, because that has to be
  // there to bind the end of the negated pattern portion, and it's easier to
  // just stick it in now rather than try to inject it later in the middle of
  // the pattern.
  //
  // We can just always return the same end, and leave it up to the caller
  // to know whether it's going to be used joined or in parts.
  // And, if the start is adjusted slightly, can do the same there:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
  // - if dots allowed or not possible: (?:/|^)
  // - if dots possible and not allowed: (?:/|^)(?!\.)
  //
  // But it's better to have a simpler binding without a conditional, for
  // performance, so probably better to return both start options.
  //
  // Then the caller just ignores the end if it's not the first pattern,
  // and the start always gets applied.
  //
  // But that's always going to be $ if it's the ending pattern, or nothing,
  // so the caller can just attach $ at the end of the pattern when building.
  //
  // So the todo is:
  // - better detect what kind of start is needed
  // - return both flavors of starting pattern
  // - attach $ at the end of the pattern when creating the actual RegExp
  //
  // Ah, but wait, no, that all only applies to the root when the first pattern
  // is not an extglob. If the first pattern IS an extglob, then we need all
  // that dot prevention biz to live in the extglob portions, because eg
  // +(*|.x*) can match .xy but not .yx.
  //
  // So, return the two flavors if it's #root and the first child is not an
  // AST, otherwise leave it to the child AST to handle it, and there,
  // use the (?:^|/) style of start binding.
  //
  // Even simplified further:
  // - Since the start for a join is eg /(?!\.) and the start for a part
  // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
  // or start or whatever) and prepend ^ or / at the Regexp construction.
  toRegExpSource(allowDot) {
    const dot = allowDot ?? !!this.#options.dot;
    if (this.#root === this)
      this.#fillNegs();
    if (!this.type) {
      const noEmpty = this.isStart() && this.isEnd();
      const src = this.#parts.map((p2) => {
        const [re2, _2, hasMagic, uflag] = typeof p2 === "string" ? _AST.#parseGlob(p2, this.#hasMagic, noEmpty) : p2.toRegExpSource(allowDot);
        this.#hasMagic = this.#hasMagic || hasMagic;
        this.#uflag = this.#uflag || uflag;
        return re2;
      }).join("");
      let start2 = "";
      if (this.isStart()) {
        if (typeof this.#parts[0] === "string") {
          const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
          if (!dotTravAllowed) {
            const aps = addPatternStart;
            const needNoTrav = (
              // dots are allowed, and the pattern starts with [ or .
              dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
              src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
              src.startsWith("\\.\\.") && aps.has(src.charAt(4))
            );
            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
            start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
          }
        }
      }
      let end = "";
      if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === "!") {
        end = "(?:$|\\/)";
      }
      const final2 = start2 + src + end;
      return [
        final2,
        unescape2(src),
        this.#hasMagic = !!this.#hasMagic,
        this.#uflag
      ];
    }
    const repeated = this.type === "*" || this.type === "+";
    const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
    let body = this.#partsToRegExp(dot);
    if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
      const s2 = this.toString();
      this.#parts = [s2];
      this.type = null;
      this.#hasMagic = void 0;
      return [s2, unescape2(this.toString()), false, false];
    }
    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : this.#partsToRegExp(true);
    if (bodyDotAllowed === body) {
      bodyDotAllowed = "";
    }
    if (bodyDotAllowed) {
      body = `(?:${body})(?:${bodyDotAllowed})*?`;
    }
    let final = "";
    if (this.type === "!" && this.#emptyExt) {
      final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
    } else {
      const close = this.type === "!" ? (
        // !() must match something,but !(x) can match ''
        "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
      ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
      final = start + body + close;
    }
    return [
      final,
      unescape2(body),
      this.#hasMagic = !!this.#hasMagic,
      this.#uflag
    ];
  }
  #partsToRegExp(dot) {
    return this.#parts.map((p2) => {
      if (typeof p2 === "string") {
        throw new Error("string type in extglob ast??");
      }
      const [re2, _2, _hasMagic, uflag] = p2.toRegExpSource(dot);
      this.#uflag = this.#uflag || uflag;
      return re2;
    }).filter((p2) => !(this.isStart() && this.isEnd()) || !!p2).join("|");
  }
  static #parseGlob(glob, hasMagic, noEmpty = false) {
    let escaping = false;
    let re2 = "";
    let uflag = false;
    for (let i2 = 0; i2 < glob.length; i2++) {
      const c2 = glob.charAt(i2);
      if (escaping) {
        escaping = false;
        re2 += (reSpecials.has(c2) ? "\\" : "") + c2;
        continue;
      }
      if (c2 === "\\") {
        if (i2 === glob.length - 1) {
          re2 += "\\\\";
        } else {
          escaping = true;
        }
        continue;
      }
      if (c2 === "[") {
        const [src, needUflag, consumed, magic] = parseClass(glob, i2);
        if (consumed) {
          re2 += src;
          uflag = uflag || needUflag;
          i2 += consumed - 1;
          hasMagic = hasMagic || magic;
          continue;
        }
      }
      if (c2 === "*") {
        if (noEmpty && glob === "*")
          re2 += starNoEmpty;
        else
          re2 += star;
        hasMagic = true;
        continue;
      }
      if (c2 === "?") {
        re2 += qmark;
        hasMagic = true;
        continue;
      }
      re2 += regExpEscape(c2);
    }
    return [re2, unescape2(glob), !!hasMagic, uflag];
  }
};

// ../node_modules/minimatch/dist/esm/escape.js
var escape = (s2, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s2.replace(/[?*()[\]]/g, "[$&]") : s2.replace(/[?*()[\]\\]/g, "\\$&");
};

// ../node_modules/minimatch/dist/esm/index.js
var minimatch = (p2, pattern, options = {}) => {
  assertValidPattern(pattern);
  if (!options.nocomment && pattern.charAt(0) === "#") {
    return false;
  }
  return new Minimatch(pattern, options).match(p2);
};
var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
var starDotExtTest = (ext2) => (f2) => !f2.startsWith(".") && f2.endsWith(ext2);
var starDotExtTestDot = (ext2) => (f2) => f2.endsWith(ext2);
var starDotExtTestNocase = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f2) => !f2.startsWith(".") && f2.toLowerCase().endsWith(ext2);
};
var starDotExtTestNocaseDot = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f2) => f2.toLowerCase().endsWith(ext2);
};
var starDotStarRE = /^\*+\.\*+$/;
var starDotStarTest = (f2) => !f2.startsWith(".") && f2.includes(".");
var starDotStarTestDot = (f2) => f2 !== "." && f2 !== ".." && f2.includes(".");
var dotStarRE = /^\.\*+$/;
var dotStarTest = (f2) => f2 !== "." && f2 !== ".." && f2.startsWith(".");
var starRE = /^\*+$/;
var starTest = (f2) => f2.length !== 0 && !f2.startsWith(".");
var starTestDot = (f2) => f2.length !== 0 && f2 !== "." && f2 !== "..";
var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
var qmarksTestNocase = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f2) => noext(f2) && f2.toLowerCase().endsWith(ext2);
};
var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f2) => noext(f2) && f2.toLowerCase().endsWith(ext2);
};
var qmarksTestDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  return !ext2 ? noext : (f2) => noext(f2) && f2.endsWith(ext2);
};
var qmarksTest = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  return !ext2 ? noext : (f2) => noext(f2) && f2.endsWith(ext2);
};
var qmarksTestNoExt = ([$0]) => {
  const len = $0.length;
  return (f2) => f2.length === len && !f2.startsWith(".");
};
var qmarksTestNoExtDot = ([$0]) => {
  const len = $0.length;
  return (f2) => f2.length === len && f2 !== "." && f2 !== "..";
};
var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
var path = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
};
var sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
minimatch.sep = sep;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var qmark2 = "[^/]";
var star2 = qmark2 + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var filter = (pattern, options = {}) => (p2) => minimatch(p2, pattern, options);
minimatch.filter = filter;
var ext = (a2, b2 = {}) => Object.assign({}, a2, b2);
var defaults = (def) => {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch;
  }
  const orig = minimatch;
  const m2 = (p2, pattern, options = {}) => orig(p2, pattern, ext(def, options));
  return Object.assign(m2, {
    Minimatch: class Minimatch extends orig.Minimatch {
      constructor(pattern, options = {}) {
        super(pattern, ext(def, options));
      }
      static defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      }
    },
    AST: class AST extends orig.AST {
      /* c8 ignore start */
      constructor(type, parent, options = {}) {
        super(type, parent, ext(def, options));
      }
      /* c8 ignore stop */
      static fromGlob(pattern, options = {}) {
        return orig.AST.fromGlob(pattern, ext(def, options));
      }
    },
    unescape: (s2, options = {}) => orig.unescape(s2, ext(def, options)),
    escape: (s2, options = {}) => orig.escape(s2, ext(def, options)),
    filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
    defaults: (options) => orig.defaults(ext(def, options)),
    makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
    braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
    match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
    sep: orig.sep,
    GLOBSTAR
  });
};
minimatch.defaults = defaults;
var braceExpand = (pattern, options = {}) => {
  assertValidPattern(pattern);
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    return [pattern];
  }
  return expand(pattern);
};
minimatch.braceExpand = braceExpand;
var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
var match4 = (list, pattern, options = {}) => {
  const mm = new Minimatch(pattern, options);
  list = list.filter((f2) => mm.match(f2));
  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list;
};
minimatch.match = match4;
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
var regExpEscape2 = (s2) => s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var Minimatch = class {
  options;
  set;
  pattern;
  windowsPathsNoEscape;
  nonegate;
  negate;
  comment;
  empty;
  preserveMultipleSlashes;
  partial;
  globSet;
  globParts;
  nocase;
  isWindows;
  platform;
  windowsNoMagicRoot;
  regexp;
  constructor(pattern, options = {}) {
    assertValidPattern(pattern);
    options = options || {};
    this.options = options;
    this.pattern = pattern;
    this.platform = options.platform || defaultPlatform;
    this.isWindows = this.platform === "win32";
    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, "/");
    }
    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
    this.regexp = null;
    this.negate = false;
    this.nonegate = !!options.nonegate;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    this.nocase = !!this.options.nocase;
    this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
    this.globSet = [];
    this.globParts = [];
    this.set = [];
    this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1) {
      return true;
    }
    for (const pattern of this.set) {
      for (const part of pattern) {
        if (typeof part !== "string")
          return true;
      }
    }
    return false;
  }
  debug(..._2) {
  }
  make() {
    const pattern = this.pattern;
    const options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    this.globSet = [...new Set(this.braceExpand())];
    if (options.debug) {
      this.debug = (...args) => console.error(...args);
    }
    this.debug(this.pattern, this.globSet);
    const rawGlobParts = this.globSet.map((s2) => this.slashSplit(s2));
    this.globParts = this.preprocess(rawGlobParts);
    this.debug(this.pattern, this.globParts);
    let set = this.globParts.map((s2, _2, __) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const isUNC = s2[0] === "" && s2[1] === "" && (s2[2] === "?" || !globMagic.test(s2[2])) && !globMagic.test(s2[3]);
        const isDrive = /^[a-z]:/i.test(s2[0]);
        if (isUNC) {
          return [...s2.slice(0, 4), ...s2.slice(4).map((ss) => this.parse(ss))];
        } else if (isDrive) {
          return [s2[0], ...s2.slice(1).map((ss) => this.parse(ss))];
        }
      }
      return s2.map((ss) => this.parse(ss));
    });
    this.debug(this.pattern, set);
    this.set = set.filter((s2) => s2.indexOf(false) === -1);
    if (this.isWindows) {
      for (let i2 = 0; i2 < this.set.length; i2++) {
        const p2 = this.set[i2];
        if (p2[0] === "" && p2[1] === "" && this.globParts[i2][2] === "?" && typeof p2[3] === "string" && /^[a-z]:$/i.test(p2[3])) {
          p2[2] = "?";
        }
      }
    }
    this.debug(this.pattern, this.set);
  }
  // various transforms to equivalent pattern sets that are
  // faster to process in a filesystem walk.  The goal is to
  // eliminate what we can, and push all ** patterns as far
  // to the right as possible, even if it increases the number
  // of patterns that we have to process.
  preprocess(globParts) {
    if (this.options.noglobstar) {
      for (let i2 = 0; i2 < globParts.length; i2++) {
        for (let j2 = 0; j2 < globParts[i2].length; j2++) {
          if (globParts[i2][j2] === "**") {
            globParts[i2][j2] = "*";
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      globParts = this.firstPhasePreProcess(globParts);
      globParts = this.secondPhasePreProcess(globParts);
    } else if (optimizationLevel >= 1) {
      globParts = this.levelOneOptimize(globParts);
    } else {
      globParts = this.adjascentGlobstarOptimize(globParts);
    }
    return globParts;
  }
  // just get rid of adjascent ** portions
  adjascentGlobstarOptimize(globParts) {
    return globParts.map((parts) => {
      let gs = -1;
      while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
        let i2 = gs;
        while (parts[i2 + 1] === "**") {
          i2++;
        }
        if (i2 !== gs) {
          parts.splice(gs, i2 - gs);
        }
      }
      return parts;
    });
  }
  // get rid of adjascent ** and resolve .. portions
  levelOneOptimize(globParts) {
    return globParts.map((parts) => {
      parts = parts.reduce((set, part) => {
        const prev = set[set.length - 1];
        if (part === "**" && prev === "**") {
          return set;
        }
        if (part === "..") {
          if (prev && prev !== ".." && prev !== "." && prev !== "**") {
            set.pop();
            return set;
          }
        }
        set.push(part);
        return set;
      }, []);
      return parts.length === 0 ? [""] : parts;
    });
  }
  levelTwoFileOptimize(parts) {
    if (!Array.isArray(parts)) {
      parts = this.slashSplit(parts);
    }
    let didSomething = false;
    do {
      didSomething = false;
      if (!this.preserveMultipleSlashes) {
        for (let i2 = 1; i2 < parts.length - 1; i2++) {
          const p2 = parts[i2];
          if (i2 === 1 && p2 === "" && parts[0] === "")
            continue;
          if (p2 === "." || p2 === "") {
            didSomething = true;
            parts.splice(i2, 1);
            i2--;
          }
        }
        if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
          didSomething = true;
          parts.pop();
        }
      }
      let dd = 0;
      while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
        const p2 = parts[dd - 1];
        if (p2 && p2 !== "." && p2 !== ".." && p2 !== "**") {
          didSomething = true;
          parts.splice(dd - 1, 2);
          dd -= 2;
        }
      }
    } while (didSomething);
    return parts.length === 0 ? [""] : parts;
  }
  // First phase: single-pattern processing
  // <pre> is 1 or more portions
  // <rest> is 1 or more portions
  // <p> is any portion other than ., .., '', or **
  // <e> is . or ''
  //
  // **/.. is *brutal* for filesystem walking performance, because
  // it effectively resets the recursive walk each time it occurs,
  // and ** cannot be reduced out by a .. pattern part like a regexp
  // or most strings (other than .., ., and '') can be.
  //
  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
  // <pre>/<e>/<rest> -> <pre>/<rest>
  // <pre>/<p>/../<rest> -> <pre>/<rest>
  // **/**/<rest> -> **/<rest>
  //
  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
  // this WOULD be allowed if ** did follow symlinks, or * didn't
  firstPhasePreProcess(globParts) {
    let didSomething = false;
    do {
      didSomething = false;
      for (let parts of globParts) {
        let gs = -1;
        while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
          let gss = gs;
          while (parts[gss + 1] === "**") {
            gss++;
          }
          if (gss > gs) {
            parts.splice(gs + 1, gss - gs);
          }
          let next = parts[gs + 1];
          const p2 = parts[gs + 2];
          const p22 = parts[gs + 3];
          if (next !== "..")
            continue;
          if (!p2 || p2 === "." || p2 === ".." || !p22 || p22 === "." || p22 === "..") {
            continue;
          }
          didSomething = true;
          parts.splice(gs, 1);
          const other = parts.slice(0);
          other[gs] = "**";
          globParts.push(other);
          gs--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let i2 = 1; i2 < parts.length - 1; i2++) {
            const p2 = parts[i2];
            if (i2 === 1 && p2 === "" && parts[0] === "")
              continue;
            if (p2 === "." || p2 === "") {
              didSomething = true;
              parts.splice(i2, 1);
              i2--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd = 0;
        while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
          const p2 = parts[dd - 1];
          if (p2 && p2 !== "." && p2 !== ".." && p2 !== "**") {
            didSomething = true;
            const needDot = dd === 1 && parts[dd + 1] === "**";
            const splin = needDot ? ["."] : [];
            parts.splice(dd - 1, 2, ...splin);
            if (parts.length === 0)
              parts.push("");
            dd -= 2;
          }
        }
      }
    } while (didSomething);
    return globParts;
  }
  // second phase: multi-pattern dedupes
  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
  //
  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
  // ^-- not valid because ** doens't follow symlinks
  secondPhasePreProcess(globParts) {
    for (let i2 = 0; i2 < globParts.length - 1; i2++) {
      for (let j2 = i2 + 1; j2 < globParts.length; j2++) {
        const matched = this.partsMatch(globParts[i2], globParts[j2], !this.preserveMultipleSlashes);
        if (matched) {
          globParts[i2] = [];
          globParts[j2] = matched;
          break;
        }
      }
    }
    return globParts.filter((gs) => gs.length);
  }
  partsMatch(a2, b2, emptyGSMatch = false) {
    let ai = 0;
    let bi = 0;
    let result = [];
    let which = "";
    while (ai < a2.length && bi < b2.length) {
      if (a2[ai] === b2[bi]) {
        result.push(which === "b" ? b2[bi] : a2[ai]);
        ai++;
        bi++;
      } else if (emptyGSMatch && a2[ai] === "**" && b2[bi] === a2[ai + 1]) {
        result.push(a2[ai]);
        ai++;
      } else if (emptyGSMatch && b2[bi] === "**" && a2[ai] === b2[bi + 1]) {
        result.push(b2[bi]);
        bi++;
      } else if (a2[ai] === "*" && b2[bi] && (this.options.dot || !b2[bi].startsWith(".")) && b2[bi] !== "**") {
        if (which === "b")
          return false;
        which = "a";
        result.push(a2[ai]);
        ai++;
        bi++;
      } else if (b2[bi] === "*" && a2[ai] && (this.options.dot || !a2[ai].startsWith(".")) && a2[ai] !== "**") {
        if (which === "a")
          return false;
        which = "b";
        result.push(b2[bi]);
        ai++;
        bi++;
      } else {
        return false;
      }
    }
    return a2.length === b2.length && result;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    const pattern = this.pattern;
    let negate = false;
    let negateOffset = 0;
    for (let i2 = 0; i2 < pattern.length && pattern.charAt(i2) === "!"; i2++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.slice(negateOffset);
    this.negate = negate;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(file, pattern, partial = false) {
    const options = this.options;
    if (this.isWindows) {
      const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
      const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
      const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
      const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
      const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
      const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
      if (typeof fdi === "number" && typeof pdi === "number") {
        const [fd, pd] = [file[fdi], pattern[pdi]];
        if (fd.toLowerCase() === pd.toLowerCase()) {
          pattern[pdi] = fd;
          if (pdi > fdi) {
            pattern = pattern.slice(pdi);
          } else if (fdi > pdi) {
            file = file.slice(fdi);
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      file = this.levelTwoFileOptimize(file);
    }
    this.debug("matchOne", this, { file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p2 = pattern[pi];
      var f2 = file[fi];
      this.debug(pattern, p2, f2);
      if (p2 === false) {
        return false;
      }
      if (p2 === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p2, f2]);
        var fr2 = fi;
        var pr2 = pi + 1;
        if (pr2 === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr2 < fl) {
          var swallowee = file[fr2];
          this.debug("\nglobstar while", file, fr2, pattern, pr2, swallowee);
          if (this.matchOne(file.slice(fr2), pattern.slice(pr2), partial)) {
            this.debug("globstar found match!", fr2, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr2, pattern, pr2);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr2++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr2, pattern, pr2);
          if (fr2 === fl) {
            return true;
          }
        }
        return false;
      }
      let hit;
      if (typeof p2 === "string") {
        hit = f2 === p2;
        this.debug("string match", p2, f2, hit);
      } else {
        hit = p2.test(f2);
        this.debug("pattern match", p2, f2, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    } else {
      throw new Error("wtf?");
    }
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern) {
    assertValidPattern(pattern);
    const options = this.options;
    if (pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    let m2;
    let fastTest = null;
    if (m2 = pattern.match(starRE)) {
      fastTest = options.dot ? starTestDot : starTest;
    } else if (m2 = pattern.match(starDotExtRE)) {
      fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m2[1]);
    } else if (m2 = pattern.match(qmarksRE)) {
      fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m2);
    } else if (m2 = pattern.match(starDotStarRE)) {
      fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
    } else if (m2 = pattern.match(dotStarRE)) {
      fastTest = dotStarTest;
    }
    const re2 = AST.fromGlob(pattern, this.options).toMMPattern();
    if (fastTest && typeof re2 === "object") {
      Reflect.defineProperty(re2, "test", { value: fastTest });
    }
    return re2;
  }
  makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    const set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    const options = this.options;
    const twoStar = options.noglobstar ? star2 : options.dot ? twoStarDot : twoStarNoDot;
    const flags = new Set(options.nocase ? ["i"] : []);
    let re2 = set.map((pattern) => {
      const pp = pattern.map((p2) => {
        if (p2 instanceof RegExp) {
          for (const f2 of p2.flags.split(""))
            flags.add(f2);
        }
        return typeof p2 === "string" ? regExpEscape2(p2) : p2 === GLOBSTAR ? GLOBSTAR : p2._src;
      });
      pp.forEach((p2, i2) => {
        const next = pp[i2 + 1];
        const prev = pp[i2 - 1];
        if (p2 !== GLOBSTAR || prev === GLOBSTAR) {
          return;
        }
        if (prev === void 0) {
          if (next !== void 0 && next !== GLOBSTAR) {
            pp[i2 + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
          } else {
            pp[i2] = twoStar;
          }
        } else if (next === void 0) {
          pp[i2 - 1] = prev + "(?:\\/|" + twoStar + ")?";
        } else if (next !== GLOBSTAR) {
          pp[i2 - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
          pp[i2 + 1] = GLOBSTAR;
        }
      });
      return pp.filter((p2) => p2 !== GLOBSTAR).join("/");
    }).join("|");
    const [open2, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
    re2 = "^" + open2 + re2 + close + "$";
    if (this.negate)
      re2 = "^(?!" + re2 + ").+$";
    try {
      this.regexp = new RegExp(re2, [...flags].join(""));
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  slashSplit(p2) {
    if (this.preserveMultipleSlashes) {
      return p2.split("/");
    } else if (this.isWindows && /^\/\/[^\/]+/.test(p2)) {
      return ["", ...p2.split(/\/+/)];
    } else {
      return p2.split(/\/+/);
    }
  }
  match(f2, partial = this.partial) {
    this.debug("match", f2, this.pattern);
    if (this.comment) {
      return false;
    }
    if (this.empty) {
      return f2 === "";
    }
    if (f2 === "/" && partial) {
      return true;
    }
    const options = this.options;
    if (this.isWindows) {
      f2 = f2.split("\\").join("/");
    }
    const ff = this.slashSplit(f2);
    this.debug(this.pattern, "split", ff);
    const set = this.set;
    this.debug(this.pattern, "set", set);
    let filename = ff[ff.length - 1];
    if (!filename) {
      for (let i2 = ff.length - 2; !filename && i2 >= 0; i2--) {
        filename = ff[i2];
      }
    }
    for (let i2 = 0; i2 < set.length; i2++) {
      const pattern = set[i2];
      let file = ff;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      const hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate) {
          return true;
        }
        return !this.negate;
      }
    }
    if (options.flipNegate) {
      return false;
    }
    return this.negate;
  }
  static defaults(def) {
    return minimatch.defaults(def).Minimatch;
  }
};
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape2;

// ../node_modules/@anthropic-ai/sdk/version.mjs
var VERSION = "0.39.0";

// ../node_modules/@anthropic-ai/sdk/_shims/registry.mjs
var auto = false;
var kind = void 0;
var fetch2 = void 0;
var Request2 = void 0;
var Response2 = void 0;
var Headers2 = void 0;
var FormData2 = void 0;
var Blob2 = void 0;
var File = void 0;
var ReadableStream2 = void 0;
var getMultipartRequestOptions = void 0;
var getDefaultAgent = void 0;
var fileFromPath = void 0;
var isFsReadStream = void 0;
function setShims(shims, options = { auto: false }) {
  if (auto) {
    throw new Error(`you must \`import '@anthropic-ai/sdk/shims/${shims.kind}'\` before importing anything else from @anthropic-ai/sdk`);
  }
  if (kind) {
    throw new Error(`can't \`import '@anthropic-ai/sdk/shims/${shims.kind}'\` after \`import '@anthropic-ai/sdk/shims/${kind}'\``);
  }
  auto = options.auto;
  kind = shims.kind;
  fetch2 = shims.fetch;
  Request2 = shims.Request;
  Response2 = shims.Response;
  Headers2 = shims.Headers;
  FormData2 = shims.FormData;
  Blob2 = shims.Blob;
  File = shims.File;
  ReadableStream2 = shims.ReadableStream;
  getMultipartRequestOptions = shims.getMultipartRequestOptions;
  getDefaultAgent = shims.getDefaultAgent;
  fileFromPath = shims.fileFromPath;
  isFsReadStream = shims.isFsReadStream;
}

// ../node_modules/@anthropic-ai/sdk/_shims/node-runtime.mjs
init_lib();

// ../node_modules/formdata-node/lib/esm/FormData.js
init_File();
init_isFile();
import { inspect } from "util";

// ../node_modules/formdata-node/lib/esm/isBlob.js
init_Blob();
var isBlob2 = (value) => value instanceof Blob4;

// ../node_modules/formdata-node/lib/esm/FormData.js
init_isFunction();

// ../node_modules/formdata-node/lib/esm/deprecateConstructorEntries.js
import { deprecate } from "util";
var deprecateConstructorEntries = deprecate(() => {
}, 'Constructor "entries" argument is not spec-compliant and will be removed in next major release.');

// ../node_modules/formdata-node/lib/esm/FormData.js
var __classPrivateFieldGet3 = function(receiver, state, kind3, f2) {
  if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind3 === "m" ? f2 : kind3 === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _FormData_instances;
var _FormData_entries;
var _FormData_setEntry;
var FormData3 = class {
  constructor(entries) {
    _FormData_instances.add(this);
    _FormData_entries.set(this, /* @__PURE__ */ new Map());
    if (entries) {
      deprecateConstructorEntries();
      entries.forEach(({ name, value, fileName }) => this.append(name, value, fileName));
    }
  }
  static [(_FormData_entries = /* @__PURE__ */ new WeakMap(), _FormData_instances = /* @__PURE__ */ new WeakSet(), Symbol.hasInstance)](value) {
    return Boolean(value && isFunction(value.constructor) && value[Symbol.toStringTag] === "FormData" && isFunction(value.append) && isFunction(value.set) && isFunction(value.get) && isFunction(value.getAll) && isFunction(value.has) && isFunction(value.delete) && isFunction(value.entries) && isFunction(value.values) && isFunction(value.keys) && isFunction(value[Symbol.iterator]) && isFunction(value.forEach));
  }
  append(name, value, fileName) {
    __classPrivateFieldGet3(this, _FormData_instances, "m", _FormData_setEntry).call(this, {
      name,
      fileName,
      append: true,
      rawValue: value,
      argsLength: arguments.length
    });
  }
  set(name, value, fileName) {
    __classPrivateFieldGet3(this, _FormData_instances, "m", _FormData_setEntry).call(this, {
      name,
      fileName,
      append: false,
      rawValue: value,
      argsLength: arguments.length
    });
  }
  get(name) {
    const field = __classPrivateFieldGet3(this, _FormData_entries, "f").get(String(name));
    if (!field) {
      return null;
    }
    return field[0];
  }
  getAll(name) {
    const field = __classPrivateFieldGet3(this, _FormData_entries, "f").get(String(name));
    if (!field) {
      return [];
    }
    return field.slice();
  }
  has(name) {
    return __classPrivateFieldGet3(this, _FormData_entries, "f").has(String(name));
  }
  delete(name) {
    __classPrivateFieldGet3(this, _FormData_entries, "f").delete(String(name));
  }
  *keys() {
    for (const key of __classPrivateFieldGet3(this, _FormData_entries, "f").keys()) {
      yield key;
    }
  }
  *entries() {
    for (const name of this.keys()) {
      const values = this.getAll(name);
      for (const value of values) {
        yield [name, value];
      }
    }
  }
  *values() {
    for (const [, value] of this) {
      yield value;
    }
  }
  [(_FormData_setEntry = function _FormData_setEntry2({ name, rawValue, append, fileName, argsLength }) {
    const methodName = append ? "append" : "set";
    if (argsLength < 2) {
      throw new TypeError(`Failed to execute '${methodName}' on 'FormData': 2 arguments required, but only ${argsLength} present.`);
    }
    name = String(name);
    let value;
    if (isFile(rawValue)) {
      value = fileName === void 0 ? rawValue : new File2([rawValue], fileName, {
        type: rawValue.type,
        lastModified: rawValue.lastModified
      });
    } else if (isBlob2(rawValue)) {
      value = new File2([rawValue], fileName === void 0 ? "blob" : fileName, {
        type: rawValue.type
      });
    } else if (fileName) {
      throw new TypeError(`Failed to execute '${methodName}' on 'FormData': parameter 2 is not of type 'Blob'.`);
    } else {
      value = String(rawValue);
    }
    const values = __classPrivateFieldGet3(this, _FormData_entries, "f").get(name);
    if (!values) {
      return void __classPrivateFieldGet3(this, _FormData_entries, "f").set(name, [value]);
    }
    if (!append) {
      return void __classPrivateFieldGet3(this, _FormData_entries, "f").set(name, [value]);
    }
    values.push(value);
  }, Symbol.iterator)]() {
    return this.entries();
  }
  forEach(callback, thisArg) {
    for (const [name, value] of this) {
      callback.call(thisArg, value, name, this);
    }
  }
  get [Symbol.toStringTag]() {
    return "FormData";
  }
  [inspect.custom]() {
    return this[Symbol.toStringTag];
  }
};

// ../node_modules/formdata-node/lib/esm/index.js
init_Blob();
init_File();

// ../node_modules/@anthropic-ai/sdk/_shims/node-runtime.mjs
var import_agentkeepalive = __toESM(require_agentkeepalive(), 1);
var import_abort_controller = __toESM(require_abort_controller(), 1);
import { ReadStream as FsReadStream } from "fs";

// ../node_modules/form-data-encoder/lib/esm/util/createBoundary.js
var alphabet = "abcdefghijklmnopqrstuvwxyz0123456789";
function createBoundary() {
  let size = 16;
  let res = "";
  while (size--) {
    res += alphabet[Math.random() * alphabet.length << 0];
  }
  return res;
}
var createBoundary_default = createBoundary;

// ../node_modules/form-data-encoder/lib/esm/util/isPlainObject.js
var getType = (value) => Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
function isPlainObject(value) {
  if (getType(value) !== "object") {
    return false;
  }
  const pp = Object.getPrototypeOf(value);
  if (pp === null || pp === void 0) {
    return true;
  }
  const Ctor = pp.constructor && pp.constructor.toString();
  return Ctor === Object.toString();
}
var isPlainObject_default = isPlainObject;

// ../node_modules/form-data-encoder/lib/esm/util/normalizeValue.js
var normalizeValue = (value) => String(value).replace(/\r|\n/g, (match7, i2, str) => {
  if (match7 === "\r" && str[i2 + 1] !== "\n" || match7 === "\n" && str[i2 - 1] !== "\r") {
    return "\r\n";
  }
  return match7;
});
var normalizeValue_default = normalizeValue;

// ../node_modules/form-data-encoder/lib/esm/util/escapeName.js
var escapeName = (name) => String(name).replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/"/g, "%22");
var escapeName_default = escapeName;

// ../node_modules/form-data-encoder/lib/esm/util/isFunction.js
var isFunction2 = (value) => typeof value === "function";
var isFunction_default = isFunction2;

// ../node_modules/form-data-encoder/lib/esm/util/isFileLike.js
var isFileLike = (value) => Boolean(value && typeof value === "object" && isFunction_default(value.constructor) && value[Symbol.toStringTag] === "File" && isFunction_default(value.stream) && value.name != null && value.size != null && value.lastModified != null);

// ../node_modules/form-data-encoder/lib/esm/util/isFormData.js
var isFormData = (value) => Boolean(value && isFunction_default(value.constructor) && value[Symbol.toStringTag] === "FormData" && isFunction_default(value.append) && isFunction_default(value.getAll) && isFunction_default(value.entries) && isFunction_default(value[Symbol.iterator]));

// ../node_modules/form-data-encoder/lib/esm/FormDataEncoder.js
var __classPrivateFieldSet3 = function(receiver, state, value, kind3, f2) {
  if (kind3 === "m") throw new TypeError("Private method is not writable");
  if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind3 === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet4 = function(receiver, state, kind3, f2) {
  if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind3 === "m" ? f2 : kind3 === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _FormDataEncoder_instances;
var _FormDataEncoder_CRLF;
var _FormDataEncoder_CRLF_BYTES;
var _FormDataEncoder_CRLF_BYTES_LENGTH;
var _FormDataEncoder_DASHES;
var _FormDataEncoder_encoder;
var _FormDataEncoder_footer;
var _FormDataEncoder_form;
var _FormDataEncoder_options;
var _FormDataEncoder_getFieldHeader;
var defaultOptions = {
  enableAdditionalHeaders: false
};
var FormDataEncoder = class {
  constructor(form, boundaryOrOptions, options) {
    _FormDataEncoder_instances.add(this);
    _FormDataEncoder_CRLF.set(this, "\r\n");
    _FormDataEncoder_CRLF_BYTES.set(this, void 0);
    _FormDataEncoder_CRLF_BYTES_LENGTH.set(this, void 0);
    _FormDataEncoder_DASHES.set(this, "-".repeat(2));
    _FormDataEncoder_encoder.set(this, new TextEncoder());
    _FormDataEncoder_footer.set(this, void 0);
    _FormDataEncoder_form.set(this, void 0);
    _FormDataEncoder_options.set(this, void 0);
    if (!isFormData(form)) {
      throw new TypeError("Expected first argument to be a FormData instance.");
    }
    let boundary;
    if (isPlainObject_default(boundaryOrOptions)) {
      options = boundaryOrOptions;
    } else {
      boundary = boundaryOrOptions;
    }
    if (!boundary) {
      boundary = createBoundary_default();
    }
    if (typeof boundary !== "string") {
      throw new TypeError("Expected boundary argument to be a string.");
    }
    if (options && !isPlainObject_default(options)) {
      throw new TypeError("Expected options argument to be an object.");
    }
    __classPrivateFieldSet3(this, _FormDataEncoder_form, form, "f");
    __classPrivateFieldSet3(this, _FormDataEncoder_options, { ...defaultOptions, ...options }, "f");
    __classPrivateFieldSet3(this, _FormDataEncoder_CRLF_BYTES, __classPrivateFieldGet4(this, _FormDataEncoder_encoder, "f").encode(__classPrivateFieldGet4(this, _FormDataEncoder_CRLF, "f")), "f");
    __classPrivateFieldSet3(this, _FormDataEncoder_CRLF_BYTES_LENGTH, __classPrivateFieldGet4(this, _FormDataEncoder_CRLF_BYTES, "f").byteLength, "f");
    this.boundary = `form-data-boundary-${boundary}`;
    this.contentType = `multipart/form-data; boundary=${this.boundary}`;
    __classPrivateFieldSet3(this, _FormDataEncoder_footer, __classPrivateFieldGet4(this, _FormDataEncoder_encoder, "f").encode(`${__classPrivateFieldGet4(this, _FormDataEncoder_DASHES, "f")}${this.boundary}${__classPrivateFieldGet4(this, _FormDataEncoder_DASHES, "f")}${__classPrivateFieldGet4(this, _FormDataEncoder_CRLF, "f").repeat(2)}`), "f");
    this.contentLength = String(this.getContentLength());
    this.headers = Object.freeze({
      "Content-Type": this.contentType,
      "Content-Length": this.contentLength
    });
    Object.defineProperties(this, {
      boundary: { writable: false, configurable: false },
      contentType: { writable: false, configurable: false },
      contentLength: { writable: false, configurable: false },
      headers: { writable: false, configurable: false }
    });
  }
  getContentLength() {
    let length = 0;
    for (const [name, raw] of __classPrivateFieldGet4(this, _FormDataEncoder_form, "f")) {
      const value = isFileLike(raw) ? raw : __classPrivateFieldGet4(this, _FormDataEncoder_encoder, "f").encode(normalizeValue_default(raw));
      length += __classPrivateFieldGet4(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getFieldHeader).call(this, name, value).byteLength;
      length += isFileLike(value) ? value.size : value.byteLength;
      length += __classPrivateFieldGet4(this, _FormDataEncoder_CRLF_BYTES_LENGTH, "f");
    }
    return length + __classPrivateFieldGet4(this, _FormDataEncoder_footer, "f").byteLength;
  }
  *values() {
    for (const [name, raw] of __classPrivateFieldGet4(this, _FormDataEncoder_form, "f").entries()) {
      const value = isFileLike(raw) ? raw : __classPrivateFieldGet4(this, _FormDataEncoder_encoder, "f").encode(normalizeValue_default(raw));
      yield __classPrivateFieldGet4(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getFieldHeader).call(this, name, value);
      yield value;
      yield __classPrivateFieldGet4(this, _FormDataEncoder_CRLF_BYTES, "f");
    }
    yield __classPrivateFieldGet4(this, _FormDataEncoder_footer, "f");
  }
  async *encode() {
    for (const part of this.values()) {
      if (isFileLike(part)) {
        yield* part.stream();
      } else {
        yield part;
      }
    }
  }
  [(_FormDataEncoder_CRLF = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_CRLF_BYTES = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_CRLF_BYTES_LENGTH = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_DASHES = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_encoder = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_footer = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_form = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_options = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_instances = /* @__PURE__ */ new WeakSet(), _FormDataEncoder_getFieldHeader = function _FormDataEncoder_getFieldHeader2(name, value) {
    let header = "";
    header += `${__classPrivateFieldGet4(this, _FormDataEncoder_DASHES, "f")}${this.boundary}${__classPrivateFieldGet4(this, _FormDataEncoder_CRLF, "f")}`;
    header += `Content-Disposition: form-data; name="${escapeName_default(name)}"`;
    if (isFileLike(value)) {
      header += `; filename="${escapeName_default(value.name)}"${__classPrivateFieldGet4(this, _FormDataEncoder_CRLF, "f")}`;
      header += `Content-Type: ${value.type || "application/octet-stream"}`;
    }
    if (__classPrivateFieldGet4(this, _FormDataEncoder_options, "f").enableAdditionalHeaders === true) {
      header += `${__classPrivateFieldGet4(this, _FormDataEncoder_CRLF, "f")}Content-Length: ${isFileLike(value) ? value.size : value.byteLength}`;
    }
    return __classPrivateFieldGet4(this, _FormDataEncoder_encoder, "f").encode(`${header}${__classPrivateFieldGet4(this, _FormDataEncoder_CRLF, "f").repeat(2)}`);
  }, Symbol.iterator)]() {
    return this.values();
  }
  [Symbol.asyncIterator]() {
    return this.encode();
  }
};

// ../node_modules/@anthropic-ai/sdk/_shims/node-runtime.mjs
import { Readable as Readable2 } from "stream";

// ../node_modules/@anthropic-ai/sdk/_shims/MultipartBody.mjs
var MultipartBody = class {
  constructor(body) {
    this.body = body;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
};

// ../node_modules/@anthropic-ai/sdk/_shims/node-runtime.mjs
import { ReadableStream as ReadableStream4 } from "stream/web";
var fileFromPathWarned = false;
async function fileFromPath3(path2, ...args) {
  const { fileFromPath: _fileFromPath } = await Promise.resolve().then(() => (init_fileFromPath(), fileFromPath_exports));
  if (!fileFromPathWarned) {
    console.warn(`fileFromPath is deprecated; use fs.createReadStream(${JSON.stringify(path2)}) instead`);
    fileFromPathWarned = true;
  }
  return await _fileFromPath(path2, ...args);
}
var defaultHttpAgent = new import_agentkeepalive.default({ keepAlive: true, timeout: 5 * 60 * 1e3 });
var defaultHttpsAgent = new import_agentkeepalive.default.HttpsAgent({ keepAlive: true, timeout: 5 * 60 * 1e3 });
async function getMultipartRequestOptions2(form, opts) {
  const encoder = new FormDataEncoder(form);
  const readable = Readable2.from(encoder);
  const body = new MultipartBody(readable);
  const headers = {
    ...opts.headers,
    ...encoder.headers,
    "Content-Length": encoder.contentLength
  };
  return { ...opts, body, headers };
}
function getRuntime() {
  if (typeof AbortController === "undefined") {
    globalThis.AbortController = import_abort_controller.AbortController;
  }
  return {
    kind: "node",
    fetch: lib_default,
    Request: Request3,
    Response: Response3,
    Headers: Headers3,
    FormData: FormData3,
    Blob: Blob4,
    File: File2,
    ReadableStream: ReadableStream4,
    getMultipartRequestOptions: getMultipartRequestOptions2,
    getDefaultAgent: (url) => url.startsWith("https") ? defaultHttpsAgent : defaultHttpAgent,
    fileFromPath: fileFromPath3,
    isFsReadStream: (value) => value instanceof FsReadStream
  };
}

// ../node_modules/@anthropic-ai/sdk/_shims/index.mjs
if (!kind) setShims(getRuntime(), { auto: true });

// ../node_modules/@anthropic-ai/sdk/error.mjs
var AnthropicError = class extends Error {
};
var APIError = class _APIError extends AnthropicError {
  constructor(status, error, message, headers) {
    super(`${_APIError.makeMessage(status, error, message)}`);
    this.status = status;
    this.headers = headers;
    this.request_id = headers?.["request-id"];
    this.error = error;
  }
  static makeMessage(status, error, message) {
    const msg = error?.message ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status || !headers) {
      return new APIConnectionError({ message, cause: castToError(errorResponse) });
    }
    const error = errorResponse;
    if (status === 400) {
      return new BadRequestError(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError(status, error, message, headers);
    }
    return new _APIError(status, error, message, headers);
  }
};
var APIUserAbortError = class extends APIError {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
  }
};
var APIConnectionError = class extends APIError {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    if (cause)
      this.cause = cause;
  }
};
var APIConnectionTimeoutError = class extends APIConnectionError {
  constructor({ message } = {}) {
    super({ message: message ?? "Request timed out." });
  }
};
var BadRequestError = class extends APIError {
};
var AuthenticationError = class extends APIError {
};
var PermissionDeniedError = class extends APIError {
};
var NotFoundError = class extends APIError {
};
var ConflictError = class extends APIError {
};
var UnprocessableEntityError = class extends APIError {
};
var RateLimitError = class extends APIError {
};
var InternalServerError = class extends APIError {
};

// ../node_modules/@anthropic-ai/sdk/internal/decoders/line.mjs
var __classPrivateFieldSet5 = function(receiver, state, value, kind3, f2) {
  if (kind3 === "m") throw new TypeError("Private method is not writable");
  if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind3 === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet6 = function(receiver, state, kind3, f2) {
  if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind3 === "m" ? f2 : kind3 === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _LineDecoder_carriageReturnIndex;
var LineDecoder = class {
  constructor() {
    _LineDecoder_carriageReturnIndex.set(this, void 0);
    this.buffer = new Uint8Array();
    __classPrivateFieldSet5(this, _LineDecoder_carriageReturnIndex, null, "f");
  }
  decode(chunk) {
    if (chunk == null) {
      return [];
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk;
    let newData = new Uint8Array(this.buffer.length + binaryChunk.length);
    newData.set(this.buffer);
    newData.set(binaryChunk, this.buffer.length);
    this.buffer = newData;
    const lines = [];
    let patternIndex;
    while ((patternIndex = findNewlineIndex(this.buffer, __classPrivateFieldGet6(this, _LineDecoder_carriageReturnIndex, "f"))) != null) {
      if (patternIndex.carriage && __classPrivateFieldGet6(this, _LineDecoder_carriageReturnIndex, "f") == null) {
        __classPrivateFieldSet5(this, _LineDecoder_carriageReturnIndex, patternIndex.index, "f");
        continue;
      }
      if (__classPrivateFieldGet6(this, _LineDecoder_carriageReturnIndex, "f") != null && (patternIndex.index !== __classPrivateFieldGet6(this, _LineDecoder_carriageReturnIndex, "f") + 1 || patternIndex.carriage)) {
        lines.push(this.decodeText(this.buffer.slice(0, __classPrivateFieldGet6(this, _LineDecoder_carriageReturnIndex, "f") - 1)));
        this.buffer = this.buffer.slice(__classPrivateFieldGet6(this, _LineDecoder_carriageReturnIndex, "f"));
        __classPrivateFieldSet5(this, _LineDecoder_carriageReturnIndex, null, "f");
        continue;
      }
      const endIndex = __classPrivateFieldGet6(this, _LineDecoder_carriageReturnIndex, "f") !== null ? patternIndex.preceding - 1 : patternIndex.preceding;
      const line = this.decodeText(this.buffer.slice(0, endIndex));
      lines.push(line);
      this.buffer = this.buffer.slice(patternIndex.index);
      __classPrivateFieldSet5(this, _LineDecoder_carriageReturnIndex, null, "f");
    }
    return lines;
  }
  decodeText(bytes) {
    if (bytes == null)
      return "";
    if (typeof bytes === "string")
      return bytes;
    if (typeof Buffer !== "undefined") {
      if (bytes instanceof Buffer) {
        return bytes.toString();
      }
      if (bytes instanceof Uint8Array) {
        return Buffer.from(bytes).toString();
      }
      throw new AnthropicError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
    }
    if (typeof TextDecoder !== "undefined") {
      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
        this.textDecoder ?? (this.textDecoder = new TextDecoder("utf8"));
        return this.textDecoder.decode(bytes);
      }
      throw new AnthropicError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
    }
    throw new AnthropicError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);
  }
  flush() {
    if (!this.buffer.length) {
      return [];
    }
    return this.decode("\n");
  }
};
_LineDecoder_carriageReturnIndex = /* @__PURE__ */ new WeakMap();
LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function findNewlineIndex(buffer, startIndex) {
  const newline = 10;
  const carriage = 13;
  for (let i2 = startIndex ?? 0; i2 < buffer.length; i2++) {
    if (buffer[i2] === newline) {
      return { preceding: i2, index: i2 + 1, carriage: false };
    }
    if (buffer[i2] === carriage) {
      return { preceding: i2, index: i2 + 1, carriage: true };
    }
  }
  return null;
}
function findDoubleNewlineIndex(buffer) {
  const newline = 10;
  const carriage = 13;
  for (let i2 = 0; i2 < buffer.length - 1; i2++) {
    if (buffer[i2] === newline && buffer[i2 + 1] === newline) {
      return i2 + 2;
    }
    if (buffer[i2] === carriage && buffer[i2 + 1] === carriage) {
      return i2 + 2;
    }
    if (buffer[i2] === carriage && buffer[i2 + 1] === newline && i2 + 3 < buffer.length && buffer[i2 + 2] === carriage && buffer[i2 + 3] === newline) {
      return i2 + 4;
    }
  }
  return -1;
}

// ../node_modules/@anthropic-ai/sdk/internal/stream-utils.mjs
function ReadableStreamToAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result?.done)
          reader.releaseLock();
        return result;
      } catch (e2) {
        reader.releaseLock();
        throw e2;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}

// ../node_modules/@anthropic-ai/sdk/streaming.mjs
var Stream2 = class _Stream {
  constructor(iterator, controller) {
    this.iterator = iterator;
    this.controller = controller;
  }
  static fromSSEResponse(response, controller) {
    let consumed = false;
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of _iterSSEMessages(response, controller)) {
          if (sse.event === "completion") {
            try {
              yield JSON.parse(sse.data);
            } catch (e2) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e2;
            }
          }
          if (sse.event === "message_start" || sse.event === "message_delta" || sse.event === "message_stop" || sse.event === "content_block_start" || sse.event === "content_block_delta" || sse.event === "content_block_stop") {
            try {
              yield JSON.parse(sse.data);
            } catch (e2) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e2;
            }
          }
          if (sse.event === "ping") {
            continue;
          }
          if (sse.event === "error") {
            throw APIError.generate(void 0, `SSE Error: ${sse.data}`, sse.data, createResponseHeaders(response.headers));
          }
        }
        done = true;
      } catch (e2) {
        if (e2 instanceof Error && e2.name === "AbortError")
          return;
        throw e2;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new _Stream(iterator, controller);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(readableStream, controller) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder();
      const iter = ReadableStreamToAsyncIterable(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done)
            continue;
          if (line)
            yield JSON.parse(line);
        }
        done = true;
      } catch (e2) {
        if (e2 instanceof Error && e2.name === "AbortError")
          return;
        throw e2;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new _Stream(iterator, controller);
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const left = [];
    const right = [];
    const iterator = this.iterator();
    const teeIterator = (queue) => {
      return {
        next: () => {
          if (queue.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue.shift();
        }
      };
    };
    return [
      new _Stream(() => teeIterator(left), this.controller),
      new _Stream(() => teeIterator(right), this.controller)
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const self2 = this;
    let iter;
    const encoder = new TextEncoder();
    return new ReadableStream2({
      async start() {
        iter = self2[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done)
            return ctrl.close();
          const bytes = encoder.encode(JSON.stringify(value) + "\n");
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        await iter.return?.();
      }
    });
  }
};
async function* _iterSSEMessages(response, controller) {
  if (!response.body) {
    controller.abort();
    throw new AnthropicError(`Attempted to iterate over a response with no body`);
  }
  const sseDecoder = new SSEDecoder();
  const lineDecoder = new LineDecoder();
  const iter = ReadableStreamToAsyncIterable(response.body);
  for await (const sseChunk of iterSSEChunks(iter)) {
    for (const line of lineDecoder.decode(sseChunk)) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  for (const line of lineDecoder.flush()) {
    const sse = sseDecoder.decode(line);
    if (sse)
      yield sse;
  }
}
async function* iterSSEChunks(iterator) {
  let data = new Uint8Array();
  for await (const chunk of iterator) {
    if (chunk == null) {
      continue;
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk;
    let newData = new Uint8Array(data.length + binaryChunk.length);
    newData.set(data);
    newData.set(binaryChunk, data.length);
    data = newData;
    let patternIndex;
    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
      yield data.slice(0, patternIndex);
      data = data.slice(patternIndex);
    }
  }
  if (data.length > 0) {
    yield data;
  }
}
var SSEDecoder = class {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _2, value] = partition(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
};
function partition(str, delimiter) {
  const index = str.indexOf(delimiter);
  if (index !== -1) {
    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];
  }
  return [str, "", ""];
}

// ../node_modules/@anthropic-ai/sdk/uploads.mjs
var isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
var isFileLike2 = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
var isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
async function toFile(value, name, options) {
  value = await value;
  if (isFileLike2(value)) {
    return value;
  }
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = new URL(value.url).pathname.split(/[\\/]/).pop() ?? "unknown_file");
    const data = isBlobLike(blob) ? [await blob.arrayBuffer()] : [blob];
    return new File(data, name, options);
  }
  const bits = await getBytes(value);
  name || (name = getName(value) ?? "unknown_file");
  if (!options?.type) {
    const type = bits[0]?.type;
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return new File(bits, name, options);
}
async function getBytes(value) {
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(await value.arrayBuffer());
  } else if (isAsyncIterableIterator(value)) {
    for await (const chunk of value) {
      parts.push(chunk);
    }
  } else {
    throw new Error(`Unexpected data type: ${typeof value}; constructor: ${value?.constructor?.name}; props: ${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  const props = Object.getOwnPropertyNames(value);
  return `[${props.map((p2) => `"${p2}"`).join(", ")}]`;
}
function getName(value) {
  return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || // For fs.ReadStream
  getStringFromMaybeBuffer(value.path)?.split(/[\\/]/).pop();
}
var getStringFromMaybeBuffer = (x2) => {
  if (typeof x2 === "string")
    return x2;
  if (typeof Buffer !== "undefined" && x2 instanceof Buffer)
    return String(x2);
  return void 0;
};
var isAsyncIterableIterator = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
var isMultipartBody = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";

// ../node_modules/@anthropic-ai/sdk/core.mjs
var __classPrivateFieldSet6 = function(receiver, state, value, kind3, f2) {
  if (kind3 === "m") throw new TypeError("Private method is not writable");
  if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind3 === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet7 = function(receiver, state, kind3, f2) {
  if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind3 === "m" ? f2 : kind3 === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _AbstractPage_client;
async function defaultParseResponse(props) {
  const { response } = props;
  if (props.options.stream) {
    debug("response", response.status, response.url, response.headers, response.body);
    if (props.options.__streamClass) {
      return props.options.__streamClass.fromSSEResponse(response, props.controller);
    }
    return Stream2.fromSSEResponse(response, props.controller);
  }
  if (response.status === 204) {
    return null;
  }
  if (props.options.__binaryResponse) {
    return response;
  }
  const contentType = response.headers.get("content-type");
  const isJSON = contentType?.includes("application/json") || contentType?.includes("application/vnd.api+json");
  if (isJSON) {
    const json = await response.json();
    debug("response", response.status, response.url, response.headers, json);
    return _addRequestID(json, response);
  }
  const text = await response.text();
  debug("response", response.status, response.url, response.headers, text);
  return text;
}
function _addRequestID(value, response) {
  if (!value || typeof value !== "object" || Array.isArray(value)) {
    return value;
  }
  return Object.defineProperty(value, "_request_id", {
    value: response.headers.get("request-id"),
    enumerable: false
  });
}
var APIPromise = class _APIPromise extends Promise {
  constructor(responsePromise, parseResponse = defaultParseResponse) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse;
  }
  _thenUnwrap(transform) {
    return new _APIPromise(this.responsePromise, async (props) => _addRequestID(transform(await this.parseResponse(props), props), props.response));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import  from '@anthropic-ai/sdk'`:
   * - `import '@anthropic-ai/sdk/shims/node'` (if you're running on Node)
   * - `import '@anthropic-ai/sdk/shims/web'` (otherwise)
   */
  asResponse() {
    return this.responsePromise.then((p2) => p2.response);
  }
  /**
   * Gets the parsed response data, the raw `Response` instance and the ID of the request,
   * returned vie the `request-id` header which is useful for debugging requests and resporting
   * issues to Anthropic.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import  from '@anthropic-ai/sdk'`:
   * - `import '@anthropic-ai/sdk/shims/node'` (if you're running on Node)
   * - `import '@anthropic-ai/sdk/shims/web'` (otherwise)
   */
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response, request_id: response.headers.get("request-id") };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then(this.parseResponse);
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
};
var APIClient = class {
  constructor({
    baseURL,
    maxRetries = 2,
    timeout = 6e5,
    // 10 minutes
    httpAgent,
    fetch: overriddenFetch
  }) {
    this.baseURL = baseURL;
    this.maxRetries = validatePositiveInteger("maxRetries", maxRetries);
    this.timeout = validatePositiveInteger("timeout", timeout);
    this.httpAgent = httpAgent;
    this.fetch = overriddenFetch ?? fetch2;
  }
  authHeaders(opts) {
    return {};
  }
  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */
  defaultHeaders(opts) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...getPlatformHeaders(),
      ...this.authHeaders(opts)
    };
  }
  /**
   * Override this to add your own headers validation:
   */
  validateHeaders(headers, customHeaders) {
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid4()}`;
  }
  get(path2, opts) {
    return this.methodRequest("get", path2, opts);
  }
  post(path2, opts) {
    return this.methodRequest("post", path2, opts);
  }
  patch(path2, opts) {
    return this.methodRequest("patch", path2, opts);
  }
  put(path2, opts) {
    return this.methodRequest("put", path2, opts);
  }
  delete(path2, opts) {
    return this.methodRequest("delete", path2, opts);
  }
  methodRequest(method, path2, opts) {
    return this.request(Promise.resolve(opts).then(async (opts2) => {
      const body = opts2 && isBlobLike(opts2?.body) ? new DataView(await opts2.body.arrayBuffer()) : opts2?.body instanceof DataView ? opts2.body : opts2?.body instanceof ArrayBuffer ? new DataView(opts2.body) : opts2 && ArrayBuffer.isView(opts2?.body) ? new DataView(opts2.body.buffer) : opts2?.body;
      return { method, path: path2, ...opts2, body };
    }));
  }
  getAPIList(path2, Page2, opts) {
    return this.requestAPIList(Page2, { method: "get", path: path2, ...opts });
  }
  calculateContentLength(body) {
    if (typeof body === "string") {
      if (typeof Buffer !== "undefined") {
        return Buffer.byteLength(body, "utf8").toString();
      }
      if (typeof TextEncoder !== "undefined") {
        const encoder = new TextEncoder();
        const encoded = encoder.encode(body);
        return encoded.length.toString();
      }
    } else if (ArrayBuffer.isView(body)) {
      return body.byteLength.toString();
    }
    return null;
  }
  buildRequest(options, { retryCount = 0 } = {}) {
    options = { ...options };
    const { method, path: path2, query, headers = {} } = options;
    const body = ArrayBuffer.isView(options.body) || options.__binaryRequest && typeof options.body === "string" ? options.body : isMultipartBody(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
    const contentLength = this.calculateContentLength(body);
    const url = this.buildURL(path2, query);
    if ("timeout" in options)
      validatePositiveInteger("timeout", options.timeout);
    options.timeout = options.timeout ?? this.timeout;
    const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent(url);
    const minAgentTimeout = options.timeout + 1e3;
    if (typeof httpAgent?.options?.timeout === "number" && minAgentTimeout > (httpAgent.options.timeout ?? 0)) {
      httpAgent.options.timeout = minAgentTimeout;
    }
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      headers[this.idempotencyHeader] = options.idempotencyKey;
    }
    const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });
    const req = {
      method,
      ...body && { body },
      headers: reqHeaders,
      ...httpAgent && { agent: httpAgent },
      // @ts-ignore node-fetch uses a custom AbortSignal type that is
      // not compatible with standard web types
      signal: options.signal ?? null
    };
    return { req, url, timeout: options.timeout };
  }
  buildHeaders({ options, headers, contentLength, retryCount }) {
    const reqHeaders = {};
    if (contentLength) {
      reqHeaders["content-length"] = contentLength;
    }
    const defaultHeaders = this.defaultHeaders(options);
    applyHeadersMut(reqHeaders, defaultHeaders);
    applyHeadersMut(reqHeaders, headers);
    if (isMultipartBody(options.body) && kind !== "node") {
      delete reqHeaders["content-type"];
    }
    if (getHeader(defaultHeaders, "x-stainless-retry-count") === void 0 && getHeader(headers, "x-stainless-retry-count") === void 0) {
      reqHeaders["x-stainless-retry-count"] = String(retryCount);
    }
    if (getHeader(defaultHeaders, "x-stainless-timeout") === void 0 && getHeader(headers, "x-stainless-timeout") === void 0 && options.timeout) {
      reqHeaders["x-stainless-timeout"] = String(options.timeout);
    }
    this.validateHeaders(reqHeaders, headers);
    return reqHeaders;
  }
  _calculateNonstreamingTimeout(maxTokens) {
    const defaultTimeout = 10 * 60;
    const expectedTimeout = 60 * 60 * maxTokens / 128e3;
    if (expectedTimeout > defaultTimeout) {
      throw new AnthropicError("Streaming is strongly recommended for operations that may take longer than 10 minutes. See https://github.com/anthropics/anthropic-sdk-python#streaming-responses for more details");
    }
    return defaultTimeout * 1e3;
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(options) {
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(request, { url, options }) {
  }
  parseHeaders(headers) {
    return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
  }
  makeStatusError(status, error, message, headers) {
    return APIError.generate(status, error, message, headers);
  }
  request(options, remainingRetries = null) {
    return new APIPromise(this.makeRequest(options, remainingRetries));
  }
  async makeRequest(optionsInput, retriesRemaining) {
    const options = await optionsInput;
    const maxRetries = options.maxRetries ?? this.maxRetries;
    if (retriesRemaining == null) {
      retriesRemaining = maxRetries;
    }
    await this.prepareOptions(options);
    const { req, url, timeout } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });
    await this.prepareRequest(req, { url, options });
    debug("request", url, options, req.headers);
    if (options.signal?.aborted) {
      throw new APIUserAbortError();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
    if (response instanceof Error) {
      if (options.signal?.aborted) {
        throw new APIUserAbortError();
      }
      if (retriesRemaining) {
        return this.retryRequest(options, retriesRemaining);
      }
      if (response.name === "AbortError") {
        throw new APIConnectionTimeoutError();
      }
      throw new APIConnectionError({ cause: response });
    }
    const responseHeaders = createResponseHeaders(response.headers);
    if (!response.ok) {
      if (retriesRemaining && this.shouldRetry(response)) {
        const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
        debug(`response (error; ${retryMessage2})`, response.status, url, responseHeaders);
        return this.retryRequest(options, retriesRemaining, responseHeaders);
      }
      const errText = await response.text().catch((e2) => castToError(e2).message);
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? void 0 : errText;
      const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;
      debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);
      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
      throw err;
    }
    return { response, options, controller };
  }
  requestAPIList(Page2, options) {
    const request = this.makeRequest(options, null);
    return new PagePromise(this, request, Page2);
  }
  buildURL(path2, query) {
    const url = isAbsoluteURL(path2) ? new URL(path2) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path2.startsWith("/") ? path2.slice(1) : path2));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  stringifyQuery(query) {
    return Object.entries(query).filter(([_2, value]) => typeof value !== "undefined").map(([key, value]) => {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      }
      if (value === null) {
        return `${encodeURIComponent(key)}=`;
      }
      throw new AnthropicError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  async fetchWithTimeout(url, init, ms, controller) {
    const { signal, ...options } = init || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    const fetchOptions = {
      signal: controller.signal,
      ...options
    };
    if (fetchOptions.method) {
      fetchOptions.method = fetchOptions.method.toUpperCase();
    }
    const socketKeepAliveInterval = 60 * 1e3;
    const keepAliveTimeout = setTimeout(() => {
      if (fetchOptions && fetchOptions?.agent?.sockets) {
        for (const socket of Object.values(fetchOptions?.agent?.sockets).flat()) {
          if (socket?.setKeepAlive) {
            socket.setKeepAlive(true, socketKeepAliveInterval);
          }
        }
      }
    }, socketKeepAliveInterval);
    return (
      // use undefined this binding; fetch errors if bound to something else in browser/cloudflare
      this.fetch.call(void 0, url, fetchOptions).finally(() => {
        clearTimeout(timeout);
        clearTimeout(keepAliveTimeout);
      })
    );
  }
  shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, responseHeaders) {
    let timeoutMillis;
    const retryAfterMillisHeader = responseHeaders?.["retry-after-ms"];
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }
    const retryAfterHeader = responseHeaders?.["retry-after"];
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1e3;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
      const maxRetries = options.maxRetries ?? this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1e3;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION}`;
  }
};
var AbstractPage = class {
  constructor(client, response, body, options) {
    _AbstractPage_client.set(this, void 0);
    __classPrivateFieldSet6(this, _AbstractPage_client, client, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageInfo() != null;
  }
  async getNextPage() {
    const nextInfo = this.nextPageInfo();
    if (!nextInfo) {
      throw new AnthropicError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    }
    const nextOptions = { ...this.options };
    if ("params" in nextInfo && typeof nextOptions.query === "object") {
      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
    } else if ("url" in nextInfo) {
      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
      for (const [key, value] of params) {
        nextInfo.url.searchParams.set(key, value);
      }
      nextOptions.query = void 0;
      nextOptions.path = nextInfo.url.toString();
    }
    return await __classPrivateFieldGet7(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
};
var PagePromise = class extends APIPromise {
  constructor(client, request, Page2) {
    super(request, async (props) => new Page2(client, props.response, await defaultParseResponse(props), props.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
};
var createResponseHeaders = (headers) => {
  return new Proxy(Object.fromEntries(
    // @ts-ignore
    headers.entries()
  ), {
    get(target, name) {
      const key = name.toString();
      return target[key.toLowerCase()] || target[key];
    }
  });
};
var requestOptionsKeys = {
  method: true,
  path: true,
  query: true,
  body: true,
  headers: true,
  maxRetries: true,
  stream: true,
  timeout: true,
  httpAgent: true,
  signal: true,
  idempotencyKey: true,
  __binaryRequest: true,
  __binaryResponse: true,
  __streamClass: true
};
var isRequestOptions = (obj) => {
  return typeof obj === "object" && obj !== null && !isEmptyObj(obj) && Object.keys(obj).every((k2) => hasOwn(requestOptionsKeys, k2));
};
var getPlatformProperties = () => {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : Deno.version?.deno ?? "unknown"
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(process.platform),
      "X-Stainless-Arch": normalizeArch(process.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match7 = pattern.exec(navigator.userAgent);
    if (match7) {
      const major = match7[1] || 0;
      const minor = match7[2] || 0;
      const patch = match7[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
var normalizePlatform = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
};
var _platformHeaders;
var getPlatformHeaders = () => {
  return _platformHeaders ?? (_platformHeaders = getPlatformProperties());
};
var safeJSON = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};
var startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
var isAbsoluteURL = (url) => {
  return startsWithSchemeRegexp.test(url);
};
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var validatePositiveInteger = (name, n2) => {
  if (typeof n2 !== "number" || !Number.isInteger(n2)) {
    throw new AnthropicError(`${name} must be an integer`);
  }
  if (n2 < 0) {
    throw new AnthropicError(`${name} must be a positive integer`);
  }
  return n2;
};
var castToError = (err) => {
  if (err instanceof Error)
    return err;
  if (typeof err === "object" && err !== null) {
    try {
      return new Error(JSON.stringify(err));
    } catch {
    }
  }
  return new Error(String(err));
};
var readEnv = (env) => {
  if (typeof process !== "undefined") {
    return process.env?.[env]?.trim() ?? void 0;
  }
  if (typeof Deno !== "undefined") {
    return Deno.env?.get?.(env)?.trim();
  }
  return void 0;
};
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function applyHeadersMut(targetHeaders, newHeaders) {
  for (const k2 in newHeaders) {
    if (!hasOwn(newHeaders, k2))
      continue;
    const lowerKey = k2.toLowerCase();
    if (!lowerKey)
      continue;
    const val = newHeaders[k2];
    if (val === null) {
      delete targetHeaders[lowerKey];
    } else if (val !== void 0) {
      targetHeaders[lowerKey] = val;
    }
  }
}
function debug(action, ...args) {
  if (typeof process !== "undefined" && process?.env?.["DEBUG"] === "true") {
    console.log(`Anthropic:DEBUG:${action}`, ...args);
  }
}
var uuid4 = () => {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c2) => {
    const r2 = Math.random() * 16 | 0;
    const v2 = c2 === "x" ? r2 : r2 & 3 | 8;
    return v2.toString(16);
  });
};
var isRunningInBrowser = () => {
  return (
    // @ts-ignore
    typeof window !== "undefined" && // @ts-ignore
    typeof window.document !== "undefined" && // @ts-ignore
    typeof navigator !== "undefined"
  );
};
var isHeadersProtocol = (headers) => {
  return typeof headers?.get === "function";
};
var getHeader = (headers, header) => {
  const lowerCasedHeader = header.toLowerCase();
  if (isHeadersProtocol(headers)) {
    const intercapsHeader = header[0]?.toUpperCase() + header.substring(1).replace(/([^\w])(\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());
    for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {
      const value = headers.get(key);
      if (value) {
        return value;
      }
    }
  }
  for (const [key, value] of Object.entries(headers)) {
    if (key.toLowerCase() === lowerCasedHeader) {
      if (Array.isArray(value)) {
        if (value.length <= 1)
          return value[0];
        console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);
        return value[0];
      }
      return value;
    }
  }
  return void 0;
};

// ../node_modules/@anthropic-ai/sdk/pagination.mjs
var Page = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.has_more = body.has_more || false;
    this.first_id = body.first_id || null;
    this.last_id = body.last_id || null;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    if (this.has_more === false) {
      return false;
    }
    return super.hasNextPage();
  }
  // @deprecated Please use `nextPageInfo()` instead
  nextPageParams() {
    const info = this.nextPageInfo();
    if (!info)
      return null;
    if ("params" in info)
      return info.params;
    const params = Object.fromEntries(info.url.searchParams);
    if (!Object.keys(params).length)
      return null;
    return params;
  }
  nextPageInfo() {
    if (this.options.query?.["before_id"]) {
      const firstId = this.first_id;
      if (!firstId) {
        return null;
      }
      return {
        params: {
          before_id: firstId
        }
      };
    }
    const cursor = this.last_id;
    if (!cursor) {
      return null;
    }
    return {
      params: {
        after_id: cursor
      }
    };
  }
};

// ../node_modules/@anthropic-ai/sdk/resource.mjs
var APIResource = class {
  constructor(client) {
    this._client = client;
  }
};

// ../node_modules/@anthropic-ai/sdk/resources/beta/models.mjs
var Models = class extends APIResource {
  /**
   * Get a specific model.
   *
   * The Models API response can be used to determine information about a specific
   * model or resolve a model alias to a model ID.
   */
  retrieve(modelId, options) {
    return this._client.get(`/v1/models/${modelId}?beta=true`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/v1/models?beta=true", BetaModelInfosPage, { query, ...options });
  }
};
var BetaModelInfosPage = class extends Page {
};
Models.BetaModelInfosPage = BetaModelInfosPage;

// ../node_modules/@anthropic-ai/sdk/internal/decoders/jsonl.mjs
var JSONLDecoder = class _JSONLDecoder {
  constructor(iterator, controller) {
    this.iterator = iterator;
    this.controller = controller;
  }
  async *decoder() {
    const lineDecoder = new LineDecoder();
    for await (const chunk of this.iterator) {
      for (const line of lineDecoder.decode(chunk)) {
        yield JSON.parse(line);
      }
    }
    for (const line of lineDecoder.flush()) {
      yield JSON.parse(line);
    }
  }
  [Symbol.asyncIterator]() {
    return this.decoder();
  }
  static fromResponse(response, controller) {
    if (!response.body) {
      controller.abort();
      throw new AnthropicError(`Attempted to iterate over a response with no body`);
    }
    return new _JSONLDecoder(ReadableStreamToAsyncIterable(response.body), controller);
  }
};

// ../node_modules/@anthropic-ai/sdk/resources/beta/messages/batches.mjs
var Batches = class extends APIResource {
  /**
   * Send a batch of Message creation requests.
   *
   * The Message Batches API can be used to process multiple Messages API requests at
   * once. Once a Message Batch is created, it begins processing immediately. Batches
   * can take up to 24 hours to complete.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   */
  create(params, options) {
    const { betas, ...body } = params;
    return this._client.post("/v1/messages/batches?beta=true", {
      body,
      ...options,
      headers: {
        "anthropic-beta": [...betas ?? [], "message-batches-2024-09-24"].toString(),
        ...options?.headers
      }
    });
  }
  retrieve(messageBatchId, params = {}, options) {
    if (isRequestOptions(params)) {
      return this.retrieve(messageBatchId, {}, params);
    }
    const { betas } = params;
    return this._client.get(`/v1/messages/batches/${messageBatchId}?beta=true`, {
      ...options,
      headers: {
        "anthropic-beta": [...betas ?? [], "message-batches-2024-09-24"].toString(),
        ...options?.headers
      }
    });
  }
  list(params = {}, options) {
    if (isRequestOptions(params)) {
      return this.list({}, params);
    }
    const { betas, ...query } = params;
    return this._client.getAPIList("/v1/messages/batches?beta=true", BetaMessageBatchesPage, {
      query,
      ...options,
      headers: {
        "anthropic-beta": [...betas ?? [], "message-batches-2024-09-24"].toString(),
        ...options?.headers
      }
    });
  }
  delete(messageBatchId, params = {}, options) {
    if (isRequestOptions(params)) {
      return this.delete(messageBatchId, {}, params);
    }
    const { betas } = params;
    return this._client.delete(`/v1/messages/batches/${messageBatchId}?beta=true`, {
      ...options,
      headers: {
        "anthropic-beta": [...betas ?? [], "message-batches-2024-09-24"].toString(),
        ...options?.headers
      }
    });
  }
  cancel(messageBatchId, params = {}, options) {
    if (isRequestOptions(params)) {
      return this.cancel(messageBatchId, {}, params);
    }
    const { betas } = params;
    return this._client.post(`/v1/messages/batches/${messageBatchId}/cancel?beta=true`, {
      ...options,
      headers: {
        "anthropic-beta": [...betas ?? [], "message-batches-2024-09-24"].toString(),
        ...options?.headers
      }
    });
  }
  async results(messageBatchId, params = {}, options) {
    if (isRequestOptions(params)) {
      return this.results(messageBatchId, {}, params);
    }
    const batch = await this.retrieve(messageBatchId);
    if (!batch.results_url) {
      throw new AnthropicError(`No batch \`results_url\`; Has it finished processing? ${batch.processing_status} - ${batch.id}`);
    }
    const { betas } = params;
    return this._client.get(batch.results_url, {
      ...options,
      headers: {
        "anthropic-beta": [...betas ?? [], "message-batches-2024-09-24"].toString(),
        Accept: "application/binary",
        ...options?.headers
      },
      __binaryResponse: true
    })._thenUnwrap((_2, props) => JSONLDecoder.fromResponse(props.response, props.controller));
  }
};
var BetaMessageBatchesPage = class extends Page {
};
Batches.BetaMessageBatchesPage = BetaMessageBatchesPage;

// ../node_modules/@anthropic-ai/sdk/_vendor/partial-json-parser/parser.mjs
var tokenize = (input) => {
  let current = 0;
  let tokens = [];
  while (current < input.length) {
    let char = input[current];
    if (char === "\\") {
      current++;
      continue;
    }
    if (char === "{") {
      tokens.push({
        type: "brace",
        value: "{"
      });
      current++;
      continue;
    }
    if (char === "}") {
      tokens.push({
        type: "brace",
        value: "}"
      });
      current++;
      continue;
    }
    if (char === "[") {
      tokens.push({
        type: "paren",
        value: "["
      });
      current++;
      continue;
    }
    if (char === "]") {
      tokens.push({
        type: "paren",
        value: "]"
      });
      current++;
      continue;
    }
    if (char === ":") {
      tokens.push({
        type: "separator",
        value: ":"
      });
      current++;
      continue;
    }
    if (char === ",") {
      tokens.push({
        type: "delimiter",
        value: ","
      });
      current++;
      continue;
    }
    if (char === '"') {
      let value = "";
      let danglingQuote = false;
      char = input[++current];
      while (char !== '"') {
        if (current === input.length) {
          danglingQuote = true;
          break;
        }
        if (char === "\\") {
          current++;
          if (current === input.length) {
            danglingQuote = true;
            break;
          }
          value += char + input[current];
          char = input[++current];
        } else {
          value += char;
          char = input[++current];
        }
      }
      char = input[++current];
      if (!danglingQuote) {
        tokens.push({
          type: "string",
          value
        });
      }
      continue;
    }
    let WHITESPACE = /\s/;
    if (char && WHITESPACE.test(char)) {
      current++;
      continue;
    }
    let NUMBERS = /[0-9]/;
    if (char && NUMBERS.test(char) || char === "-" || char === ".") {
      let value = "";
      if (char === "-") {
        value += char;
        char = input[++current];
      }
      while (char && NUMBERS.test(char) || char === ".") {
        value += char;
        char = input[++current];
      }
      tokens.push({
        type: "number",
        value
      });
      continue;
    }
    let LETTERS = /[a-z]/i;
    if (char && LETTERS.test(char)) {
      let value = "";
      while (char && LETTERS.test(char)) {
        if (current === input.length) {
          break;
        }
        value += char;
        char = input[++current];
      }
      if (value == "true" || value == "false" || value === "null") {
        tokens.push({
          type: "name",
          value
        });
      } else {
        current++;
        continue;
      }
      continue;
    }
    current++;
  }
  return tokens;
};
var strip = (tokens) => {
  if (tokens.length === 0) {
    return tokens;
  }
  let lastToken = tokens[tokens.length - 1];
  switch (lastToken.type) {
    case "separator":
      tokens = tokens.slice(0, tokens.length - 1);
      return strip(tokens);
      break;
    case "number":
      let lastCharacterOfLastToken = lastToken.value[lastToken.value.length - 1];
      if (lastCharacterOfLastToken === "." || lastCharacterOfLastToken === "-") {
        tokens = tokens.slice(0, tokens.length - 1);
        return strip(tokens);
      }
    case "string":
      let tokenBeforeTheLastToken = tokens[tokens.length - 2];
      if (tokenBeforeTheLastToken?.type === "delimiter") {
        tokens = tokens.slice(0, tokens.length - 1);
        return strip(tokens);
      } else if (tokenBeforeTheLastToken?.type === "brace" && tokenBeforeTheLastToken.value === "{") {
        tokens = tokens.slice(0, tokens.length - 1);
        return strip(tokens);
      }
      break;
    case "delimiter":
      tokens = tokens.slice(0, tokens.length - 1);
      return strip(tokens);
      break;
  }
  return tokens;
};
var unstrip = (tokens) => {
  let tail = [];
  tokens.map((token) => {
    if (token.type === "brace") {
      if (token.value === "{") {
        tail.push("}");
      } else {
        tail.splice(tail.lastIndexOf("}"), 1);
      }
    }
    if (token.type === "paren") {
      if (token.value === "[") {
        tail.push("]");
      } else {
        tail.splice(tail.lastIndexOf("]"), 1);
      }
    }
  });
  if (tail.length > 0) {
    tail.reverse().map((item) => {
      if (item === "}") {
        tokens.push({
          type: "brace",
          value: "}"
        });
      } else if (item === "]") {
        tokens.push({
          type: "paren",
          value: "]"
        });
      }
    });
  }
  return tokens;
};
var generate = (tokens) => {
  let output = "";
  tokens.map((token) => {
    switch (token.type) {
      case "string":
        output += '"' + token.value + '"';
        break;
      default:
        output += token.value;
        break;
    }
  });
  return output;
};
var partialParse = (input) => JSON.parse(generate(unstrip(strip(tokenize(input)))));

// ../node_modules/@anthropic-ai/sdk/lib/BetaMessageStream.mjs
var __classPrivateFieldSet7 = function(receiver, state, value, kind3, f2) {
  if (kind3 === "m") throw new TypeError("Private method is not writable");
  if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind3 === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet8 = function(receiver, state, kind3, f2) {
  if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind3 === "m" ? f2 : kind3 === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _BetaMessageStream_instances;
var _BetaMessageStream_currentMessageSnapshot;
var _BetaMessageStream_connectedPromise;
var _BetaMessageStream_resolveConnectedPromise;
var _BetaMessageStream_rejectConnectedPromise;
var _BetaMessageStream_endPromise;
var _BetaMessageStream_resolveEndPromise;
var _BetaMessageStream_rejectEndPromise;
var _BetaMessageStream_listeners;
var _BetaMessageStream_ended;
var _BetaMessageStream_errored;
var _BetaMessageStream_aborted;
var _BetaMessageStream_catchingPromiseCreated;
var _BetaMessageStream_response;
var _BetaMessageStream_request_id;
var _BetaMessageStream_getFinalMessage;
var _BetaMessageStream_getFinalText;
var _BetaMessageStream_handleError;
var _BetaMessageStream_beginRequest;
var _BetaMessageStream_addStreamEvent;
var _BetaMessageStream_endRequest;
var _BetaMessageStream_accumulateMessage;
var JSON_BUF_PROPERTY = "__json_buf";
var BetaMessageStream = class _BetaMessageStream {
  constructor() {
    _BetaMessageStream_instances.add(this);
    this.messages = [];
    this.receivedMessages = [];
    _BetaMessageStream_currentMessageSnapshot.set(this, void 0);
    this.controller = new AbortController();
    _BetaMessageStream_connectedPromise.set(this, void 0);
    _BetaMessageStream_resolveConnectedPromise.set(this, () => {
    });
    _BetaMessageStream_rejectConnectedPromise.set(this, () => {
    });
    _BetaMessageStream_endPromise.set(this, void 0);
    _BetaMessageStream_resolveEndPromise.set(this, () => {
    });
    _BetaMessageStream_rejectEndPromise.set(this, () => {
    });
    _BetaMessageStream_listeners.set(this, {});
    _BetaMessageStream_ended.set(this, false);
    _BetaMessageStream_errored.set(this, false);
    _BetaMessageStream_aborted.set(this, false);
    _BetaMessageStream_catchingPromiseCreated.set(this, false);
    _BetaMessageStream_response.set(this, void 0);
    _BetaMessageStream_request_id.set(this, void 0);
    _BetaMessageStream_handleError.set(this, (error) => {
      __classPrivateFieldSet7(this, _BetaMessageStream_errored, true, "f");
      if (error instanceof Error && error.name === "AbortError") {
        error = new APIUserAbortError();
      }
      if (error instanceof APIUserAbortError) {
        __classPrivateFieldSet7(this, _BetaMessageStream_aborted, true, "f");
        return this._emit("abort", error);
      }
      if (error instanceof AnthropicError) {
        return this._emit("error", error);
      }
      if (error instanceof Error) {
        const anthropicError = new AnthropicError(error.message);
        anthropicError.cause = error;
        return this._emit("error", anthropicError);
      }
      return this._emit("error", new AnthropicError(String(error)));
    });
    __classPrivateFieldSet7(this, _BetaMessageStream_connectedPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet7(this, _BetaMessageStream_resolveConnectedPromise, resolve, "f");
      __classPrivateFieldSet7(this, _BetaMessageStream_rejectConnectedPromise, reject, "f");
    }), "f");
    __classPrivateFieldSet7(this, _BetaMessageStream_endPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet7(this, _BetaMessageStream_resolveEndPromise, resolve, "f");
      __classPrivateFieldSet7(this, _BetaMessageStream_rejectEndPromise, reject, "f");
    }), "f");
    __classPrivateFieldGet8(this, _BetaMessageStream_connectedPromise, "f").catch(() => {
    });
    __classPrivateFieldGet8(this, _BetaMessageStream_endPromise, "f").catch(() => {
    });
  }
  get response() {
    return __classPrivateFieldGet8(this, _BetaMessageStream_response, "f");
  }
  get request_id() {
    return __classPrivateFieldGet8(this, _BetaMessageStream_request_id, "f");
  }
  /**
   * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,
   * returned vie the `request-id` header which is useful for debugging requests and resporting
   * issues to Anthropic.
   *
   * This is the same as the `APIPromise.withResponse()` method.
   *
   * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`
   * as no `Response` is available.
   */
  async withResponse() {
    const response = await __classPrivateFieldGet8(this, _BetaMessageStream_connectedPromise, "f");
    if (!response) {
      throw new Error("Could not resolve a `Response` object");
    }
    return {
      data: this,
      response,
      request_id: response.headers.get("request-id")
    };
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(stream) {
    const runner = new _BetaMessageStream();
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static createMessage(messages, params, options) {
    const runner = new _BetaMessageStream();
    for (const message of params.messages) {
      runner._addMessageParam(message);
    }
    runner._run(() => runner._createMessage(messages, { ...params, stream: true }, { ...options, headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" } }));
    return runner;
  }
  _run(executor) {
    executor().then(() => {
      this._emitFinal();
      this._emit("end");
    }, __classPrivateFieldGet8(this, _BetaMessageStream_handleError, "f"));
  }
  _addMessageParam(message) {
    this.messages.push(message);
  }
  _addMessage(message, emit = true) {
    this.receivedMessages.push(message);
    if (emit) {
      this._emit("message", message);
    }
  }
  async _createMessage(messages, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet8(this, _BetaMessageStream_instances, "m", _BetaMessageStream_beginRequest).call(this);
    const { response, data: stream } = await messages.create({ ...params, stream: true }, { ...options, signal: this.controller.signal }).withResponse();
    this._connected(response);
    for await (const event of stream) {
      __classPrivateFieldGet8(this, _BetaMessageStream_instances, "m", _BetaMessageStream_addStreamEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    __classPrivateFieldGet8(this, _BetaMessageStream_instances, "m", _BetaMessageStream_endRequest).call(this);
  }
  _connected(response) {
    if (this.ended)
      return;
    __classPrivateFieldSet7(this, _BetaMessageStream_response, response, "f");
    __classPrivateFieldSet7(this, _BetaMessageStream_request_id, response?.headers.get("request-id"), "f");
    __classPrivateFieldGet8(this, _BetaMessageStream_resolveConnectedPromise, "f").call(this, response);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet8(this, _BetaMessageStream_ended, "f");
  }
  get errored() {
    return __classPrivateFieldGet8(this, _BetaMessageStream_errored, "f");
  }
  get aborted() {
    return __classPrivateFieldGet8(this, _BetaMessageStream_aborted, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this MessageStream, so that calls can be chained
   */
  on(event, listener) {
    const listeners = __classPrivateFieldGet8(this, _BetaMessageStream_listeners, "f")[event] || (__classPrivateFieldGet8(this, _BetaMessageStream_listeners, "f")[event] = []);
    listeners.push({ listener });
    return this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this MessageStream, so that calls can be chained
   */
  off(event, listener) {
    const listeners = __classPrivateFieldGet8(this, _BetaMessageStream_listeners, "f")[event];
    if (!listeners)
      return this;
    const index = listeners.findIndex((l2) => l2.listener === listener);
    if (index >= 0)
      listeners.splice(index, 1);
    return this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this MessageStream, so that calls can be chained
   */
  once(event, listener) {
    const listeners = __classPrivateFieldGet8(this, _BetaMessageStream_listeners, "f")[event] || (__classPrivateFieldGet8(this, _BetaMessageStream_listeners, "f")[event] = []);
    listeners.push({ listener, once: true });
    return this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(event) {
    return new Promise((resolve, reject) => {
      __classPrivateFieldSet7(this, _BetaMessageStream_catchingPromiseCreated, true, "f");
      if (event !== "error")
        this.once("error", reject);
      this.once(event, resolve);
    });
  }
  async done() {
    __classPrivateFieldSet7(this, _BetaMessageStream_catchingPromiseCreated, true, "f");
    await __classPrivateFieldGet8(this, _BetaMessageStream_endPromise, "f");
  }
  get currentMessage() {
    return __classPrivateFieldGet8(this, _BetaMessageStream_currentMessageSnapshot, "f");
  }
  /**
   * @returns a promise that resolves with the the final assistant Message response,
   * or rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
  async finalMessage() {
    await this.done();
    return __classPrivateFieldGet8(this, _BetaMessageStream_instances, "m", _BetaMessageStream_getFinalMessage).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant Message's text response, concatenated
   * together if there are more than one text blocks.
   * Rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
  async finalText() {
    await this.done();
    return __classPrivateFieldGet8(this, _BetaMessageStream_instances, "m", _BetaMessageStream_getFinalText).call(this);
  }
  _emit(event, ...args) {
    if (__classPrivateFieldGet8(this, _BetaMessageStream_ended, "f"))
      return;
    if (event === "end") {
      __classPrivateFieldSet7(this, _BetaMessageStream_ended, true, "f");
      __classPrivateFieldGet8(this, _BetaMessageStream_resolveEndPromise, "f").call(this);
    }
    const listeners = __classPrivateFieldGet8(this, _BetaMessageStream_listeners, "f")[event];
    if (listeners) {
      __classPrivateFieldGet8(this, _BetaMessageStream_listeners, "f")[event] = listeners.filter((l2) => !l2.once);
      listeners.forEach(({ listener }) => listener(...args));
    }
    if (event === "abort") {
      const error = args[0];
      if (!__classPrivateFieldGet8(this, _BetaMessageStream_catchingPromiseCreated, "f") && !listeners?.length) {
        Promise.reject(error);
      }
      __classPrivateFieldGet8(this, _BetaMessageStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet8(this, _BetaMessageStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error = args[0];
      if (!__classPrivateFieldGet8(this, _BetaMessageStream_catchingPromiseCreated, "f") && !listeners?.length) {
        Promise.reject(error);
      }
      __classPrivateFieldGet8(this, _BetaMessageStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet8(this, _BetaMessageStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
    }
  }
  _emitFinal() {
    const finalMessage = this.receivedMessages.at(-1);
    if (finalMessage) {
      this._emit("finalMessage", __classPrivateFieldGet8(this, _BetaMessageStream_instances, "m", _BetaMessageStream_getFinalMessage).call(this));
    }
  }
  async _fromReadableStream(readableStream, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet8(this, _BetaMessageStream_instances, "m", _BetaMessageStream_beginRequest).call(this);
    this._connected(null);
    const stream = Stream2.fromReadableStream(readableStream, this.controller);
    for await (const event of stream) {
      __classPrivateFieldGet8(this, _BetaMessageStream_instances, "m", _BetaMessageStream_addStreamEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    __classPrivateFieldGet8(this, _BetaMessageStream_instances, "m", _BetaMessageStream_endRequest).call(this);
  }
  [(_BetaMessageStream_currentMessageSnapshot = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_endPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_listeners = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_ended = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_errored = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_aborted = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_response = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_request_id = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_handleError = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_instances = /* @__PURE__ */ new WeakSet(), _BetaMessageStream_getFinalMessage = function _BetaMessageStream_getFinalMessage2() {
    if (this.receivedMessages.length === 0) {
      throw new AnthropicError("stream ended without producing a Message with role=assistant");
    }
    return this.receivedMessages.at(-1);
  }, _BetaMessageStream_getFinalText = function _BetaMessageStream_getFinalText2() {
    if (this.receivedMessages.length === 0) {
      throw new AnthropicError("stream ended without producing a Message with role=assistant");
    }
    const textBlocks = this.receivedMessages.at(-1).content.filter((block) => block.type === "text").map((block) => block.text);
    if (textBlocks.length === 0) {
      throw new AnthropicError("stream ended without producing a content block with type=text");
    }
    return textBlocks.join(" ");
  }, _BetaMessageStream_beginRequest = function _BetaMessageStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet7(this, _BetaMessageStream_currentMessageSnapshot, void 0, "f");
  }, _BetaMessageStream_addStreamEvent = function _BetaMessageStream_addStreamEvent2(event) {
    if (this.ended)
      return;
    const messageSnapshot = __classPrivateFieldGet8(this, _BetaMessageStream_instances, "m", _BetaMessageStream_accumulateMessage).call(this, event);
    this._emit("streamEvent", event, messageSnapshot);
    switch (event.type) {
      case "content_block_delta": {
        const content = messageSnapshot.content.at(-1);
        switch (event.delta.type) {
          case "text_delta": {
            if (content.type === "text") {
              this._emit("text", event.delta.text, content.text || "");
            }
            break;
          }
          case "citations_delta": {
            if (content.type === "text") {
              this._emit("citation", event.delta.citation, content.citations ?? []);
            }
            break;
          }
          case "input_json_delta": {
            if (content.type === "tool_use" && content.input) {
              this._emit("inputJson", event.delta.partial_json, content.input);
            }
            break;
          }
          case "thinking_delta": {
            if (content.type === "thinking") {
              this._emit("thinking", event.delta.thinking, content.thinking);
            }
            break;
          }
          case "signature_delta": {
            if (content.type === "thinking") {
              this._emit("signature", content.signature);
            }
            break;
          }
          default:
            checkNever(event.delta);
        }
        break;
      }
      case "message_stop": {
        this._addMessageParam(messageSnapshot);
        this._addMessage(messageSnapshot, true);
        break;
      }
      case "content_block_stop": {
        this._emit("contentBlock", messageSnapshot.content.at(-1));
        break;
      }
      case "message_start": {
        __classPrivateFieldSet7(this, _BetaMessageStream_currentMessageSnapshot, messageSnapshot, "f");
        break;
      }
      case "content_block_start":
      case "message_delta":
        break;
    }
  }, _BetaMessageStream_endRequest = function _BetaMessageStream_endRequest2() {
    if (this.ended) {
      throw new AnthropicError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet8(this, _BetaMessageStream_currentMessageSnapshot, "f");
    if (!snapshot) {
      throw new AnthropicError(`request ended without sending any chunks`);
    }
    __classPrivateFieldSet7(this, _BetaMessageStream_currentMessageSnapshot, void 0, "f");
    return snapshot;
  }, _BetaMessageStream_accumulateMessage = function _BetaMessageStream_accumulateMessage2(event) {
    let snapshot = __classPrivateFieldGet8(this, _BetaMessageStream_currentMessageSnapshot, "f");
    if (event.type === "message_start") {
      if (snapshot) {
        throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving "message_stop"`);
      }
      return event.message;
    }
    if (!snapshot) {
      throw new AnthropicError(`Unexpected event order, got ${event.type} before "message_start"`);
    }
    switch (event.type) {
      case "message_stop":
        return snapshot;
      case "message_delta":
        snapshot.stop_reason = event.delta.stop_reason;
        snapshot.stop_sequence = event.delta.stop_sequence;
        snapshot.usage.output_tokens = event.usage.output_tokens;
        return snapshot;
      case "content_block_start":
        snapshot.content.push(event.content_block);
        return snapshot;
      case "content_block_delta": {
        const snapshotContent = snapshot.content.at(event.index);
        switch (event.delta.type) {
          case "text_delta": {
            if (snapshotContent?.type === "text") {
              snapshotContent.text += event.delta.text;
            }
            break;
          }
          case "citations_delta": {
            if (snapshotContent?.type === "text") {
              snapshotContent.citations ?? (snapshotContent.citations = []);
              snapshotContent.citations.push(event.delta.citation);
            }
            break;
          }
          case "input_json_delta": {
            if (snapshotContent?.type === "tool_use") {
              let jsonBuf = snapshotContent[JSON_BUF_PROPERTY] || "";
              jsonBuf += event.delta.partial_json;
              Object.defineProperty(snapshotContent, JSON_BUF_PROPERTY, {
                value: jsonBuf,
                enumerable: false,
                writable: true
              });
              if (jsonBuf) {
                snapshotContent.input = partialParse(jsonBuf);
              }
            }
            break;
          }
          case "thinking_delta": {
            if (snapshotContent?.type === "thinking") {
              snapshotContent.thinking += event.delta.thinking;
            }
            break;
          }
          case "signature_delta": {
            if (snapshotContent?.type === "thinking") {
              snapshotContent.signature = event.delta.signature;
            }
            break;
          }
          default:
            checkNever(event.delta);
        }
        return snapshot;
      }
      case "content_block_stop":
        return snapshot;
    }
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("streamEvent", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  toReadableStream() {
    const stream = new Stream2(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
};
function checkNever(x2) {
}

// ../node_modules/@anthropic-ai/sdk/resources/beta/messages/messages.mjs
var DEPRECATED_MODELS = {
  "claude-1.3": "November 6th, 2024",
  "claude-1.3-100k": "November 6th, 2024",
  "claude-instant-1.1": "November 6th, 2024",
  "claude-instant-1.1-100k": "November 6th, 2024",
  "claude-instant-1.2": "November 6th, 2024",
  "claude-3-sonnet-20240229": "July 21st, 2025",
  "claude-2.1": "July 21st, 2025",
  "claude-2.0": "July 21st, 2025"
};
var Messages = class extends APIResource {
  constructor() {
    super(...arguments);
    this.batches = new Batches(this._client);
  }
  create(params, options) {
    const { betas, ...body } = params;
    if (body.model in DEPRECATED_MODELS) {
      console.warn(`The model '${body.model}' is deprecated and will reach end-of-life on ${DEPRECATED_MODELS[body.model]}
Please migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`);
    }
    return this._client.post("/v1/messages?beta=true", {
      body,
      timeout: this._client._options.timeout ?? (body.stream ? 6e5 : this._client._calculateNonstreamingTimeout(body.max_tokens)),
      ...options,
      headers: {
        ...betas?.toString() != null ? { "anthropic-beta": betas?.toString() } : void 0,
        ...options?.headers
      },
      stream: params.stream ?? false
    });
  }
  /**
   * Create a Message stream
   */
  stream(body, options) {
    return BetaMessageStream.createMessage(this, body, options);
  }
  /**
   * Count the number of tokens in a Message.
   *
   * The Token Count API can be used to count the number of tokens in a Message,
   * including tools, images, and documents, without creating it.
   *
   * Learn more about token counting in our
   * [user guide](/en/docs/build-with-claude/token-counting)
   */
  countTokens(params, options) {
    const { betas, ...body } = params;
    return this._client.post("/v1/messages/count_tokens?beta=true", {
      body,
      ...options,
      headers: {
        "anthropic-beta": [...betas ?? [], "token-counting-2024-11-01"].toString(),
        ...options?.headers
      }
    });
  }
};
Messages.Batches = Batches;
Messages.BetaMessageBatchesPage = BetaMessageBatchesPage;

// ../node_modules/@anthropic-ai/sdk/resources/beta/beta.mjs
var Beta = class extends APIResource {
  constructor() {
    super(...arguments);
    this.models = new Models(this._client);
    this.messages = new Messages(this._client);
  }
};
Beta.Models = Models;
Beta.BetaModelInfosPage = BetaModelInfosPage;
Beta.Messages = Messages;

// ../node_modules/@anthropic-ai/sdk/resources/completions.mjs
var Completions = class extends APIResource {
  create(body, options) {
    return this._client.post("/v1/complete", {
      body,
      timeout: this._client._options.timeout ?? 6e5,
      ...options,
      stream: body.stream ?? false
    });
  }
};

// ../node_modules/@anthropic-ai/sdk/resources/messages/batches.mjs
var Batches2 = class extends APIResource {
  /**
   * Send a batch of Message creation requests.
   *
   * The Message Batches API can be used to process multiple Messages API requests at
   * once. Once a Message Batch is created, it begins processing immediately. Batches
   * can take up to 24 hours to complete.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   */
  create(body, options) {
    return this._client.post("/v1/messages/batches", { body, ...options });
  }
  /**
   * This endpoint is idempotent and can be used to poll for Message Batch
   * completion. To access the results of a Message Batch, make a request to the
   * `results_url` field in the response.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   */
  retrieve(messageBatchId, options) {
    return this._client.get(`/v1/messages/batches/${messageBatchId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/v1/messages/batches", MessageBatchesPage, { query, ...options });
  }
  /**
   * Delete a Message Batch.
   *
   * Message Batches can only be deleted once they've finished processing. If you'd
   * like to delete an in-progress batch, you must first cancel it.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   */
  delete(messageBatchId, options) {
    return this._client.delete(`/v1/messages/batches/${messageBatchId}`, options);
  }
  /**
   * Batches may be canceled any time before processing ends. Once cancellation is
   * initiated, the batch enters a `canceling` state, at which time the system may
   * complete any in-progress, non-interruptible requests before finalizing
   * cancellation.
   *
   * The number of canceled requests is specified in `request_counts`. To determine
   * which requests were canceled, check the individual results within the batch.
   * Note that cancellation may not result in any canceled requests if they were
   * non-interruptible.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   */
  cancel(messageBatchId, options) {
    return this._client.post(`/v1/messages/batches/${messageBatchId}/cancel`, options);
  }
  /**
   * Streams the results of a Message Batch as a `.jsonl` file.
   *
   * Each line in the file is a JSON object containing the result of a single request
   * in the Message Batch. Results are not guaranteed to be in the same order as
   * requests. Use the `custom_id` field to match results to requests.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   */
  async results(messageBatchId, options) {
    const batch = await this.retrieve(messageBatchId);
    if (!batch.results_url) {
      throw new AnthropicError(`No batch \`results_url\`; Has it finished processing? ${batch.processing_status} - ${batch.id}`);
    }
    return this._client.get(batch.results_url, {
      ...options,
      headers: {
        Accept: "application/binary",
        ...options?.headers
      },
      __binaryResponse: true
    })._thenUnwrap((_2, props) => JSONLDecoder.fromResponse(props.response, props.controller));
  }
};
var MessageBatchesPage = class extends Page {
};
Batches2.MessageBatchesPage = MessageBatchesPage;

// ../node_modules/@anthropic-ai/sdk/lib/MessageStream.mjs
var __classPrivateFieldSet8 = function(receiver, state, value, kind3, f2) {
  if (kind3 === "m") throw new TypeError("Private method is not writable");
  if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind3 === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet9 = function(receiver, state, kind3, f2) {
  if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind3 === "m" ? f2 : kind3 === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _MessageStream_instances;
var _MessageStream_currentMessageSnapshot;
var _MessageStream_connectedPromise;
var _MessageStream_resolveConnectedPromise;
var _MessageStream_rejectConnectedPromise;
var _MessageStream_endPromise;
var _MessageStream_resolveEndPromise;
var _MessageStream_rejectEndPromise;
var _MessageStream_listeners;
var _MessageStream_ended;
var _MessageStream_errored;
var _MessageStream_aborted;
var _MessageStream_catchingPromiseCreated;
var _MessageStream_response;
var _MessageStream_request_id;
var _MessageStream_getFinalMessage;
var _MessageStream_getFinalText;
var _MessageStream_handleError;
var _MessageStream_beginRequest;
var _MessageStream_addStreamEvent;
var _MessageStream_endRequest;
var _MessageStream_accumulateMessage;
var JSON_BUF_PROPERTY2 = "__json_buf";
var MessageStream = class _MessageStream {
  constructor() {
    _MessageStream_instances.add(this);
    this.messages = [];
    this.receivedMessages = [];
    _MessageStream_currentMessageSnapshot.set(this, void 0);
    this.controller = new AbortController();
    _MessageStream_connectedPromise.set(this, void 0);
    _MessageStream_resolveConnectedPromise.set(this, () => {
    });
    _MessageStream_rejectConnectedPromise.set(this, () => {
    });
    _MessageStream_endPromise.set(this, void 0);
    _MessageStream_resolveEndPromise.set(this, () => {
    });
    _MessageStream_rejectEndPromise.set(this, () => {
    });
    _MessageStream_listeners.set(this, {});
    _MessageStream_ended.set(this, false);
    _MessageStream_errored.set(this, false);
    _MessageStream_aborted.set(this, false);
    _MessageStream_catchingPromiseCreated.set(this, false);
    _MessageStream_response.set(this, void 0);
    _MessageStream_request_id.set(this, void 0);
    _MessageStream_handleError.set(this, (error) => {
      __classPrivateFieldSet8(this, _MessageStream_errored, true, "f");
      if (error instanceof Error && error.name === "AbortError") {
        error = new APIUserAbortError();
      }
      if (error instanceof APIUserAbortError) {
        __classPrivateFieldSet8(this, _MessageStream_aborted, true, "f");
        return this._emit("abort", error);
      }
      if (error instanceof AnthropicError) {
        return this._emit("error", error);
      }
      if (error instanceof Error) {
        const anthropicError = new AnthropicError(error.message);
        anthropicError.cause = error;
        return this._emit("error", anthropicError);
      }
      return this._emit("error", new AnthropicError(String(error)));
    });
    __classPrivateFieldSet8(this, _MessageStream_connectedPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet8(this, _MessageStream_resolveConnectedPromise, resolve, "f");
      __classPrivateFieldSet8(this, _MessageStream_rejectConnectedPromise, reject, "f");
    }), "f");
    __classPrivateFieldSet8(this, _MessageStream_endPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet8(this, _MessageStream_resolveEndPromise, resolve, "f");
      __classPrivateFieldSet8(this, _MessageStream_rejectEndPromise, reject, "f");
    }), "f");
    __classPrivateFieldGet9(this, _MessageStream_connectedPromise, "f").catch(() => {
    });
    __classPrivateFieldGet9(this, _MessageStream_endPromise, "f").catch(() => {
    });
  }
  get response() {
    return __classPrivateFieldGet9(this, _MessageStream_response, "f");
  }
  get request_id() {
    return __classPrivateFieldGet9(this, _MessageStream_request_id, "f");
  }
  /**
   * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,
   * returned vie the `request-id` header which is useful for debugging requests and resporting
   * issues to Anthropic.
   *
   * This is the same as the `APIPromise.withResponse()` method.
   *
   * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`
   * as no `Response` is available.
   */
  async withResponse() {
    const response = await __classPrivateFieldGet9(this, _MessageStream_connectedPromise, "f");
    if (!response) {
      throw new Error("Could not resolve a `Response` object");
    }
    return {
      data: this,
      response,
      request_id: response.headers.get("request-id")
    };
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(stream) {
    const runner = new _MessageStream();
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static createMessage(messages, params, options) {
    const runner = new _MessageStream();
    for (const message of params.messages) {
      runner._addMessageParam(message);
    }
    runner._run(() => runner._createMessage(messages, { ...params, stream: true }, { ...options, headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" } }));
    return runner;
  }
  _run(executor) {
    executor().then(() => {
      this._emitFinal();
      this._emit("end");
    }, __classPrivateFieldGet9(this, _MessageStream_handleError, "f"));
  }
  _addMessageParam(message) {
    this.messages.push(message);
  }
  _addMessage(message, emit = true) {
    this.receivedMessages.push(message);
    if (emit) {
      this._emit("message", message);
    }
  }
  async _createMessage(messages, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet9(this, _MessageStream_instances, "m", _MessageStream_beginRequest).call(this);
    const { response, data: stream } = await messages.create({ ...params, stream: true }, { ...options, signal: this.controller.signal }).withResponse();
    this._connected(response);
    for await (const event of stream) {
      __classPrivateFieldGet9(this, _MessageStream_instances, "m", _MessageStream_addStreamEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    __classPrivateFieldGet9(this, _MessageStream_instances, "m", _MessageStream_endRequest).call(this);
  }
  _connected(response) {
    if (this.ended)
      return;
    __classPrivateFieldSet8(this, _MessageStream_response, response, "f");
    __classPrivateFieldSet8(this, _MessageStream_request_id, response?.headers.get("request-id"), "f");
    __classPrivateFieldGet9(this, _MessageStream_resolveConnectedPromise, "f").call(this, response);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet9(this, _MessageStream_ended, "f");
  }
  get errored() {
    return __classPrivateFieldGet9(this, _MessageStream_errored, "f");
  }
  get aborted() {
    return __classPrivateFieldGet9(this, _MessageStream_aborted, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this MessageStream, so that calls can be chained
   */
  on(event, listener) {
    const listeners = __classPrivateFieldGet9(this, _MessageStream_listeners, "f")[event] || (__classPrivateFieldGet9(this, _MessageStream_listeners, "f")[event] = []);
    listeners.push({ listener });
    return this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this MessageStream, so that calls can be chained
   */
  off(event, listener) {
    const listeners = __classPrivateFieldGet9(this, _MessageStream_listeners, "f")[event];
    if (!listeners)
      return this;
    const index = listeners.findIndex((l2) => l2.listener === listener);
    if (index >= 0)
      listeners.splice(index, 1);
    return this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this MessageStream, so that calls can be chained
   */
  once(event, listener) {
    const listeners = __classPrivateFieldGet9(this, _MessageStream_listeners, "f")[event] || (__classPrivateFieldGet9(this, _MessageStream_listeners, "f")[event] = []);
    listeners.push({ listener, once: true });
    return this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(event) {
    return new Promise((resolve, reject) => {
      __classPrivateFieldSet8(this, _MessageStream_catchingPromiseCreated, true, "f");
      if (event !== "error")
        this.once("error", reject);
      this.once(event, resolve);
    });
  }
  async done() {
    __classPrivateFieldSet8(this, _MessageStream_catchingPromiseCreated, true, "f");
    await __classPrivateFieldGet9(this, _MessageStream_endPromise, "f");
  }
  get currentMessage() {
    return __classPrivateFieldGet9(this, _MessageStream_currentMessageSnapshot, "f");
  }
  /**
   * @returns a promise that resolves with the the final assistant Message response,
   * or rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
  async finalMessage() {
    await this.done();
    return __classPrivateFieldGet9(this, _MessageStream_instances, "m", _MessageStream_getFinalMessage).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant Message's text response, concatenated
   * together if there are more than one text blocks.
   * Rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
  async finalText() {
    await this.done();
    return __classPrivateFieldGet9(this, _MessageStream_instances, "m", _MessageStream_getFinalText).call(this);
  }
  _emit(event, ...args) {
    if (__classPrivateFieldGet9(this, _MessageStream_ended, "f"))
      return;
    if (event === "end") {
      __classPrivateFieldSet8(this, _MessageStream_ended, true, "f");
      __classPrivateFieldGet9(this, _MessageStream_resolveEndPromise, "f").call(this);
    }
    const listeners = __classPrivateFieldGet9(this, _MessageStream_listeners, "f")[event];
    if (listeners) {
      __classPrivateFieldGet9(this, _MessageStream_listeners, "f")[event] = listeners.filter((l2) => !l2.once);
      listeners.forEach(({ listener }) => listener(...args));
    }
    if (event === "abort") {
      const error = args[0];
      if (!__classPrivateFieldGet9(this, _MessageStream_catchingPromiseCreated, "f") && !listeners?.length) {
        Promise.reject(error);
      }
      __classPrivateFieldGet9(this, _MessageStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet9(this, _MessageStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error = args[0];
      if (!__classPrivateFieldGet9(this, _MessageStream_catchingPromiseCreated, "f") && !listeners?.length) {
        Promise.reject(error);
      }
      __classPrivateFieldGet9(this, _MessageStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet9(this, _MessageStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
    }
  }
  _emitFinal() {
    const finalMessage = this.receivedMessages.at(-1);
    if (finalMessage) {
      this._emit("finalMessage", __classPrivateFieldGet9(this, _MessageStream_instances, "m", _MessageStream_getFinalMessage).call(this));
    }
  }
  async _fromReadableStream(readableStream, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet9(this, _MessageStream_instances, "m", _MessageStream_beginRequest).call(this);
    this._connected(null);
    const stream = Stream2.fromReadableStream(readableStream, this.controller);
    for await (const event of stream) {
      __classPrivateFieldGet9(this, _MessageStream_instances, "m", _MessageStream_addStreamEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    __classPrivateFieldGet9(this, _MessageStream_instances, "m", _MessageStream_endRequest).call(this);
  }
  [(_MessageStream_currentMessageSnapshot = /* @__PURE__ */ new WeakMap(), _MessageStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_endPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_listeners = /* @__PURE__ */ new WeakMap(), _MessageStream_ended = /* @__PURE__ */ new WeakMap(), _MessageStream_errored = /* @__PURE__ */ new WeakMap(), _MessageStream_aborted = /* @__PURE__ */ new WeakMap(), _MessageStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _MessageStream_response = /* @__PURE__ */ new WeakMap(), _MessageStream_request_id = /* @__PURE__ */ new WeakMap(), _MessageStream_handleError = /* @__PURE__ */ new WeakMap(), _MessageStream_instances = /* @__PURE__ */ new WeakSet(), _MessageStream_getFinalMessage = function _MessageStream_getFinalMessage2() {
    if (this.receivedMessages.length === 0) {
      throw new AnthropicError("stream ended without producing a Message with role=assistant");
    }
    return this.receivedMessages.at(-1);
  }, _MessageStream_getFinalText = function _MessageStream_getFinalText2() {
    if (this.receivedMessages.length === 0) {
      throw new AnthropicError("stream ended without producing a Message with role=assistant");
    }
    const textBlocks = this.receivedMessages.at(-1).content.filter((block) => block.type === "text").map((block) => block.text);
    if (textBlocks.length === 0) {
      throw new AnthropicError("stream ended without producing a content block with type=text");
    }
    return textBlocks.join(" ");
  }, _MessageStream_beginRequest = function _MessageStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet8(this, _MessageStream_currentMessageSnapshot, void 0, "f");
  }, _MessageStream_addStreamEvent = function _MessageStream_addStreamEvent2(event) {
    if (this.ended)
      return;
    const messageSnapshot = __classPrivateFieldGet9(this, _MessageStream_instances, "m", _MessageStream_accumulateMessage).call(this, event);
    this._emit("streamEvent", event, messageSnapshot);
    switch (event.type) {
      case "content_block_delta": {
        const content = messageSnapshot.content.at(-1);
        switch (event.delta.type) {
          case "text_delta": {
            if (content.type === "text") {
              this._emit("text", event.delta.text, content.text || "");
            }
            break;
          }
          case "citations_delta": {
            if (content.type === "text") {
              this._emit("citation", event.delta.citation, content.citations ?? []);
            }
            break;
          }
          case "input_json_delta": {
            if (content.type === "tool_use" && content.input) {
              this._emit("inputJson", event.delta.partial_json, content.input);
            }
            break;
          }
          case "thinking_delta": {
            if (content.type === "thinking") {
              this._emit("thinking", event.delta.thinking, content.thinking);
            }
            break;
          }
          case "signature_delta": {
            if (content.type === "thinking") {
              this._emit("signature", content.signature);
            }
            break;
          }
          default:
            checkNever2(event.delta);
        }
        break;
      }
      case "message_stop": {
        this._addMessageParam(messageSnapshot);
        this._addMessage(messageSnapshot, true);
        break;
      }
      case "content_block_stop": {
        this._emit("contentBlock", messageSnapshot.content.at(-1));
        break;
      }
      case "message_start": {
        __classPrivateFieldSet8(this, _MessageStream_currentMessageSnapshot, messageSnapshot, "f");
        break;
      }
      case "content_block_start":
      case "message_delta":
        break;
    }
  }, _MessageStream_endRequest = function _MessageStream_endRequest2() {
    if (this.ended) {
      throw new AnthropicError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet9(this, _MessageStream_currentMessageSnapshot, "f");
    if (!snapshot) {
      throw new AnthropicError(`request ended without sending any chunks`);
    }
    __classPrivateFieldSet8(this, _MessageStream_currentMessageSnapshot, void 0, "f");
    return snapshot;
  }, _MessageStream_accumulateMessage = function _MessageStream_accumulateMessage2(event) {
    let snapshot = __classPrivateFieldGet9(this, _MessageStream_currentMessageSnapshot, "f");
    if (event.type === "message_start") {
      if (snapshot) {
        throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving "message_stop"`);
      }
      return event.message;
    }
    if (!snapshot) {
      throw new AnthropicError(`Unexpected event order, got ${event.type} before "message_start"`);
    }
    switch (event.type) {
      case "message_stop":
        return snapshot;
      case "message_delta":
        snapshot.stop_reason = event.delta.stop_reason;
        snapshot.stop_sequence = event.delta.stop_sequence;
        snapshot.usage.output_tokens = event.usage.output_tokens;
        return snapshot;
      case "content_block_start":
        snapshot.content.push(event.content_block);
        return snapshot;
      case "content_block_delta": {
        const snapshotContent = snapshot.content.at(event.index);
        switch (event.delta.type) {
          case "text_delta": {
            if (snapshotContent?.type === "text") {
              snapshotContent.text += event.delta.text;
            }
            break;
          }
          case "citations_delta": {
            if (snapshotContent?.type === "text") {
              snapshotContent.citations ?? (snapshotContent.citations = []);
              snapshotContent.citations.push(event.delta.citation);
            }
            break;
          }
          case "input_json_delta": {
            if (snapshotContent?.type === "tool_use") {
              let jsonBuf = snapshotContent[JSON_BUF_PROPERTY2] || "";
              jsonBuf += event.delta.partial_json;
              Object.defineProperty(snapshotContent, JSON_BUF_PROPERTY2, {
                value: jsonBuf,
                enumerable: false,
                writable: true
              });
              if (jsonBuf) {
                snapshotContent.input = partialParse(jsonBuf);
              }
            }
            break;
          }
          case "thinking_delta": {
            if (snapshotContent?.type === "thinking") {
              snapshotContent.thinking += event.delta.thinking;
            }
            break;
          }
          case "signature_delta": {
            if (snapshotContent?.type === "thinking") {
              snapshotContent.signature = event.delta.signature;
            }
            break;
          }
          default:
            checkNever2(event.delta);
        }
        return snapshot;
      }
      case "content_block_stop":
        return snapshot;
    }
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("streamEvent", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  toReadableStream() {
    const stream = new Stream2(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
};
function checkNever2(x2) {
}

// ../node_modules/@anthropic-ai/sdk/resources/messages/messages.mjs
var Messages2 = class extends APIResource {
  constructor() {
    super(...arguments);
    this.batches = new Batches2(this._client);
  }
  create(body, options) {
    if (body.model in DEPRECATED_MODELS2) {
      console.warn(`The model '${body.model}' is deprecated and will reach end-of-life on ${DEPRECATED_MODELS2[body.model]}
Please migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`);
    }
    return this._client.post("/v1/messages", {
      body,
      timeout: this._client._options.timeout ?? (body.stream ? 6e5 : this._client._calculateNonstreamingTimeout(body.max_tokens)),
      ...options,
      stream: body.stream ?? false
    });
  }
  /**
   * Create a Message stream
   */
  stream(body, options) {
    return MessageStream.createMessage(this, body, options);
  }
  /**
   * Count the number of tokens in a Message.
   *
   * The Token Count API can be used to count the number of tokens in a Message,
   * including tools, images, and documents, without creating it.
   *
   * Learn more about token counting in our
   * [user guide](/en/docs/build-with-claude/token-counting)
   */
  countTokens(body, options) {
    return this._client.post("/v1/messages/count_tokens", { body, ...options });
  }
};
var DEPRECATED_MODELS2 = {
  "claude-1.3": "November 6th, 2024",
  "claude-1.3-100k": "November 6th, 2024",
  "claude-instant-1.1": "November 6th, 2024",
  "claude-instant-1.1-100k": "November 6th, 2024",
  "claude-instant-1.2": "November 6th, 2024",
  "claude-3-sonnet-20240229": "July 21st, 2025",
  "claude-2.1": "July 21st, 2025",
  "claude-2.0": "July 21st, 2025"
};
Messages2.Batches = Batches2;
Messages2.MessageBatchesPage = MessageBatchesPage;

// ../node_modules/@anthropic-ai/sdk/resources/models.mjs
var Models2 = class extends APIResource {
  /**
   * Get a specific model.
   *
   * The Models API response can be used to determine information about a specific
   * model or resolve a model alias to a model ID.
   */
  retrieve(modelId, options) {
    return this._client.get(`/v1/models/${modelId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/v1/models", ModelInfosPage, { query, ...options });
  }
};
var ModelInfosPage = class extends Page {
};
Models2.ModelInfosPage = ModelInfosPage;

// ../node_modules/@anthropic-ai/sdk/index.mjs
var _a;
var Anthropic = class extends APIClient {
  /**
   * API Client for interfacing with the Anthropic API.
   *
   * @param {string | null | undefined} [opts.apiKey=process.env['ANTHROPIC_API_KEY'] ?? null]
   * @param {string | null | undefined} [opts.authToken=process.env['ANTHROPIC_AUTH_TOKEN'] ?? null]
   * @param {string} [opts.baseURL=process.env['ANTHROPIC_BASE_URL'] ?? https://api.anthropic.com] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL = readEnv("ANTHROPIC_BASE_URL"), apiKey = readEnv("ANTHROPIC_API_KEY") ?? null, authToken = readEnv("ANTHROPIC_AUTH_TOKEN") ?? null, ...opts } = {}) {
    const options = {
      apiKey,
      authToken,
      ...opts,
      baseURL: baseURL || `https://api.anthropic.com`
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
      throw new AnthropicError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew Anthropic({ apiKey, dangerouslyAllowBrowser: true });\n");
    }
    super({
      baseURL: options.baseURL,
      timeout: options.timeout ?? 6e5,
      httpAgent: options.httpAgent,
      maxRetries: options.maxRetries,
      fetch: options.fetch
    });
    this.completions = new Completions(this);
    this.messages = new Messages2(this);
    this.models = new Models2(this);
    this.beta = new Beta(this);
    this._options = options;
    this.apiKey = apiKey;
    this.authToken = authToken;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(opts) {
    return {
      ...super.defaultHeaders(opts),
      ...this._options.dangerouslyAllowBrowser ? { "anthropic-dangerous-direct-browser-access": "true" } : void 0,
      "anthropic-version": "2023-06-01",
      ...this._options.defaultHeaders
    };
  }
  validateHeaders(headers, customHeaders) {
    if (this.apiKey && headers["x-api-key"]) {
      return;
    }
    if (customHeaders["x-api-key"] === null) {
      return;
    }
    if (this.authToken && headers["authorization"]) {
      return;
    }
    if (customHeaders["authorization"] === null) {
      return;
    }
    throw new Error('Could not resolve authentication method. Expected either apiKey or authToken to be set. Or for one of the "X-Api-Key" or "Authorization" headers to be explicitly omitted');
  }
  authHeaders(opts) {
    const apiKeyAuth = this.apiKeyAuth(opts);
    const bearerAuth = this.bearerAuth(opts);
    if (apiKeyAuth != null && !isEmptyObj(apiKeyAuth)) {
      return apiKeyAuth;
    }
    if (bearerAuth != null && !isEmptyObj(bearerAuth)) {
      return bearerAuth;
    }
    return {};
  }
  apiKeyAuth(opts) {
    if (this.apiKey == null) {
      return {};
    }
    return { "X-Api-Key": this.apiKey };
  }
  bearerAuth(opts) {
    if (this.authToken == null) {
      return {};
    }
    return { Authorization: `Bearer ${this.authToken}` };
  }
};
_a = Anthropic;
Anthropic.Anthropic = _a;
Anthropic.HUMAN_PROMPT = "\n\nHuman:";
Anthropic.AI_PROMPT = "\n\nAssistant:";
Anthropic.DEFAULT_TIMEOUT = 6e5;
Anthropic.AnthropicError = AnthropicError;
Anthropic.APIError = APIError;
Anthropic.APIConnectionError = APIConnectionError;
Anthropic.APIConnectionTimeoutError = APIConnectionTimeoutError;
Anthropic.APIUserAbortError = APIUserAbortError;
Anthropic.NotFoundError = NotFoundError;
Anthropic.ConflictError = ConflictError;
Anthropic.RateLimitError = RateLimitError;
Anthropic.BadRequestError = BadRequestError;
Anthropic.AuthenticationError = AuthenticationError;
Anthropic.InternalServerError = InternalServerError;
Anthropic.PermissionDeniedError = PermissionDeniedError;
Anthropic.UnprocessableEntityError = UnprocessableEntityError;
Anthropic.toFile = toFile;
Anthropic.fileFromPath = fileFromPath;
Anthropic.Completions = Completions;
Anthropic.Messages = Messages2;
Anthropic.Models = Models2;
Anthropic.ModelInfosPage = ModelInfosPage;
Anthropic.Beta = Beta;
var { HUMAN_PROMPT, AI_PROMPT } = Anthropic;
var sdk_default = Anthropic;

// ../node_modules/@google/genai/dist/node/index.mjs
var import_google_auth_library = __toESM(require_src6(), 1);
import { createWriteStream, writeFile } from "fs";
import { Readable as Readable3 } from "stream";

// ../node_modules/@google/genai/node_modules/ws/wrapper.mjs
var import_stream2 = __toESM(require_stream(), 1);
var import_receiver = __toESM(require_receiver(), 1);
var import_sender = __toESM(require_sender(), 1);
var import_websocket = __toESM(require_websocket(), 1);
var import_websocket_server = __toESM(require_websocket_server(), 1);

// ../node_modules/@google/genai/dist/node/index.mjs
import * as fs2 from "fs/promises";
var _defaultBaseGeminiUrl = void 0;
var _defaultBaseVertexUrl = void 0;
function getDefaultBaseUrls() {
  return {
    geminiUrl: _defaultBaseGeminiUrl,
    vertexUrl: _defaultBaseVertexUrl
  };
}
function getBaseUrl(httpOptions, vertexai, vertexBaseUrlFromEnv, geminiBaseUrlFromEnv) {
  var _a3, _b;
  if (!(httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.baseUrl)) {
    const defaultBaseUrls = getDefaultBaseUrls();
    if (vertexai) {
      return (_a3 = defaultBaseUrls.vertexUrl) !== null && _a3 !== void 0 ? _a3 : vertexBaseUrlFromEnv;
    } else {
      return (_b = defaultBaseUrls.geminiUrl) !== null && _b !== void 0 ? _b : geminiBaseUrlFromEnv;
    }
  }
  return httpOptions.baseUrl;
}
var BaseModule = class {
};
function formatMap(templateString, valueMap) {
  const regex = /\{([^}]+)\}/g;
  return templateString.replace(regex, (match7, key) => {
    if (Object.prototype.hasOwnProperty.call(valueMap, key)) {
      const value = valueMap[key];
      return value !== void 0 && value !== null ? String(value) : "";
    } else {
      throw new Error(`Key '${key}' not found in valueMap.`);
    }
  });
}
function setValueByPath(data, keys, value) {
  for (let i2 = 0; i2 < keys.length - 1; i2++) {
    const key = keys[i2];
    if (key.endsWith("[]")) {
      const keyName = key.slice(0, -2);
      if (!(keyName in data)) {
        if (Array.isArray(value)) {
          data[keyName] = Array.from({ length: value.length }, () => ({}));
        } else {
          throw new Error(`Value must be a list given an array path ${key}`);
        }
      }
      if (Array.isArray(data[keyName])) {
        const arrayData = data[keyName];
        if (Array.isArray(value)) {
          for (let j2 = 0; j2 < arrayData.length; j2++) {
            const entry = arrayData[j2];
            setValueByPath(entry, keys.slice(i2 + 1), value[j2]);
          }
        } else {
          for (const d2 of arrayData) {
            setValueByPath(d2, keys.slice(i2 + 1), value);
          }
        }
      }
      return;
    } else if (key.endsWith("[0]")) {
      const keyName = key.slice(0, -3);
      if (!(keyName in data)) {
        data[keyName] = [{}];
      }
      const arrayData = data[keyName];
      setValueByPath(arrayData[0], keys.slice(i2 + 1), value);
      return;
    }
    if (!data[key] || typeof data[key] !== "object") {
      data[key] = {};
    }
    data = data[key];
  }
  const keyToSet = keys[keys.length - 1];
  const existingData = data[keyToSet];
  if (existingData !== void 0) {
    if (!value || typeof value === "object" && Object.keys(value).length === 0) {
      return;
    }
    if (value === existingData) {
      return;
    }
    if (typeof existingData === "object" && typeof value === "object" && existingData !== null && value !== null) {
      Object.assign(existingData, value);
    } else {
      throw new Error(`Cannot set value for an existing key. Key: ${keyToSet}`);
    }
  } else {
    data[keyToSet] = value;
  }
}
function getValueByPath(data, keys) {
  try {
    if (keys.length === 1 && keys[0] === "_self") {
      return data;
    }
    for (let i2 = 0; i2 < keys.length; i2++) {
      if (typeof data !== "object" || data === null) {
        return void 0;
      }
      const key = keys[i2];
      if (key.endsWith("[]")) {
        const keyName = key.slice(0, -2);
        if (keyName in data) {
          const arrayData = data[keyName];
          if (!Array.isArray(arrayData)) {
            return void 0;
          }
          return arrayData.map((d2) => getValueByPath(d2, keys.slice(i2 + 1)));
        } else {
          return void 0;
        }
      } else {
        data = data[key];
      }
    }
    return data;
  } catch (error) {
    if (error instanceof TypeError) {
      return void 0;
    }
    throw error;
  }
}
function tBytes$1(fromBytes) {
  if (typeof fromBytes !== "string") {
    throw new Error("fromImageBytes must be a string");
  }
  return fromBytes;
}
var Outcome;
(function(Outcome2) {
  Outcome2["OUTCOME_UNSPECIFIED"] = "OUTCOME_UNSPECIFIED";
  Outcome2["OUTCOME_OK"] = "OUTCOME_OK";
  Outcome2["OUTCOME_FAILED"] = "OUTCOME_FAILED";
  Outcome2["OUTCOME_DEADLINE_EXCEEDED"] = "OUTCOME_DEADLINE_EXCEEDED";
})(Outcome || (Outcome = {}));
var Language;
(function(Language2) {
  Language2["LANGUAGE_UNSPECIFIED"] = "LANGUAGE_UNSPECIFIED";
  Language2["PYTHON"] = "PYTHON";
})(Language || (Language = {}));
var Type;
(function(Type2) {
  Type2["TYPE_UNSPECIFIED"] = "TYPE_UNSPECIFIED";
  Type2["STRING"] = "STRING";
  Type2["NUMBER"] = "NUMBER";
  Type2["INTEGER"] = "INTEGER";
  Type2["BOOLEAN"] = "BOOLEAN";
  Type2["ARRAY"] = "ARRAY";
  Type2["OBJECT"] = "OBJECT";
  Type2["NULL"] = "NULL";
})(Type || (Type = {}));
var HarmCategory;
(function(HarmCategory2) {
  HarmCategory2["HARM_CATEGORY_UNSPECIFIED"] = "HARM_CATEGORY_UNSPECIFIED";
  HarmCategory2["HARM_CATEGORY_HATE_SPEECH"] = "HARM_CATEGORY_HATE_SPEECH";
  HarmCategory2["HARM_CATEGORY_DANGEROUS_CONTENT"] = "HARM_CATEGORY_DANGEROUS_CONTENT";
  HarmCategory2["HARM_CATEGORY_HARASSMENT"] = "HARM_CATEGORY_HARASSMENT";
  HarmCategory2["HARM_CATEGORY_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_SEXUALLY_EXPLICIT";
  HarmCategory2["HARM_CATEGORY_CIVIC_INTEGRITY"] = "HARM_CATEGORY_CIVIC_INTEGRITY";
  HarmCategory2["HARM_CATEGORY_IMAGE_HATE"] = "HARM_CATEGORY_IMAGE_HATE";
  HarmCategory2["HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT"] = "HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT";
  HarmCategory2["HARM_CATEGORY_IMAGE_HARASSMENT"] = "HARM_CATEGORY_IMAGE_HARASSMENT";
  HarmCategory2["HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT";
})(HarmCategory || (HarmCategory = {}));
var HarmBlockMethod;
(function(HarmBlockMethod2) {
  HarmBlockMethod2["HARM_BLOCK_METHOD_UNSPECIFIED"] = "HARM_BLOCK_METHOD_UNSPECIFIED";
  HarmBlockMethod2["SEVERITY"] = "SEVERITY";
  HarmBlockMethod2["PROBABILITY"] = "PROBABILITY";
})(HarmBlockMethod || (HarmBlockMethod = {}));
var HarmBlockThreshold;
(function(HarmBlockThreshold2) {
  HarmBlockThreshold2["HARM_BLOCK_THRESHOLD_UNSPECIFIED"] = "HARM_BLOCK_THRESHOLD_UNSPECIFIED";
  HarmBlockThreshold2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
  HarmBlockThreshold2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
  HarmBlockThreshold2["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
  HarmBlockThreshold2["BLOCK_NONE"] = "BLOCK_NONE";
  HarmBlockThreshold2["OFF"] = "OFF";
})(HarmBlockThreshold || (HarmBlockThreshold = {}));
var Mode;
(function(Mode2) {
  Mode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
  Mode2["MODE_DYNAMIC"] = "MODE_DYNAMIC";
})(Mode || (Mode = {}));
var AuthType;
(function(AuthType2) {
  AuthType2["AUTH_TYPE_UNSPECIFIED"] = "AUTH_TYPE_UNSPECIFIED";
  AuthType2["NO_AUTH"] = "NO_AUTH";
  AuthType2["API_KEY_AUTH"] = "API_KEY_AUTH";
  AuthType2["HTTP_BASIC_AUTH"] = "HTTP_BASIC_AUTH";
  AuthType2["GOOGLE_SERVICE_ACCOUNT_AUTH"] = "GOOGLE_SERVICE_ACCOUNT_AUTH";
  AuthType2["OAUTH"] = "OAUTH";
  AuthType2["OIDC_AUTH"] = "OIDC_AUTH";
})(AuthType || (AuthType = {}));
var ApiSpec;
(function(ApiSpec2) {
  ApiSpec2["API_SPEC_UNSPECIFIED"] = "API_SPEC_UNSPECIFIED";
  ApiSpec2["SIMPLE_SEARCH"] = "SIMPLE_SEARCH";
  ApiSpec2["ELASTIC_SEARCH"] = "ELASTIC_SEARCH";
})(ApiSpec || (ApiSpec = {}));
var Environment;
(function(Environment2) {
  Environment2["ENVIRONMENT_UNSPECIFIED"] = "ENVIRONMENT_UNSPECIFIED";
  Environment2["ENVIRONMENT_BROWSER"] = "ENVIRONMENT_BROWSER";
})(Environment || (Environment = {}));
var UrlRetrievalStatus;
(function(UrlRetrievalStatus2) {
  UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_UNSPECIFIED"] = "URL_RETRIEVAL_STATUS_UNSPECIFIED";
  UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_SUCCESS"] = "URL_RETRIEVAL_STATUS_SUCCESS";
  UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_ERROR"] = "URL_RETRIEVAL_STATUS_ERROR";
  UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_PAYWALL"] = "URL_RETRIEVAL_STATUS_PAYWALL";
  UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_UNSAFE"] = "URL_RETRIEVAL_STATUS_UNSAFE";
})(UrlRetrievalStatus || (UrlRetrievalStatus = {}));
var FinishReason;
(function(FinishReason2) {
  FinishReason2["FINISH_REASON_UNSPECIFIED"] = "FINISH_REASON_UNSPECIFIED";
  FinishReason2["STOP"] = "STOP";
  FinishReason2["MAX_TOKENS"] = "MAX_TOKENS";
  FinishReason2["SAFETY"] = "SAFETY";
  FinishReason2["RECITATION"] = "RECITATION";
  FinishReason2["LANGUAGE"] = "LANGUAGE";
  FinishReason2["OTHER"] = "OTHER";
  FinishReason2["BLOCKLIST"] = "BLOCKLIST";
  FinishReason2["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
  FinishReason2["SPII"] = "SPII";
  FinishReason2["MALFORMED_FUNCTION_CALL"] = "MALFORMED_FUNCTION_CALL";
  FinishReason2["IMAGE_SAFETY"] = "IMAGE_SAFETY";
  FinishReason2["UNEXPECTED_TOOL_CALL"] = "UNEXPECTED_TOOL_CALL";
})(FinishReason || (FinishReason = {}));
var HarmProbability;
(function(HarmProbability2) {
  HarmProbability2["HARM_PROBABILITY_UNSPECIFIED"] = "HARM_PROBABILITY_UNSPECIFIED";
  HarmProbability2["NEGLIGIBLE"] = "NEGLIGIBLE";
  HarmProbability2["LOW"] = "LOW";
  HarmProbability2["MEDIUM"] = "MEDIUM";
  HarmProbability2["HIGH"] = "HIGH";
})(HarmProbability || (HarmProbability = {}));
var HarmSeverity;
(function(HarmSeverity2) {
  HarmSeverity2["HARM_SEVERITY_UNSPECIFIED"] = "HARM_SEVERITY_UNSPECIFIED";
  HarmSeverity2["HARM_SEVERITY_NEGLIGIBLE"] = "HARM_SEVERITY_NEGLIGIBLE";
  HarmSeverity2["HARM_SEVERITY_LOW"] = "HARM_SEVERITY_LOW";
  HarmSeverity2["HARM_SEVERITY_MEDIUM"] = "HARM_SEVERITY_MEDIUM";
  HarmSeverity2["HARM_SEVERITY_HIGH"] = "HARM_SEVERITY_HIGH";
})(HarmSeverity || (HarmSeverity = {}));
var BlockedReason;
(function(BlockedReason2) {
  BlockedReason2["BLOCKED_REASON_UNSPECIFIED"] = "BLOCKED_REASON_UNSPECIFIED";
  BlockedReason2["SAFETY"] = "SAFETY";
  BlockedReason2["OTHER"] = "OTHER";
  BlockedReason2["BLOCKLIST"] = "BLOCKLIST";
  BlockedReason2["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
  BlockedReason2["IMAGE_SAFETY"] = "IMAGE_SAFETY";
})(BlockedReason || (BlockedReason = {}));
var TrafficType;
(function(TrafficType2) {
  TrafficType2["TRAFFIC_TYPE_UNSPECIFIED"] = "TRAFFIC_TYPE_UNSPECIFIED";
  TrafficType2["ON_DEMAND"] = "ON_DEMAND";
  TrafficType2["PROVISIONED_THROUGHPUT"] = "PROVISIONED_THROUGHPUT";
})(TrafficType || (TrafficType = {}));
var Modality;
(function(Modality2) {
  Modality2["MODALITY_UNSPECIFIED"] = "MODALITY_UNSPECIFIED";
  Modality2["TEXT"] = "TEXT";
  Modality2["IMAGE"] = "IMAGE";
  Modality2["AUDIO"] = "AUDIO";
})(Modality || (Modality = {}));
var MediaResolution;
(function(MediaResolution2) {
  MediaResolution2["MEDIA_RESOLUTION_UNSPECIFIED"] = "MEDIA_RESOLUTION_UNSPECIFIED";
  MediaResolution2["MEDIA_RESOLUTION_LOW"] = "MEDIA_RESOLUTION_LOW";
  MediaResolution2["MEDIA_RESOLUTION_MEDIUM"] = "MEDIA_RESOLUTION_MEDIUM";
  MediaResolution2["MEDIA_RESOLUTION_HIGH"] = "MEDIA_RESOLUTION_HIGH";
})(MediaResolution || (MediaResolution = {}));
var JobState;
(function(JobState2) {
  JobState2["JOB_STATE_UNSPECIFIED"] = "JOB_STATE_UNSPECIFIED";
  JobState2["JOB_STATE_QUEUED"] = "JOB_STATE_QUEUED";
  JobState2["JOB_STATE_PENDING"] = "JOB_STATE_PENDING";
  JobState2["JOB_STATE_RUNNING"] = "JOB_STATE_RUNNING";
  JobState2["JOB_STATE_SUCCEEDED"] = "JOB_STATE_SUCCEEDED";
  JobState2["JOB_STATE_FAILED"] = "JOB_STATE_FAILED";
  JobState2["JOB_STATE_CANCELLING"] = "JOB_STATE_CANCELLING";
  JobState2["JOB_STATE_CANCELLED"] = "JOB_STATE_CANCELLED";
  JobState2["JOB_STATE_PAUSED"] = "JOB_STATE_PAUSED";
  JobState2["JOB_STATE_EXPIRED"] = "JOB_STATE_EXPIRED";
  JobState2["JOB_STATE_UPDATING"] = "JOB_STATE_UPDATING";
  JobState2["JOB_STATE_PARTIALLY_SUCCEEDED"] = "JOB_STATE_PARTIALLY_SUCCEEDED";
})(JobState || (JobState = {}));
var AdapterSize;
(function(AdapterSize2) {
  AdapterSize2["ADAPTER_SIZE_UNSPECIFIED"] = "ADAPTER_SIZE_UNSPECIFIED";
  AdapterSize2["ADAPTER_SIZE_ONE"] = "ADAPTER_SIZE_ONE";
  AdapterSize2["ADAPTER_SIZE_TWO"] = "ADAPTER_SIZE_TWO";
  AdapterSize2["ADAPTER_SIZE_FOUR"] = "ADAPTER_SIZE_FOUR";
  AdapterSize2["ADAPTER_SIZE_EIGHT"] = "ADAPTER_SIZE_EIGHT";
  AdapterSize2["ADAPTER_SIZE_SIXTEEN"] = "ADAPTER_SIZE_SIXTEEN";
  AdapterSize2["ADAPTER_SIZE_THIRTY_TWO"] = "ADAPTER_SIZE_THIRTY_TWO";
})(AdapterSize || (AdapterSize = {}));
var FeatureSelectionPreference;
(function(FeatureSelectionPreference2) {
  FeatureSelectionPreference2["FEATURE_SELECTION_PREFERENCE_UNSPECIFIED"] = "FEATURE_SELECTION_PREFERENCE_UNSPECIFIED";
  FeatureSelectionPreference2["PRIORITIZE_QUALITY"] = "PRIORITIZE_QUALITY";
  FeatureSelectionPreference2["BALANCED"] = "BALANCED";
  FeatureSelectionPreference2["PRIORITIZE_COST"] = "PRIORITIZE_COST";
})(FeatureSelectionPreference || (FeatureSelectionPreference = {}));
var Behavior;
(function(Behavior2) {
  Behavior2["UNSPECIFIED"] = "UNSPECIFIED";
  Behavior2["BLOCKING"] = "BLOCKING";
  Behavior2["NON_BLOCKING"] = "NON_BLOCKING";
})(Behavior || (Behavior = {}));
var DynamicRetrievalConfigMode;
(function(DynamicRetrievalConfigMode2) {
  DynamicRetrievalConfigMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
  DynamicRetrievalConfigMode2["MODE_DYNAMIC"] = "MODE_DYNAMIC";
})(DynamicRetrievalConfigMode || (DynamicRetrievalConfigMode = {}));
var FunctionCallingConfigMode;
(function(FunctionCallingConfigMode2) {
  FunctionCallingConfigMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
  FunctionCallingConfigMode2["AUTO"] = "AUTO";
  FunctionCallingConfigMode2["ANY"] = "ANY";
  FunctionCallingConfigMode2["NONE"] = "NONE";
})(FunctionCallingConfigMode || (FunctionCallingConfigMode = {}));
var SafetyFilterLevel;
(function(SafetyFilterLevel2) {
  SafetyFilterLevel2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
  SafetyFilterLevel2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
  SafetyFilterLevel2["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
  SafetyFilterLevel2["BLOCK_NONE"] = "BLOCK_NONE";
})(SafetyFilterLevel || (SafetyFilterLevel = {}));
var PersonGeneration;
(function(PersonGeneration2) {
  PersonGeneration2["DONT_ALLOW"] = "DONT_ALLOW";
  PersonGeneration2["ALLOW_ADULT"] = "ALLOW_ADULT";
  PersonGeneration2["ALLOW_ALL"] = "ALLOW_ALL";
})(PersonGeneration || (PersonGeneration = {}));
var ImagePromptLanguage;
(function(ImagePromptLanguage2) {
  ImagePromptLanguage2["auto"] = "auto";
  ImagePromptLanguage2["en"] = "en";
  ImagePromptLanguage2["ja"] = "ja";
  ImagePromptLanguage2["ko"] = "ko";
  ImagePromptLanguage2["hi"] = "hi";
  ImagePromptLanguage2["zh"] = "zh";
  ImagePromptLanguage2["pt"] = "pt";
  ImagePromptLanguage2["es"] = "es";
})(ImagePromptLanguage || (ImagePromptLanguage = {}));
var MaskReferenceMode;
(function(MaskReferenceMode2) {
  MaskReferenceMode2["MASK_MODE_DEFAULT"] = "MASK_MODE_DEFAULT";
  MaskReferenceMode2["MASK_MODE_USER_PROVIDED"] = "MASK_MODE_USER_PROVIDED";
  MaskReferenceMode2["MASK_MODE_BACKGROUND"] = "MASK_MODE_BACKGROUND";
  MaskReferenceMode2["MASK_MODE_FOREGROUND"] = "MASK_MODE_FOREGROUND";
  MaskReferenceMode2["MASK_MODE_SEMANTIC"] = "MASK_MODE_SEMANTIC";
})(MaskReferenceMode || (MaskReferenceMode = {}));
var ControlReferenceType;
(function(ControlReferenceType2) {
  ControlReferenceType2["CONTROL_TYPE_DEFAULT"] = "CONTROL_TYPE_DEFAULT";
  ControlReferenceType2["CONTROL_TYPE_CANNY"] = "CONTROL_TYPE_CANNY";
  ControlReferenceType2["CONTROL_TYPE_SCRIBBLE"] = "CONTROL_TYPE_SCRIBBLE";
  ControlReferenceType2["CONTROL_TYPE_FACE_MESH"] = "CONTROL_TYPE_FACE_MESH";
})(ControlReferenceType || (ControlReferenceType = {}));
var SubjectReferenceType;
(function(SubjectReferenceType2) {
  SubjectReferenceType2["SUBJECT_TYPE_DEFAULT"] = "SUBJECT_TYPE_DEFAULT";
  SubjectReferenceType2["SUBJECT_TYPE_PERSON"] = "SUBJECT_TYPE_PERSON";
  SubjectReferenceType2["SUBJECT_TYPE_ANIMAL"] = "SUBJECT_TYPE_ANIMAL";
  SubjectReferenceType2["SUBJECT_TYPE_PRODUCT"] = "SUBJECT_TYPE_PRODUCT";
})(SubjectReferenceType || (SubjectReferenceType = {}));
var EditMode;
(function(EditMode2) {
  EditMode2["EDIT_MODE_DEFAULT"] = "EDIT_MODE_DEFAULT";
  EditMode2["EDIT_MODE_INPAINT_REMOVAL"] = "EDIT_MODE_INPAINT_REMOVAL";
  EditMode2["EDIT_MODE_INPAINT_INSERTION"] = "EDIT_MODE_INPAINT_INSERTION";
  EditMode2["EDIT_MODE_OUTPAINT"] = "EDIT_MODE_OUTPAINT";
  EditMode2["EDIT_MODE_CONTROLLED_EDITING"] = "EDIT_MODE_CONTROLLED_EDITING";
  EditMode2["EDIT_MODE_STYLE"] = "EDIT_MODE_STYLE";
  EditMode2["EDIT_MODE_BGSWAP"] = "EDIT_MODE_BGSWAP";
  EditMode2["EDIT_MODE_PRODUCT_IMAGE"] = "EDIT_MODE_PRODUCT_IMAGE";
})(EditMode || (EditMode = {}));
var VideoCompressionQuality;
(function(VideoCompressionQuality2) {
  VideoCompressionQuality2["OPTIMIZED"] = "OPTIMIZED";
  VideoCompressionQuality2["LOSSLESS"] = "LOSSLESS";
})(VideoCompressionQuality || (VideoCompressionQuality = {}));
var FileState;
(function(FileState2) {
  FileState2["STATE_UNSPECIFIED"] = "STATE_UNSPECIFIED";
  FileState2["PROCESSING"] = "PROCESSING";
  FileState2["ACTIVE"] = "ACTIVE";
  FileState2["FAILED"] = "FAILED";
})(FileState || (FileState = {}));
var FileSource;
(function(FileSource2) {
  FileSource2["SOURCE_UNSPECIFIED"] = "SOURCE_UNSPECIFIED";
  FileSource2["UPLOADED"] = "UPLOADED";
  FileSource2["GENERATED"] = "GENERATED";
})(FileSource || (FileSource = {}));
var MediaModality;
(function(MediaModality2) {
  MediaModality2["MODALITY_UNSPECIFIED"] = "MODALITY_UNSPECIFIED";
  MediaModality2["TEXT"] = "TEXT";
  MediaModality2["IMAGE"] = "IMAGE";
  MediaModality2["VIDEO"] = "VIDEO";
  MediaModality2["AUDIO"] = "AUDIO";
  MediaModality2["DOCUMENT"] = "DOCUMENT";
})(MediaModality || (MediaModality = {}));
var StartSensitivity;
(function(StartSensitivity2) {
  StartSensitivity2["START_SENSITIVITY_UNSPECIFIED"] = "START_SENSITIVITY_UNSPECIFIED";
  StartSensitivity2["START_SENSITIVITY_HIGH"] = "START_SENSITIVITY_HIGH";
  StartSensitivity2["START_SENSITIVITY_LOW"] = "START_SENSITIVITY_LOW";
})(StartSensitivity || (StartSensitivity = {}));
var EndSensitivity;
(function(EndSensitivity2) {
  EndSensitivity2["END_SENSITIVITY_UNSPECIFIED"] = "END_SENSITIVITY_UNSPECIFIED";
  EndSensitivity2["END_SENSITIVITY_HIGH"] = "END_SENSITIVITY_HIGH";
  EndSensitivity2["END_SENSITIVITY_LOW"] = "END_SENSITIVITY_LOW";
})(EndSensitivity || (EndSensitivity = {}));
var ActivityHandling;
(function(ActivityHandling2) {
  ActivityHandling2["ACTIVITY_HANDLING_UNSPECIFIED"] = "ACTIVITY_HANDLING_UNSPECIFIED";
  ActivityHandling2["START_OF_ACTIVITY_INTERRUPTS"] = "START_OF_ACTIVITY_INTERRUPTS";
  ActivityHandling2["NO_INTERRUPTION"] = "NO_INTERRUPTION";
})(ActivityHandling || (ActivityHandling = {}));
var TurnCoverage;
(function(TurnCoverage2) {
  TurnCoverage2["TURN_COVERAGE_UNSPECIFIED"] = "TURN_COVERAGE_UNSPECIFIED";
  TurnCoverage2["TURN_INCLUDES_ONLY_ACTIVITY"] = "TURN_INCLUDES_ONLY_ACTIVITY";
  TurnCoverage2["TURN_INCLUDES_ALL_INPUT"] = "TURN_INCLUDES_ALL_INPUT";
})(TurnCoverage || (TurnCoverage = {}));
var FunctionResponseScheduling;
(function(FunctionResponseScheduling2) {
  FunctionResponseScheduling2["SCHEDULING_UNSPECIFIED"] = "SCHEDULING_UNSPECIFIED";
  FunctionResponseScheduling2["SILENT"] = "SILENT";
  FunctionResponseScheduling2["WHEN_IDLE"] = "WHEN_IDLE";
  FunctionResponseScheduling2["INTERRUPT"] = "INTERRUPT";
})(FunctionResponseScheduling || (FunctionResponseScheduling = {}));
var Scale;
(function(Scale2) {
  Scale2["SCALE_UNSPECIFIED"] = "SCALE_UNSPECIFIED";
  Scale2["C_MAJOR_A_MINOR"] = "C_MAJOR_A_MINOR";
  Scale2["D_FLAT_MAJOR_B_FLAT_MINOR"] = "D_FLAT_MAJOR_B_FLAT_MINOR";
  Scale2["D_MAJOR_B_MINOR"] = "D_MAJOR_B_MINOR";
  Scale2["E_FLAT_MAJOR_C_MINOR"] = "E_FLAT_MAJOR_C_MINOR";
  Scale2["E_MAJOR_D_FLAT_MINOR"] = "E_MAJOR_D_FLAT_MINOR";
  Scale2["F_MAJOR_D_MINOR"] = "F_MAJOR_D_MINOR";
  Scale2["G_FLAT_MAJOR_E_FLAT_MINOR"] = "G_FLAT_MAJOR_E_FLAT_MINOR";
  Scale2["G_MAJOR_E_MINOR"] = "G_MAJOR_E_MINOR";
  Scale2["A_FLAT_MAJOR_F_MINOR"] = "A_FLAT_MAJOR_F_MINOR";
  Scale2["A_MAJOR_G_FLAT_MINOR"] = "A_MAJOR_G_FLAT_MINOR";
  Scale2["B_FLAT_MAJOR_G_MINOR"] = "B_FLAT_MAJOR_G_MINOR";
  Scale2["B_MAJOR_A_FLAT_MINOR"] = "B_MAJOR_A_FLAT_MINOR";
})(Scale || (Scale = {}));
var MusicGenerationMode;
(function(MusicGenerationMode2) {
  MusicGenerationMode2["MUSIC_GENERATION_MODE_UNSPECIFIED"] = "MUSIC_GENERATION_MODE_UNSPECIFIED";
  MusicGenerationMode2["QUALITY"] = "QUALITY";
  MusicGenerationMode2["DIVERSITY"] = "DIVERSITY";
  MusicGenerationMode2["VOCALIZATION"] = "VOCALIZATION";
})(MusicGenerationMode || (MusicGenerationMode = {}));
var LiveMusicPlaybackControl;
(function(LiveMusicPlaybackControl2) {
  LiveMusicPlaybackControl2["PLAYBACK_CONTROL_UNSPECIFIED"] = "PLAYBACK_CONTROL_UNSPECIFIED";
  LiveMusicPlaybackControl2["PLAY"] = "PLAY";
  LiveMusicPlaybackControl2["PAUSE"] = "PAUSE";
  LiveMusicPlaybackControl2["STOP"] = "STOP";
  LiveMusicPlaybackControl2["RESET_CONTEXT"] = "RESET_CONTEXT";
})(LiveMusicPlaybackControl || (LiveMusicPlaybackControl = {}));
var HttpResponse = class {
  constructor(response) {
    const headers = {};
    for (const pair of response.headers.entries()) {
      headers[pair[0]] = pair[1];
    }
    this.headers = headers;
    this.responseInternal = response;
  }
  json() {
    return this.responseInternal.json();
  }
};
var GenerateContentResponse = class {
  /**
   * Returns the concatenation of all text parts from the first candidate in the response.
   *
   * @remarks
   * If there are multiple candidates in the response, the text from the first
   * one will be returned.
   * If there are non-text parts in the response, the concatenation of all text
   * parts will be returned, and a warning will be logged.
   * If there are thought parts in the response, the concatenation of all text
   * parts excluding the thought parts will be returned.
   *
   * @example
   * ```ts
   * const response = await ai.models.generateContent({
   *   model: 'gemini-2.0-flash',
   *   contents:
   *     'Why is the sky blue?',
   * });
   *
   * console.debug(response.text);
   * ```
   */
  get text() {
    var _a3, _b, _c, _d, _e2, _f, _g, _h;
    if (((_d = (_c = (_b = (_a3 = this.candidates) === null || _a3 === void 0 ? void 0 : _a3[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
      return void 0;
    }
    if (this.candidates && this.candidates.length > 1) {
      console.warn("there are multiple candidates in the response, returning text from the first one.");
    }
    let text = "";
    let anyTextPartText = false;
    const nonTextParts = [];
    for (const part of (_h = (_g = (_f = (_e2 = this.candidates) === null || _e2 === void 0 ? void 0 : _e2[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []) {
      for (const [fieldName, fieldValue] of Object.entries(part)) {
        if (fieldName !== "text" && fieldName !== "thought" && (fieldValue !== null || fieldValue !== void 0)) {
          nonTextParts.push(fieldName);
        }
      }
      if (typeof part.text === "string") {
        if (typeof part.thought === "boolean" && part.thought) {
          continue;
        }
        anyTextPartText = true;
        text += part.text;
      }
    }
    if (nonTextParts.length > 0) {
      console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);
    }
    return anyTextPartText ? text : void 0;
  }
  /**
   * Returns the concatenation of all inline data parts from the first candidate
   * in the response.
   *
   * @remarks
   * If there are multiple candidates in the response, the inline data from the
   * first one will be returned. If there are non-inline data parts in the
   * response, the concatenation of all inline data parts will be returned, and
   * a warning will be logged.
   */
  get data() {
    var _a3, _b, _c, _d, _e2, _f, _g, _h;
    if (((_d = (_c = (_b = (_a3 = this.candidates) === null || _a3 === void 0 ? void 0 : _a3[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
      return void 0;
    }
    if (this.candidates && this.candidates.length > 1) {
      console.warn("there are multiple candidates in the response, returning data from the first one.");
    }
    let data = "";
    const nonDataParts = [];
    for (const part of (_h = (_g = (_f = (_e2 = this.candidates) === null || _e2 === void 0 ? void 0 : _e2[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []) {
      for (const [fieldName, fieldValue] of Object.entries(part)) {
        if (fieldName !== "inlineData" && (fieldValue !== null || fieldValue !== void 0)) {
          nonDataParts.push(fieldName);
        }
      }
      if (part.inlineData && typeof part.inlineData.data === "string") {
        data += atob(part.inlineData.data);
      }
    }
    if (nonDataParts.length > 0) {
      console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);
    }
    return data.length > 0 ? btoa(data) : void 0;
  }
  /**
   * Returns the function calls from the first candidate in the response.
   *
   * @remarks
   * If there are multiple candidates in the response, the function calls from
   * the first one will be returned.
   * If there are no function calls in the response, undefined will be returned.
   *
   * @example
   * ```ts
   * const controlLightFunctionDeclaration: FunctionDeclaration = {
   *   name: 'controlLight',
   *   parameters: {
   *   type: Type.OBJECT,
   *   description: 'Set the brightness and color temperature of a room light.',
   *   properties: {
   *     brightness: {
   *       type: Type.NUMBER,
   *       description:
   *         'Light level from 0 to 100. Zero is off and 100 is full brightness.',
   *     },
   *     colorTemperature: {
   *       type: Type.STRING,
   *       description:
   *         'Color temperature of the light fixture which can be `daylight`, `cool` or `warm`.',
   *     },
   *   },
   *   required: ['brightness', 'colorTemperature'],
   *  };
   *  const response = await ai.models.generateContent({
   *     model: 'gemini-2.0-flash',
   *     contents: 'Dim the lights so the room feels cozy and warm.',
   *     config: {
   *       tools: [{functionDeclarations: [controlLightFunctionDeclaration]}],
   *       toolConfig: {
   *         functionCallingConfig: {
   *           mode: FunctionCallingConfigMode.ANY,
   *           allowedFunctionNames: ['controlLight'],
   *         },
   *       },
   *     },
   *   });
   *  console.debug(JSON.stringify(response.functionCalls));
   * ```
   */
  get functionCalls() {
    var _a3, _b, _c, _d, _e2, _f, _g, _h;
    if (((_d = (_c = (_b = (_a3 = this.candidates) === null || _a3 === void 0 ? void 0 : _a3[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
      return void 0;
    }
    if (this.candidates && this.candidates.length > 1) {
      console.warn("there are multiple candidates in the response, returning function calls from the first one.");
    }
    const functionCalls = (_h = (_g = (_f = (_e2 = this.candidates) === null || _e2 === void 0 ? void 0 : _e2[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.functionCall).map((part) => part.functionCall).filter((functionCall) => functionCall !== void 0);
    if ((functionCalls === null || functionCalls === void 0 ? void 0 : functionCalls.length) === 0) {
      return void 0;
    }
    return functionCalls;
  }
  /**
   * Returns the first executable code from the first candidate in the response.
   *
   * @remarks
   * If there are multiple candidates in the response, the executable code from
   * the first one will be returned.
   * If there are no executable code in the response, undefined will be
   * returned.
   *
   * @example
   * ```ts
   * const response = await ai.models.generateContent({
   *   model: 'gemini-2.0-flash',
   *   contents:
   *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'
   *   config: {
   *     tools: [{codeExecution: {}}],
   *   },
   * });
   *
   * console.debug(response.executableCode);
   * ```
   */
  get executableCode() {
    var _a3, _b, _c, _d, _e2, _f, _g, _h, _j;
    if (((_d = (_c = (_b = (_a3 = this.candidates) === null || _a3 === void 0 ? void 0 : _a3[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
      return void 0;
    }
    if (this.candidates && this.candidates.length > 1) {
      console.warn("there are multiple candidates in the response, returning executable code from the first one.");
    }
    const executableCode = (_h = (_g = (_f = (_e2 = this.candidates) === null || _e2 === void 0 ? void 0 : _e2[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.executableCode).map((part) => part.executableCode).filter((executableCode2) => executableCode2 !== void 0);
    if ((executableCode === null || executableCode === void 0 ? void 0 : executableCode.length) === 0) {
      return void 0;
    }
    return (_j = executableCode === null || executableCode === void 0 ? void 0 : executableCode[0]) === null || _j === void 0 ? void 0 : _j.code;
  }
  /**
   * Returns the first code execution result from the first candidate in the response.
   *
   * @remarks
   * If there are multiple candidates in the response, the code execution result from
   * the first one will be returned.
   * If there are no code execution result in the response, undefined will be returned.
   *
   * @example
   * ```ts
   * const response = await ai.models.generateContent({
   *   model: 'gemini-2.0-flash',
   *   contents:
   *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'
   *   config: {
   *     tools: [{codeExecution: {}}],
   *   },
   * });
   *
   * console.debug(response.codeExecutionResult);
   * ```
   */
  get codeExecutionResult() {
    var _a3, _b, _c, _d, _e2, _f, _g, _h, _j;
    if (((_d = (_c = (_b = (_a3 = this.candidates) === null || _a3 === void 0 ? void 0 : _a3[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
      return void 0;
    }
    if (this.candidates && this.candidates.length > 1) {
      console.warn("there are multiple candidates in the response, returning code execution result from the first one.");
    }
    const codeExecutionResult = (_h = (_g = (_f = (_e2 = this.candidates) === null || _e2 === void 0 ? void 0 : _e2[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.codeExecutionResult).map((part) => part.codeExecutionResult).filter((codeExecutionResult2) => codeExecutionResult2 !== void 0);
    if ((codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult.length) === 0) {
      return void 0;
    }
    return (_j = codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult[0]) === null || _j === void 0 ? void 0 : _j.output;
  }
};
var EmbedContentResponse = class {
};
var GenerateImagesResponse = class {
};
var EditImageResponse = class {
};
var UpscaleImageResponse = class {
};
var RecontextImageResponse = class {
};
var ListModelsResponse = class {
};
var DeleteModelResponse = class {
};
var CountTokensResponse = class {
};
var ComputeTokensResponse = class {
};
var GenerateVideosResponse = class {
};
var ListTuningJobsResponse = class {
};
var DeleteCachedContentResponse = class {
};
var ListCachedContentsResponse = class {
};
var ListFilesResponse = class {
};
var CreateFileResponse = class {
};
var DeleteFileResponse = class {
};
var ListBatchJobsResponse = class {
};
var LiveServerMessage = class {
  /**
   * Returns the concatenation of all text parts from the server content if present.
   *
   * @remarks
   * If there are non-text parts in the response, the concatenation of all text
   * parts will be returned, and a warning will be logged.
   */
  get text() {
    var _a3, _b, _c;
    let text = "";
    let anyTextPartFound = false;
    const nonTextParts = [];
    for (const part of (_c = (_b = (_a3 = this.serverContent) === null || _a3 === void 0 ? void 0 : _a3.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []) {
      for (const [fieldName, fieldValue] of Object.entries(part)) {
        if (fieldName !== "text" && fieldName !== "thought" && fieldValue !== null) {
          nonTextParts.push(fieldName);
        }
      }
      if (typeof part.text === "string") {
        if (typeof part.thought === "boolean" && part.thought) {
          continue;
        }
        anyTextPartFound = true;
        text += part.text;
      }
    }
    if (nonTextParts.length > 0) {
      console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);
    }
    return anyTextPartFound ? text : void 0;
  }
  /**
   * Returns the concatenation of all inline data parts from the server content if present.
   *
   * @remarks
   * If there are non-inline data parts in the
   * response, the concatenation of all inline data parts will be returned, and
   * a warning will be logged.
   */
  get data() {
    var _a3, _b, _c;
    let data = "";
    const nonDataParts = [];
    for (const part of (_c = (_b = (_a3 = this.serverContent) === null || _a3 === void 0 ? void 0 : _a3.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []) {
      for (const [fieldName, fieldValue] of Object.entries(part)) {
        if (fieldName !== "inlineData" && fieldValue !== null) {
          nonDataParts.push(fieldName);
        }
      }
      if (part.inlineData && typeof part.inlineData.data === "string") {
        data += atob(part.inlineData.data);
      }
    }
    if (nonDataParts.length > 0) {
      console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);
    }
    return data.length > 0 ? btoa(data) : void 0;
  }
};
var GenerateVideosOperation = class _GenerateVideosOperation {
  /**
   * Instantiates an Operation of the same type as the one being called with the fields set from the API response.
   * @internal
   */
  _fromAPIResponse({ apiResponse, isVertexAI }) {
    const operation = new _GenerateVideosOperation();
    operation.name = apiResponse["name"];
    operation.metadata = apiResponse["metadata"];
    operation.done = apiResponse["done"];
    operation.error = apiResponse["error"];
    if (isVertexAI) {
      const response = apiResponse["response"];
      if (response) {
        const operationResponse = new GenerateVideosResponse();
        const responseVideos = response["videos"];
        operationResponse.generatedVideos = responseVideos === null || responseVideos === void 0 ? void 0 : responseVideos.map((generatedVideo) => {
          return {
            video: {
              uri: generatedVideo["gcsUri"],
              videoBytes: generatedVideo["bytesBase64Encoded"] ? tBytes$1(generatedVideo["bytesBase64Encoded"]) : void 0,
              mimeType: generatedVideo["mimeType"]
            }
          };
        });
        operationResponse.raiMediaFilteredCount = response["raiMediaFilteredCount"];
        operationResponse.raiMediaFilteredReasons = response["raiMediaFilteredReasons"];
        operation.response = operationResponse;
      }
    } else {
      const response = apiResponse["response"];
      if (response) {
        const operationResponse = new GenerateVideosResponse();
        const generatedVideoResponse = response["generateVideoResponse"];
        const responseVideos = generatedVideoResponse === null || generatedVideoResponse === void 0 ? void 0 : generatedVideoResponse["generatedSamples"];
        operationResponse.generatedVideos = responseVideos === null || responseVideos === void 0 ? void 0 : responseVideos.map((generatedVideo) => {
          const video = generatedVideo["video"];
          return {
            video: {
              uri: video === null || video === void 0 ? void 0 : video["uri"],
              videoBytes: (video === null || video === void 0 ? void 0 : video["encodedVideo"]) ? tBytes$1(video === null || video === void 0 ? void 0 : video["encodedVideo"]) : void 0,
              mimeType: generatedVideo["encoding"]
            }
          };
        });
        operationResponse.raiMediaFilteredCount = generatedVideoResponse === null || generatedVideoResponse === void 0 ? void 0 : generatedVideoResponse["raiMediaFilteredCount"];
        operationResponse.raiMediaFilteredReasons = generatedVideoResponse === null || generatedVideoResponse === void 0 ? void 0 : generatedVideoResponse["raiMediaFilteredReasons"];
        operation.response = operationResponse;
      }
    }
    return operation;
  }
};
var LiveMusicServerMessage = class {
  /**
   * Returns the first audio chunk from the server content, if present.
   *
   * @remarks
   * If there are no audio chunks in the response, undefined will be returned.
   */
  get audioChunk() {
    if (this.serverContent && this.serverContent.audioChunks && this.serverContent.audioChunks.length > 0) {
      return this.serverContent.audioChunks[0];
    }
    return void 0;
  }
};
function tModel(apiClient, model) {
  if (!model || typeof model !== "string") {
    throw new Error("model is required and must be a string");
  }
  if (apiClient.isVertexAI()) {
    if (model.startsWith("publishers/") || model.startsWith("projects/") || model.startsWith("models/")) {
      return model;
    } else if (model.indexOf("/") >= 0) {
      const parts = model.split("/", 2);
      return `publishers/${parts[0]}/models/${parts[1]}`;
    } else {
      return `publishers/google/models/${model}`;
    }
  } else {
    if (model.startsWith("models/") || model.startsWith("tunedModels/")) {
      return model;
    } else {
      return `models/${model}`;
    }
  }
}
function tCachesModel(apiClient, model) {
  const transformedModel = tModel(apiClient, model);
  if (!transformedModel) {
    return "";
  }
  if (transformedModel.startsWith("publishers/") && apiClient.isVertexAI()) {
    return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/${transformedModel}`;
  } else if (transformedModel.startsWith("models/") && apiClient.isVertexAI()) {
    return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/publishers/google/${transformedModel}`;
  } else {
    return transformedModel;
  }
}
function tBlobs(blobs) {
  if (Array.isArray(blobs)) {
    return blobs.map((blob) => tBlob(blob));
  } else {
    return [tBlob(blobs)];
  }
}
function tBlob(blob) {
  if (typeof blob === "object" && blob !== null) {
    return blob;
  }
  throw new Error(`Could not parse input as Blob. Unsupported blob type: ${typeof blob}`);
}
function tImageBlob(blob) {
  const transformedBlob = tBlob(blob);
  if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith("image/")) {
    return transformedBlob;
  }
  throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);
}
function tAudioBlob(blob) {
  const transformedBlob = tBlob(blob);
  if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith("audio/")) {
    return transformedBlob;
  }
  throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);
}
function tPart(origin) {
  if (origin === null || origin === void 0) {
    throw new Error("PartUnion is required");
  }
  if (typeof origin === "object") {
    return origin;
  }
  if (typeof origin === "string") {
    return { text: origin };
  }
  throw new Error(`Unsupported part type: ${typeof origin}`);
}
function tParts(origin) {
  if (origin === null || origin === void 0 || Array.isArray(origin) && origin.length === 0) {
    throw new Error("PartListUnion is required");
  }
  if (Array.isArray(origin)) {
    return origin.map((item) => tPart(item));
  }
  return [tPart(origin)];
}
function _isContent(origin) {
  return origin !== null && origin !== void 0 && typeof origin === "object" && "parts" in origin && Array.isArray(origin.parts);
}
function _isFunctionCallPart(origin) {
  return origin !== null && origin !== void 0 && typeof origin === "object" && "functionCall" in origin;
}
function _isFunctionResponsePart(origin) {
  return origin !== null && origin !== void 0 && typeof origin === "object" && "functionResponse" in origin;
}
function tContent(origin) {
  if (origin === null || origin === void 0) {
    throw new Error("ContentUnion is required");
  }
  if (_isContent(origin)) {
    return origin;
  }
  return {
    role: "user",
    parts: tParts(origin)
  };
}
function tContentsForEmbed(apiClient, origin) {
  if (!origin) {
    return [];
  }
  if (apiClient.isVertexAI() && Array.isArray(origin)) {
    return origin.flatMap((item) => {
      const content = tContent(item);
      if (content.parts && content.parts.length > 0 && content.parts[0].text !== void 0) {
        return [content.parts[0].text];
      }
      return [];
    });
  } else if (apiClient.isVertexAI()) {
    const content = tContent(origin);
    if (content.parts && content.parts.length > 0 && content.parts[0].text !== void 0) {
      return [content.parts[0].text];
    }
    return [];
  }
  if (Array.isArray(origin)) {
    return origin.map((item) => tContent(item));
  }
  return [tContent(origin)];
}
function tContents(origin) {
  if (origin === null || origin === void 0 || Array.isArray(origin) && origin.length === 0) {
    throw new Error("contents are required");
  }
  if (!Array.isArray(origin)) {
    if (_isFunctionCallPart(origin) || _isFunctionResponsePart(origin)) {
      throw new Error("To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them");
    }
    return [tContent(origin)];
  }
  const result = [];
  const accumulatedParts = [];
  const isContentArray = _isContent(origin[0]);
  for (const item of origin) {
    const isContent = _isContent(item);
    if (isContent != isContentArray) {
      throw new Error("Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them");
    }
    if (isContent) {
      result.push(item);
    } else if (_isFunctionCallPart(item) || _isFunctionResponsePart(item)) {
      throw new Error("To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them");
    } else {
      accumulatedParts.push(item);
    }
  }
  if (!isContentArray) {
    result.push({ role: "user", parts: tParts(accumulatedParts) });
  }
  return result;
}
function flattenTypeArrayToAnyOf(typeList, resultingSchema) {
  if (typeList.includes("null")) {
    resultingSchema["nullable"] = true;
  }
  const listWithoutNull = typeList.filter((type) => type !== "null");
  if (listWithoutNull.length === 1) {
    resultingSchema["type"] = Object.values(Type).includes(listWithoutNull[0].toUpperCase()) ? listWithoutNull[0].toUpperCase() : Type.TYPE_UNSPECIFIED;
  } else {
    resultingSchema["anyOf"] = [];
    for (const i2 of listWithoutNull) {
      resultingSchema["anyOf"].push({
        "type": Object.values(Type).includes(i2.toUpperCase()) ? i2.toUpperCase() : Type.TYPE_UNSPECIFIED
      });
    }
  }
}
function processJsonSchema(_jsonSchema) {
  const genAISchema = {};
  const schemaFieldNames = ["items"];
  const listSchemaFieldNames = ["anyOf"];
  const dictSchemaFieldNames = ["properties"];
  if (_jsonSchema["type"] && _jsonSchema["anyOf"]) {
    throw new Error("type and anyOf cannot be both populated.");
  }
  const incomingAnyOf = _jsonSchema["anyOf"];
  if (incomingAnyOf != null && incomingAnyOf.length == 2) {
    if (incomingAnyOf[0]["type"] === "null") {
      genAISchema["nullable"] = true;
      _jsonSchema = incomingAnyOf[1];
    } else if (incomingAnyOf[1]["type"] === "null") {
      genAISchema["nullable"] = true;
      _jsonSchema = incomingAnyOf[0];
    }
  }
  if (_jsonSchema["type"] instanceof Array) {
    flattenTypeArrayToAnyOf(_jsonSchema["type"], genAISchema);
  }
  for (const [fieldName, fieldValue] of Object.entries(_jsonSchema)) {
    if (fieldValue == null) {
      continue;
    }
    if (fieldName == "type") {
      if (fieldValue === "null") {
        throw new Error("type: null can not be the only possible type for the field.");
      }
      if (fieldValue instanceof Array) {
        continue;
      }
      genAISchema["type"] = Object.values(Type).includes(fieldValue.toUpperCase()) ? fieldValue.toUpperCase() : Type.TYPE_UNSPECIFIED;
    } else if (schemaFieldNames.includes(fieldName)) {
      genAISchema[fieldName] = processJsonSchema(fieldValue);
    } else if (listSchemaFieldNames.includes(fieldName)) {
      const listSchemaFieldValue = [];
      for (const item of fieldValue) {
        if (item["type"] == "null") {
          genAISchema["nullable"] = true;
          continue;
        }
        listSchemaFieldValue.push(processJsonSchema(item));
      }
      genAISchema[fieldName] = listSchemaFieldValue;
    } else if (dictSchemaFieldNames.includes(fieldName)) {
      const dictSchemaFieldValue = {};
      for (const [key, value] of Object.entries(fieldValue)) {
        dictSchemaFieldValue[key] = processJsonSchema(value);
      }
      genAISchema[fieldName] = dictSchemaFieldValue;
    } else {
      if (fieldName === "additionalProperties") {
        continue;
      }
      genAISchema[fieldName] = fieldValue;
    }
  }
  return genAISchema;
}
function tSchema(schema) {
  return processJsonSchema(schema);
}
function tSpeechConfig(speechConfig) {
  if (typeof speechConfig === "object") {
    return speechConfig;
  } else if (typeof speechConfig === "string") {
    return {
      voiceConfig: {
        prebuiltVoiceConfig: {
          voiceName: speechConfig
        }
      }
    };
  } else {
    throw new Error(`Unsupported speechConfig type: ${typeof speechConfig}`);
  }
}
function tLiveSpeechConfig(speechConfig) {
  if ("multiSpeakerVoiceConfig" in speechConfig) {
    throw new Error("multiSpeakerVoiceConfig is not supported in the live API.");
  }
  return speechConfig;
}
function tTool(tool) {
  if (tool.functionDeclarations) {
    for (const functionDeclaration of tool.functionDeclarations) {
      if (functionDeclaration.parameters) {
        if (!Object.keys(functionDeclaration.parameters).includes("$schema")) {
          functionDeclaration.parameters = processJsonSchema(functionDeclaration.parameters);
        } else {
          if (!functionDeclaration.parametersJsonSchema) {
            functionDeclaration.parametersJsonSchema = functionDeclaration.parameters;
            delete functionDeclaration.parameters;
          }
        }
      }
      if (functionDeclaration.response) {
        if (!Object.keys(functionDeclaration.response).includes("$schema")) {
          functionDeclaration.response = processJsonSchema(functionDeclaration.response);
        } else {
          if (!functionDeclaration.responseJsonSchema) {
            functionDeclaration.responseJsonSchema = functionDeclaration.response;
            delete functionDeclaration.response;
          }
        }
      }
    }
  }
  return tool;
}
function tTools(tools) {
  if (tools === void 0 || tools === null) {
    throw new Error("tools is required");
  }
  if (!Array.isArray(tools)) {
    throw new Error("tools is required and must be an array of Tools");
  }
  const result = [];
  for (const tool of tools) {
    result.push(tool);
  }
  return result;
}
function resourceName(client, resourceName2, resourcePrefix, splitsAfterPrefix = 1) {
  const shouldAppendPrefix = !resourceName2.startsWith(`${resourcePrefix}/`) && resourceName2.split("/").length === splitsAfterPrefix;
  if (client.isVertexAI()) {
    if (resourceName2.startsWith("projects/")) {
      return resourceName2;
    } else if (resourceName2.startsWith("locations/")) {
      return `projects/${client.getProject()}/${resourceName2}`;
    } else if (resourceName2.startsWith(`${resourcePrefix}/`)) {
      return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourceName2}`;
    } else if (shouldAppendPrefix) {
      return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourcePrefix}/${resourceName2}`;
    } else {
      return resourceName2;
    }
  }
  if (shouldAppendPrefix) {
    return `${resourcePrefix}/${resourceName2}`;
  }
  return resourceName2;
}
function tCachedContentName(apiClient, name) {
  if (typeof name !== "string") {
    throw new Error("name must be a string");
  }
  return resourceName(apiClient, name, "cachedContents");
}
function tTuningJobStatus(status) {
  switch (status) {
    case "STATE_UNSPECIFIED":
      return "JOB_STATE_UNSPECIFIED";
    case "CREATING":
      return "JOB_STATE_RUNNING";
    case "ACTIVE":
      return "JOB_STATE_SUCCEEDED";
    case "FAILED":
      return "JOB_STATE_FAILED";
    default:
      return status;
  }
}
function tBytes(fromImageBytes) {
  return tBytes$1(fromImageBytes);
}
function _isFile(origin) {
  return origin !== null && origin !== void 0 && typeof origin === "object" && "name" in origin;
}
function isGeneratedVideo(origin) {
  return origin !== null && origin !== void 0 && typeof origin === "object" && "video" in origin;
}
function isVideo(origin) {
  return origin !== null && origin !== void 0 && typeof origin === "object" && "uri" in origin;
}
function tFileName(fromName) {
  var _a3;
  let name;
  if (_isFile(fromName)) {
    name = fromName.name;
  }
  if (isVideo(fromName)) {
    name = fromName.uri;
    if (name === void 0) {
      return void 0;
    }
  }
  if (isGeneratedVideo(fromName)) {
    name = (_a3 = fromName.video) === null || _a3 === void 0 ? void 0 : _a3.uri;
    if (name === void 0) {
      return void 0;
    }
  }
  if (typeof fromName === "string") {
    name = fromName;
  }
  if (name === void 0) {
    throw new Error("Could not extract file name from the provided input.");
  }
  if (name.startsWith("https://")) {
    const suffix = name.split("files/")[1];
    const match7 = suffix.match(/[a-z0-9]+/);
    if (match7 === null) {
      throw new Error(`Could not extract file name from URI ${name}`);
    }
    name = match7[0];
  } else if (name.startsWith("files/")) {
    name = name.split("files/")[1];
  }
  return name;
}
function tModelsUrl(apiClient, baseModels) {
  let res;
  if (apiClient.isVertexAI()) {
    res = baseModels ? "publishers/google/models" : "models";
  } else {
    res = baseModels ? "models" : "tunedModels";
  }
  return res;
}
function tExtractModels(response) {
  for (const key of ["models", "tunedModels", "publisherModels"]) {
    if (hasField(response, key)) {
      return response[key];
    }
  }
  return [];
}
function hasField(data, fieldName) {
  return data !== null && typeof data === "object" && fieldName in data;
}
function mcpToGeminiTool(mcpTool, config = {}) {
  const mcpToolSchema = mcpTool;
  const functionDeclaration = {
    name: mcpToolSchema["name"],
    description: mcpToolSchema["description"],
    parametersJsonSchema: mcpToolSchema["inputSchema"]
  };
  if (config.behavior) {
    functionDeclaration["behavior"] = config.behavior;
  }
  const geminiTool = {
    functionDeclarations: [
      functionDeclaration
    ]
  };
  return geminiTool;
}
function mcpToolsToGeminiTool(mcpTools, config = {}) {
  const functionDeclarations = [];
  const toolNames = /* @__PURE__ */ new Set();
  for (const mcpTool of mcpTools) {
    const mcpToolName = mcpTool.name;
    if (toolNames.has(mcpToolName)) {
      throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);
    }
    toolNames.add(mcpToolName);
    const geminiTool = mcpToGeminiTool(mcpTool, config);
    if (geminiTool.functionDeclarations) {
      functionDeclarations.push(...geminiTool.functionDeclarations);
    }
  }
  return { functionDeclarations };
}
function tBatchJobSource(apiClient, src) {
  if (typeof src !== "string" && !Array.isArray(src)) {
    if (apiClient && apiClient.isVertexAI()) {
      if (src.gcsUri && src.bigqueryUri) {
        throw new Error("Only one of `gcsUri` or `bigqueryUri` can be set.");
      } else if (!src.gcsUri && !src.bigqueryUri) {
        throw new Error("One of `gcsUri` or `bigqueryUri` must be set.");
      }
    } else {
      if (src.inlinedRequests && src.fileName) {
        throw new Error("Only one of `inlinedRequests` or `fileName` can be set.");
      } else if (!src.inlinedRequests && !src.fileName) {
        throw new Error("One of `inlinedRequests` or `fileName` must be set.");
      }
    }
    return src;
  } else if (Array.isArray(src)) {
    return { inlinedRequests: src };
  } else if (typeof src === "string") {
    if (src.startsWith("gs://")) {
      return {
        format: "jsonl",
        gcsUri: [src]
        // GCS URI is expected as an array
      };
    } else if (src.startsWith("bq://")) {
      return {
        format: "bigquery",
        bigqueryUri: src
      };
    } else if (src.startsWith("files/")) {
      return {
        fileName: src
      };
    }
  }
  throw new Error(`Unsupported source: ${src}`);
}
function tBatchJobDestination(dest) {
  if (typeof dest !== "string") {
    return dest;
  }
  const destString = dest;
  if (destString.startsWith("gs://")) {
    return {
      format: "jsonl",
      gcsUri: destString
    };
  } else if (destString.startsWith("bq://")) {
    return {
      format: "bigquery",
      bigqueryUri: destString
    };
  } else {
    throw new Error(`Unsupported destination: ${destString}`);
  }
}
function tBatchJobName(apiClient, name) {
  const nameString = name;
  if (!apiClient.isVertexAI()) {
    const mldevPattern = /batches\/[^/]+$/;
    if (mldevPattern.test(nameString)) {
      return nameString.split("/").pop();
    } else {
      throw new Error(`Invalid batch job name: ${nameString}.`);
    }
  }
  const vertexPattern = /^projects\/[^/]+\/locations\/[^/]+\/batchPredictionJobs\/[^/]+$/;
  if (vertexPattern.test(nameString)) {
    return nameString.split("/").pop();
  } else if (/^\d+$/.test(nameString)) {
    return nameString;
  } else {
    throw new Error(`Invalid batch job name: ${nameString}.`);
  }
}
function tJobState(state) {
  const stateString = state;
  if (stateString === "BATCH_STATE_UNSPECIFIED") {
    return "JOB_STATE_UNSPECIFIED";
  } else if (stateString === "BATCH_STATE_PENDING") {
    return "JOB_STATE_PENDING";
  } else if (stateString === "BATCH_STATE_SUCCEEDED") {
    return "JOB_STATE_SUCCEEDED";
  } else if (stateString === "BATCH_STATE_FAILED") {
    return "JOB_STATE_FAILED";
  } else if (stateString === "BATCH_STATE_CANCELLED") {
    return "JOB_STATE_CANCELLED";
  } else {
    return stateString;
  }
}
function videoMetadataToMldev$4(fromObject) {
  const toObject = {};
  const fromFps = getValueByPath(fromObject, ["fps"]);
  if (fromFps != null) {
    setValueByPath(toObject, ["fps"], fromFps);
  }
  const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
  if (fromEndOffset != null) {
    setValueByPath(toObject, ["endOffset"], fromEndOffset);
  }
  const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
  if (fromStartOffset != null) {
    setValueByPath(toObject, ["startOffset"], fromStartOffset);
  }
  return toObject;
}
function blobToMldev$4(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function fileDataToMldev$4(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function partToMldev$4(fromObject) {
  const toObject = {};
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], videoMetadataToMldev$4(fromVideoMetadata));
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobToMldev$4(fromInlineData));
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataToMldev$4(fromFileData));
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], fromFunctionCall);
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  return toObject;
}
function contentToMldev$4(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partToMldev$4(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function schemaToMldev$1(fromObject) {
  const toObject = {};
  const fromAnyOf = getValueByPath(fromObject, ["anyOf"]);
  if (fromAnyOf != null) {
    setValueByPath(toObject, ["anyOf"], fromAnyOf);
  }
  const fromDefault = getValueByPath(fromObject, ["default"]);
  if (fromDefault != null) {
    setValueByPath(toObject, ["default"], fromDefault);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromEnum = getValueByPath(fromObject, ["enum"]);
  if (fromEnum != null) {
    setValueByPath(toObject, ["enum"], fromEnum);
  }
  const fromExample = getValueByPath(fromObject, ["example"]);
  if (fromExample != null) {
    setValueByPath(toObject, ["example"], fromExample);
  }
  const fromFormat = getValueByPath(fromObject, ["format"]);
  if (fromFormat != null) {
    setValueByPath(toObject, ["format"], fromFormat);
  }
  const fromItems = getValueByPath(fromObject, ["items"]);
  if (fromItems != null) {
    setValueByPath(toObject, ["items"], fromItems);
  }
  const fromMaxItems = getValueByPath(fromObject, ["maxItems"]);
  if (fromMaxItems != null) {
    setValueByPath(toObject, ["maxItems"], fromMaxItems);
  }
  const fromMaxLength = getValueByPath(fromObject, ["maxLength"]);
  if (fromMaxLength != null) {
    setValueByPath(toObject, ["maxLength"], fromMaxLength);
  }
  const fromMaxProperties = getValueByPath(fromObject, [
    "maxProperties"
  ]);
  if (fromMaxProperties != null) {
    setValueByPath(toObject, ["maxProperties"], fromMaxProperties);
  }
  const fromMaximum = getValueByPath(fromObject, ["maximum"]);
  if (fromMaximum != null) {
    setValueByPath(toObject, ["maximum"], fromMaximum);
  }
  const fromMinItems = getValueByPath(fromObject, ["minItems"]);
  if (fromMinItems != null) {
    setValueByPath(toObject, ["minItems"], fromMinItems);
  }
  const fromMinLength = getValueByPath(fromObject, ["minLength"]);
  if (fromMinLength != null) {
    setValueByPath(toObject, ["minLength"], fromMinLength);
  }
  const fromMinProperties = getValueByPath(fromObject, [
    "minProperties"
  ]);
  if (fromMinProperties != null) {
    setValueByPath(toObject, ["minProperties"], fromMinProperties);
  }
  const fromMinimum = getValueByPath(fromObject, ["minimum"]);
  if (fromMinimum != null) {
    setValueByPath(toObject, ["minimum"], fromMinimum);
  }
  const fromNullable = getValueByPath(fromObject, ["nullable"]);
  if (fromNullable != null) {
    setValueByPath(toObject, ["nullable"], fromNullable);
  }
  const fromPattern = getValueByPath(fromObject, ["pattern"]);
  if (fromPattern != null) {
    setValueByPath(toObject, ["pattern"], fromPattern);
  }
  const fromProperties = getValueByPath(fromObject, ["properties"]);
  if (fromProperties != null) {
    setValueByPath(toObject, ["properties"], fromProperties);
  }
  const fromPropertyOrdering = getValueByPath(fromObject, [
    "propertyOrdering"
  ]);
  if (fromPropertyOrdering != null) {
    setValueByPath(toObject, ["propertyOrdering"], fromPropertyOrdering);
  }
  const fromRequired = getValueByPath(fromObject, ["required"]);
  if (fromRequired != null) {
    setValueByPath(toObject, ["required"], fromRequired);
  }
  const fromTitle = getValueByPath(fromObject, ["title"]);
  if (fromTitle != null) {
    setValueByPath(toObject, ["title"], fromTitle);
  }
  const fromType = getValueByPath(fromObject, ["type"]);
  if (fromType != null) {
    setValueByPath(toObject, ["type"], fromType);
  }
  return toObject;
}
function safetySettingToMldev$1(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["method"]) !== void 0) {
    throw new Error("method parameter is not supported in Gemini API.");
  }
  const fromCategory = getValueByPath(fromObject, ["category"]);
  if (fromCategory != null) {
    setValueByPath(toObject, ["category"], fromCategory);
  }
  const fromThreshold = getValueByPath(fromObject, ["threshold"]);
  if (fromThreshold != null) {
    setValueByPath(toObject, ["threshold"], fromThreshold);
  }
  return toObject;
}
function functionDeclarationToMldev$4(fromObject) {
  const toObject = {};
  const fromBehavior = getValueByPath(fromObject, ["behavior"]);
  if (fromBehavior != null) {
    setValueByPath(toObject, ["behavior"], fromBehavior);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromParameters = getValueByPath(fromObject, ["parameters"]);
  if (fromParameters != null) {
    setValueByPath(toObject, ["parameters"], fromParameters);
  }
  const fromParametersJsonSchema = getValueByPath(fromObject, [
    "parametersJsonSchema"
  ]);
  if (fromParametersJsonSchema != null) {
    setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], fromResponse);
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  return toObject;
}
function intervalToMldev$4(fromObject) {
  const toObject = {};
  const fromStartTime = getValueByPath(fromObject, ["startTime"]);
  if (fromStartTime != null) {
    setValueByPath(toObject, ["startTime"], fromStartTime);
  }
  const fromEndTime = getValueByPath(fromObject, ["endTime"]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  return toObject;
}
function googleSearchToMldev$4(fromObject) {
  const toObject = {};
  const fromTimeRangeFilter = getValueByPath(fromObject, [
    "timeRangeFilter"
  ]);
  if (fromTimeRangeFilter != null) {
    setValueByPath(toObject, ["timeRangeFilter"], intervalToMldev$4(fromTimeRangeFilter));
  }
  return toObject;
}
function dynamicRetrievalConfigToMldev$4(fromObject) {
  const toObject = {};
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  const fromDynamicThreshold = getValueByPath(fromObject, [
    "dynamicThreshold"
  ]);
  if (fromDynamicThreshold != null) {
    setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
  }
  return toObject;
}
function googleSearchRetrievalToMldev$4(fromObject) {
  const toObject = {};
  const fromDynamicRetrievalConfig = getValueByPath(fromObject, [
    "dynamicRetrievalConfig"
  ]);
  if (fromDynamicRetrievalConfig != null) {
    setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToMldev$4(fromDynamicRetrievalConfig));
  }
  return toObject;
}
function urlContextToMldev$4() {
  const toObject = {};
  return toObject;
}
function toolToMldev$4(fromObject) {
  const toObject = {};
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return functionDeclarationToMldev$4(item);
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
    throw new Error("retrieval parameter is not supported in Gemini API.");
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$4(fromGoogleSearch));
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToMldev$4(fromGoogleSearchRetrieval));
  }
  if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
    throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["googleMaps"]) !== void 0) {
    throw new Error("googleMaps parameter is not supported in Gemini API.");
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], urlContextToMldev$4());
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  return toObject;
}
function functionCallingConfigToMldev$2(fromObject) {
  const toObject = {};
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  const fromAllowedFunctionNames = getValueByPath(fromObject, [
    "allowedFunctionNames"
  ]);
  if (fromAllowedFunctionNames != null) {
    setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
  }
  return toObject;
}
function latLngToMldev$2(fromObject) {
  const toObject = {};
  const fromLatitude = getValueByPath(fromObject, ["latitude"]);
  if (fromLatitude != null) {
    setValueByPath(toObject, ["latitude"], fromLatitude);
  }
  const fromLongitude = getValueByPath(fromObject, ["longitude"]);
  if (fromLongitude != null) {
    setValueByPath(toObject, ["longitude"], fromLongitude);
  }
  return toObject;
}
function retrievalConfigToMldev$2(fromObject) {
  const toObject = {};
  const fromLatLng = getValueByPath(fromObject, ["latLng"]);
  if (fromLatLng != null) {
    setValueByPath(toObject, ["latLng"], latLngToMldev$2(fromLatLng));
  }
  const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
  if (fromLanguageCode != null) {
    setValueByPath(toObject, ["languageCode"], fromLanguageCode);
  }
  return toObject;
}
function toolConfigToMldev$2(fromObject) {
  const toObject = {};
  const fromFunctionCallingConfig = getValueByPath(fromObject, [
    "functionCallingConfig"
  ]);
  if (fromFunctionCallingConfig != null) {
    setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev$2(fromFunctionCallingConfig));
  }
  const fromRetrievalConfig = getValueByPath(fromObject, [
    "retrievalConfig"
  ]);
  if (fromRetrievalConfig != null) {
    setValueByPath(toObject, ["retrievalConfig"], retrievalConfigToMldev$2(fromRetrievalConfig));
  }
  return toObject;
}
function prebuiltVoiceConfigToMldev$3(fromObject) {
  const toObject = {};
  const fromVoiceName = getValueByPath(fromObject, ["voiceName"]);
  if (fromVoiceName != null) {
    setValueByPath(toObject, ["voiceName"], fromVoiceName);
  }
  return toObject;
}
function voiceConfigToMldev$3(fromObject) {
  const toObject = {};
  const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [
    "prebuiltVoiceConfig"
  ]);
  if (fromPrebuiltVoiceConfig != null) {
    setValueByPath(toObject, ["prebuiltVoiceConfig"], prebuiltVoiceConfigToMldev$3(fromPrebuiltVoiceConfig));
  }
  return toObject;
}
function speakerVoiceConfigToMldev$3(fromObject) {
  const toObject = {};
  const fromSpeaker = getValueByPath(fromObject, ["speaker"]);
  if (fromSpeaker != null) {
    setValueByPath(toObject, ["speaker"], fromSpeaker);
  }
  const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
  if (fromVoiceConfig != null) {
    setValueByPath(toObject, ["voiceConfig"], voiceConfigToMldev$3(fromVoiceConfig));
  }
  return toObject;
}
function multiSpeakerVoiceConfigToMldev$3(fromObject) {
  const toObject = {};
  const fromSpeakerVoiceConfigs = getValueByPath(fromObject, [
    "speakerVoiceConfigs"
  ]);
  if (fromSpeakerVoiceConfigs != null) {
    let transformedList = fromSpeakerVoiceConfigs;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return speakerVoiceConfigToMldev$3(item);
      });
    }
    setValueByPath(toObject, ["speakerVoiceConfigs"], transformedList);
  }
  return toObject;
}
function speechConfigToMldev$3(fromObject) {
  const toObject = {};
  const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
  if (fromVoiceConfig != null) {
    setValueByPath(toObject, ["voiceConfig"], voiceConfigToMldev$3(fromVoiceConfig));
  }
  const fromMultiSpeakerVoiceConfig = getValueByPath(fromObject, [
    "multiSpeakerVoiceConfig"
  ]);
  if (fromMultiSpeakerVoiceConfig != null) {
    setValueByPath(toObject, ["multiSpeakerVoiceConfig"], multiSpeakerVoiceConfigToMldev$3(fromMultiSpeakerVoiceConfig));
  }
  const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
  if (fromLanguageCode != null) {
    setValueByPath(toObject, ["languageCode"], fromLanguageCode);
  }
  return toObject;
}
function thinkingConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromIncludeThoughts = getValueByPath(fromObject, [
    "includeThoughts"
  ]);
  if (fromIncludeThoughts != null) {
    setValueByPath(toObject, ["includeThoughts"], fromIncludeThoughts);
  }
  const fromThinkingBudget = getValueByPath(fromObject, [
    "thinkingBudget"
  ]);
  if (fromThinkingBudget != null) {
    setValueByPath(toObject, ["thinkingBudget"], fromThinkingBudget);
  }
  return toObject;
}
function generateContentConfigToMldev$1(apiClient, fromObject, parentObject) {
  const toObject = {};
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== void 0 && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["systemInstruction"], contentToMldev$4(tContent(fromSystemInstruction)));
  }
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (fromTemperature != null) {
    setValueByPath(toObject, ["temperature"], fromTemperature);
  }
  const fromTopP = getValueByPath(fromObject, ["topP"]);
  if (fromTopP != null) {
    setValueByPath(toObject, ["topP"], fromTopP);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (fromTopK != null) {
    setValueByPath(toObject, ["topK"], fromTopK);
  }
  const fromCandidateCount = getValueByPath(fromObject, [
    "candidateCount"
  ]);
  if (fromCandidateCount != null) {
    setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
  }
  const fromMaxOutputTokens = getValueByPath(fromObject, [
    "maxOutputTokens"
  ]);
  if (fromMaxOutputTokens != null) {
    setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
  }
  const fromStopSequences = getValueByPath(fromObject, [
    "stopSequences"
  ]);
  if (fromStopSequences != null) {
    setValueByPath(toObject, ["stopSequences"], fromStopSequences);
  }
  const fromResponseLogprobs = getValueByPath(fromObject, [
    "responseLogprobs"
  ]);
  if (fromResponseLogprobs != null) {
    setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
  }
  const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
  if (fromLogprobs != null) {
    setValueByPath(toObject, ["logprobs"], fromLogprobs);
  }
  const fromPresencePenalty = getValueByPath(fromObject, [
    "presencePenalty"
  ]);
  if (fromPresencePenalty != null) {
    setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
  }
  const fromFrequencyPenalty = getValueByPath(fromObject, [
    "frequencyPenalty"
  ]);
  if (fromFrequencyPenalty != null) {
    setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (fromSeed != null) {
    setValueByPath(toObject, ["seed"], fromSeed);
  }
  const fromResponseMimeType = getValueByPath(fromObject, [
    "responseMimeType"
  ]);
  if (fromResponseMimeType != null) {
    setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
  }
  const fromResponseSchema = getValueByPath(fromObject, [
    "responseSchema"
  ]);
  if (fromResponseSchema != null) {
    setValueByPath(toObject, ["responseSchema"], schemaToMldev$1(tSchema(fromResponseSchema)));
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  if (getValueByPath(fromObject, ["routingConfig"]) !== void 0) {
    throw new Error("routingConfig parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["modelSelectionConfig"]) !== void 0) {
    throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");
  }
  const fromSafetySettings = getValueByPath(fromObject, [
    "safetySettings"
  ]);
  if (parentObject !== void 0 && fromSafetySettings != null) {
    let transformedList = fromSafetySettings;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return safetySettingToMldev$1(item);
      });
    }
    setValueByPath(parentObject, ["safetySettings"], transformedList);
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== void 0 && fromTools != null) {
    let transformedList = tTools(fromTools);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToMldev$4(tTool(item));
      });
    }
    setValueByPath(parentObject, ["tools"], transformedList);
  }
  const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
  if (parentObject !== void 0 && fromToolConfig != null) {
    setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev$2(fromToolConfig));
  }
  if (getValueByPath(fromObject, ["labels"]) !== void 0) {
    throw new Error("labels parameter is not supported in Gemini API.");
  }
  const fromCachedContent = getValueByPath(fromObject, [
    "cachedContent"
  ]);
  if (parentObject !== void 0 && fromCachedContent != null) {
    setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
  }
  const fromResponseModalities = getValueByPath(fromObject, [
    "responseModalities"
  ]);
  if (fromResponseModalities != null) {
    setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
  }
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (fromMediaResolution != null) {
    setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
  }
  const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
  if (fromSpeechConfig != null) {
    setValueByPath(toObject, ["speechConfig"], speechConfigToMldev$3(tSpeechConfig(fromSpeechConfig)));
  }
  if (getValueByPath(fromObject, ["audioTimestamp"]) !== void 0) {
    throw new Error("audioTimestamp parameter is not supported in Gemini API.");
  }
  const fromThinkingConfig = getValueByPath(fromObject, [
    "thinkingConfig"
  ]);
  if (fromThinkingConfig != null) {
    setValueByPath(toObject, ["thinkingConfig"], thinkingConfigToMldev$1(fromThinkingConfig));
  }
  return toObject;
}
function inlinedRequestToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["request", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return contentToMldev$4(item);
      });
    }
    setValueByPath(toObject, ["request", "contents"], transformedList);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["request", "generationConfig"], generateContentConfigToMldev$1(apiClient, fromConfig, toObject));
  }
  return toObject;
}
function batchJobSourceToMldev(apiClient, fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["format"]) !== void 0) {
    throw new Error("format parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["gcsUri"]) !== void 0) {
    throw new Error("gcsUri parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["bigqueryUri"]) !== void 0) {
    throw new Error("bigqueryUri parameter is not supported in Gemini API.");
  }
  const fromFileName = getValueByPath(fromObject, ["fileName"]);
  if (fromFileName != null) {
    setValueByPath(toObject, ["fileName"], fromFileName);
  }
  const fromInlinedRequests = getValueByPath(fromObject, [
    "inlinedRequests"
  ]);
  if (fromInlinedRequests != null) {
    let transformedList = fromInlinedRequests;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return inlinedRequestToMldev(apiClient, item);
      });
    }
    setValueByPath(toObject, ["requests", "requests"], transformedList);
  }
  return toObject;
}
function createBatchJobConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (parentObject !== void 0 && fromDisplayName != null) {
    setValueByPath(parentObject, ["batch", "displayName"], fromDisplayName);
  }
  if (getValueByPath(fromObject, ["dest"]) !== void 0) {
    throw new Error("dest parameter is not supported in Gemini API.");
  }
  return toObject;
}
function createBatchJobParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromSrc = getValueByPath(fromObject, ["src"]);
  if (fromSrc != null) {
    setValueByPath(toObject, ["batch", "inputConfig"], batchJobSourceToMldev(apiClient, tBatchJobSource(apiClient, fromSrc)));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], createBatchJobConfigToMldev(fromConfig, toObject));
  }
  return toObject;
}
function getBatchJobParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function cancelBatchJobParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function listBatchJobsConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  if (getValueByPath(fromObject, ["filter"]) !== void 0) {
    throw new Error("filter parameter is not supported in Gemini API.");
  }
  return toObject;
}
function listBatchJobsParametersToMldev(fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], listBatchJobsConfigToMldev(fromConfig, toObject));
  }
  return toObject;
}
function deleteBatchJobParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function batchJobSourceToVertex(fromObject) {
  const toObject = {};
  const fromFormat = getValueByPath(fromObject, ["format"]);
  if (fromFormat != null) {
    setValueByPath(toObject, ["instancesFormat"], fromFormat);
  }
  const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
  if (fromGcsUri != null) {
    setValueByPath(toObject, ["gcsSource", "uris"], fromGcsUri);
  }
  const fromBigqueryUri = getValueByPath(fromObject, ["bigqueryUri"]);
  if (fromBigqueryUri != null) {
    setValueByPath(toObject, ["bigquerySource", "inputUri"], fromBigqueryUri);
  }
  if (getValueByPath(fromObject, ["fileName"]) !== void 0) {
    throw new Error("fileName parameter is not supported in Vertex AI.");
  }
  if (getValueByPath(fromObject, ["inlinedRequests"]) !== void 0) {
    throw new Error("inlinedRequests parameter is not supported in Vertex AI.");
  }
  return toObject;
}
function batchJobDestinationToVertex(fromObject) {
  const toObject = {};
  const fromFormat = getValueByPath(fromObject, ["format"]);
  if (fromFormat != null) {
    setValueByPath(toObject, ["predictionsFormat"], fromFormat);
  }
  const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
  if (fromGcsUri != null) {
    setValueByPath(toObject, ["gcsDestination", "outputUriPrefix"], fromGcsUri);
  }
  const fromBigqueryUri = getValueByPath(fromObject, ["bigqueryUri"]);
  if (fromBigqueryUri != null) {
    setValueByPath(toObject, ["bigqueryDestination", "outputUri"], fromBigqueryUri);
  }
  if (getValueByPath(fromObject, ["fileName"]) !== void 0) {
    throw new Error("fileName parameter is not supported in Vertex AI.");
  }
  if (getValueByPath(fromObject, ["inlinedResponses"]) !== void 0) {
    throw new Error("inlinedResponses parameter is not supported in Vertex AI.");
  }
  return toObject;
}
function createBatchJobConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (parentObject !== void 0 && fromDisplayName != null) {
    setValueByPath(parentObject, ["displayName"], fromDisplayName);
  }
  const fromDest = getValueByPath(fromObject, ["dest"]);
  if (parentObject !== void 0 && fromDest != null) {
    setValueByPath(parentObject, ["outputConfig"], batchJobDestinationToVertex(tBatchJobDestination(fromDest)));
  }
  return toObject;
}
function createBatchJobParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], tModel(apiClient, fromModel));
  }
  const fromSrc = getValueByPath(fromObject, ["src"]);
  if (fromSrc != null) {
    setValueByPath(toObject, ["inputConfig"], batchJobSourceToVertex(tBatchJobSource(apiClient, fromSrc)));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], createBatchJobConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function getBatchJobParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function cancelBatchJobParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function listBatchJobsConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  const fromFilter = getValueByPath(fromObject, ["filter"]);
  if (parentObject !== void 0 && fromFilter != null) {
    setValueByPath(parentObject, ["_query", "filter"], fromFilter);
  }
  return toObject;
}
function listBatchJobsParametersToVertex(fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], listBatchJobsConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function deleteBatchJobParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function videoMetadataFromMldev$2(fromObject) {
  const toObject = {};
  const fromFps = getValueByPath(fromObject, ["fps"]);
  if (fromFps != null) {
    setValueByPath(toObject, ["fps"], fromFps);
  }
  const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
  if (fromEndOffset != null) {
    setValueByPath(toObject, ["endOffset"], fromEndOffset);
  }
  const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
  if (fromStartOffset != null) {
    setValueByPath(toObject, ["startOffset"], fromStartOffset);
  }
  return toObject;
}
function blobFromMldev$2(fromObject) {
  const toObject = {};
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function fileDataFromMldev$2(fromObject) {
  const toObject = {};
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function partFromMldev$2(fromObject) {
  const toObject = {};
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], videoMetadataFromMldev$2(fromVideoMetadata));
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobFromMldev$2(fromInlineData));
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataFromMldev$2(fromFileData));
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], fromFunctionCall);
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  return toObject;
}
function contentFromMldev$2(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partFromMldev$2(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function citationMetadataFromMldev$1(fromObject) {
  const toObject = {};
  const fromCitations = getValueByPath(fromObject, ["citationSources"]);
  if (fromCitations != null) {
    setValueByPath(toObject, ["citations"], fromCitations);
  }
  return toObject;
}
function urlMetadataFromMldev$2(fromObject) {
  const toObject = {};
  const fromRetrievedUrl = getValueByPath(fromObject, ["retrievedUrl"]);
  if (fromRetrievedUrl != null) {
    setValueByPath(toObject, ["retrievedUrl"], fromRetrievedUrl);
  }
  const fromUrlRetrievalStatus = getValueByPath(fromObject, [
    "urlRetrievalStatus"
  ]);
  if (fromUrlRetrievalStatus != null) {
    setValueByPath(toObject, ["urlRetrievalStatus"], fromUrlRetrievalStatus);
  }
  return toObject;
}
function urlContextMetadataFromMldev$2(fromObject) {
  const toObject = {};
  const fromUrlMetadata = getValueByPath(fromObject, ["urlMetadata"]);
  if (fromUrlMetadata != null) {
    let transformedList = fromUrlMetadata;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return urlMetadataFromMldev$2(item);
      });
    }
    setValueByPath(toObject, ["urlMetadata"], transformedList);
  }
  return toObject;
}
function candidateFromMldev$1(fromObject) {
  const toObject = {};
  const fromContent = getValueByPath(fromObject, ["content"]);
  if (fromContent != null) {
    setValueByPath(toObject, ["content"], contentFromMldev$2(fromContent));
  }
  const fromCitationMetadata = getValueByPath(fromObject, [
    "citationMetadata"
  ]);
  if (fromCitationMetadata != null) {
    setValueByPath(toObject, ["citationMetadata"], citationMetadataFromMldev$1(fromCitationMetadata));
  }
  const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
  if (fromTokenCount != null) {
    setValueByPath(toObject, ["tokenCount"], fromTokenCount);
  }
  const fromFinishReason = getValueByPath(fromObject, ["finishReason"]);
  if (fromFinishReason != null) {
    setValueByPath(toObject, ["finishReason"], fromFinishReason);
  }
  const fromUrlContextMetadata = getValueByPath(fromObject, [
    "urlContextMetadata"
  ]);
  if (fromUrlContextMetadata != null) {
    setValueByPath(toObject, ["urlContextMetadata"], urlContextMetadataFromMldev$2(fromUrlContextMetadata));
  }
  const fromAvgLogprobs = getValueByPath(fromObject, ["avgLogprobs"]);
  if (fromAvgLogprobs != null) {
    setValueByPath(toObject, ["avgLogprobs"], fromAvgLogprobs);
  }
  const fromGroundingMetadata = getValueByPath(fromObject, [
    "groundingMetadata"
  ]);
  if (fromGroundingMetadata != null) {
    setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
  }
  const fromIndex = getValueByPath(fromObject, ["index"]);
  if (fromIndex != null) {
    setValueByPath(toObject, ["index"], fromIndex);
  }
  const fromLogprobsResult = getValueByPath(fromObject, [
    "logprobsResult"
  ]);
  if (fromLogprobsResult != null) {
    setValueByPath(toObject, ["logprobsResult"], fromLogprobsResult);
  }
  const fromSafetyRatings = getValueByPath(fromObject, [
    "safetyRatings"
  ]);
  if (fromSafetyRatings != null) {
    setValueByPath(toObject, ["safetyRatings"], fromSafetyRatings);
  }
  return toObject;
}
function generateContentResponseFromMldev$1(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromCandidates = getValueByPath(fromObject, ["candidates"]);
  if (fromCandidates != null) {
    let transformedList = fromCandidates;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return candidateFromMldev$1(item);
      });
    }
    setValueByPath(toObject, ["candidates"], transformedList);
  }
  const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
  if (fromModelVersion != null) {
    setValueByPath(toObject, ["modelVersion"], fromModelVersion);
  }
  const fromPromptFeedback = getValueByPath(fromObject, [
    "promptFeedback"
  ]);
  if (fromPromptFeedback != null) {
    setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
  }
  const fromResponseId = getValueByPath(fromObject, ["responseId"]);
  if (fromResponseId != null) {
    setValueByPath(toObject, ["responseId"], fromResponseId);
  }
  const fromUsageMetadata = getValueByPath(fromObject, [
    "usageMetadata"
  ]);
  if (fromUsageMetadata != null) {
    setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
  }
  return toObject;
}
function jobErrorFromMldev(fromObject) {
  const toObject = {};
  const fromDetails = getValueByPath(fromObject, ["details"]);
  if (fromDetails != null) {
    setValueByPath(toObject, ["details"], fromDetails);
  }
  const fromCode = getValueByPath(fromObject, ["code"]);
  if (fromCode != null) {
    setValueByPath(toObject, ["code"], fromCode);
  }
  const fromMessage = getValueByPath(fromObject, ["message"]);
  if (fromMessage != null) {
    setValueByPath(toObject, ["message"], fromMessage);
  }
  return toObject;
}
function inlinedResponseFromMldev(fromObject) {
  const toObject = {};
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], generateContentResponseFromMldev$1(fromResponse));
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], jobErrorFromMldev(fromError));
  }
  return toObject;
}
function batchJobDestinationFromMldev(fromObject) {
  const toObject = {};
  const fromFileName = getValueByPath(fromObject, ["responsesFile"]);
  if (fromFileName != null) {
    setValueByPath(toObject, ["fileName"], fromFileName);
  }
  const fromInlinedResponses = getValueByPath(fromObject, [
    "inlinedResponses",
    "inlinedResponses"
  ]);
  if (fromInlinedResponses != null) {
    let transformedList = fromInlinedResponses;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return inlinedResponseFromMldev(item);
      });
    }
    setValueByPath(toObject, ["inlinedResponses"], transformedList);
  }
  return toObject;
}
function batchJobFromMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDisplayName = getValueByPath(fromObject, [
    "metadata",
    "displayName"
  ]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromState = getValueByPath(fromObject, ["metadata", "state"]);
  if (fromState != null) {
    setValueByPath(toObject, ["state"], tJobState(fromState));
  }
  const fromCreateTime = getValueByPath(fromObject, [
    "metadata",
    "createTime"
  ]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromEndTime = getValueByPath(fromObject, [
    "metadata",
    "endTime"
  ]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, [
    "metadata",
    "updateTime"
  ]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  const fromModel = getValueByPath(fromObject, ["metadata", "model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], fromModel);
  }
  const fromDest = getValueByPath(fromObject, ["metadata", "output"]);
  if (fromDest != null) {
    setValueByPath(toObject, ["dest"], batchJobDestinationFromMldev(fromDest));
  }
  return toObject;
}
function listBatchJobsResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromBatchJobs = getValueByPath(fromObject, ["operations"]);
  if (fromBatchJobs != null) {
    let transformedList = fromBatchJobs;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return batchJobFromMldev(item);
      });
    }
    setValueByPath(toObject, ["batchJobs"], transformedList);
  }
  return toObject;
}
function deleteResourceJobFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDone = getValueByPath(fromObject, ["done"]);
  if (fromDone != null) {
    setValueByPath(toObject, ["done"], fromDone);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], jobErrorFromMldev(fromError));
  }
  return toObject;
}
function jobErrorFromVertex(fromObject) {
  const toObject = {};
  const fromDetails = getValueByPath(fromObject, ["details"]);
  if (fromDetails != null) {
    setValueByPath(toObject, ["details"], fromDetails);
  }
  const fromCode = getValueByPath(fromObject, ["code"]);
  if (fromCode != null) {
    setValueByPath(toObject, ["code"], fromCode);
  }
  const fromMessage = getValueByPath(fromObject, ["message"]);
  if (fromMessage != null) {
    setValueByPath(toObject, ["message"], fromMessage);
  }
  return toObject;
}
function batchJobSourceFromVertex(fromObject) {
  const toObject = {};
  const fromFormat = getValueByPath(fromObject, ["instancesFormat"]);
  if (fromFormat != null) {
    setValueByPath(toObject, ["format"], fromFormat);
  }
  const fromGcsUri = getValueByPath(fromObject, ["gcsSource", "uris"]);
  if (fromGcsUri != null) {
    setValueByPath(toObject, ["gcsUri"], fromGcsUri);
  }
  const fromBigqueryUri = getValueByPath(fromObject, [
    "bigquerySource",
    "inputUri"
  ]);
  if (fromBigqueryUri != null) {
    setValueByPath(toObject, ["bigqueryUri"], fromBigqueryUri);
  }
  return toObject;
}
function batchJobDestinationFromVertex(fromObject) {
  const toObject = {};
  const fromFormat = getValueByPath(fromObject, ["predictionsFormat"]);
  if (fromFormat != null) {
    setValueByPath(toObject, ["format"], fromFormat);
  }
  const fromGcsUri = getValueByPath(fromObject, [
    "gcsDestination",
    "outputUriPrefix"
  ]);
  if (fromGcsUri != null) {
    setValueByPath(toObject, ["gcsUri"], fromGcsUri);
  }
  const fromBigqueryUri = getValueByPath(fromObject, [
    "bigqueryDestination",
    "outputUri"
  ]);
  if (fromBigqueryUri != null) {
    setValueByPath(toObject, ["bigqueryUri"], fromBigqueryUri);
  }
  return toObject;
}
function batchJobFromVertex(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromState = getValueByPath(fromObject, ["state"]);
  if (fromState != null) {
    setValueByPath(toObject, ["state"], tJobState(fromState));
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], jobErrorFromVertex(fromError));
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromStartTime = getValueByPath(fromObject, ["startTime"]);
  if (fromStartTime != null) {
    setValueByPath(toObject, ["startTime"], fromStartTime);
  }
  const fromEndTime = getValueByPath(fromObject, ["endTime"]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], fromModel);
  }
  const fromSrc = getValueByPath(fromObject, ["inputConfig"]);
  if (fromSrc != null) {
    setValueByPath(toObject, ["src"], batchJobSourceFromVertex(fromSrc));
  }
  const fromDest = getValueByPath(fromObject, ["outputConfig"]);
  if (fromDest != null) {
    setValueByPath(toObject, ["dest"], batchJobDestinationFromVertex(fromDest));
  }
  return toObject;
}
function listBatchJobsResponseFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromBatchJobs = getValueByPath(fromObject, [
    "batchPredictionJobs"
  ]);
  if (fromBatchJobs != null) {
    let transformedList = fromBatchJobs;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return batchJobFromVertex(item);
      });
    }
    setValueByPath(toObject, ["batchJobs"], transformedList);
  }
  return toObject;
}
function deleteResourceJobFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDone = getValueByPath(fromObject, ["done"]);
  if (fromDone != null) {
    setValueByPath(toObject, ["done"], fromDone);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], jobErrorFromVertex(fromError));
  }
  return toObject;
}
var PagedItem;
(function(PagedItem2) {
  PagedItem2["PAGED_ITEM_BATCH_JOBS"] = "batchJobs";
  PagedItem2["PAGED_ITEM_MODELS"] = "models";
  PagedItem2["PAGED_ITEM_TUNING_JOBS"] = "tuningJobs";
  PagedItem2["PAGED_ITEM_FILES"] = "files";
  PagedItem2["PAGED_ITEM_CACHED_CONTENTS"] = "cachedContents";
})(PagedItem || (PagedItem = {}));
var Pager = class {
  constructor(name, request, response, params) {
    this.pageInternal = [];
    this.paramsInternal = {};
    this.requestInternal = request;
    this.init(name, response, params);
  }
  init(name, response, params) {
    var _a3, _b;
    this.nameInternal = name;
    this.pageInternal = response[this.nameInternal] || [];
    this.sdkHttpResponseInternal = response === null || response === void 0 ? void 0 : response.sdkHttpResponse;
    this.idxInternal = 0;
    let requestParams = { config: {} };
    if (!params || Object.keys(params).length === 0) {
      requestParams = { config: {} };
    } else if (typeof params === "object") {
      requestParams = Object.assign({}, params);
    } else {
      requestParams = params;
    }
    if (requestParams["config"]) {
      requestParams["config"]["pageToken"] = response["nextPageToken"];
    }
    this.paramsInternal = requestParams;
    this.pageInternalSize = (_b = (_a3 = requestParams["config"]) === null || _a3 === void 0 ? void 0 : _a3["pageSize"]) !== null && _b !== void 0 ? _b : this.pageInternal.length;
  }
  initNextPage(response) {
    this.init(this.nameInternal, response, this.paramsInternal);
  }
  /**
   * Returns the current page, which is a list of items.
   *
   * @remarks
   * The first page is retrieved when the pager is created. The returned list of
   * items could be a subset of the entire list.
   */
  get page() {
    return this.pageInternal;
  }
  /**
   * Returns the type of paged item (for example, ``batch_jobs``).
   */
  get name() {
    return this.nameInternal;
  }
  /**
   * Returns the length of the page fetched each time by this pager.
   *
   * @remarks
   * The number of items in the page is less than or equal to the page length.
   */
  get pageSize() {
    return this.pageInternalSize;
  }
  /**
   * Returns the headers of the API response.
   */
  get sdkHttpResponse() {
    return this.sdkHttpResponseInternal;
  }
  /**
   * Returns the parameters when making the API request for the next page.
   *
   * @remarks
   * Parameters contain a set of optional configs that can be
   * used to customize the API request. For example, the `pageToken` parameter
   * contains the token to request the next page.
   */
  get params() {
    return this.paramsInternal;
  }
  /**
   * Returns the total number of items in the current page.
   */
  get pageLength() {
    return this.pageInternal.length;
  }
  /**
   * Returns the item at the given index.
   */
  getItem(index) {
    return this.pageInternal[index];
  }
  /**
   * Returns an async iterator that support iterating through all items
   * retrieved from the API.
   *
   * @remarks
   * The iterator will automatically fetch the next page if there are more items
   * to fetch from the API.
   *
   * @example
   *
   * ```ts
   * const pager = await ai.files.list({config: {pageSize: 10}});
   * for await (const file of pager) {
   *   console.log(file.name);
   * }
   * ```
   */
  [Symbol.asyncIterator]() {
    return {
      next: async () => {
        if (this.idxInternal >= this.pageLength) {
          if (this.hasNextPage()) {
            await this.nextPage();
          } else {
            return { value: void 0, done: true };
          }
        }
        const item = this.getItem(this.idxInternal);
        this.idxInternal += 1;
        return { value: item, done: false };
      },
      return: async () => {
        return { value: void 0, done: true };
      }
    };
  }
  /**
   * Fetches the next page of items. This makes a new API request.
   *
   * @throws {Error} If there are no more pages to fetch.
   *
   * @example
   *
   * ```ts
   * const pager = await ai.files.list({config: {pageSize: 10}});
   * let page = pager.page;
   * while (true) {
   *   for (const file of page) {
   *     console.log(file.name);
   *   }
   *   if (!pager.hasNextPage()) {
   *     break;
   *   }
   *   page = await pager.nextPage();
   * }
   * ```
   */
  async nextPage() {
    if (!this.hasNextPage()) {
      throw new Error("No more pages to fetch.");
    }
    const response = await this.requestInternal(this.params);
    this.initNextPage(response);
    return this.page;
  }
  /**
   * Returns true if there are more pages to fetch from the API.
   */
  hasNextPage() {
    var _a3;
    if (((_a3 = this.params["config"]) === null || _a3 === void 0 ? void 0 : _a3["pageToken"]) !== void 0) {
      return true;
    }
    return false;
  }
};
var Batches3 = class extends BaseModule {
  constructor(apiClient) {
    super();
    this.apiClient = apiClient;
    this.create = async (params) => {
      if (this.apiClient.isVertexAI()) {
        const timestamp = Date.now();
        const timestampStr = timestamp.toString();
        if (Array.isArray(params.src)) {
          throw new Error("InlinedRequest[] is not supported in Vertex AI. Please use Google Cloud Storage URI or BigQuery URI instead.");
        }
        params.config = params.config || {};
        if (params.config.displayName === void 0) {
          params.config.displayName = "genaiBatchJob_${timestampStr}";
        }
        if (params.config.dest === void 0 && typeof params.src === "string") {
          if (params.src.startsWith("gs://") && params.src.endsWith(".jsonl")) {
            params.config.dest = `${params.src.slice(0, -6)}/dest`;
          } else if (params.src.startsWith("bq://")) {
            params.config.dest = `${params.src}_dest_${timestampStr}`;
          } else {
            throw new Error("Unsupported source:" + params.src);
          }
        }
      }
      return await this.createInternal(params);
    };
    this.list = async (params = {}) => {
      return new Pager(PagedItem.PAGED_ITEM_BATCH_JOBS, (x2) => this.listInternal(x2), await this.listInternal(params), params);
    };
  }
  /**
   * Internal method to create batch job.
   *
   * @param params - The parameters for create batch job request.
   * @return The created batch job.
   *
   */
  async createInternal(params) {
    var _a3, _b, _c, _d;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = createBatchJobParametersToVertex(this.apiClient, params);
      path2 = formatMap("batchPredictionJobs", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = batchJobFromVertex(apiResponse);
        return resp;
      });
    } else {
      const body = createBatchJobParametersToMldev(this.apiClient, params);
      path2 = formatMap("{model}:batchGenerateContent", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = batchJobFromMldev(apiResponse);
        return resp;
      });
    }
  }
  /**
   * Gets batch job configurations.
   *
   * @param params - The parameters for the get request.
   * @return The batch job.
   *
   * @example
   * ```ts
   * await ai.batches.get({name: '...'}); // The server-generated resource name.
   * ```
   */
  async get(params) {
    var _a3, _b, _c, _d;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = getBatchJobParametersToVertex(this.apiClient, params);
      path2 = formatMap("batchPredictionJobs/{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = batchJobFromVertex(apiResponse);
        return resp;
      });
    } else {
      const body = getBatchJobParametersToMldev(this.apiClient, params);
      path2 = formatMap("batches/{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = batchJobFromMldev(apiResponse);
        return resp;
      });
    }
  }
  /**
   * Cancels a batch job.
   *
   * @param params - The parameters for the cancel request.
   * @return The empty response returned by the API.
   *
   * @example
   * ```ts
   * await ai.batches.cancel({name: '...'}); // The server-generated resource name.
   * ```
   */
  async cancel(params) {
    var _a3, _b, _c, _d;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = cancelBatchJobParametersToVertex(this.apiClient, params);
      path2 = formatMap("batchPredictionJobs/{name}:cancel", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      await this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      });
    } else {
      const body = cancelBatchJobParametersToMldev(this.apiClient, params);
      path2 = formatMap("batches/{name}:cancel", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      await this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      });
    }
  }
  async listInternal(params) {
    var _a3, _b, _c, _d;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = listBatchJobsParametersToVertex(params);
      path2 = formatMap("batchPredictionJobs", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = listBatchJobsResponseFromVertex(apiResponse);
        const typedResp = new ListBatchJobsResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = listBatchJobsParametersToMldev(params);
      path2 = formatMap("batches", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = listBatchJobsResponseFromMldev(apiResponse);
        const typedResp = new ListBatchJobsResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  /**
   * Deletes a batch job.
   *
   * @param params - The parameters for the delete request.
   * @return The empty response returned by the API.
   *
   * @example
   * ```ts
   * await ai.batches.delete({name: '...'}); // The server-generated resource name.
   * ```
   */
  async delete(params) {
    var _a3, _b, _c, _d;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = deleteBatchJobParametersToVertex(this.apiClient, params);
      path2 = formatMap("batchPredictionJobs/{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "DELETE",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = deleteResourceJobFromVertex(apiResponse);
        return resp;
      });
    } else {
      const body = deleteBatchJobParametersToMldev(this.apiClient, params);
      path2 = formatMap("batches/{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "DELETE",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = deleteResourceJobFromMldev(apiResponse);
        return resp;
      });
    }
  }
};
function videoMetadataToMldev$3(fromObject) {
  const toObject = {};
  const fromFps = getValueByPath(fromObject, ["fps"]);
  if (fromFps != null) {
    setValueByPath(toObject, ["fps"], fromFps);
  }
  const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
  if (fromEndOffset != null) {
    setValueByPath(toObject, ["endOffset"], fromEndOffset);
  }
  const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
  if (fromStartOffset != null) {
    setValueByPath(toObject, ["startOffset"], fromStartOffset);
  }
  return toObject;
}
function blobToMldev$3(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function fileDataToMldev$3(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function partToMldev$3(fromObject) {
  const toObject = {};
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], videoMetadataToMldev$3(fromVideoMetadata));
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobToMldev$3(fromInlineData));
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataToMldev$3(fromFileData));
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], fromFunctionCall);
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  return toObject;
}
function contentToMldev$3(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partToMldev$3(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function functionDeclarationToMldev$3(fromObject) {
  const toObject = {};
  const fromBehavior = getValueByPath(fromObject, ["behavior"]);
  if (fromBehavior != null) {
    setValueByPath(toObject, ["behavior"], fromBehavior);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromParameters = getValueByPath(fromObject, ["parameters"]);
  if (fromParameters != null) {
    setValueByPath(toObject, ["parameters"], fromParameters);
  }
  const fromParametersJsonSchema = getValueByPath(fromObject, [
    "parametersJsonSchema"
  ]);
  if (fromParametersJsonSchema != null) {
    setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], fromResponse);
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  return toObject;
}
function intervalToMldev$3(fromObject) {
  const toObject = {};
  const fromStartTime = getValueByPath(fromObject, ["startTime"]);
  if (fromStartTime != null) {
    setValueByPath(toObject, ["startTime"], fromStartTime);
  }
  const fromEndTime = getValueByPath(fromObject, ["endTime"]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  return toObject;
}
function googleSearchToMldev$3(fromObject) {
  const toObject = {};
  const fromTimeRangeFilter = getValueByPath(fromObject, [
    "timeRangeFilter"
  ]);
  if (fromTimeRangeFilter != null) {
    setValueByPath(toObject, ["timeRangeFilter"], intervalToMldev$3(fromTimeRangeFilter));
  }
  return toObject;
}
function dynamicRetrievalConfigToMldev$3(fromObject) {
  const toObject = {};
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  const fromDynamicThreshold = getValueByPath(fromObject, [
    "dynamicThreshold"
  ]);
  if (fromDynamicThreshold != null) {
    setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
  }
  return toObject;
}
function googleSearchRetrievalToMldev$3(fromObject) {
  const toObject = {};
  const fromDynamicRetrievalConfig = getValueByPath(fromObject, [
    "dynamicRetrievalConfig"
  ]);
  if (fromDynamicRetrievalConfig != null) {
    setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToMldev$3(fromDynamicRetrievalConfig));
  }
  return toObject;
}
function urlContextToMldev$3() {
  const toObject = {};
  return toObject;
}
function toolToMldev$3(fromObject) {
  const toObject = {};
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return functionDeclarationToMldev$3(item);
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
    throw new Error("retrieval parameter is not supported in Gemini API.");
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$3(fromGoogleSearch));
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToMldev$3(fromGoogleSearchRetrieval));
  }
  if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
    throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["googleMaps"]) !== void 0) {
    throw new Error("googleMaps parameter is not supported in Gemini API.");
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], urlContextToMldev$3());
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  return toObject;
}
function functionCallingConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  const fromAllowedFunctionNames = getValueByPath(fromObject, [
    "allowedFunctionNames"
  ]);
  if (fromAllowedFunctionNames != null) {
    setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
  }
  return toObject;
}
function latLngToMldev$1(fromObject) {
  const toObject = {};
  const fromLatitude = getValueByPath(fromObject, ["latitude"]);
  if (fromLatitude != null) {
    setValueByPath(toObject, ["latitude"], fromLatitude);
  }
  const fromLongitude = getValueByPath(fromObject, ["longitude"]);
  if (fromLongitude != null) {
    setValueByPath(toObject, ["longitude"], fromLongitude);
  }
  return toObject;
}
function retrievalConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromLatLng = getValueByPath(fromObject, ["latLng"]);
  if (fromLatLng != null) {
    setValueByPath(toObject, ["latLng"], latLngToMldev$1(fromLatLng));
  }
  const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
  if (fromLanguageCode != null) {
    setValueByPath(toObject, ["languageCode"], fromLanguageCode);
  }
  return toObject;
}
function toolConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromFunctionCallingConfig = getValueByPath(fromObject, [
    "functionCallingConfig"
  ]);
  if (fromFunctionCallingConfig != null) {
    setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev$1(fromFunctionCallingConfig));
  }
  const fromRetrievalConfig = getValueByPath(fromObject, [
    "retrievalConfig"
  ]);
  if (fromRetrievalConfig != null) {
    setValueByPath(toObject, ["retrievalConfig"], retrievalConfigToMldev$1(fromRetrievalConfig));
  }
  return toObject;
}
function createCachedContentConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromTtl = getValueByPath(fromObject, ["ttl"]);
  if (parentObject !== void 0 && fromTtl != null) {
    setValueByPath(parentObject, ["ttl"], fromTtl);
  }
  const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
  if (parentObject !== void 0 && fromExpireTime != null) {
    setValueByPath(parentObject, ["expireTime"], fromExpireTime);
  }
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (parentObject !== void 0 && fromDisplayName != null) {
    setValueByPath(parentObject, ["displayName"], fromDisplayName);
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (parentObject !== void 0 && fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return contentToMldev$3(item);
      });
    }
    setValueByPath(parentObject, ["contents"], transformedList);
  }
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== void 0 && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["systemInstruction"], contentToMldev$3(tContent(fromSystemInstruction)));
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== void 0 && fromTools != null) {
    let transformedList = fromTools;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToMldev$3(item);
      });
    }
    setValueByPath(parentObject, ["tools"], transformedList);
  }
  const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
  if (parentObject !== void 0 && fromToolConfig != null) {
    setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev$1(fromToolConfig));
  }
  if (getValueByPath(fromObject, ["kmsKeyName"]) !== void 0) {
    throw new Error("kmsKeyName parameter is not supported in Gemini API.");
  }
  return toObject;
}
function createCachedContentParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], tCachesModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], createCachedContentConfigToMldev(fromConfig, toObject));
  }
  return toObject;
}
function getCachedContentParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function deleteCachedContentParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function updateCachedContentConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromTtl = getValueByPath(fromObject, ["ttl"]);
  if (parentObject !== void 0 && fromTtl != null) {
    setValueByPath(parentObject, ["ttl"], fromTtl);
  }
  const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
  if (parentObject !== void 0 && fromExpireTime != null) {
    setValueByPath(parentObject, ["expireTime"], fromExpireTime);
  }
  return toObject;
}
function updateCachedContentParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], updateCachedContentConfigToMldev(fromConfig, toObject));
  }
  return toObject;
}
function listCachedContentsConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  return toObject;
}
function listCachedContentsParametersToMldev(fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], listCachedContentsConfigToMldev(fromConfig, toObject));
  }
  return toObject;
}
function videoMetadataToVertex$2(fromObject) {
  const toObject = {};
  const fromFps = getValueByPath(fromObject, ["fps"]);
  if (fromFps != null) {
    setValueByPath(toObject, ["fps"], fromFps);
  }
  const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
  if (fromEndOffset != null) {
    setValueByPath(toObject, ["endOffset"], fromEndOffset);
  }
  const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
  if (fromStartOffset != null) {
    setValueByPath(toObject, ["startOffset"], fromStartOffset);
  }
  return toObject;
}
function blobToVertex$2(fromObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function fileDataToVertex$2(fromObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function partToVertex$2(fromObject) {
  const toObject = {};
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], videoMetadataToVertex$2(fromVideoMetadata));
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobToVertex$2(fromInlineData));
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataToVertex$2(fromFileData));
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], fromFunctionCall);
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  return toObject;
}
function contentToVertex$2(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partToVertex$2(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function functionDeclarationToVertex$2(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["behavior"]) !== void 0) {
    throw new Error("behavior parameter is not supported in Vertex AI.");
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromParameters = getValueByPath(fromObject, ["parameters"]);
  if (fromParameters != null) {
    setValueByPath(toObject, ["parameters"], fromParameters);
  }
  const fromParametersJsonSchema = getValueByPath(fromObject, [
    "parametersJsonSchema"
  ]);
  if (fromParametersJsonSchema != null) {
    setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], fromResponse);
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  return toObject;
}
function intervalToVertex$2(fromObject) {
  const toObject = {};
  const fromStartTime = getValueByPath(fromObject, ["startTime"]);
  if (fromStartTime != null) {
    setValueByPath(toObject, ["startTime"], fromStartTime);
  }
  const fromEndTime = getValueByPath(fromObject, ["endTime"]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  return toObject;
}
function googleSearchToVertex$2(fromObject) {
  const toObject = {};
  const fromTimeRangeFilter = getValueByPath(fromObject, [
    "timeRangeFilter"
  ]);
  if (fromTimeRangeFilter != null) {
    setValueByPath(toObject, ["timeRangeFilter"], intervalToVertex$2(fromTimeRangeFilter));
  }
  return toObject;
}
function dynamicRetrievalConfigToVertex$2(fromObject) {
  const toObject = {};
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  const fromDynamicThreshold = getValueByPath(fromObject, [
    "dynamicThreshold"
  ]);
  if (fromDynamicThreshold != null) {
    setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
  }
  return toObject;
}
function googleSearchRetrievalToVertex$2(fromObject) {
  const toObject = {};
  const fromDynamicRetrievalConfig = getValueByPath(fromObject, [
    "dynamicRetrievalConfig"
  ]);
  if (fromDynamicRetrievalConfig != null) {
    setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToVertex$2(fromDynamicRetrievalConfig));
  }
  return toObject;
}
function enterpriseWebSearchToVertex$2() {
  const toObject = {};
  return toObject;
}
function apiKeyConfigToVertex$2(fromObject) {
  const toObject = {};
  const fromApiKeyString = getValueByPath(fromObject, ["apiKeyString"]);
  if (fromApiKeyString != null) {
    setValueByPath(toObject, ["apiKeyString"], fromApiKeyString);
  }
  return toObject;
}
function authConfigToVertex$2(fromObject) {
  const toObject = {};
  const fromApiKeyConfig = getValueByPath(fromObject, ["apiKeyConfig"]);
  if (fromApiKeyConfig != null) {
    setValueByPath(toObject, ["apiKeyConfig"], apiKeyConfigToVertex$2(fromApiKeyConfig));
  }
  const fromAuthType = getValueByPath(fromObject, ["authType"]);
  if (fromAuthType != null) {
    setValueByPath(toObject, ["authType"], fromAuthType);
  }
  const fromGoogleServiceAccountConfig = getValueByPath(fromObject, [
    "googleServiceAccountConfig"
  ]);
  if (fromGoogleServiceAccountConfig != null) {
    setValueByPath(toObject, ["googleServiceAccountConfig"], fromGoogleServiceAccountConfig);
  }
  const fromHttpBasicAuthConfig = getValueByPath(fromObject, [
    "httpBasicAuthConfig"
  ]);
  if (fromHttpBasicAuthConfig != null) {
    setValueByPath(toObject, ["httpBasicAuthConfig"], fromHttpBasicAuthConfig);
  }
  const fromOauthConfig = getValueByPath(fromObject, ["oauthConfig"]);
  if (fromOauthConfig != null) {
    setValueByPath(toObject, ["oauthConfig"], fromOauthConfig);
  }
  const fromOidcConfig = getValueByPath(fromObject, ["oidcConfig"]);
  if (fromOidcConfig != null) {
    setValueByPath(toObject, ["oidcConfig"], fromOidcConfig);
  }
  return toObject;
}
function googleMapsToVertex$2(fromObject) {
  const toObject = {};
  const fromAuthConfig = getValueByPath(fromObject, ["authConfig"]);
  if (fromAuthConfig != null) {
    setValueByPath(toObject, ["authConfig"], authConfigToVertex$2(fromAuthConfig));
  }
  return toObject;
}
function urlContextToVertex$2() {
  const toObject = {};
  return toObject;
}
function toolToVertex$2(fromObject) {
  const toObject = {};
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return functionDeclarationToVertex$2(item);
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
  if (fromRetrieval != null) {
    setValueByPath(toObject, ["retrieval"], fromRetrieval);
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], googleSearchToVertex$2(fromGoogleSearch));
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToVertex$2(fromGoogleSearchRetrieval));
  }
  const fromEnterpriseWebSearch = getValueByPath(fromObject, [
    "enterpriseWebSearch"
  ]);
  if (fromEnterpriseWebSearch != null) {
    setValueByPath(toObject, ["enterpriseWebSearch"], enterpriseWebSearchToVertex$2());
  }
  const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
  if (fromGoogleMaps != null) {
    setValueByPath(toObject, ["googleMaps"], googleMapsToVertex$2(fromGoogleMaps));
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], urlContextToVertex$2());
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  return toObject;
}
function functionCallingConfigToVertex$1(fromObject) {
  const toObject = {};
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  const fromAllowedFunctionNames = getValueByPath(fromObject, [
    "allowedFunctionNames"
  ]);
  if (fromAllowedFunctionNames != null) {
    setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
  }
  return toObject;
}
function latLngToVertex$1(fromObject) {
  const toObject = {};
  const fromLatitude = getValueByPath(fromObject, ["latitude"]);
  if (fromLatitude != null) {
    setValueByPath(toObject, ["latitude"], fromLatitude);
  }
  const fromLongitude = getValueByPath(fromObject, ["longitude"]);
  if (fromLongitude != null) {
    setValueByPath(toObject, ["longitude"], fromLongitude);
  }
  return toObject;
}
function retrievalConfigToVertex$1(fromObject) {
  const toObject = {};
  const fromLatLng = getValueByPath(fromObject, ["latLng"]);
  if (fromLatLng != null) {
    setValueByPath(toObject, ["latLng"], latLngToVertex$1(fromLatLng));
  }
  const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
  if (fromLanguageCode != null) {
    setValueByPath(toObject, ["languageCode"], fromLanguageCode);
  }
  return toObject;
}
function toolConfigToVertex$1(fromObject) {
  const toObject = {};
  const fromFunctionCallingConfig = getValueByPath(fromObject, [
    "functionCallingConfig"
  ]);
  if (fromFunctionCallingConfig != null) {
    setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToVertex$1(fromFunctionCallingConfig));
  }
  const fromRetrievalConfig = getValueByPath(fromObject, [
    "retrievalConfig"
  ]);
  if (fromRetrievalConfig != null) {
    setValueByPath(toObject, ["retrievalConfig"], retrievalConfigToVertex$1(fromRetrievalConfig));
  }
  return toObject;
}
function createCachedContentConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromTtl = getValueByPath(fromObject, ["ttl"]);
  if (parentObject !== void 0 && fromTtl != null) {
    setValueByPath(parentObject, ["ttl"], fromTtl);
  }
  const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
  if (parentObject !== void 0 && fromExpireTime != null) {
    setValueByPath(parentObject, ["expireTime"], fromExpireTime);
  }
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (parentObject !== void 0 && fromDisplayName != null) {
    setValueByPath(parentObject, ["displayName"], fromDisplayName);
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (parentObject !== void 0 && fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return contentToVertex$2(item);
      });
    }
    setValueByPath(parentObject, ["contents"], transformedList);
  }
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== void 0 && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["systemInstruction"], contentToVertex$2(tContent(fromSystemInstruction)));
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== void 0 && fromTools != null) {
    let transformedList = fromTools;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToVertex$2(item);
      });
    }
    setValueByPath(parentObject, ["tools"], transformedList);
  }
  const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
  if (parentObject !== void 0 && fromToolConfig != null) {
    setValueByPath(parentObject, ["toolConfig"], toolConfigToVertex$1(fromToolConfig));
  }
  const fromKmsKeyName = getValueByPath(fromObject, ["kmsKeyName"]);
  if (parentObject !== void 0 && fromKmsKeyName != null) {
    setValueByPath(parentObject, ["encryption_spec", "kmsKeyName"], fromKmsKeyName);
  }
  return toObject;
}
function createCachedContentParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], tCachesModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], createCachedContentConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function getCachedContentParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function deleteCachedContentParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function updateCachedContentConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromTtl = getValueByPath(fromObject, ["ttl"]);
  if (parentObject !== void 0 && fromTtl != null) {
    setValueByPath(parentObject, ["ttl"], fromTtl);
  }
  const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
  if (parentObject !== void 0 && fromExpireTime != null) {
    setValueByPath(parentObject, ["expireTime"], fromExpireTime);
  }
  return toObject;
}
function updateCachedContentParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], updateCachedContentConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function listCachedContentsConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  return toObject;
}
function listCachedContentsParametersToVertex(fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], listCachedContentsConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function cachedContentFromMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], fromModel);
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
  if (fromExpireTime != null) {
    setValueByPath(toObject, ["expireTime"], fromExpireTime);
  }
  const fromUsageMetadata = getValueByPath(fromObject, [
    "usageMetadata"
  ]);
  if (fromUsageMetadata != null) {
    setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
  }
  return toObject;
}
function deleteCachedContentResponseFromMldev() {
  const toObject = {};
  return toObject;
}
function listCachedContentsResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromCachedContents = getValueByPath(fromObject, [
    "cachedContents"
  ]);
  if (fromCachedContents != null) {
    let transformedList = fromCachedContents;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return cachedContentFromMldev(item);
      });
    }
    setValueByPath(toObject, ["cachedContents"], transformedList);
  }
  return toObject;
}
function cachedContentFromVertex(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], fromModel);
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
  if (fromExpireTime != null) {
    setValueByPath(toObject, ["expireTime"], fromExpireTime);
  }
  const fromUsageMetadata = getValueByPath(fromObject, [
    "usageMetadata"
  ]);
  if (fromUsageMetadata != null) {
    setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
  }
  return toObject;
}
function deleteCachedContentResponseFromVertex() {
  const toObject = {};
  return toObject;
}
function listCachedContentsResponseFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromCachedContents = getValueByPath(fromObject, [
    "cachedContents"
  ]);
  if (fromCachedContents != null) {
    let transformedList = fromCachedContents;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return cachedContentFromVertex(item);
      });
    }
    setValueByPath(toObject, ["cachedContents"], transformedList);
  }
  return toObject;
}
var Caches = class extends BaseModule {
  constructor(apiClient) {
    super();
    this.apiClient = apiClient;
    this.list = async (params = {}) => {
      return new Pager(PagedItem.PAGED_ITEM_CACHED_CONTENTS, (x2) => this.listInternal(x2), await this.listInternal(params), params);
    };
  }
  /**
   * Creates a cached contents resource.
   *
   * @remarks
   * Context caching is only supported for specific models. See [Gemini
   * Developer API reference](https://ai.google.dev/gemini-api/docs/caching?lang=node/context-cac)
   * and [Vertex AI reference](https://cloud.google.com/vertex-ai/generative-ai/docs/context-cache/context-cache-overview#supported_models)
   * for more information.
   *
   * @param params - The parameters for the create request.
   * @return The created cached content.
   *
   * @example
   * ```ts
   * const contents = ...; // Initialize the content to cache.
   * const response = await ai.caches.create({
   *   model: 'gemini-2.0-flash-001',
   *   config: {
   *    'contents': contents,
   *    'displayName': 'test cache',
   *    'systemInstruction': 'What is the sum of the two pdfs?',
   *    'ttl': '86400s',
   *  }
   * });
   * ```
   */
  async create(params) {
    var _a3, _b, _c, _d;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = createCachedContentParametersToVertex(this.apiClient, params);
      path2 = formatMap("cachedContents", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = cachedContentFromVertex(apiResponse);
        return resp;
      });
    } else {
      const body = createCachedContentParametersToMldev(this.apiClient, params);
      path2 = formatMap("cachedContents", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = cachedContentFromMldev(apiResponse);
        return resp;
      });
    }
  }
  /**
   * Gets cached content configurations.
   *
   * @param params - The parameters for the get request.
   * @return The cached content.
   *
   * @example
   * ```ts
   * await ai.caches.get({name: '...'}); // The server-generated resource name.
   * ```
   */
  async get(params) {
    var _a3, _b, _c, _d;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = getCachedContentParametersToVertex(this.apiClient, params);
      path2 = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = cachedContentFromVertex(apiResponse);
        return resp;
      });
    } else {
      const body = getCachedContentParametersToMldev(this.apiClient, params);
      path2 = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = cachedContentFromMldev(apiResponse);
        return resp;
      });
    }
  }
  /**
   * Deletes cached content.
   *
   * @param params - The parameters for the delete request.
   * @return The empty response returned by the API.
   *
   * @example
   * ```ts
   * await ai.caches.delete({name: '...'}); // The server-generated resource name.
   * ```
   */
  async delete(params) {
    var _a3, _b, _c, _d;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = deleteCachedContentParametersToVertex(this.apiClient, params);
      path2 = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "DELETE",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then(() => {
        const resp = deleteCachedContentResponseFromVertex();
        const typedResp = new DeleteCachedContentResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = deleteCachedContentParametersToMldev(this.apiClient, params);
      path2 = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "DELETE",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then(() => {
        const resp = deleteCachedContentResponseFromMldev();
        const typedResp = new DeleteCachedContentResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  /**
   * Updates cached content configurations.
   *
   * @param params - The parameters for the update request.
   * @return The updated cached content.
   *
   * @example
   * ```ts
   * const response = await ai.caches.update({
   *   name: '...',  // The server-generated resource name.
   *   config: {'ttl': '7600s'}
   * });
   * ```
   */
  async update(params) {
    var _a3, _b, _c, _d;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = updateCachedContentParametersToVertex(this.apiClient, params);
      path2 = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "PATCH",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = cachedContentFromVertex(apiResponse);
        return resp;
      });
    } else {
      const body = updateCachedContentParametersToMldev(this.apiClient, params);
      path2 = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "PATCH",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = cachedContentFromMldev(apiResponse);
        return resp;
      });
    }
  }
  async listInternal(params) {
    var _a3, _b, _c, _d;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = listCachedContentsParametersToVertex(params);
      path2 = formatMap("cachedContents", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = listCachedContentsResponseFromVertex(apiResponse);
        const typedResp = new ListCachedContentsResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = listCachedContentsParametersToMldev(params);
      path2 = formatMap("cachedContents", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = listCachedContentsResponseFromMldev(apiResponse);
        const typedResp = new ListCachedContentsResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
};
function __values(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2) return m2.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i2 >= o2.length) o2 = void 0;
      return { value: o2 && o2[i2++], done: !o2 };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
  return i2 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function awaitReturn(f2) {
    return function(v2) {
      return Promise.resolve(v2).then(f2, reject);
    };
  }
  function verb(n2, f2) {
    if (g2[n2]) {
      i2[n2] = function(v2) {
        return new Promise(function(a2, b2) {
          q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
        });
      };
      if (f2) i2[n2] = f2(i2[n2]);
    }
  }
  function resume(n2, v2) {
    try {
      step(g2[n2](v2));
    } catch (e2) {
      settle(q2[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v2) {
    if (f2(v2), q2.shift(), q2.length) resume(q2[0][0], q2[0][1]);
  }
}
function __asyncValues(o2) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i2;
  return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d2, v2) {
    Promise.resolve(v2).then(function(v6) {
      resolve({ value: v6, done: d2 });
    }, reject);
  }
}
function isValidResponse(response) {
  var _a3;
  if (response.candidates == void 0 || response.candidates.length === 0) {
    return false;
  }
  const content = (_a3 = response.candidates[0]) === null || _a3 === void 0 ? void 0 : _a3.content;
  if (content === void 0) {
    return false;
  }
  return isValidContent(content);
}
function isValidContent(content) {
  if (content.parts === void 0 || content.parts.length === 0) {
    return false;
  }
  for (const part of content.parts) {
    if (part === void 0 || Object.keys(part).length === 0) {
      return false;
    }
    if (!part.thought && part.text !== void 0 && part.text === "") {
      return false;
    }
  }
  return true;
}
function validateHistory(history) {
  if (history.length === 0) {
    return;
  }
  for (const content of history) {
    if (content.role !== "user" && content.role !== "model") {
      throw new Error(`Role must be user or model, but got ${content.role}.`);
    }
  }
}
function extractCuratedHistory(comprehensiveHistory) {
  if (comprehensiveHistory === void 0 || comprehensiveHistory.length === 0) {
    return [];
  }
  const curatedHistory = [];
  const length = comprehensiveHistory.length;
  let i2 = 0;
  while (i2 < length) {
    if (comprehensiveHistory[i2].role === "user") {
      curatedHistory.push(comprehensiveHistory[i2]);
      i2++;
    } else {
      const modelOutput = [];
      let isValid = true;
      while (i2 < length && comprehensiveHistory[i2].role === "model") {
        modelOutput.push(comprehensiveHistory[i2]);
        if (isValid && !isValidContent(comprehensiveHistory[i2])) {
          isValid = false;
        }
        i2++;
      }
      if (isValid) {
        curatedHistory.push(...modelOutput);
      } else {
        curatedHistory.pop();
      }
    }
  }
  return curatedHistory;
}
var Chats = class {
  constructor(modelsModule, apiClient) {
    this.modelsModule = modelsModule;
    this.apiClient = apiClient;
  }
  /**
   * Creates a new chat session.
   *
   * @remarks
   * The config in the params will be used for all requests within the chat
   * session unless overridden by a per-request `config` in
   * @see {@link types.SendMessageParameters#config}.
   *
   * @param params - Parameters for creating a chat session.
   * @returns A new chat session.
   *
   * @example
   * ```ts
   * const chat = ai.chats.create({
   *   model: 'gemini-2.0-flash'
   *   config: {
   *     temperature: 0.5,
   *     maxOutputTokens: 1024,
   *   }
   * });
   * ```
   */
  create(params) {
    return new Chat(
      this.apiClient,
      this.modelsModule,
      params.model,
      params.config,
      // Deep copy the history to avoid mutating the history outside of the
      // chat session.
      structuredClone(params.history)
    );
  }
};
var Chat = class {
  constructor(apiClient, modelsModule, model, config = {}, history = []) {
    this.apiClient = apiClient;
    this.modelsModule = modelsModule;
    this.model = model;
    this.config = config;
    this.history = history;
    this.sendPromise = Promise.resolve();
    validateHistory(history);
  }
  /**
   * Sends a message to the model and returns the response.
   *
   * @remarks
   * This method will wait for the previous message to be processed before
   * sending the next message.
   *
   * @see {@link Chat#sendMessageStream} for streaming method.
   * @param params - parameters for sending messages within a chat session.
   * @returns The model's response.
   *
   * @example
   * ```ts
   * const chat = ai.chats.create({model: 'gemini-2.0-flash'});
   * const response = await chat.sendMessage({
   *   message: 'Why is the sky blue?'
   * });
   * console.log(response.text);
   * ```
   */
  async sendMessage(params) {
    var _a3;
    await this.sendPromise;
    const inputContent = tContent(params.message);
    const responsePromise = this.modelsModule.generateContent({
      model: this.model,
      contents: this.getHistory(true).concat(inputContent),
      config: (_a3 = params.config) !== null && _a3 !== void 0 ? _a3 : this.config
    });
    this.sendPromise = (async () => {
      var _a4, _b, _c;
      const response = await responsePromise;
      const outputContent = (_b = (_a4 = response.candidates) === null || _a4 === void 0 ? void 0 : _a4[0]) === null || _b === void 0 ? void 0 : _b.content;
      const fullAutomaticFunctionCallingHistory = response.automaticFunctionCallingHistory;
      const index = this.getHistory(true).length;
      let automaticFunctionCallingHistory = [];
      if (fullAutomaticFunctionCallingHistory != null) {
        automaticFunctionCallingHistory = (_c = fullAutomaticFunctionCallingHistory.slice(index)) !== null && _c !== void 0 ? _c : [];
      }
      const modelOutput = outputContent ? [outputContent] : [];
      this.recordHistory(inputContent, modelOutput, automaticFunctionCallingHistory);
      return;
    })();
    await this.sendPromise.catch(() => {
      this.sendPromise = Promise.resolve();
    });
    return responsePromise;
  }
  /**
   * Sends a message to the model and returns the response in chunks.
   *
   * @remarks
   * This method will wait for the previous message to be processed before
   * sending the next message.
   *
   * @see {@link Chat#sendMessage} for non-streaming method.
   * @param params - parameters for sending the message.
   * @return The model's response.
   *
   * @example
   * ```ts
   * const chat = ai.chats.create({model: 'gemini-2.0-flash'});
   * const response = await chat.sendMessageStream({
   *   message: 'Why is the sky blue?'
   * });
   * for await (const chunk of response) {
   *   console.log(chunk.text);
   * }
   * ```
   */
  async sendMessageStream(params) {
    var _a3;
    await this.sendPromise;
    const inputContent = tContent(params.message);
    const streamResponse = this.modelsModule.generateContentStream({
      model: this.model,
      contents: this.getHistory(true).concat(inputContent),
      config: (_a3 = params.config) !== null && _a3 !== void 0 ? _a3 : this.config
    });
    this.sendPromise = streamResponse.then(() => void 0).catch(() => void 0);
    const response = await streamResponse;
    const result = this.processStreamResponse(response, inputContent);
    return result;
  }
  /**
   * Returns the chat history.
   *
   * @remarks
   * The history is a list of contents alternating between user and model.
   *
   * There are two types of history:
   * - The `curated history` contains only the valid turns between user and
   * model, which will be included in the subsequent requests sent to the model.
   * - The `comprehensive history` contains all turns, including invalid or
   *   empty model outputs, providing a complete record of the history.
   *
   * The history is updated after receiving the response from the model,
   * for streaming response, it means receiving the last chunk of the response.
   *
   * The `comprehensive history` is returned by default. To get the `curated
   * history`, set the `curated` parameter to `true`.
   *
   * @param curated - whether to return the curated history or the comprehensive
   *     history.
   * @return History contents alternating between user and model for the entire
   *     chat session.
   */
  getHistory(curated = false) {
    const history = curated ? extractCuratedHistory(this.history) : this.history;
    return structuredClone(history);
  }
  processStreamResponse(streamResponse, inputContent) {
    var _a3, _b;
    return __asyncGenerator(this, arguments, function* processStreamResponse_1() {
      var _c, e_1, _d, _e2;
      const outputContent = [];
      try {
        for (var _f = true, streamResponse_1 = __asyncValues(streamResponse), streamResponse_1_1; streamResponse_1_1 = yield __await(streamResponse_1.next()), _c = streamResponse_1_1.done, !_c; _f = true) {
          _e2 = streamResponse_1_1.value;
          _f = false;
          const chunk = _e2;
          if (isValidResponse(chunk)) {
            const content = (_b = (_a3 = chunk.candidates) === null || _a3 === void 0 ? void 0 : _a3[0]) === null || _b === void 0 ? void 0 : _b.content;
            if (content !== void 0) {
              outputContent.push(content);
            }
          }
          yield yield __await(chunk);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_f && !_c && (_d = streamResponse_1.return)) yield __await(_d.call(streamResponse_1));
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      this.recordHistory(inputContent, outputContent);
    });
  }
  recordHistory(userInput, modelOutput, automaticFunctionCallingHistory) {
    let outputContents = [];
    if (modelOutput.length > 0 && modelOutput.every((content) => content.role !== void 0)) {
      outputContents = modelOutput;
    } else {
      outputContents.push({
        role: "model",
        parts: []
      });
    }
    if (automaticFunctionCallingHistory && automaticFunctionCallingHistory.length > 0) {
      this.history.push(...extractCuratedHistory(automaticFunctionCallingHistory));
    } else {
      this.history.push(userInput);
    }
    this.history.push(...outputContents);
  }
};
var ApiError = class _ApiError extends Error {
  constructor(options) {
    super(options.message);
    this.name = "ApiError";
    this.status = options.status;
    Object.setPrototypeOf(this, _ApiError.prototype);
  }
};
function listFilesConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  return toObject;
}
function listFilesParametersToMldev(fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], listFilesConfigToMldev(fromConfig, toObject));
  }
  return toObject;
}
function fileStatusToMldev(fromObject) {
  const toObject = {};
  const fromDetails = getValueByPath(fromObject, ["details"]);
  if (fromDetails != null) {
    setValueByPath(toObject, ["details"], fromDetails);
  }
  const fromMessage = getValueByPath(fromObject, ["message"]);
  if (fromMessage != null) {
    setValueByPath(toObject, ["message"], fromMessage);
  }
  const fromCode = getValueByPath(fromObject, ["code"]);
  if (fromCode != null) {
    setValueByPath(toObject, ["code"], fromCode);
  }
  return toObject;
}
function fileToMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  const fromSizeBytes = getValueByPath(fromObject, ["sizeBytes"]);
  if (fromSizeBytes != null) {
    setValueByPath(toObject, ["sizeBytes"], fromSizeBytes);
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromExpirationTime = getValueByPath(fromObject, [
    "expirationTime"
  ]);
  if (fromExpirationTime != null) {
    setValueByPath(toObject, ["expirationTime"], fromExpirationTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  const fromSha256Hash = getValueByPath(fromObject, ["sha256Hash"]);
  if (fromSha256Hash != null) {
    setValueByPath(toObject, ["sha256Hash"], fromSha256Hash);
  }
  const fromUri = getValueByPath(fromObject, ["uri"]);
  if (fromUri != null) {
    setValueByPath(toObject, ["uri"], fromUri);
  }
  const fromDownloadUri = getValueByPath(fromObject, ["downloadUri"]);
  if (fromDownloadUri != null) {
    setValueByPath(toObject, ["downloadUri"], fromDownloadUri);
  }
  const fromState = getValueByPath(fromObject, ["state"]);
  if (fromState != null) {
    setValueByPath(toObject, ["state"], fromState);
  }
  const fromSource = getValueByPath(fromObject, ["source"]);
  if (fromSource != null) {
    setValueByPath(toObject, ["source"], fromSource);
  }
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fileStatusToMldev(fromError));
  }
  return toObject;
}
function createFileParametersToMldev(fromObject) {
  const toObject = {};
  const fromFile = getValueByPath(fromObject, ["file"]);
  if (fromFile != null) {
    setValueByPath(toObject, ["file"], fileToMldev(fromFile));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function getFileParametersToMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "file"], tFileName(fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function deleteFileParametersToMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "file"], tFileName(fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function fileStatusFromMldev(fromObject) {
  const toObject = {};
  const fromDetails = getValueByPath(fromObject, ["details"]);
  if (fromDetails != null) {
    setValueByPath(toObject, ["details"], fromDetails);
  }
  const fromMessage = getValueByPath(fromObject, ["message"]);
  if (fromMessage != null) {
    setValueByPath(toObject, ["message"], fromMessage);
  }
  const fromCode = getValueByPath(fromObject, ["code"]);
  if (fromCode != null) {
    setValueByPath(toObject, ["code"], fromCode);
  }
  return toObject;
}
function fileFromMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  const fromSizeBytes = getValueByPath(fromObject, ["sizeBytes"]);
  if (fromSizeBytes != null) {
    setValueByPath(toObject, ["sizeBytes"], fromSizeBytes);
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromExpirationTime = getValueByPath(fromObject, [
    "expirationTime"
  ]);
  if (fromExpirationTime != null) {
    setValueByPath(toObject, ["expirationTime"], fromExpirationTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  const fromSha256Hash = getValueByPath(fromObject, ["sha256Hash"]);
  if (fromSha256Hash != null) {
    setValueByPath(toObject, ["sha256Hash"], fromSha256Hash);
  }
  const fromUri = getValueByPath(fromObject, ["uri"]);
  if (fromUri != null) {
    setValueByPath(toObject, ["uri"], fromUri);
  }
  const fromDownloadUri = getValueByPath(fromObject, ["downloadUri"]);
  if (fromDownloadUri != null) {
    setValueByPath(toObject, ["downloadUri"], fromDownloadUri);
  }
  const fromState = getValueByPath(fromObject, ["state"]);
  if (fromState != null) {
    setValueByPath(toObject, ["state"], fromState);
  }
  const fromSource = getValueByPath(fromObject, ["source"]);
  if (fromSource != null) {
    setValueByPath(toObject, ["source"], fromSource);
  }
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fileStatusFromMldev(fromError));
  }
  return toObject;
}
function listFilesResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromFiles = getValueByPath(fromObject, ["files"]);
  if (fromFiles != null) {
    let transformedList = fromFiles;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return fileFromMldev(item);
      });
    }
    setValueByPath(toObject, ["files"], transformedList);
  }
  return toObject;
}
function createFileResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  return toObject;
}
function deleteFileResponseFromMldev() {
  const toObject = {};
  return toObject;
}
var Files = class extends BaseModule {
  constructor(apiClient) {
    super();
    this.apiClient = apiClient;
    this.list = async (params = {}) => {
      return new Pager(PagedItem.PAGED_ITEM_FILES, (x2) => this.listInternal(x2), await this.listInternal(params), params);
    };
  }
  /**
   * Uploads a file asynchronously to the Gemini API.
   * This method is not available in Vertex AI.
   * Supported upload sources:
   * - Node.js: File path (string) or Blob object.
   * - Browser: Blob object (e.g., File).
   *
   * @remarks
   * The `mimeType` can be specified in the `config` parameter. If omitted:
   *  - For file path (string) inputs, the `mimeType` will be inferred from the
   *     file extension.
   *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`
   *     property.
   * Somex eamples for file extension to mimeType mapping:
   * .txt -> text/plain
   * .json -> application/json
   * .jpg  -> image/jpeg
   * .png -> image/png
   * .mp3 -> audio/mpeg
   * .mp4 -> video/mp4
   *
   * This section can contain multiple paragraphs and code examples.
   *
   * @param params - Optional parameters specified in the
   *        `types.UploadFileParameters` interface.
   *         @see {@link types.UploadFileParameters#config} for the optional
   *         config in the parameters.
   * @return A promise that resolves to a `types.File` object.
   * @throws An error if called on a Vertex AI client.
   * @throws An error if the `mimeType` is not provided and can not be inferred,
   * the `mimeType` can be provided in the `params.config` parameter.
   * @throws An error occurs if a suitable upload location cannot be established.
   *
   * @example
   * The following code uploads a file to Gemini API.
   *
   * ```ts
   * const file = await ai.files.upload({file: 'file.txt', config: {
   *   mimeType: 'text/plain',
   * }});
   * console.log(file.name);
   * ```
   */
  async upload(params) {
    if (this.apiClient.isVertexAI()) {
      throw new Error("Vertex AI does not support uploading files. You can share files through a GCS bucket.");
    }
    return this.apiClient.uploadFile(params.file, params.config).then((response) => {
      const file = fileFromMldev(response);
      return file;
    });
  }
  /**
   * Downloads a remotely stored file asynchronously to a location specified in
   * the `params` object. This method only works on Node environment, to
   * download files in the browser, use a browser compliant method like an <a>
   * tag.
   *
   * @param params - The parameters for the download request.
   *
   * @example
   * The following code downloads an example file named "files/mehozpxf877d" as
   * "file.txt".
   *
   * ```ts
   * await ai.files.download({file: file.name, downloadPath: 'file.txt'});
   * ```
   */
  async download(params) {
    await this.apiClient.downloadFile(params);
  }
  async listInternal(params) {
    var _a3, _b;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error("This method is only supported by the Gemini Developer API.");
    } else {
      const body = listFilesParametersToMldev(params);
      path2 = formatMap("files", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = listFilesResponseFromMldev(apiResponse);
        const typedResp = new ListFilesResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  async createInternal(params) {
    var _a3, _b;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error("This method is only supported by the Gemini Developer API.");
    } else {
      const body = createFileParametersToMldev(params);
      path2 = formatMap("upload/v1beta/files", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = createFileResponseFromMldev(apiResponse);
        const typedResp = new CreateFileResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  /**
   * Retrieves the file information from the service.
   *
   * @param params - The parameters for the get request
   * @return The Promise that resolves to the types.File object requested.
   *
   * @example
   * ```ts
   * const config: GetFileParameters = {
   *   name: fileName,
   * };
   * file = await ai.files.get(config);
   * console.log(file.name);
   * ```
   */
  async get(params) {
    var _a3, _b;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error("This method is only supported by the Gemini Developer API.");
    } else {
      const body = getFileParametersToMldev(params);
      path2 = formatMap("files/{file}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = fileFromMldev(apiResponse);
        return resp;
      });
    }
  }
  /**
   * Deletes a remotely stored file.
   *
   * @param params - The parameters for the delete request.
   * @return The DeleteFileResponse, the response for the delete method.
   *
   * @example
   * The following code deletes an example file named "files/mehozpxf877d".
   *
   * ```ts
   * await ai.files.delete({name: file.name});
   * ```
   */
  async delete(params) {
    var _a3, _b;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error("This method is only supported by the Gemini Developer API.");
    } else {
      const body = deleteFileParametersToMldev(params);
      path2 = formatMap("files/{file}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "DELETE",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then(() => {
        const resp = deleteFileResponseFromMldev();
        const typedResp = new DeleteFileResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
};
function prebuiltVoiceConfigToMldev$2(fromObject) {
  const toObject = {};
  const fromVoiceName = getValueByPath(fromObject, ["voiceName"]);
  if (fromVoiceName != null) {
    setValueByPath(toObject, ["voiceName"], fromVoiceName);
  }
  return toObject;
}
function voiceConfigToMldev$2(fromObject) {
  const toObject = {};
  const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [
    "prebuiltVoiceConfig"
  ]);
  if (fromPrebuiltVoiceConfig != null) {
    setValueByPath(toObject, ["prebuiltVoiceConfig"], prebuiltVoiceConfigToMldev$2(fromPrebuiltVoiceConfig));
  }
  return toObject;
}
function speakerVoiceConfigToMldev$2(fromObject) {
  const toObject = {};
  const fromSpeaker = getValueByPath(fromObject, ["speaker"]);
  if (fromSpeaker != null) {
    setValueByPath(toObject, ["speaker"], fromSpeaker);
  }
  const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
  if (fromVoiceConfig != null) {
    setValueByPath(toObject, ["voiceConfig"], voiceConfigToMldev$2(fromVoiceConfig));
  }
  return toObject;
}
function multiSpeakerVoiceConfigToMldev$2(fromObject) {
  const toObject = {};
  const fromSpeakerVoiceConfigs = getValueByPath(fromObject, [
    "speakerVoiceConfigs"
  ]);
  if (fromSpeakerVoiceConfigs != null) {
    let transformedList = fromSpeakerVoiceConfigs;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return speakerVoiceConfigToMldev$2(item);
      });
    }
    setValueByPath(toObject, ["speakerVoiceConfigs"], transformedList);
  }
  return toObject;
}
function speechConfigToMldev$2(fromObject) {
  const toObject = {};
  const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
  if (fromVoiceConfig != null) {
    setValueByPath(toObject, ["voiceConfig"], voiceConfigToMldev$2(fromVoiceConfig));
  }
  const fromMultiSpeakerVoiceConfig = getValueByPath(fromObject, [
    "multiSpeakerVoiceConfig"
  ]);
  if (fromMultiSpeakerVoiceConfig != null) {
    setValueByPath(toObject, ["multiSpeakerVoiceConfig"], multiSpeakerVoiceConfigToMldev$2(fromMultiSpeakerVoiceConfig));
  }
  const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
  if (fromLanguageCode != null) {
    setValueByPath(toObject, ["languageCode"], fromLanguageCode);
  }
  return toObject;
}
function videoMetadataToMldev$2(fromObject) {
  const toObject = {};
  const fromFps = getValueByPath(fromObject, ["fps"]);
  if (fromFps != null) {
    setValueByPath(toObject, ["fps"], fromFps);
  }
  const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
  if (fromEndOffset != null) {
    setValueByPath(toObject, ["endOffset"], fromEndOffset);
  }
  const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
  if (fromStartOffset != null) {
    setValueByPath(toObject, ["startOffset"], fromStartOffset);
  }
  return toObject;
}
function blobToMldev$2(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function fileDataToMldev$2(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function partToMldev$2(fromObject) {
  const toObject = {};
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], videoMetadataToMldev$2(fromVideoMetadata));
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobToMldev$2(fromInlineData));
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataToMldev$2(fromFileData));
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], fromFunctionCall);
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  return toObject;
}
function contentToMldev$2(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partToMldev$2(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function functionDeclarationToMldev$2(fromObject) {
  const toObject = {};
  const fromBehavior = getValueByPath(fromObject, ["behavior"]);
  if (fromBehavior != null) {
    setValueByPath(toObject, ["behavior"], fromBehavior);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromParameters = getValueByPath(fromObject, ["parameters"]);
  if (fromParameters != null) {
    setValueByPath(toObject, ["parameters"], fromParameters);
  }
  const fromParametersJsonSchema = getValueByPath(fromObject, [
    "parametersJsonSchema"
  ]);
  if (fromParametersJsonSchema != null) {
    setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], fromResponse);
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  return toObject;
}
function intervalToMldev$2(fromObject) {
  const toObject = {};
  const fromStartTime = getValueByPath(fromObject, ["startTime"]);
  if (fromStartTime != null) {
    setValueByPath(toObject, ["startTime"], fromStartTime);
  }
  const fromEndTime = getValueByPath(fromObject, ["endTime"]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  return toObject;
}
function googleSearchToMldev$2(fromObject) {
  const toObject = {};
  const fromTimeRangeFilter = getValueByPath(fromObject, [
    "timeRangeFilter"
  ]);
  if (fromTimeRangeFilter != null) {
    setValueByPath(toObject, ["timeRangeFilter"], intervalToMldev$2(fromTimeRangeFilter));
  }
  return toObject;
}
function dynamicRetrievalConfigToMldev$2(fromObject) {
  const toObject = {};
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  const fromDynamicThreshold = getValueByPath(fromObject, [
    "dynamicThreshold"
  ]);
  if (fromDynamicThreshold != null) {
    setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
  }
  return toObject;
}
function googleSearchRetrievalToMldev$2(fromObject) {
  const toObject = {};
  const fromDynamicRetrievalConfig = getValueByPath(fromObject, [
    "dynamicRetrievalConfig"
  ]);
  if (fromDynamicRetrievalConfig != null) {
    setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToMldev$2(fromDynamicRetrievalConfig));
  }
  return toObject;
}
function urlContextToMldev$2() {
  const toObject = {};
  return toObject;
}
function toolToMldev$2(fromObject) {
  const toObject = {};
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return functionDeclarationToMldev$2(item);
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
    throw new Error("retrieval parameter is not supported in Gemini API.");
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$2(fromGoogleSearch));
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToMldev$2(fromGoogleSearchRetrieval));
  }
  if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
    throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["googleMaps"]) !== void 0) {
    throw new Error("googleMaps parameter is not supported in Gemini API.");
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], urlContextToMldev$2());
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  return toObject;
}
function sessionResumptionConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromHandle = getValueByPath(fromObject, ["handle"]);
  if (fromHandle != null) {
    setValueByPath(toObject, ["handle"], fromHandle);
  }
  if (getValueByPath(fromObject, ["transparent"]) !== void 0) {
    throw new Error("transparent parameter is not supported in Gemini API.");
  }
  return toObject;
}
function audioTranscriptionConfigToMldev$1() {
  const toObject = {};
  return toObject;
}
function automaticActivityDetectionToMldev$1(fromObject) {
  const toObject = {};
  const fromDisabled = getValueByPath(fromObject, ["disabled"]);
  if (fromDisabled != null) {
    setValueByPath(toObject, ["disabled"], fromDisabled);
  }
  const fromStartOfSpeechSensitivity = getValueByPath(fromObject, [
    "startOfSpeechSensitivity"
  ]);
  if (fromStartOfSpeechSensitivity != null) {
    setValueByPath(toObject, ["startOfSpeechSensitivity"], fromStartOfSpeechSensitivity);
  }
  const fromEndOfSpeechSensitivity = getValueByPath(fromObject, [
    "endOfSpeechSensitivity"
  ]);
  if (fromEndOfSpeechSensitivity != null) {
    setValueByPath(toObject, ["endOfSpeechSensitivity"], fromEndOfSpeechSensitivity);
  }
  const fromPrefixPaddingMs = getValueByPath(fromObject, [
    "prefixPaddingMs"
  ]);
  if (fromPrefixPaddingMs != null) {
    setValueByPath(toObject, ["prefixPaddingMs"], fromPrefixPaddingMs);
  }
  const fromSilenceDurationMs = getValueByPath(fromObject, [
    "silenceDurationMs"
  ]);
  if (fromSilenceDurationMs != null) {
    setValueByPath(toObject, ["silenceDurationMs"], fromSilenceDurationMs);
  }
  return toObject;
}
function realtimeInputConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromAutomaticActivityDetection = getValueByPath(fromObject, [
    "automaticActivityDetection"
  ]);
  if (fromAutomaticActivityDetection != null) {
    setValueByPath(toObject, ["automaticActivityDetection"], automaticActivityDetectionToMldev$1(fromAutomaticActivityDetection));
  }
  const fromActivityHandling = getValueByPath(fromObject, [
    "activityHandling"
  ]);
  if (fromActivityHandling != null) {
    setValueByPath(toObject, ["activityHandling"], fromActivityHandling);
  }
  const fromTurnCoverage = getValueByPath(fromObject, ["turnCoverage"]);
  if (fromTurnCoverage != null) {
    setValueByPath(toObject, ["turnCoverage"], fromTurnCoverage);
  }
  return toObject;
}
function slidingWindowToMldev$1(fromObject) {
  const toObject = {};
  const fromTargetTokens = getValueByPath(fromObject, ["targetTokens"]);
  if (fromTargetTokens != null) {
    setValueByPath(toObject, ["targetTokens"], fromTargetTokens);
  }
  return toObject;
}
function contextWindowCompressionConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromTriggerTokens = getValueByPath(fromObject, [
    "triggerTokens"
  ]);
  if (fromTriggerTokens != null) {
    setValueByPath(toObject, ["triggerTokens"], fromTriggerTokens);
  }
  const fromSlidingWindow = getValueByPath(fromObject, [
    "slidingWindow"
  ]);
  if (fromSlidingWindow != null) {
    setValueByPath(toObject, ["slidingWindow"], slidingWindowToMldev$1(fromSlidingWindow));
  }
  return toObject;
}
function proactivityConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromProactiveAudio = getValueByPath(fromObject, [
    "proactiveAudio"
  ]);
  if (fromProactiveAudio != null) {
    setValueByPath(toObject, ["proactiveAudio"], fromProactiveAudio);
  }
  return toObject;
}
function liveConnectConfigToMldev$1(fromObject, parentObject) {
  const toObject = {};
  const fromGenerationConfig = getValueByPath(fromObject, [
    "generationConfig"
  ]);
  if (parentObject !== void 0 && fromGenerationConfig != null) {
    setValueByPath(parentObject, ["setup", "generationConfig"], fromGenerationConfig);
  }
  const fromResponseModalities = getValueByPath(fromObject, [
    "responseModalities"
  ]);
  if (parentObject !== void 0 && fromResponseModalities != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "responseModalities"], fromResponseModalities);
  }
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (parentObject !== void 0 && fromTemperature != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "temperature"], fromTemperature);
  }
  const fromTopP = getValueByPath(fromObject, ["topP"]);
  if (parentObject !== void 0 && fromTopP != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "topP"], fromTopP);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (parentObject !== void 0 && fromTopK != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "topK"], fromTopK);
  }
  const fromMaxOutputTokens = getValueByPath(fromObject, [
    "maxOutputTokens"
  ]);
  if (parentObject !== void 0 && fromMaxOutputTokens != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "maxOutputTokens"], fromMaxOutputTokens);
  }
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (parentObject !== void 0 && fromMediaResolution != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "mediaResolution"], fromMediaResolution);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (parentObject !== void 0 && fromSeed != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "seed"], fromSeed);
  }
  const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
  if (parentObject !== void 0 && fromSpeechConfig != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "speechConfig"], speechConfigToMldev$2(tLiveSpeechConfig(fromSpeechConfig)));
  }
  const fromEnableAffectiveDialog = getValueByPath(fromObject, [
    "enableAffectiveDialog"
  ]);
  if (parentObject !== void 0 && fromEnableAffectiveDialog != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "enableAffectiveDialog"], fromEnableAffectiveDialog);
  }
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== void 0 && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["setup", "systemInstruction"], contentToMldev$2(tContent(fromSystemInstruction)));
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== void 0 && fromTools != null) {
    let transformedList = tTools(fromTools);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToMldev$2(tTool(item));
      });
    }
    setValueByPath(parentObject, ["setup", "tools"], transformedList);
  }
  const fromSessionResumption = getValueByPath(fromObject, [
    "sessionResumption"
  ]);
  if (parentObject !== void 0 && fromSessionResumption != null) {
    setValueByPath(parentObject, ["setup", "sessionResumption"], sessionResumptionConfigToMldev$1(fromSessionResumption));
  }
  const fromInputAudioTranscription = getValueByPath(fromObject, [
    "inputAudioTranscription"
  ]);
  if (parentObject !== void 0 && fromInputAudioTranscription != null) {
    setValueByPath(parentObject, ["setup", "inputAudioTranscription"], audioTranscriptionConfigToMldev$1());
  }
  const fromOutputAudioTranscription = getValueByPath(fromObject, [
    "outputAudioTranscription"
  ]);
  if (parentObject !== void 0 && fromOutputAudioTranscription != null) {
    setValueByPath(parentObject, ["setup", "outputAudioTranscription"], audioTranscriptionConfigToMldev$1());
  }
  const fromRealtimeInputConfig = getValueByPath(fromObject, [
    "realtimeInputConfig"
  ]);
  if (parentObject !== void 0 && fromRealtimeInputConfig != null) {
    setValueByPath(parentObject, ["setup", "realtimeInputConfig"], realtimeInputConfigToMldev$1(fromRealtimeInputConfig));
  }
  const fromContextWindowCompression = getValueByPath(fromObject, [
    "contextWindowCompression"
  ]);
  if (parentObject !== void 0 && fromContextWindowCompression != null) {
    setValueByPath(parentObject, ["setup", "contextWindowCompression"], contextWindowCompressionConfigToMldev$1(fromContextWindowCompression));
  }
  const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
  if (parentObject !== void 0 && fromProactivity != null) {
    setValueByPath(parentObject, ["setup", "proactivity"], proactivityConfigToMldev$1(fromProactivity));
  }
  return toObject;
}
function liveConnectParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], liveConnectConfigToMldev$1(fromConfig, toObject));
  }
  return toObject;
}
function activityStartToMldev() {
  const toObject = {};
  return toObject;
}
function activityEndToMldev() {
  const toObject = {};
  return toObject;
}
function liveSendRealtimeInputParametersToMldev(fromObject) {
  const toObject = {};
  const fromMedia = getValueByPath(fromObject, ["media"]);
  if (fromMedia != null) {
    setValueByPath(toObject, ["mediaChunks"], tBlobs(fromMedia));
  }
  const fromAudio = getValueByPath(fromObject, ["audio"]);
  if (fromAudio != null) {
    setValueByPath(toObject, ["audio"], tAudioBlob(fromAudio));
  }
  const fromAudioStreamEnd = getValueByPath(fromObject, [
    "audioStreamEnd"
  ]);
  if (fromAudioStreamEnd != null) {
    setValueByPath(toObject, ["audioStreamEnd"], fromAudioStreamEnd);
  }
  const fromVideo = getValueByPath(fromObject, ["video"]);
  if (fromVideo != null) {
    setValueByPath(toObject, ["video"], tImageBlob(fromVideo));
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  const fromActivityStart = getValueByPath(fromObject, [
    "activityStart"
  ]);
  if (fromActivityStart != null) {
    setValueByPath(toObject, ["activityStart"], activityStartToMldev());
  }
  const fromActivityEnd = getValueByPath(fromObject, ["activityEnd"]);
  if (fromActivityEnd != null) {
    setValueByPath(toObject, ["activityEnd"], activityEndToMldev());
  }
  return toObject;
}
function weightedPromptToMldev(fromObject) {
  const toObject = {};
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  const fromWeight = getValueByPath(fromObject, ["weight"]);
  if (fromWeight != null) {
    setValueByPath(toObject, ["weight"], fromWeight);
  }
  return toObject;
}
function liveMusicSetWeightedPromptsParametersToMldev(fromObject) {
  const toObject = {};
  const fromWeightedPrompts = getValueByPath(fromObject, [
    "weightedPrompts"
  ]);
  if (fromWeightedPrompts != null) {
    let transformedList = fromWeightedPrompts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return weightedPromptToMldev(item);
      });
    }
    setValueByPath(toObject, ["weightedPrompts"], transformedList);
  }
  return toObject;
}
function liveMusicGenerationConfigToMldev(fromObject) {
  const toObject = {};
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (fromTemperature != null) {
    setValueByPath(toObject, ["temperature"], fromTemperature);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (fromTopK != null) {
    setValueByPath(toObject, ["topK"], fromTopK);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (fromSeed != null) {
    setValueByPath(toObject, ["seed"], fromSeed);
  }
  const fromGuidance = getValueByPath(fromObject, ["guidance"]);
  if (fromGuidance != null) {
    setValueByPath(toObject, ["guidance"], fromGuidance);
  }
  const fromBpm = getValueByPath(fromObject, ["bpm"]);
  if (fromBpm != null) {
    setValueByPath(toObject, ["bpm"], fromBpm);
  }
  const fromDensity = getValueByPath(fromObject, ["density"]);
  if (fromDensity != null) {
    setValueByPath(toObject, ["density"], fromDensity);
  }
  const fromBrightness = getValueByPath(fromObject, ["brightness"]);
  if (fromBrightness != null) {
    setValueByPath(toObject, ["brightness"], fromBrightness);
  }
  const fromScale = getValueByPath(fromObject, ["scale"]);
  if (fromScale != null) {
    setValueByPath(toObject, ["scale"], fromScale);
  }
  const fromMuteBass = getValueByPath(fromObject, ["muteBass"]);
  if (fromMuteBass != null) {
    setValueByPath(toObject, ["muteBass"], fromMuteBass);
  }
  const fromMuteDrums = getValueByPath(fromObject, ["muteDrums"]);
  if (fromMuteDrums != null) {
    setValueByPath(toObject, ["muteDrums"], fromMuteDrums);
  }
  const fromOnlyBassAndDrums = getValueByPath(fromObject, [
    "onlyBassAndDrums"
  ]);
  if (fromOnlyBassAndDrums != null) {
    setValueByPath(toObject, ["onlyBassAndDrums"], fromOnlyBassAndDrums);
  }
  const fromMusicGenerationMode = getValueByPath(fromObject, [
    "musicGenerationMode"
  ]);
  if (fromMusicGenerationMode != null) {
    setValueByPath(toObject, ["musicGenerationMode"], fromMusicGenerationMode);
  }
  return toObject;
}
function liveMusicSetConfigParametersToMldev(fromObject) {
  const toObject = {};
  const fromMusicGenerationConfig = getValueByPath(fromObject, [
    "musicGenerationConfig"
  ]);
  if (fromMusicGenerationConfig != null) {
    setValueByPath(toObject, ["musicGenerationConfig"], liveMusicGenerationConfigToMldev(fromMusicGenerationConfig));
  }
  return toObject;
}
function liveMusicClientSetupToMldev(fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], fromModel);
  }
  return toObject;
}
function liveMusicClientContentToMldev(fromObject) {
  const toObject = {};
  const fromWeightedPrompts = getValueByPath(fromObject, [
    "weightedPrompts"
  ]);
  if (fromWeightedPrompts != null) {
    let transformedList = fromWeightedPrompts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return weightedPromptToMldev(item);
      });
    }
    setValueByPath(toObject, ["weightedPrompts"], transformedList);
  }
  return toObject;
}
function liveMusicClientMessageToMldev(fromObject) {
  const toObject = {};
  const fromSetup = getValueByPath(fromObject, ["setup"]);
  if (fromSetup != null) {
    setValueByPath(toObject, ["setup"], liveMusicClientSetupToMldev(fromSetup));
  }
  const fromClientContent = getValueByPath(fromObject, [
    "clientContent"
  ]);
  if (fromClientContent != null) {
    setValueByPath(toObject, ["clientContent"], liveMusicClientContentToMldev(fromClientContent));
  }
  const fromMusicGenerationConfig = getValueByPath(fromObject, [
    "musicGenerationConfig"
  ]);
  if (fromMusicGenerationConfig != null) {
    setValueByPath(toObject, ["musicGenerationConfig"], liveMusicGenerationConfigToMldev(fromMusicGenerationConfig));
  }
  const fromPlaybackControl = getValueByPath(fromObject, [
    "playbackControl"
  ]);
  if (fromPlaybackControl != null) {
    setValueByPath(toObject, ["playbackControl"], fromPlaybackControl);
  }
  return toObject;
}
function prebuiltVoiceConfigToVertex$1(fromObject) {
  const toObject = {};
  const fromVoiceName = getValueByPath(fromObject, ["voiceName"]);
  if (fromVoiceName != null) {
    setValueByPath(toObject, ["voiceName"], fromVoiceName);
  }
  return toObject;
}
function voiceConfigToVertex$1(fromObject) {
  const toObject = {};
  const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [
    "prebuiltVoiceConfig"
  ]);
  if (fromPrebuiltVoiceConfig != null) {
    setValueByPath(toObject, ["prebuiltVoiceConfig"], prebuiltVoiceConfigToVertex$1(fromPrebuiltVoiceConfig));
  }
  return toObject;
}
function speechConfigToVertex$1(fromObject) {
  const toObject = {};
  const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
  if (fromVoiceConfig != null) {
    setValueByPath(toObject, ["voiceConfig"], voiceConfigToVertex$1(fromVoiceConfig));
  }
  if (getValueByPath(fromObject, ["multiSpeakerVoiceConfig"]) !== void 0) {
    throw new Error("multiSpeakerVoiceConfig parameter is not supported in Vertex AI.");
  }
  const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
  if (fromLanguageCode != null) {
    setValueByPath(toObject, ["languageCode"], fromLanguageCode);
  }
  return toObject;
}
function videoMetadataToVertex$1(fromObject) {
  const toObject = {};
  const fromFps = getValueByPath(fromObject, ["fps"]);
  if (fromFps != null) {
    setValueByPath(toObject, ["fps"], fromFps);
  }
  const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
  if (fromEndOffset != null) {
    setValueByPath(toObject, ["endOffset"], fromEndOffset);
  }
  const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
  if (fromStartOffset != null) {
    setValueByPath(toObject, ["startOffset"], fromStartOffset);
  }
  return toObject;
}
function blobToVertex$1(fromObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function fileDataToVertex$1(fromObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function partToVertex$1(fromObject) {
  const toObject = {};
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], videoMetadataToVertex$1(fromVideoMetadata));
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobToVertex$1(fromInlineData));
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataToVertex$1(fromFileData));
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], fromFunctionCall);
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  return toObject;
}
function contentToVertex$1(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partToVertex$1(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function functionDeclarationToVertex$1(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["behavior"]) !== void 0) {
    throw new Error("behavior parameter is not supported in Vertex AI.");
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromParameters = getValueByPath(fromObject, ["parameters"]);
  if (fromParameters != null) {
    setValueByPath(toObject, ["parameters"], fromParameters);
  }
  const fromParametersJsonSchema = getValueByPath(fromObject, [
    "parametersJsonSchema"
  ]);
  if (fromParametersJsonSchema != null) {
    setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], fromResponse);
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  return toObject;
}
function intervalToVertex$1(fromObject) {
  const toObject = {};
  const fromStartTime = getValueByPath(fromObject, ["startTime"]);
  if (fromStartTime != null) {
    setValueByPath(toObject, ["startTime"], fromStartTime);
  }
  const fromEndTime = getValueByPath(fromObject, ["endTime"]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  return toObject;
}
function googleSearchToVertex$1(fromObject) {
  const toObject = {};
  const fromTimeRangeFilter = getValueByPath(fromObject, [
    "timeRangeFilter"
  ]);
  if (fromTimeRangeFilter != null) {
    setValueByPath(toObject, ["timeRangeFilter"], intervalToVertex$1(fromTimeRangeFilter));
  }
  return toObject;
}
function dynamicRetrievalConfigToVertex$1(fromObject) {
  const toObject = {};
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  const fromDynamicThreshold = getValueByPath(fromObject, [
    "dynamicThreshold"
  ]);
  if (fromDynamicThreshold != null) {
    setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
  }
  return toObject;
}
function googleSearchRetrievalToVertex$1(fromObject) {
  const toObject = {};
  const fromDynamicRetrievalConfig = getValueByPath(fromObject, [
    "dynamicRetrievalConfig"
  ]);
  if (fromDynamicRetrievalConfig != null) {
    setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToVertex$1(fromDynamicRetrievalConfig));
  }
  return toObject;
}
function enterpriseWebSearchToVertex$1() {
  const toObject = {};
  return toObject;
}
function apiKeyConfigToVertex$1(fromObject) {
  const toObject = {};
  const fromApiKeyString = getValueByPath(fromObject, ["apiKeyString"]);
  if (fromApiKeyString != null) {
    setValueByPath(toObject, ["apiKeyString"], fromApiKeyString);
  }
  return toObject;
}
function authConfigToVertex$1(fromObject) {
  const toObject = {};
  const fromApiKeyConfig = getValueByPath(fromObject, ["apiKeyConfig"]);
  if (fromApiKeyConfig != null) {
    setValueByPath(toObject, ["apiKeyConfig"], apiKeyConfigToVertex$1(fromApiKeyConfig));
  }
  const fromAuthType = getValueByPath(fromObject, ["authType"]);
  if (fromAuthType != null) {
    setValueByPath(toObject, ["authType"], fromAuthType);
  }
  const fromGoogleServiceAccountConfig = getValueByPath(fromObject, [
    "googleServiceAccountConfig"
  ]);
  if (fromGoogleServiceAccountConfig != null) {
    setValueByPath(toObject, ["googleServiceAccountConfig"], fromGoogleServiceAccountConfig);
  }
  const fromHttpBasicAuthConfig = getValueByPath(fromObject, [
    "httpBasicAuthConfig"
  ]);
  if (fromHttpBasicAuthConfig != null) {
    setValueByPath(toObject, ["httpBasicAuthConfig"], fromHttpBasicAuthConfig);
  }
  const fromOauthConfig = getValueByPath(fromObject, ["oauthConfig"]);
  if (fromOauthConfig != null) {
    setValueByPath(toObject, ["oauthConfig"], fromOauthConfig);
  }
  const fromOidcConfig = getValueByPath(fromObject, ["oidcConfig"]);
  if (fromOidcConfig != null) {
    setValueByPath(toObject, ["oidcConfig"], fromOidcConfig);
  }
  return toObject;
}
function googleMapsToVertex$1(fromObject) {
  const toObject = {};
  const fromAuthConfig = getValueByPath(fromObject, ["authConfig"]);
  if (fromAuthConfig != null) {
    setValueByPath(toObject, ["authConfig"], authConfigToVertex$1(fromAuthConfig));
  }
  return toObject;
}
function urlContextToVertex$1() {
  const toObject = {};
  return toObject;
}
function toolToVertex$1(fromObject) {
  const toObject = {};
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return functionDeclarationToVertex$1(item);
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
  if (fromRetrieval != null) {
    setValueByPath(toObject, ["retrieval"], fromRetrieval);
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], googleSearchToVertex$1(fromGoogleSearch));
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToVertex$1(fromGoogleSearchRetrieval));
  }
  const fromEnterpriseWebSearch = getValueByPath(fromObject, [
    "enterpriseWebSearch"
  ]);
  if (fromEnterpriseWebSearch != null) {
    setValueByPath(toObject, ["enterpriseWebSearch"], enterpriseWebSearchToVertex$1());
  }
  const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
  if (fromGoogleMaps != null) {
    setValueByPath(toObject, ["googleMaps"], googleMapsToVertex$1(fromGoogleMaps));
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], urlContextToVertex$1());
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  return toObject;
}
function sessionResumptionConfigToVertex(fromObject) {
  const toObject = {};
  const fromHandle = getValueByPath(fromObject, ["handle"]);
  if (fromHandle != null) {
    setValueByPath(toObject, ["handle"], fromHandle);
  }
  const fromTransparent = getValueByPath(fromObject, ["transparent"]);
  if (fromTransparent != null) {
    setValueByPath(toObject, ["transparent"], fromTransparent);
  }
  return toObject;
}
function audioTranscriptionConfigToVertex() {
  const toObject = {};
  return toObject;
}
function automaticActivityDetectionToVertex(fromObject) {
  const toObject = {};
  const fromDisabled = getValueByPath(fromObject, ["disabled"]);
  if (fromDisabled != null) {
    setValueByPath(toObject, ["disabled"], fromDisabled);
  }
  const fromStartOfSpeechSensitivity = getValueByPath(fromObject, [
    "startOfSpeechSensitivity"
  ]);
  if (fromStartOfSpeechSensitivity != null) {
    setValueByPath(toObject, ["startOfSpeechSensitivity"], fromStartOfSpeechSensitivity);
  }
  const fromEndOfSpeechSensitivity = getValueByPath(fromObject, [
    "endOfSpeechSensitivity"
  ]);
  if (fromEndOfSpeechSensitivity != null) {
    setValueByPath(toObject, ["endOfSpeechSensitivity"], fromEndOfSpeechSensitivity);
  }
  const fromPrefixPaddingMs = getValueByPath(fromObject, [
    "prefixPaddingMs"
  ]);
  if (fromPrefixPaddingMs != null) {
    setValueByPath(toObject, ["prefixPaddingMs"], fromPrefixPaddingMs);
  }
  const fromSilenceDurationMs = getValueByPath(fromObject, [
    "silenceDurationMs"
  ]);
  if (fromSilenceDurationMs != null) {
    setValueByPath(toObject, ["silenceDurationMs"], fromSilenceDurationMs);
  }
  return toObject;
}
function realtimeInputConfigToVertex(fromObject) {
  const toObject = {};
  const fromAutomaticActivityDetection = getValueByPath(fromObject, [
    "automaticActivityDetection"
  ]);
  if (fromAutomaticActivityDetection != null) {
    setValueByPath(toObject, ["automaticActivityDetection"], automaticActivityDetectionToVertex(fromAutomaticActivityDetection));
  }
  const fromActivityHandling = getValueByPath(fromObject, [
    "activityHandling"
  ]);
  if (fromActivityHandling != null) {
    setValueByPath(toObject, ["activityHandling"], fromActivityHandling);
  }
  const fromTurnCoverage = getValueByPath(fromObject, ["turnCoverage"]);
  if (fromTurnCoverage != null) {
    setValueByPath(toObject, ["turnCoverage"], fromTurnCoverage);
  }
  return toObject;
}
function slidingWindowToVertex(fromObject) {
  const toObject = {};
  const fromTargetTokens = getValueByPath(fromObject, ["targetTokens"]);
  if (fromTargetTokens != null) {
    setValueByPath(toObject, ["targetTokens"], fromTargetTokens);
  }
  return toObject;
}
function contextWindowCompressionConfigToVertex(fromObject) {
  const toObject = {};
  const fromTriggerTokens = getValueByPath(fromObject, [
    "triggerTokens"
  ]);
  if (fromTriggerTokens != null) {
    setValueByPath(toObject, ["triggerTokens"], fromTriggerTokens);
  }
  const fromSlidingWindow = getValueByPath(fromObject, [
    "slidingWindow"
  ]);
  if (fromSlidingWindow != null) {
    setValueByPath(toObject, ["slidingWindow"], slidingWindowToVertex(fromSlidingWindow));
  }
  return toObject;
}
function proactivityConfigToVertex(fromObject) {
  const toObject = {};
  const fromProactiveAudio = getValueByPath(fromObject, [
    "proactiveAudio"
  ]);
  if (fromProactiveAudio != null) {
    setValueByPath(toObject, ["proactiveAudio"], fromProactiveAudio);
  }
  return toObject;
}
function liveConnectConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromGenerationConfig = getValueByPath(fromObject, [
    "generationConfig"
  ]);
  if (parentObject !== void 0 && fromGenerationConfig != null) {
    setValueByPath(parentObject, ["setup", "generationConfig"], fromGenerationConfig);
  }
  const fromResponseModalities = getValueByPath(fromObject, [
    "responseModalities"
  ]);
  if (parentObject !== void 0 && fromResponseModalities != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "responseModalities"], fromResponseModalities);
  }
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (parentObject !== void 0 && fromTemperature != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "temperature"], fromTemperature);
  }
  const fromTopP = getValueByPath(fromObject, ["topP"]);
  if (parentObject !== void 0 && fromTopP != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "topP"], fromTopP);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (parentObject !== void 0 && fromTopK != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "topK"], fromTopK);
  }
  const fromMaxOutputTokens = getValueByPath(fromObject, [
    "maxOutputTokens"
  ]);
  if (parentObject !== void 0 && fromMaxOutputTokens != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "maxOutputTokens"], fromMaxOutputTokens);
  }
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (parentObject !== void 0 && fromMediaResolution != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "mediaResolution"], fromMediaResolution);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (parentObject !== void 0 && fromSeed != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "seed"], fromSeed);
  }
  const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
  if (parentObject !== void 0 && fromSpeechConfig != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "speechConfig"], speechConfigToVertex$1(tLiveSpeechConfig(fromSpeechConfig)));
  }
  const fromEnableAffectiveDialog = getValueByPath(fromObject, [
    "enableAffectiveDialog"
  ]);
  if (parentObject !== void 0 && fromEnableAffectiveDialog != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "enableAffectiveDialog"], fromEnableAffectiveDialog);
  }
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== void 0 && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["setup", "systemInstruction"], contentToVertex$1(tContent(fromSystemInstruction)));
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== void 0 && fromTools != null) {
    let transformedList = tTools(fromTools);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToVertex$1(tTool(item));
      });
    }
    setValueByPath(parentObject, ["setup", "tools"], transformedList);
  }
  const fromSessionResumption = getValueByPath(fromObject, [
    "sessionResumption"
  ]);
  if (parentObject !== void 0 && fromSessionResumption != null) {
    setValueByPath(parentObject, ["setup", "sessionResumption"], sessionResumptionConfigToVertex(fromSessionResumption));
  }
  const fromInputAudioTranscription = getValueByPath(fromObject, [
    "inputAudioTranscription"
  ]);
  if (parentObject !== void 0 && fromInputAudioTranscription != null) {
    setValueByPath(parentObject, ["setup", "inputAudioTranscription"], audioTranscriptionConfigToVertex());
  }
  const fromOutputAudioTranscription = getValueByPath(fromObject, [
    "outputAudioTranscription"
  ]);
  if (parentObject !== void 0 && fromOutputAudioTranscription != null) {
    setValueByPath(parentObject, ["setup", "outputAudioTranscription"], audioTranscriptionConfigToVertex());
  }
  const fromRealtimeInputConfig = getValueByPath(fromObject, [
    "realtimeInputConfig"
  ]);
  if (parentObject !== void 0 && fromRealtimeInputConfig != null) {
    setValueByPath(parentObject, ["setup", "realtimeInputConfig"], realtimeInputConfigToVertex(fromRealtimeInputConfig));
  }
  const fromContextWindowCompression = getValueByPath(fromObject, [
    "contextWindowCompression"
  ]);
  if (parentObject !== void 0 && fromContextWindowCompression != null) {
    setValueByPath(parentObject, ["setup", "contextWindowCompression"], contextWindowCompressionConfigToVertex(fromContextWindowCompression));
  }
  const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
  if (parentObject !== void 0 && fromProactivity != null) {
    setValueByPath(parentObject, ["setup", "proactivity"], proactivityConfigToVertex(fromProactivity));
  }
  return toObject;
}
function liveConnectParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], liveConnectConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function activityStartToVertex() {
  const toObject = {};
  return toObject;
}
function activityEndToVertex() {
  const toObject = {};
  return toObject;
}
function liveSendRealtimeInputParametersToVertex(fromObject) {
  const toObject = {};
  const fromMedia = getValueByPath(fromObject, ["media"]);
  if (fromMedia != null) {
    setValueByPath(toObject, ["mediaChunks"], tBlobs(fromMedia));
  }
  const fromAudio = getValueByPath(fromObject, ["audio"]);
  if (fromAudio != null) {
    setValueByPath(toObject, ["audio"], tAudioBlob(fromAudio));
  }
  const fromAudioStreamEnd = getValueByPath(fromObject, [
    "audioStreamEnd"
  ]);
  if (fromAudioStreamEnd != null) {
    setValueByPath(toObject, ["audioStreamEnd"], fromAudioStreamEnd);
  }
  const fromVideo = getValueByPath(fromObject, ["video"]);
  if (fromVideo != null) {
    setValueByPath(toObject, ["video"], tImageBlob(fromVideo));
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  const fromActivityStart = getValueByPath(fromObject, [
    "activityStart"
  ]);
  if (fromActivityStart != null) {
    setValueByPath(toObject, ["activityStart"], activityStartToVertex());
  }
  const fromActivityEnd = getValueByPath(fromObject, ["activityEnd"]);
  if (fromActivityEnd != null) {
    setValueByPath(toObject, ["activityEnd"], activityEndToVertex());
  }
  return toObject;
}
function liveServerSetupCompleteFromMldev() {
  const toObject = {};
  return toObject;
}
function videoMetadataFromMldev$1(fromObject) {
  const toObject = {};
  const fromFps = getValueByPath(fromObject, ["fps"]);
  if (fromFps != null) {
    setValueByPath(toObject, ["fps"], fromFps);
  }
  const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
  if (fromEndOffset != null) {
    setValueByPath(toObject, ["endOffset"], fromEndOffset);
  }
  const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
  if (fromStartOffset != null) {
    setValueByPath(toObject, ["startOffset"], fromStartOffset);
  }
  return toObject;
}
function blobFromMldev$1(fromObject) {
  const toObject = {};
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function fileDataFromMldev$1(fromObject) {
  const toObject = {};
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function partFromMldev$1(fromObject) {
  const toObject = {};
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], videoMetadataFromMldev$1(fromVideoMetadata));
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobFromMldev$1(fromInlineData));
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataFromMldev$1(fromFileData));
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], fromFunctionCall);
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  return toObject;
}
function contentFromMldev$1(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partFromMldev$1(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function transcriptionFromMldev(fromObject) {
  const toObject = {};
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  const fromFinished = getValueByPath(fromObject, ["finished"]);
  if (fromFinished != null) {
    setValueByPath(toObject, ["finished"], fromFinished);
  }
  return toObject;
}
function urlMetadataFromMldev$1(fromObject) {
  const toObject = {};
  const fromRetrievedUrl = getValueByPath(fromObject, ["retrievedUrl"]);
  if (fromRetrievedUrl != null) {
    setValueByPath(toObject, ["retrievedUrl"], fromRetrievedUrl);
  }
  const fromUrlRetrievalStatus = getValueByPath(fromObject, [
    "urlRetrievalStatus"
  ]);
  if (fromUrlRetrievalStatus != null) {
    setValueByPath(toObject, ["urlRetrievalStatus"], fromUrlRetrievalStatus);
  }
  return toObject;
}
function urlContextMetadataFromMldev$1(fromObject) {
  const toObject = {};
  const fromUrlMetadata = getValueByPath(fromObject, ["urlMetadata"]);
  if (fromUrlMetadata != null) {
    let transformedList = fromUrlMetadata;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return urlMetadataFromMldev$1(item);
      });
    }
    setValueByPath(toObject, ["urlMetadata"], transformedList);
  }
  return toObject;
}
function liveServerContentFromMldev(fromObject) {
  const toObject = {};
  const fromModelTurn = getValueByPath(fromObject, ["modelTurn"]);
  if (fromModelTurn != null) {
    setValueByPath(toObject, ["modelTurn"], contentFromMldev$1(fromModelTurn));
  }
  const fromTurnComplete = getValueByPath(fromObject, ["turnComplete"]);
  if (fromTurnComplete != null) {
    setValueByPath(toObject, ["turnComplete"], fromTurnComplete);
  }
  const fromInterrupted = getValueByPath(fromObject, ["interrupted"]);
  if (fromInterrupted != null) {
    setValueByPath(toObject, ["interrupted"], fromInterrupted);
  }
  const fromGroundingMetadata = getValueByPath(fromObject, [
    "groundingMetadata"
  ]);
  if (fromGroundingMetadata != null) {
    setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
  }
  const fromGenerationComplete = getValueByPath(fromObject, [
    "generationComplete"
  ]);
  if (fromGenerationComplete != null) {
    setValueByPath(toObject, ["generationComplete"], fromGenerationComplete);
  }
  const fromInputTranscription = getValueByPath(fromObject, [
    "inputTranscription"
  ]);
  if (fromInputTranscription != null) {
    setValueByPath(toObject, ["inputTranscription"], transcriptionFromMldev(fromInputTranscription));
  }
  const fromOutputTranscription = getValueByPath(fromObject, [
    "outputTranscription"
  ]);
  if (fromOutputTranscription != null) {
    setValueByPath(toObject, ["outputTranscription"], transcriptionFromMldev(fromOutputTranscription));
  }
  const fromUrlContextMetadata = getValueByPath(fromObject, [
    "urlContextMetadata"
  ]);
  if (fromUrlContextMetadata != null) {
    setValueByPath(toObject, ["urlContextMetadata"], urlContextMetadataFromMldev$1(fromUrlContextMetadata));
  }
  return toObject;
}
function functionCallFromMldev(fromObject) {
  const toObject = {};
  const fromId = getValueByPath(fromObject, ["id"]);
  if (fromId != null) {
    setValueByPath(toObject, ["id"], fromId);
  }
  const fromArgs = getValueByPath(fromObject, ["args"]);
  if (fromArgs != null) {
    setValueByPath(toObject, ["args"], fromArgs);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  return toObject;
}
function liveServerToolCallFromMldev(fromObject) {
  const toObject = {};
  const fromFunctionCalls = getValueByPath(fromObject, [
    "functionCalls"
  ]);
  if (fromFunctionCalls != null) {
    let transformedList = fromFunctionCalls;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return functionCallFromMldev(item);
      });
    }
    setValueByPath(toObject, ["functionCalls"], transformedList);
  }
  return toObject;
}
function liveServerToolCallCancellationFromMldev(fromObject) {
  const toObject = {};
  const fromIds = getValueByPath(fromObject, ["ids"]);
  if (fromIds != null) {
    setValueByPath(toObject, ["ids"], fromIds);
  }
  return toObject;
}
function modalityTokenCountFromMldev(fromObject) {
  const toObject = {};
  const fromModality = getValueByPath(fromObject, ["modality"]);
  if (fromModality != null) {
    setValueByPath(toObject, ["modality"], fromModality);
  }
  const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
  if (fromTokenCount != null) {
    setValueByPath(toObject, ["tokenCount"], fromTokenCount);
  }
  return toObject;
}
function usageMetadataFromMldev(fromObject) {
  const toObject = {};
  const fromPromptTokenCount = getValueByPath(fromObject, [
    "promptTokenCount"
  ]);
  if (fromPromptTokenCount != null) {
    setValueByPath(toObject, ["promptTokenCount"], fromPromptTokenCount);
  }
  const fromCachedContentTokenCount = getValueByPath(fromObject, [
    "cachedContentTokenCount"
  ]);
  if (fromCachedContentTokenCount != null) {
    setValueByPath(toObject, ["cachedContentTokenCount"], fromCachedContentTokenCount);
  }
  const fromResponseTokenCount = getValueByPath(fromObject, [
    "responseTokenCount"
  ]);
  if (fromResponseTokenCount != null) {
    setValueByPath(toObject, ["responseTokenCount"], fromResponseTokenCount);
  }
  const fromToolUsePromptTokenCount = getValueByPath(fromObject, [
    "toolUsePromptTokenCount"
  ]);
  if (fromToolUsePromptTokenCount != null) {
    setValueByPath(toObject, ["toolUsePromptTokenCount"], fromToolUsePromptTokenCount);
  }
  const fromThoughtsTokenCount = getValueByPath(fromObject, [
    "thoughtsTokenCount"
  ]);
  if (fromThoughtsTokenCount != null) {
    setValueByPath(toObject, ["thoughtsTokenCount"], fromThoughtsTokenCount);
  }
  const fromTotalTokenCount = getValueByPath(fromObject, [
    "totalTokenCount"
  ]);
  if (fromTotalTokenCount != null) {
    setValueByPath(toObject, ["totalTokenCount"], fromTotalTokenCount);
  }
  const fromPromptTokensDetails = getValueByPath(fromObject, [
    "promptTokensDetails"
  ]);
  if (fromPromptTokensDetails != null) {
    let transformedList = fromPromptTokensDetails;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return modalityTokenCountFromMldev(item);
      });
    }
    setValueByPath(toObject, ["promptTokensDetails"], transformedList);
  }
  const fromCacheTokensDetails = getValueByPath(fromObject, [
    "cacheTokensDetails"
  ]);
  if (fromCacheTokensDetails != null) {
    let transformedList = fromCacheTokensDetails;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return modalityTokenCountFromMldev(item);
      });
    }
    setValueByPath(toObject, ["cacheTokensDetails"], transformedList);
  }
  const fromResponseTokensDetails = getValueByPath(fromObject, [
    "responseTokensDetails"
  ]);
  if (fromResponseTokensDetails != null) {
    let transformedList = fromResponseTokensDetails;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return modalityTokenCountFromMldev(item);
      });
    }
    setValueByPath(toObject, ["responseTokensDetails"], transformedList);
  }
  const fromToolUsePromptTokensDetails = getValueByPath(fromObject, [
    "toolUsePromptTokensDetails"
  ]);
  if (fromToolUsePromptTokensDetails != null) {
    let transformedList = fromToolUsePromptTokensDetails;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return modalityTokenCountFromMldev(item);
      });
    }
    setValueByPath(toObject, ["toolUsePromptTokensDetails"], transformedList);
  }
  return toObject;
}
function liveServerGoAwayFromMldev(fromObject) {
  const toObject = {};
  const fromTimeLeft = getValueByPath(fromObject, ["timeLeft"]);
  if (fromTimeLeft != null) {
    setValueByPath(toObject, ["timeLeft"], fromTimeLeft);
  }
  return toObject;
}
function liveServerSessionResumptionUpdateFromMldev(fromObject) {
  const toObject = {};
  const fromNewHandle = getValueByPath(fromObject, ["newHandle"]);
  if (fromNewHandle != null) {
    setValueByPath(toObject, ["newHandle"], fromNewHandle);
  }
  const fromResumable = getValueByPath(fromObject, ["resumable"]);
  if (fromResumable != null) {
    setValueByPath(toObject, ["resumable"], fromResumable);
  }
  const fromLastConsumedClientMessageIndex = getValueByPath(fromObject, [
    "lastConsumedClientMessageIndex"
  ]);
  if (fromLastConsumedClientMessageIndex != null) {
    setValueByPath(toObject, ["lastConsumedClientMessageIndex"], fromLastConsumedClientMessageIndex);
  }
  return toObject;
}
function liveServerMessageFromMldev(fromObject) {
  const toObject = {};
  const fromSetupComplete = getValueByPath(fromObject, [
    "setupComplete"
  ]);
  if (fromSetupComplete != null) {
    setValueByPath(toObject, ["setupComplete"], liveServerSetupCompleteFromMldev());
  }
  const fromServerContent = getValueByPath(fromObject, [
    "serverContent"
  ]);
  if (fromServerContent != null) {
    setValueByPath(toObject, ["serverContent"], liveServerContentFromMldev(fromServerContent));
  }
  const fromToolCall = getValueByPath(fromObject, ["toolCall"]);
  if (fromToolCall != null) {
    setValueByPath(toObject, ["toolCall"], liveServerToolCallFromMldev(fromToolCall));
  }
  const fromToolCallCancellation = getValueByPath(fromObject, [
    "toolCallCancellation"
  ]);
  if (fromToolCallCancellation != null) {
    setValueByPath(toObject, ["toolCallCancellation"], liveServerToolCallCancellationFromMldev(fromToolCallCancellation));
  }
  const fromUsageMetadata = getValueByPath(fromObject, [
    "usageMetadata"
  ]);
  if (fromUsageMetadata != null) {
    setValueByPath(toObject, ["usageMetadata"], usageMetadataFromMldev(fromUsageMetadata));
  }
  const fromGoAway = getValueByPath(fromObject, ["goAway"]);
  if (fromGoAway != null) {
    setValueByPath(toObject, ["goAway"], liveServerGoAwayFromMldev(fromGoAway));
  }
  const fromSessionResumptionUpdate = getValueByPath(fromObject, [
    "sessionResumptionUpdate"
  ]);
  if (fromSessionResumptionUpdate != null) {
    setValueByPath(toObject, ["sessionResumptionUpdate"], liveServerSessionResumptionUpdateFromMldev(fromSessionResumptionUpdate));
  }
  return toObject;
}
function liveMusicServerSetupCompleteFromMldev() {
  const toObject = {};
  return toObject;
}
function weightedPromptFromMldev(fromObject) {
  const toObject = {};
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  const fromWeight = getValueByPath(fromObject, ["weight"]);
  if (fromWeight != null) {
    setValueByPath(toObject, ["weight"], fromWeight);
  }
  return toObject;
}
function liveMusicClientContentFromMldev(fromObject) {
  const toObject = {};
  const fromWeightedPrompts = getValueByPath(fromObject, [
    "weightedPrompts"
  ]);
  if (fromWeightedPrompts != null) {
    let transformedList = fromWeightedPrompts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return weightedPromptFromMldev(item);
      });
    }
    setValueByPath(toObject, ["weightedPrompts"], transformedList);
  }
  return toObject;
}
function liveMusicGenerationConfigFromMldev(fromObject) {
  const toObject = {};
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (fromTemperature != null) {
    setValueByPath(toObject, ["temperature"], fromTemperature);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (fromTopK != null) {
    setValueByPath(toObject, ["topK"], fromTopK);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (fromSeed != null) {
    setValueByPath(toObject, ["seed"], fromSeed);
  }
  const fromGuidance = getValueByPath(fromObject, ["guidance"]);
  if (fromGuidance != null) {
    setValueByPath(toObject, ["guidance"], fromGuidance);
  }
  const fromBpm = getValueByPath(fromObject, ["bpm"]);
  if (fromBpm != null) {
    setValueByPath(toObject, ["bpm"], fromBpm);
  }
  const fromDensity = getValueByPath(fromObject, ["density"]);
  if (fromDensity != null) {
    setValueByPath(toObject, ["density"], fromDensity);
  }
  const fromBrightness = getValueByPath(fromObject, ["brightness"]);
  if (fromBrightness != null) {
    setValueByPath(toObject, ["brightness"], fromBrightness);
  }
  const fromScale = getValueByPath(fromObject, ["scale"]);
  if (fromScale != null) {
    setValueByPath(toObject, ["scale"], fromScale);
  }
  const fromMuteBass = getValueByPath(fromObject, ["muteBass"]);
  if (fromMuteBass != null) {
    setValueByPath(toObject, ["muteBass"], fromMuteBass);
  }
  const fromMuteDrums = getValueByPath(fromObject, ["muteDrums"]);
  if (fromMuteDrums != null) {
    setValueByPath(toObject, ["muteDrums"], fromMuteDrums);
  }
  const fromOnlyBassAndDrums = getValueByPath(fromObject, [
    "onlyBassAndDrums"
  ]);
  if (fromOnlyBassAndDrums != null) {
    setValueByPath(toObject, ["onlyBassAndDrums"], fromOnlyBassAndDrums);
  }
  const fromMusicGenerationMode = getValueByPath(fromObject, [
    "musicGenerationMode"
  ]);
  if (fromMusicGenerationMode != null) {
    setValueByPath(toObject, ["musicGenerationMode"], fromMusicGenerationMode);
  }
  return toObject;
}
function liveMusicSourceMetadataFromMldev(fromObject) {
  const toObject = {};
  const fromClientContent = getValueByPath(fromObject, [
    "clientContent"
  ]);
  if (fromClientContent != null) {
    setValueByPath(toObject, ["clientContent"], liveMusicClientContentFromMldev(fromClientContent));
  }
  const fromMusicGenerationConfig = getValueByPath(fromObject, [
    "musicGenerationConfig"
  ]);
  if (fromMusicGenerationConfig != null) {
    setValueByPath(toObject, ["musicGenerationConfig"], liveMusicGenerationConfigFromMldev(fromMusicGenerationConfig));
  }
  return toObject;
}
function audioChunkFromMldev(fromObject) {
  const toObject = {};
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  const fromSourceMetadata = getValueByPath(fromObject, [
    "sourceMetadata"
  ]);
  if (fromSourceMetadata != null) {
    setValueByPath(toObject, ["sourceMetadata"], liveMusicSourceMetadataFromMldev(fromSourceMetadata));
  }
  return toObject;
}
function liveMusicServerContentFromMldev(fromObject) {
  const toObject = {};
  const fromAudioChunks = getValueByPath(fromObject, ["audioChunks"]);
  if (fromAudioChunks != null) {
    let transformedList = fromAudioChunks;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return audioChunkFromMldev(item);
      });
    }
    setValueByPath(toObject, ["audioChunks"], transformedList);
  }
  return toObject;
}
function liveMusicFilteredPromptFromMldev(fromObject) {
  const toObject = {};
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  const fromFilteredReason = getValueByPath(fromObject, [
    "filteredReason"
  ]);
  if (fromFilteredReason != null) {
    setValueByPath(toObject, ["filteredReason"], fromFilteredReason);
  }
  return toObject;
}
function liveMusicServerMessageFromMldev(fromObject) {
  const toObject = {};
  const fromSetupComplete = getValueByPath(fromObject, [
    "setupComplete"
  ]);
  if (fromSetupComplete != null) {
    setValueByPath(toObject, ["setupComplete"], liveMusicServerSetupCompleteFromMldev());
  }
  const fromServerContent = getValueByPath(fromObject, [
    "serverContent"
  ]);
  if (fromServerContent != null) {
    setValueByPath(toObject, ["serverContent"], liveMusicServerContentFromMldev(fromServerContent));
  }
  const fromFilteredPrompt = getValueByPath(fromObject, [
    "filteredPrompt"
  ]);
  if (fromFilteredPrompt != null) {
    setValueByPath(toObject, ["filteredPrompt"], liveMusicFilteredPromptFromMldev(fromFilteredPrompt));
  }
  return toObject;
}
function liveServerSetupCompleteFromVertex(fromObject) {
  const toObject = {};
  const fromSessionId = getValueByPath(fromObject, ["sessionId"]);
  if (fromSessionId != null) {
    setValueByPath(toObject, ["sessionId"], fromSessionId);
  }
  return toObject;
}
function videoMetadataFromVertex$1(fromObject) {
  const toObject = {};
  const fromFps = getValueByPath(fromObject, ["fps"]);
  if (fromFps != null) {
    setValueByPath(toObject, ["fps"], fromFps);
  }
  const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
  if (fromEndOffset != null) {
    setValueByPath(toObject, ["endOffset"], fromEndOffset);
  }
  const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
  if (fromStartOffset != null) {
    setValueByPath(toObject, ["startOffset"], fromStartOffset);
  }
  return toObject;
}
function blobFromVertex$1(fromObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function fileDataFromVertex$1(fromObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function partFromVertex$1(fromObject) {
  const toObject = {};
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], videoMetadataFromVertex$1(fromVideoMetadata));
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobFromVertex$1(fromInlineData));
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataFromVertex$1(fromFileData));
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], fromFunctionCall);
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  return toObject;
}
function contentFromVertex$1(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partFromVertex$1(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function transcriptionFromVertex(fromObject) {
  const toObject = {};
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  const fromFinished = getValueByPath(fromObject, ["finished"]);
  if (fromFinished != null) {
    setValueByPath(toObject, ["finished"], fromFinished);
  }
  return toObject;
}
function liveServerContentFromVertex(fromObject) {
  const toObject = {};
  const fromModelTurn = getValueByPath(fromObject, ["modelTurn"]);
  if (fromModelTurn != null) {
    setValueByPath(toObject, ["modelTurn"], contentFromVertex$1(fromModelTurn));
  }
  const fromTurnComplete = getValueByPath(fromObject, ["turnComplete"]);
  if (fromTurnComplete != null) {
    setValueByPath(toObject, ["turnComplete"], fromTurnComplete);
  }
  const fromInterrupted = getValueByPath(fromObject, ["interrupted"]);
  if (fromInterrupted != null) {
    setValueByPath(toObject, ["interrupted"], fromInterrupted);
  }
  const fromGroundingMetadata = getValueByPath(fromObject, [
    "groundingMetadata"
  ]);
  if (fromGroundingMetadata != null) {
    setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
  }
  const fromGenerationComplete = getValueByPath(fromObject, [
    "generationComplete"
  ]);
  if (fromGenerationComplete != null) {
    setValueByPath(toObject, ["generationComplete"], fromGenerationComplete);
  }
  const fromInputTranscription = getValueByPath(fromObject, [
    "inputTranscription"
  ]);
  if (fromInputTranscription != null) {
    setValueByPath(toObject, ["inputTranscription"], transcriptionFromVertex(fromInputTranscription));
  }
  const fromOutputTranscription = getValueByPath(fromObject, [
    "outputTranscription"
  ]);
  if (fromOutputTranscription != null) {
    setValueByPath(toObject, ["outputTranscription"], transcriptionFromVertex(fromOutputTranscription));
  }
  return toObject;
}
function functionCallFromVertex(fromObject) {
  const toObject = {};
  const fromArgs = getValueByPath(fromObject, ["args"]);
  if (fromArgs != null) {
    setValueByPath(toObject, ["args"], fromArgs);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  return toObject;
}
function liveServerToolCallFromVertex(fromObject) {
  const toObject = {};
  const fromFunctionCalls = getValueByPath(fromObject, [
    "functionCalls"
  ]);
  if (fromFunctionCalls != null) {
    let transformedList = fromFunctionCalls;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return functionCallFromVertex(item);
      });
    }
    setValueByPath(toObject, ["functionCalls"], transformedList);
  }
  return toObject;
}
function liveServerToolCallCancellationFromVertex(fromObject) {
  const toObject = {};
  const fromIds = getValueByPath(fromObject, ["ids"]);
  if (fromIds != null) {
    setValueByPath(toObject, ["ids"], fromIds);
  }
  return toObject;
}
function modalityTokenCountFromVertex(fromObject) {
  const toObject = {};
  const fromModality = getValueByPath(fromObject, ["modality"]);
  if (fromModality != null) {
    setValueByPath(toObject, ["modality"], fromModality);
  }
  const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
  if (fromTokenCount != null) {
    setValueByPath(toObject, ["tokenCount"], fromTokenCount);
  }
  return toObject;
}
function usageMetadataFromVertex(fromObject) {
  const toObject = {};
  const fromPromptTokenCount = getValueByPath(fromObject, [
    "promptTokenCount"
  ]);
  if (fromPromptTokenCount != null) {
    setValueByPath(toObject, ["promptTokenCount"], fromPromptTokenCount);
  }
  const fromCachedContentTokenCount = getValueByPath(fromObject, [
    "cachedContentTokenCount"
  ]);
  if (fromCachedContentTokenCount != null) {
    setValueByPath(toObject, ["cachedContentTokenCount"], fromCachedContentTokenCount);
  }
  const fromResponseTokenCount = getValueByPath(fromObject, [
    "candidatesTokenCount"
  ]);
  if (fromResponseTokenCount != null) {
    setValueByPath(toObject, ["responseTokenCount"], fromResponseTokenCount);
  }
  const fromToolUsePromptTokenCount = getValueByPath(fromObject, [
    "toolUsePromptTokenCount"
  ]);
  if (fromToolUsePromptTokenCount != null) {
    setValueByPath(toObject, ["toolUsePromptTokenCount"], fromToolUsePromptTokenCount);
  }
  const fromThoughtsTokenCount = getValueByPath(fromObject, [
    "thoughtsTokenCount"
  ]);
  if (fromThoughtsTokenCount != null) {
    setValueByPath(toObject, ["thoughtsTokenCount"], fromThoughtsTokenCount);
  }
  const fromTotalTokenCount = getValueByPath(fromObject, [
    "totalTokenCount"
  ]);
  if (fromTotalTokenCount != null) {
    setValueByPath(toObject, ["totalTokenCount"], fromTotalTokenCount);
  }
  const fromPromptTokensDetails = getValueByPath(fromObject, [
    "promptTokensDetails"
  ]);
  if (fromPromptTokensDetails != null) {
    let transformedList = fromPromptTokensDetails;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return modalityTokenCountFromVertex(item);
      });
    }
    setValueByPath(toObject, ["promptTokensDetails"], transformedList);
  }
  const fromCacheTokensDetails = getValueByPath(fromObject, [
    "cacheTokensDetails"
  ]);
  if (fromCacheTokensDetails != null) {
    let transformedList = fromCacheTokensDetails;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return modalityTokenCountFromVertex(item);
      });
    }
    setValueByPath(toObject, ["cacheTokensDetails"], transformedList);
  }
  const fromResponseTokensDetails = getValueByPath(fromObject, [
    "candidatesTokensDetails"
  ]);
  if (fromResponseTokensDetails != null) {
    let transformedList = fromResponseTokensDetails;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return modalityTokenCountFromVertex(item);
      });
    }
    setValueByPath(toObject, ["responseTokensDetails"], transformedList);
  }
  const fromToolUsePromptTokensDetails = getValueByPath(fromObject, [
    "toolUsePromptTokensDetails"
  ]);
  if (fromToolUsePromptTokensDetails != null) {
    let transformedList = fromToolUsePromptTokensDetails;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return modalityTokenCountFromVertex(item);
      });
    }
    setValueByPath(toObject, ["toolUsePromptTokensDetails"], transformedList);
  }
  const fromTrafficType = getValueByPath(fromObject, ["trafficType"]);
  if (fromTrafficType != null) {
    setValueByPath(toObject, ["trafficType"], fromTrafficType);
  }
  return toObject;
}
function liveServerGoAwayFromVertex(fromObject) {
  const toObject = {};
  const fromTimeLeft = getValueByPath(fromObject, ["timeLeft"]);
  if (fromTimeLeft != null) {
    setValueByPath(toObject, ["timeLeft"], fromTimeLeft);
  }
  return toObject;
}
function liveServerSessionResumptionUpdateFromVertex(fromObject) {
  const toObject = {};
  const fromNewHandle = getValueByPath(fromObject, ["newHandle"]);
  if (fromNewHandle != null) {
    setValueByPath(toObject, ["newHandle"], fromNewHandle);
  }
  const fromResumable = getValueByPath(fromObject, ["resumable"]);
  if (fromResumable != null) {
    setValueByPath(toObject, ["resumable"], fromResumable);
  }
  const fromLastConsumedClientMessageIndex = getValueByPath(fromObject, [
    "lastConsumedClientMessageIndex"
  ]);
  if (fromLastConsumedClientMessageIndex != null) {
    setValueByPath(toObject, ["lastConsumedClientMessageIndex"], fromLastConsumedClientMessageIndex);
  }
  return toObject;
}
function liveServerMessageFromVertex(fromObject) {
  const toObject = {};
  const fromSetupComplete = getValueByPath(fromObject, [
    "setupComplete"
  ]);
  if (fromSetupComplete != null) {
    setValueByPath(toObject, ["setupComplete"], liveServerSetupCompleteFromVertex(fromSetupComplete));
  }
  const fromServerContent = getValueByPath(fromObject, [
    "serverContent"
  ]);
  if (fromServerContent != null) {
    setValueByPath(toObject, ["serverContent"], liveServerContentFromVertex(fromServerContent));
  }
  const fromToolCall = getValueByPath(fromObject, ["toolCall"]);
  if (fromToolCall != null) {
    setValueByPath(toObject, ["toolCall"], liveServerToolCallFromVertex(fromToolCall));
  }
  const fromToolCallCancellation = getValueByPath(fromObject, [
    "toolCallCancellation"
  ]);
  if (fromToolCallCancellation != null) {
    setValueByPath(toObject, ["toolCallCancellation"], liveServerToolCallCancellationFromVertex(fromToolCallCancellation));
  }
  const fromUsageMetadata = getValueByPath(fromObject, [
    "usageMetadata"
  ]);
  if (fromUsageMetadata != null) {
    setValueByPath(toObject, ["usageMetadata"], usageMetadataFromVertex(fromUsageMetadata));
  }
  const fromGoAway = getValueByPath(fromObject, ["goAway"]);
  if (fromGoAway != null) {
    setValueByPath(toObject, ["goAway"], liveServerGoAwayFromVertex(fromGoAway));
  }
  const fromSessionResumptionUpdate = getValueByPath(fromObject, [
    "sessionResumptionUpdate"
  ]);
  if (fromSessionResumptionUpdate != null) {
    setValueByPath(toObject, ["sessionResumptionUpdate"], liveServerSessionResumptionUpdateFromVertex(fromSessionResumptionUpdate));
  }
  return toObject;
}
function videoMetadataToMldev$1(fromObject) {
  const toObject = {};
  const fromFps = getValueByPath(fromObject, ["fps"]);
  if (fromFps != null) {
    setValueByPath(toObject, ["fps"], fromFps);
  }
  const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
  if (fromEndOffset != null) {
    setValueByPath(toObject, ["endOffset"], fromEndOffset);
  }
  const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
  if (fromStartOffset != null) {
    setValueByPath(toObject, ["startOffset"], fromStartOffset);
  }
  return toObject;
}
function blobToMldev$1(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function fileDataToMldev$1(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function partToMldev$1(fromObject) {
  const toObject = {};
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], videoMetadataToMldev$1(fromVideoMetadata));
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobToMldev$1(fromInlineData));
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataToMldev$1(fromFileData));
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], fromFunctionCall);
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  return toObject;
}
function contentToMldev$1(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partToMldev$1(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function schemaToMldev(fromObject) {
  const toObject = {};
  const fromAnyOf = getValueByPath(fromObject, ["anyOf"]);
  if (fromAnyOf != null) {
    setValueByPath(toObject, ["anyOf"], fromAnyOf);
  }
  const fromDefault = getValueByPath(fromObject, ["default"]);
  if (fromDefault != null) {
    setValueByPath(toObject, ["default"], fromDefault);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromEnum = getValueByPath(fromObject, ["enum"]);
  if (fromEnum != null) {
    setValueByPath(toObject, ["enum"], fromEnum);
  }
  const fromExample = getValueByPath(fromObject, ["example"]);
  if (fromExample != null) {
    setValueByPath(toObject, ["example"], fromExample);
  }
  const fromFormat = getValueByPath(fromObject, ["format"]);
  if (fromFormat != null) {
    setValueByPath(toObject, ["format"], fromFormat);
  }
  const fromItems = getValueByPath(fromObject, ["items"]);
  if (fromItems != null) {
    setValueByPath(toObject, ["items"], fromItems);
  }
  const fromMaxItems = getValueByPath(fromObject, ["maxItems"]);
  if (fromMaxItems != null) {
    setValueByPath(toObject, ["maxItems"], fromMaxItems);
  }
  const fromMaxLength = getValueByPath(fromObject, ["maxLength"]);
  if (fromMaxLength != null) {
    setValueByPath(toObject, ["maxLength"], fromMaxLength);
  }
  const fromMaxProperties = getValueByPath(fromObject, [
    "maxProperties"
  ]);
  if (fromMaxProperties != null) {
    setValueByPath(toObject, ["maxProperties"], fromMaxProperties);
  }
  const fromMaximum = getValueByPath(fromObject, ["maximum"]);
  if (fromMaximum != null) {
    setValueByPath(toObject, ["maximum"], fromMaximum);
  }
  const fromMinItems = getValueByPath(fromObject, ["minItems"]);
  if (fromMinItems != null) {
    setValueByPath(toObject, ["minItems"], fromMinItems);
  }
  const fromMinLength = getValueByPath(fromObject, ["minLength"]);
  if (fromMinLength != null) {
    setValueByPath(toObject, ["minLength"], fromMinLength);
  }
  const fromMinProperties = getValueByPath(fromObject, [
    "minProperties"
  ]);
  if (fromMinProperties != null) {
    setValueByPath(toObject, ["minProperties"], fromMinProperties);
  }
  const fromMinimum = getValueByPath(fromObject, ["minimum"]);
  if (fromMinimum != null) {
    setValueByPath(toObject, ["minimum"], fromMinimum);
  }
  const fromNullable = getValueByPath(fromObject, ["nullable"]);
  if (fromNullable != null) {
    setValueByPath(toObject, ["nullable"], fromNullable);
  }
  const fromPattern = getValueByPath(fromObject, ["pattern"]);
  if (fromPattern != null) {
    setValueByPath(toObject, ["pattern"], fromPattern);
  }
  const fromProperties = getValueByPath(fromObject, ["properties"]);
  if (fromProperties != null) {
    setValueByPath(toObject, ["properties"], fromProperties);
  }
  const fromPropertyOrdering = getValueByPath(fromObject, [
    "propertyOrdering"
  ]);
  if (fromPropertyOrdering != null) {
    setValueByPath(toObject, ["propertyOrdering"], fromPropertyOrdering);
  }
  const fromRequired = getValueByPath(fromObject, ["required"]);
  if (fromRequired != null) {
    setValueByPath(toObject, ["required"], fromRequired);
  }
  const fromTitle = getValueByPath(fromObject, ["title"]);
  if (fromTitle != null) {
    setValueByPath(toObject, ["title"], fromTitle);
  }
  const fromType = getValueByPath(fromObject, ["type"]);
  if (fromType != null) {
    setValueByPath(toObject, ["type"], fromType);
  }
  return toObject;
}
function safetySettingToMldev(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["method"]) !== void 0) {
    throw new Error("method parameter is not supported in Gemini API.");
  }
  const fromCategory = getValueByPath(fromObject, ["category"]);
  if (fromCategory != null) {
    setValueByPath(toObject, ["category"], fromCategory);
  }
  const fromThreshold = getValueByPath(fromObject, ["threshold"]);
  if (fromThreshold != null) {
    setValueByPath(toObject, ["threshold"], fromThreshold);
  }
  return toObject;
}
function functionDeclarationToMldev$1(fromObject) {
  const toObject = {};
  const fromBehavior = getValueByPath(fromObject, ["behavior"]);
  if (fromBehavior != null) {
    setValueByPath(toObject, ["behavior"], fromBehavior);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromParameters = getValueByPath(fromObject, ["parameters"]);
  if (fromParameters != null) {
    setValueByPath(toObject, ["parameters"], fromParameters);
  }
  const fromParametersJsonSchema = getValueByPath(fromObject, [
    "parametersJsonSchema"
  ]);
  if (fromParametersJsonSchema != null) {
    setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], fromResponse);
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  return toObject;
}
function intervalToMldev$1(fromObject) {
  const toObject = {};
  const fromStartTime = getValueByPath(fromObject, ["startTime"]);
  if (fromStartTime != null) {
    setValueByPath(toObject, ["startTime"], fromStartTime);
  }
  const fromEndTime = getValueByPath(fromObject, ["endTime"]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  return toObject;
}
function googleSearchToMldev$1(fromObject) {
  const toObject = {};
  const fromTimeRangeFilter = getValueByPath(fromObject, [
    "timeRangeFilter"
  ]);
  if (fromTimeRangeFilter != null) {
    setValueByPath(toObject, ["timeRangeFilter"], intervalToMldev$1(fromTimeRangeFilter));
  }
  return toObject;
}
function dynamicRetrievalConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  const fromDynamicThreshold = getValueByPath(fromObject, [
    "dynamicThreshold"
  ]);
  if (fromDynamicThreshold != null) {
    setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
  }
  return toObject;
}
function googleSearchRetrievalToMldev$1(fromObject) {
  const toObject = {};
  const fromDynamicRetrievalConfig = getValueByPath(fromObject, [
    "dynamicRetrievalConfig"
  ]);
  if (fromDynamicRetrievalConfig != null) {
    setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToMldev$1(fromDynamicRetrievalConfig));
  }
  return toObject;
}
function urlContextToMldev$1() {
  const toObject = {};
  return toObject;
}
function toolToMldev$1(fromObject) {
  const toObject = {};
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return functionDeclarationToMldev$1(item);
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
    throw new Error("retrieval parameter is not supported in Gemini API.");
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$1(fromGoogleSearch));
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToMldev$1(fromGoogleSearchRetrieval));
  }
  if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
    throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["googleMaps"]) !== void 0) {
    throw new Error("googleMaps parameter is not supported in Gemini API.");
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], urlContextToMldev$1());
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  return toObject;
}
function functionCallingConfigToMldev(fromObject) {
  const toObject = {};
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  const fromAllowedFunctionNames = getValueByPath(fromObject, [
    "allowedFunctionNames"
  ]);
  if (fromAllowedFunctionNames != null) {
    setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
  }
  return toObject;
}
function latLngToMldev(fromObject) {
  const toObject = {};
  const fromLatitude = getValueByPath(fromObject, ["latitude"]);
  if (fromLatitude != null) {
    setValueByPath(toObject, ["latitude"], fromLatitude);
  }
  const fromLongitude = getValueByPath(fromObject, ["longitude"]);
  if (fromLongitude != null) {
    setValueByPath(toObject, ["longitude"], fromLongitude);
  }
  return toObject;
}
function retrievalConfigToMldev(fromObject) {
  const toObject = {};
  const fromLatLng = getValueByPath(fromObject, ["latLng"]);
  if (fromLatLng != null) {
    setValueByPath(toObject, ["latLng"], latLngToMldev(fromLatLng));
  }
  const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
  if (fromLanguageCode != null) {
    setValueByPath(toObject, ["languageCode"], fromLanguageCode);
  }
  return toObject;
}
function toolConfigToMldev(fromObject) {
  const toObject = {};
  const fromFunctionCallingConfig = getValueByPath(fromObject, [
    "functionCallingConfig"
  ]);
  if (fromFunctionCallingConfig != null) {
    setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev(fromFunctionCallingConfig));
  }
  const fromRetrievalConfig = getValueByPath(fromObject, [
    "retrievalConfig"
  ]);
  if (fromRetrievalConfig != null) {
    setValueByPath(toObject, ["retrievalConfig"], retrievalConfigToMldev(fromRetrievalConfig));
  }
  return toObject;
}
function prebuiltVoiceConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromVoiceName = getValueByPath(fromObject, ["voiceName"]);
  if (fromVoiceName != null) {
    setValueByPath(toObject, ["voiceName"], fromVoiceName);
  }
  return toObject;
}
function voiceConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [
    "prebuiltVoiceConfig"
  ]);
  if (fromPrebuiltVoiceConfig != null) {
    setValueByPath(toObject, ["prebuiltVoiceConfig"], prebuiltVoiceConfigToMldev$1(fromPrebuiltVoiceConfig));
  }
  return toObject;
}
function speakerVoiceConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromSpeaker = getValueByPath(fromObject, ["speaker"]);
  if (fromSpeaker != null) {
    setValueByPath(toObject, ["speaker"], fromSpeaker);
  }
  const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
  if (fromVoiceConfig != null) {
    setValueByPath(toObject, ["voiceConfig"], voiceConfigToMldev$1(fromVoiceConfig));
  }
  return toObject;
}
function multiSpeakerVoiceConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromSpeakerVoiceConfigs = getValueByPath(fromObject, [
    "speakerVoiceConfigs"
  ]);
  if (fromSpeakerVoiceConfigs != null) {
    let transformedList = fromSpeakerVoiceConfigs;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return speakerVoiceConfigToMldev$1(item);
      });
    }
    setValueByPath(toObject, ["speakerVoiceConfigs"], transformedList);
  }
  return toObject;
}
function speechConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
  if (fromVoiceConfig != null) {
    setValueByPath(toObject, ["voiceConfig"], voiceConfigToMldev$1(fromVoiceConfig));
  }
  const fromMultiSpeakerVoiceConfig = getValueByPath(fromObject, [
    "multiSpeakerVoiceConfig"
  ]);
  if (fromMultiSpeakerVoiceConfig != null) {
    setValueByPath(toObject, ["multiSpeakerVoiceConfig"], multiSpeakerVoiceConfigToMldev$1(fromMultiSpeakerVoiceConfig));
  }
  const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
  if (fromLanguageCode != null) {
    setValueByPath(toObject, ["languageCode"], fromLanguageCode);
  }
  return toObject;
}
function thinkingConfigToMldev(fromObject) {
  const toObject = {};
  const fromIncludeThoughts = getValueByPath(fromObject, [
    "includeThoughts"
  ]);
  if (fromIncludeThoughts != null) {
    setValueByPath(toObject, ["includeThoughts"], fromIncludeThoughts);
  }
  const fromThinkingBudget = getValueByPath(fromObject, [
    "thinkingBudget"
  ]);
  if (fromThinkingBudget != null) {
    setValueByPath(toObject, ["thinkingBudget"], fromThinkingBudget);
  }
  return toObject;
}
function generateContentConfigToMldev(apiClient, fromObject, parentObject) {
  const toObject = {};
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== void 0 && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["systemInstruction"], contentToMldev$1(tContent(fromSystemInstruction)));
  }
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (fromTemperature != null) {
    setValueByPath(toObject, ["temperature"], fromTemperature);
  }
  const fromTopP = getValueByPath(fromObject, ["topP"]);
  if (fromTopP != null) {
    setValueByPath(toObject, ["topP"], fromTopP);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (fromTopK != null) {
    setValueByPath(toObject, ["topK"], fromTopK);
  }
  const fromCandidateCount = getValueByPath(fromObject, [
    "candidateCount"
  ]);
  if (fromCandidateCount != null) {
    setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
  }
  const fromMaxOutputTokens = getValueByPath(fromObject, [
    "maxOutputTokens"
  ]);
  if (fromMaxOutputTokens != null) {
    setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
  }
  const fromStopSequences = getValueByPath(fromObject, [
    "stopSequences"
  ]);
  if (fromStopSequences != null) {
    setValueByPath(toObject, ["stopSequences"], fromStopSequences);
  }
  const fromResponseLogprobs = getValueByPath(fromObject, [
    "responseLogprobs"
  ]);
  if (fromResponseLogprobs != null) {
    setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
  }
  const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
  if (fromLogprobs != null) {
    setValueByPath(toObject, ["logprobs"], fromLogprobs);
  }
  const fromPresencePenalty = getValueByPath(fromObject, [
    "presencePenalty"
  ]);
  if (fromPresencePenalty != null) {
    setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
  }
  const fromFrequencyPenalty = getValueByPath(fromObject, [
    "frequencyPenalty"
  ]);
  if (fromFrequencyPenalty != null) {
    setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (fromSeed != null) {
    setValueByPath(toObject, ["seed"], fromSeed);
  }
  const fromResponseMimeType = getValueByPath(fromObject, [
    "responseMimeType"
  ]);
  if (fromResponseMimeType != null) {
    setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
  }
  const fromResponseSchema = getValueByPath(fromObject, [
    "responseSchema"
  ]);
  if (fromResponseSchema != null) {
    setValueByPath(toObject, ["responseSchema"], schemaToMldev(tSchema(fromResponseSchema)));
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  if (getValueByPath(fromObject, ["routingConfig"]) !== void 0) {
    throw new Error("routingConfig parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["modelSelectionConfig"]) !== void 0) {
    throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");
  }
  const fromSafetySettings = getValueByPath(fromObject, [
    "safetySettings"
  ]);
  if (parentObject !== void 0 && fromSafetySettings != null) {
    let transformedList = fromSafetySettings;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return safetySettingToMldev(item);
      });
    }
    setValueByPath(parentObject, ["safetySettings"], transformedList);
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== void 0 && fromTools != null) {
    let transformedList = tTools(fromTools);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToMldev$1(tTool(item));
      });
    }
    setValueByPath(parentObject, ["tools"], transformedList);
  }
  const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
  if (parentObject !== void 0 && fromToolConfig != null) {
    setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev(fromToolConfig));
  }
  if (getValueByPath(fromObject, ["labels"]) !== void 0) {
    throw new Error("labels parameter is not supported in Gemini API.");
  }
  const fromCachedContent = getValueByPath(fromObject, [
    "cachedContent"
  ]);
  if (parentObject !== void 0 && fromCachedContent != null) {
    setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
  }
  const fromResponseModalities = getValueByPath(fromObject, [
    "responseModalities"
  ]);
  if (fromResponseModalities != null) {
    setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
  }
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (fromMediaResolution != null) {
    setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
  }
  const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
  if (fromSpeechConfig != null) {
    setValueByPath(toObject, ["speechConfig"], speechConfigToMldev$1(tSpeechConfig(fromSpeechConfig)));
  }
  if (getValueByPath(fromObject, ["audioTimestamp"]) !== void 0) {
    throw new Error("audioTimestamp parameter is not supported in Gemini API.");
  }
  const fromThinkingConfig = getValueByPath(fromObject, [
    "thinkingConfig"
  ]);
  if (fromThinkingConfig != null) {
    setValueByPath(toObject, ["thinkingConfig"], thinkingConfigToMldev(fromThinkingConfig));
  }
  return toObject;
}
function generateContentParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return contentToMldev$1(item);
      });
    }
    setValueByPath(toObject, ["contents"], transformedList);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["generationConfig"], generateContentConfigToMldev(apiClient, fromConfig, toObject));
  }
  return toObject;
}
function embedContentConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromTaskType = getValueByPath(fromObject, ["taskType"]);
  if (parentObject !== void 0 && fromTaskType != null) {
    setValueByPath(parentObject, ["requests[]", "taskType"], fromTaskType);
  }
  const fromTitle = getValueByPath(fromObject, ["title"]);
  if (parentObject !== void 0 && fromTitle != null) {
    setValueByPath(parentObject, ["requests[]", "title"], fromTitle);
  }
  const fromOutputDimensionality = getValueByPath(fromObject, [
    "outputDimensionality"
  ]);
  if (parentObject !== void 0 && fromOutputDimensionality != null) {
    setValueByPath(parentObject, ["requests[]", "outputDimensionality"], fromOutputDimensionality);
  }
  if (getValueByPath(fromObject, ["mimeType"]) !== void 0) {
    throw new Error("mimeType parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["autoTruncate"]) !== void 0) {
    throw new Error("autoTruncate parameter is not supported in Gemini API.");
  }
  return toObject;
}
function embedContentParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    setValueByPath(toObject, ["requests[]", "content"], tContentsForEmbed(apiClient, fromContents));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], embedContentConfigToMldev(fromConfig, toObject));
  }
  const fromModelForEmbedContent = getValueByPath(fromObject, ["model"]);
  if (fromModelForEmbedContent !== void 0) {
    setValueByPath(toObject, ["requests[]", "model"], tModel(apiClient, fromModelForEmbedContent));
  }
  return toObject;
}
function generateImagesConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["outputGcsUri"]) !== void 0) {
    throw new Error("outputGcsUri parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["negativePrompt"]) !== void 0) {
    throw new Error("negativePrompt parameter is not supported in Gemini API.");
  }
  const fromNumberOfImages = getValueByPath(fromObject, [
    "numberOfImages"
  ]);
  if (parentObject !== void 0 && fromNumberOfImages != null) {
    setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
  }
  const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
  if (parentObject !== void 0 && fromAspectRatio != null) {
    setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
  }
  const fromGuidanceScale = getValueByPath(fromObject, [
    "guidanceScale"
  ]);
  if (parentObject !== void 0 && fromGuidanceScale != null) {
    setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
  }
  if (getValueByPath(fromObject, ["seed"]) !== void 0) {
    throw new Error("seed parameter is not supported in Gemini API.");
  }
  const fromSafetyFilterLevel = getValueByPath(fromObject, [
    "safetyFilterLevel"
  ]);
  if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
    setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
  }
  const fromPersonGeneration = getValueByPath(fromObject, [
    "personGeneration"
  ]);
  if (parentObject !== void 0 && fromPersonGeneration != null) {
    setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
  }
  const fromIncludeSafetyAttributes = getValueByPath(fromObject, [
    "includeSafetyAttributes"
  ]);
  if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) {
    setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
  }
  const fromIncludeRaiReason = getValueByPath(fromObject, [
    "includeRaiReason"
  ]);
  if (parentObject !== void 0 && fromIncludeRaiReason != null) {
    setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
  }
  const fromLanguage = getValueByPath(fromObject, ["language"]);
  if (parentObject !== void 0 && fromLanguage != null) {
    setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
  }
  const fromOutputMimeType = getValueByPath(fromObject, [
    "outputMimeType"
  ]);
  if (parentObject !== void 0 && fromOutputMimeType != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
  }
  const fromOutputCompressionQuality = getValueByPath(fromObject, [
    "outputCompressionQuality"
  ]);
  if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
  }
  if (getValueByPath(fromObject, ["addWatermark"]) !== void 0) {
    throw new Error("addWatermark parameter is not supported in Gemini API.");
  }
  const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
  if (parentObject !== void 0 && fromImageSize != null) {
    setValueByPath(parentObject, ["parameters", "sampleImageSize"], fromImageSize);
  }
  if (getValueByPath(fromObject, ["enhancePrompt"]) !== void 0) {
    throw new Error("enhancePrompt parameter is not supported in Gemini API.");
  }
  return toObject;
}
function generateImagesParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromPrompt = getValueByPath(fromObject, ["prompt"]);
  if (fromPrompt != null) {
    setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], generateImagesConfigToMldev(fromConfig, toObject));
  }
  return toObject;
}
function getModelParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function listModelsConfigToMldev(apiClient, fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  const fromFilter = getValueByPath(fromObject, ["filter"]);
  if (parentObject !== void 0 && fromFilter != null) {
    setValueByPath(parentObject, ["_query", "filter"], fromFilter);
  }
  const fromQueryBase = getValueByPath(fromObject, ["queryBase"]);
  if (parentObject !== void 0 && fromQueryBase != null) {
    setValueByPath(parentObject, ["_url", "models_url"], tModelsUrl(apiClient, fromQueryBase));
  }
  return toObject;
}
function listModelsParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], listModelsConfigToMldev(apiClient, fromConfig, toObject));
  }
  return toObject;
}
function updateModelConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (parentObject !== void 0 && fromDisplayName != null) {
    setValueByPath(parentObject, ["displayName"], fromDisplayName);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (parentObject !== void 0 && fromDescription != null) {
    setValueByPath(parentObject, ["description"], fromDescription);
  }
  const fromDefaultCheckpointId = getValueByPath(fromObject, [
    "defaultCheckpointId"
  ]);
  if (parentObject !== void 0 && fromDefaultCheckpointId != null) {
    setValueByPath(parentObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
  }
  return toObject;
}
function updateModelParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], updateModelConfigToMldev(fromConfig, toObject));
  }
  return toObject;
}
function deleteModelParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function countTokensConfigToMldev(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["systemInstruction"]) !== void 0) {
    throw new Error("systemInstruction parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["tools"]) !== void 0) {
    throw new Error("tools parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["generationConfig"]) !== void 0) {
    throw new Error("generationConfig parameter is not supported in Gemini API.");
  }
  return toObject;
}
function countTokensParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return contentToMldev$1(item);
      });
    }
    setValueByPath(toObject, ["contents"], transformedList);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], countTokensConfigToMldev(fromConfig));
  }
  return toObject;
}
function imageToMldev(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["gcsUri"]) !== void 0) {
    throw new Error("gcsUri parameter is not supported in Gemini API.");
  }
  const fromImageBytes = getValueByPath(fromObject, ["imageBytes"]);
  if (fromImageBytes != null) {
    setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(fromImageBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function generateVideosConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromNumberOfVideos = getValueByPath(fromObject, [
    "numberOfVideos"
  ]);
  if (parentObject !== void 0 && fromNumberOfVideos != null) {
    setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfVideos);
  }
  if (getValueByPath(fromObject, ["outputGcsUri"]) !== void 0) {
    throw new Error("outputGcsUri parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["fps"]) !== void 0) {
    throw new Error("fps parameter is not supported in Gemini API.");
  }
  const fromDurationSeconds = getValueByPath(fromObject, [
    "durationSeconds"
  ]);
  if (parentObject !== void 0 && fromDurationSeconds != null) {
    setValueByPath(parentObject, ["parameters", "durationSeconds"], fromDurationSeconds);
  }
  if (getValueByPath(fromObject, ["seed"]) !== void 0) {
    throw new Error("seed parameter is not supported in Gemini API.");
  }
  const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
  if (parentObject !== void 0 && fromAspectRatio != null) {
    setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
  }
  if (getValueByPath(fromObject, ["resolution"]) !== void 0) {
    throw new Error("resolution parameter is not supported in Gemini API.");
  }
  const fromPersonGeneration = getValueByPath(fromObject, [
    "personGeneration"
  ]);
  if (parentObject !== void 0 && fromPersonGeneration != null) {
    setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
  }
  if (getValueByPath(fromObject, ["pubsubTopic"]) !== void 0) {
    throw new Error("pubsubTopic parameter is not supported in Gemini API.");
  }
  const fromNegativePrompt = getValueByPath(fromObject, [
    "negativePrompt"
  ]);
  if (parentObject !== void 0 && fromNegativePrompt != null) {
    setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
  }
  const fromEnhancePrompt = getValueByPath(fromObject, [
    "enhancePrompt"
  ]);
  if (parentObject !== void 0 && fromEnhancePrompt != null) {
    setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
  }
  if (getValueByPath(fromObject, ["generateAudio"]) !== void 0) {
    throw new Error("generateAudio parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["lastFrame"]) !== void 0) {
    throw new Error("lastFrame parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["compressionQuality"]) !== void 0) {
    throw new Error("compressionQuality parameter is not supported in Gemini API.");
  }
  return toObject;
}
function generateVideosParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromPrompt = getValueByPath(fromObject, ["prompt"]);
  if (fromPrompt != null) {
    setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
  }
  const fromImage = getValueByPath(fromObject, ["image"]);
  if (fromImage != null) {
    setValueByPath(toObject, ["instances[0]", "image"], imageToMldev(fromImage));
  }
  if (getValueByPath(fromObject, ["video"]) !== void 0) {
    throw new Error("video parameter is not supported in Gemini API.");
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], generateVideosConfigToMldev(fromConfig, toObject));
  }
  return toObject;
}
function videoMetadataToVertex(fromObject) {
  const toObject = {};
  const fromFps = getValueByPath(fromObject, ["fps"]);
  if (fromFps != null) {
    setValueByPath(toObject, ["fps"], fromFps);
  }
  const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
  if (fromEndOffset != null) {
    setValueByPath(toObject, ["endOffset"], fromEndOffset);
  }
  const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
  if (fromStartOffset != null) {
    setValueByPath(toObject, ["startOffset"], fromStartOffset);
  }
  return toObject;
}
function blobToVertex(fromObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function fileDataToVertex(fromObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function partToVertex(fromObject) {
  const toObject = {};
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], videoMetadataToVertex(fromVideoMetadata));
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobToVertex(fromInlineData));
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataToVertex(fromFileData));
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], fromFunctionCall);
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  return toObject;
}
function contentToVertex(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partToVertex(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function schemaToVertex(fromObject) {
  const toObject = {};
  const fromAnyOf = getValueByPath(fromObject, ["anyOf"]);
  if (fromAnyOf != null) {
    setValueByPath(toObject, ["anyOf"], fromAnyOf);
  }
  const fromDefault = getValueByPath(fromObject, ["default"]);
  if (fromDefault != null) {
    setValueByPath(toObject, ["default"], fromDefault);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromEnum = getValueByPath(fromObject, ["enum"]);
  if (fromEnum != null) {
    setValueByPath(toObject, ["enum"], fromEnum);
  }
  const fromExample = getValueByPath(fromObject, ["example"]);
  if (fromExample != null) {
    setValueByPath(toObject, ["example"], fromExample);
  }
  const fromFormat = getValueByPath(fromObject, ["format"]);
  if (fromFormat != null) {
    setValueByPath(toObject, ["format"], fromFormat);
  }
  const fromItems = getValueByPath(fromObject, ["items"]);
  if (fromItems != null) {
    setValueByPath(toObject, ["items"], fromItems);
  }
  const fromMaxItems = getValueByPath(fromObject, ["maxItems"]);
  if (fromMaxItems != null) {
    setValueByPath(toObject, ["maxItems"], fromMaxItems);
  }
  const fromMaxLength = getValueByPath(fromObject, ["maxLength"]);
  if (fromMaxLength != null) {
    setValueByPath(toObject, ["maxLength"], fromMaxLength);
  }
  const fromMaxProperties = getValueByPath(fromObject, [
    "maxProperties"
  ]);
  if (fromMaxProperties != null) {
    setValueByPath(toObject, ["maxProperties"], fromMaxProperties);
  }
  const fromMaximum = getValueByPath(fromObject, ["maximum"]);
  if (fromMaximum != null) {
    setValueByPath(toObject, ["maximum"], fromMaximum);
  }
  const fromMinItems = getValueByPath(fromObject, ["minItems"]);
  if (fromMinItems != null) {
    setValueByPath(toObject, ["minItems"], fromMinItems);
  }
  const fromMinLength = getValueByPath(fromObject, ["minLength"]);
  if (fromMinLength != null) {
    setValueByPath(toObject, ["minLength"], fromMinLength);
  }
  const fromMinProperties = getValueByPath(fromObject, [
    "minProperties"
  ]);
  if (fromMinProperties != null) {
    setValueByPath(toObject, ["minProperties"], fromMinProperties);
  }
  const fromMinimum = getValueByPath(fromObject, ["minimum"]);
  if (fromMinimum != null) {
    setValueByPath(toObject, ["minimum"], fromMinimum);
  }
  const fromNullable = getValueByPath(fromObject, ["nullable"]);
  if (fromNullable != null) {
    setValueByPath(toObject, ["nullable"], fromNullable);
  }
  const fromPattern = getValueByPath(fromObject, ["pattern"]);
  if (fromPattern != null) {
    setValueByPath(toObject, ["pattern"], fromPattern);
  }
  const fromProperties = getValueByPath(fromObject, ["properties"]);
  if (fromProperties != null) {
    setValueByPath(toObject, ["properties"], fromProperties);
  }
  const fromPropertyOrdering = getValueByPath(fromObject, [
    "propertyOrdering"
  ]);
  if (fromPropertyOrdering != null) {
    setValueByPath(toObject, ["propertyOrdering"], fromPropertyOrdering);
  }
  const fromRequired = getValueByPath(fromObject, ["required"]);
  if (fromRequired != null) {
    setValueByPath(toObject, ["required"], fromRequired);
  }
  const fromTitle = getValueByPath(fromObject, ["title"]);
  if (fromTitle != null) {
    setValueByPath(toObject, ["title"], fromTitle);
  }
  const fromType = getValueByPath(fromObject, ["type"]);
  if (fromType != null) {
    setValueByPath(toObject, ["type"], fromType);
  }
  return toObject;
}
function modelSelectionConfigToVertex(fromObject) {
  const toObject = {};
  const fromFeatureSelectionPreference = getValueByPath(fromObject, [
    "featureSelectionPreference"
  ]);
  if (fromFeatureSelectionPreference != null) {
    setValueByPath(toObject, ["featureSelectionPreference"], fromFeatureSelectionPreference);
  }
  return toObject;
}
function safetySettingToVertex(fromObject) {
  const toObject = {};
  const fromMethod = getValueByPath(fromObject, ["method"]);
  if (fromMethod != null) {
    setValueByPath(toObject, ["method"], fromMethod);
  }
  const fromCategory = getValueByPath(fromObject, ["category"]);
  if (fromCategory != null) {
    setValueByPath(toObject, ["category"], fromCategory);
  }
  const fromThreshold = getValueByPath(fromObject, ["threshold"]);
  if (fromThreshold != null) {
    setValueByPath(toObject, ["threshold"], fromThreshold);
  }
  return toObject;
}
function functionDeclarationToVertex(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["behavior"]) !== void 0) {
    throw new Error("behavior parameter is not supported in Vertex AI.");
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromParameters = getValueByPath(fromObject, ["parameters"]);
  if (fromParameters != null) {
    setValueByPath(toObject, ["parameters"], fromParameters);
  }
  const fromParametersJsonSchema = getValueByPath(fromObject, [
    "parametersJsonSchema"
  ]);
  if (fromParametersJsonSchema != null) {
    setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], fromResponse);
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  return toObject;
}
function intervalToVertex(fromObject) {
  const toObject = {};
  const fromStartTime = getValueByPath(fromObject, ["startTime"]);
  if (fromStartTime != null) {
    setValueByPath(toObject, ["startTime"], fromStartTime);
  }
  const fromEndTime = getValueByPath(fromObject, ["endTime"]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  return toObject;
}
function googleSearchToVertex(fromObject) {
  const toObject = {};
  const fromTimeRangeFilter = getValueByPath(fromObject, [
    "timeRangeFilter"
  ]);
  if (fromTimeRangeFilter != null) {
    setValueByPath(toObject, ["timeRangeFilter"], intervalToVertex(fromTimeRangeFilter));
  }
  return toObject;
}
function dynamicRetrievalConfigToVertex(fromObject) {
  const toObject = {};
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  const fromDynamicThreshold = getValueByPath(fromObject, [
    "dynamicThreshold"
  ]);
  if (fromDynamicThreshold != null) {
    setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
  }
  return toObject;
}
function googleSearchRetrievalToVertex(fromObject) {
  const toObject = {};
  const fromDynamicRetrievalConfig = getValueByPath(fromObject, [
    "dynamicRetrievalConfig"
  ]);
  if (fromDynamicRetrievalConfig != null) {
    setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToVertex(fromDynamicRetrievalConfig));
  }
  return toObject;
}
function enterpriseWebSearchToVertex() {
  const toObject = {};
  return toObject;
}
function apiKeyConfigToVertex(fromObject) {
  const toObject = {};
  const fromApiKeyString = getValueByPath(fromObject, ["apiKeyString"]);
  if (fromApiKeyString != null) {
    setValueByPath(toObject, ["apiKeyString"], fromApiKeyString);
  }
  return toObject;
}
function authConfigToVertex(fromObject) {
  const toObject = {};
  const fromApiKeyConfig = getValueByPath(fromObject, ["apiKeyConfig"]);
  if (fromApiKeyConfig != null) {
    setValueByPath(toObject, ["apiKeyConfig"], apiKeyConfigToVertex(fromApiKeyConfig));
  }
  const fromAuthType = getValueByPath(fromObject, ["authType"]);
  if (fromAuthType != null) {
    setValueByPath(toObject, ["authType"], fromAuthType);
  }
  const fromGoogleServiceAccountConfig = getValueByPath(fromObject, [
    "googleServiceAccountConfig"
  ]);
  if (fromGoogleServiceAccountConfig != null) {
    setValueByPath(toObject, ["googleServiceAccountConfig"], fromGoogleServiceAccountConfig);
  }
  const fromHttpBasicAuthConfig = getValueByPath(fromObject, [
    "httpBasicAuthConfig"
  ]);
  if (fromHttpBasicAuthConfig != null) {
    setValueByPath(toObject, ["httpBasicAuthConfig"], fromHttpBasicAuthConfig);
  }
  const fromOauthConfig = getValueByPath(fromObject, ["oauthConfig"]);
  if (fromOauthConfig != null) {
    setValueByPath(toObject, ["oauthConfig"], fromOauthConfig);
  }
  const fromOidcConfig = getValueByPath(fromObject, ["oidcConfig"]);
  if (fromOidcConfig != null) {
    setValueByPath(toObject, ["oidcConfig"], fromOidcConfig);
  }
  return toObject;
}
function googleMapsToVertex(fromObject) {
  const toObject = {};
  const fromAuthConfig = getValueByPath(fromObject, ["authConfig"]);
  if (fromAuthConfig != null) {
    setValueByPath(toObject, ["authConfig"], authConfigToVertex(fromAuthConfig));
  }
  return toObject;
}
function urlContextToVertex() {
  const toObject = {};
  return toObject;
}
function toolToVertex(fromObject) {
  const toObject = {};
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return functionDeclarationToVertex(item);
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
  if (fromRetrieval != null) {
    setValueByPath(toObject, ["retrieval"], fromRetrieval);
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], googleSearchToVertex(fromGoogleSearch));
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToVertex(fromGoogleSearchRetrieval));
  }
  const fromEnterpriseWebSearch = getValueByPath(fromObject, [
    "enterpriseWebSearch"
  ]);
  if (fromEnterpriseWebSearch != null) {
    setValueByPath(toObject, ["enterpriseWebSearch"], enterpriseWebSearchToVertex());
  }
  const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
  if (fromGoogleMaps != null) {
    setValueByPath(toObject, ["googleMaps"], googleMapsToVertex(fromGoogleMaps));
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], urlContextToVertex());
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  return toObject;
}
function functionCallingConfigToVertex(fromObject) {
  const toObject = {};
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  const fromAllowedFunctionNames = getValueByPath(fromObject, [
    "allowedFunctionNames"
  ]);
  if (fromAllowedFunctionNames != null) {
    setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
  }
  return toObject;
}
function latLngToVertex(fromObject) {
  const toObject = {};
  const fromLatitude = getValueByPath(fromObject, ["latitude"]);
  if (fromLatitude != null) {
    setValueByPath(toObject, ["latitude"], fromLatitude);
  }
  const fromLongitude = getValueByPath(fromObject, ["longitude"]);
  if (fromLongitude != null) {
    setValueByPath(toObject, ["longitude"], fromLongitude);
  }
  return toObject;
}
function retrievalConfigToVertex(fromObject) {
  const toObject = {};
  const fromLatLng = getValueByPath(fromObject, ["latLng"]);
  if (fromLatLng != null) {
    setValueByPath(toObject, ["latLng"], latLngToVertex(fromLatLng));
  }
  const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
  if (fromLanguageCode != null) {
    setValueByPath(toObject, ["languageCode"], fromLanguageCode);
  }
  return toObject;
}
function toolConfigToVertex(fromObject) {
  const toObject = {};
  const fromFunctionCallingConfig = getValueByPath(fromObject, [
    "functionCallingConfig"
  ]);
  if (fromFunctionCallingConfig != null) {
    setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToVertex(fromFunctionCallingConfig));
  }
  const fromRetrievalConfig = getValueByPath(fromObject, [
    "retrievalConfig"
  ]);
  if (fromRetrievalConfig != null) {
    setValueByPath(toObject, ["retrievalConfig"], retrievalConfigToVertex(fromRetrievalConfig));
  }
  return toObject;
}
function prebuiltVoiceConfigToVertex(fromObject) {
  const toObject = {};
  const fromVoiceName = getValueByPath(fromObject, ["voiceName"]);
  if (fromVoiceName != null) {
    setValueByPath(toObject, ["voiceName"], fromVoiceName);
  }
  return toObject;
}
function voiceConfigToVertex(fromObject) {
  const toObject = {};
  const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [
    "prebuiltVoiceConfig"
  ]);
  if (fromPrebuiltVoiceConfig != null) {
    setValueByPath(toObject, ["prebuiltVoiceConfig"], prebuiltVoiceConfigToVertex(fromPrebuiltVoiceConfig));
  }
  return toObject;
}
function speechConfigToVertex(fromObject) {
  const toObject = {};
  const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
  if (fromVoiceConfig != null) {
    setValueByPath(toObject, ["voiceConfig"], voiceConfigToVertex(fromVoiceConfig));
  }
  if (getValueByPath(fromObject, ["multiSpeakerVoiceConfig"]) !== void 0) {
    throw new Error("multiSpeakerVoiceConfig parameter is not supported in Vertex AI.");
  }
  const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
  if (fromLanguageCode != null) {
    setValueByPath(toObject, ["languageCode"], fromLanguageCode);
  }
  return toObject;
}
function thinkingConfigToVertex(fromObject) {
  const toObject = {};
  const fromIncludeThoughts = getValueByPath(fromObject, [
    "includeThoughts"
  ]);
  if (fromIncludeThoughts != null) {
    setValueByPath(toObject, ["includeThoughts"], fromIncludeThoughts);
  }
  const fromThinkingBudget = getValueByPath(fromObject, [
    "thinkingBudget"
  ]);
  if (fromThinkingBudget != null) {
    setValueByPath(toObject, ["thinkingBudget"], fromThinkingBudget);
  }
  return toObject;
}
function generateContentConfigToVertex(apiClient, fromObject, parentObject) {
  const toObject = {};
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== void 0 && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["systemInstruction"], contentToVertex(tContent(fromSystemInstruction)));
  }
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (fromTemperature != null) {
    setValueByPath(toObject, ["temperature"], fromTemperature);
  }
  const fromTopP = getValueByPath(fromObject, ["topP"]);
  if (fromTopP != null) {
    setValueByPath(toObject, ["topP"], fromTopP);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (fromTopK != null) {
    setValueByPath(toObject, ["topK"], fromTopK);
  }
  const fromCandidateCount = getValueByPath(fromObject, [
    "candidateCount"
  ]);
  if (fromCandidateCount != null) {
    setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
  }
  const fromMaxOutputTokens = getValueByPath(fromObject, [
    "maxOutputTokens"
  ]);
  if (fromMaxOutputTokens != null) {
    setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
  }
  const fromStopSequences = getValueByPath(fromObject, [
    "stopSequences"
  ]);
  if (fromStopSequences != null) {
    setValueByPath(toObject, ["stopSequences"], fromStopSequences);
  }
  const fromResponseLogprobs = getValueByPath(fromObject, [
    "responseLogprobs"
  ]);
  if (fromResponseLogprobs != null) {
    setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
  }
  const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
  if (fromLogprobs != null) {
    setValueByPath(toObject, ["logprobs"], fromLogprobs);
  }
  const fromPresencePenalty = getValueByPath(fromObject, [
    "presencePenalty"
  ]);
  if (fromPresencePenalty != null) {
    setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
  }
  const fromFrequencyPenalty = getValueByPath(fromObject, [
    "frequencyPenalty"
  ]);
  if (fromFrequencyPenalty != null) {
    setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (fromSeed != null) {
    setValueByPath(toObject, ["seed"], fromSeed);
  }
  const fromResponseMimeType = getValueByPath(fromObject, [
    "responseMimeType"
  ]);
  if (fromResponseMimeType != null) {
    setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
  }
  const fromResponseSchema = getValueByPath(fromObject, [
    "responseSchema"
  ]);
  if (fromResponseSchema != null) {
    setValueByPath(toObject, ["responseSchema"], schemaToVertex(tSchema(fromResponseSchema)));
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  const fromRoutingConfig = getValueByPath(fromObject, [
    "routingConfig"
  ]);
  if (fromRoutingConfig != null) {
    setValueByPath(toObject, ["routingConfig"], fromRoutingConfig);
  }
  const fromModelSelectionConfig = getValueByPath(fromObject, [
    "modelSelectionConfig"
  ]);
  if (fromModelSelectionConfig != null) {
    setValueByPath(toObject, ["modelConfig"], modelSelectionConfigToVertex(fromModelSelectionConfig));
  }
  const fromSafetySettings = getValueByPath(fromObject, [
    "safetySettings"
  ]);
  if (parentObject !== void 0 && fromSafetySettings != null) {
    let transformedList = fromSafetySettings;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return safetySettingToVertex(item);
      });
    }
    setValueByPath(parentObject, ["safetySettings"], transformedList);
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== void 0 && fromTools != null) {
    let transformedList = tTools(fromTools);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToVertex(tTool(item));
      });
    }
    setValueByPath(parentObject, ["tools"], transformedList);
  }
  const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
  if (parentObject !== void 0 && fromToolConfig != null) {
    setValueByPath(parentObject, ["toolConfig"], toolConfigToVertex(fromToolConfig));
  }
  const fromLabels = getValueByPath(fromObject, ["labels"]);
  if (parentObject !== void 0 && fromLabels != null) {
    setValueByPath(parentObject, ["labels"], fromLabels);
  }
  const fromCachedContent = getValueByPath(fromObject, [
    "cachedContent"
  ]);
  if (parentObject !== void 0 && fromCachedContent != null) {
    setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
  }
  const fromResponseModalities = getValueByPath(fromObject, [
    "responseModalities"
  ]);
  if (fromResponseModalities != null) {
    setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
  }
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (fromMediaResolution != null) {
    setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
  }
  const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
  if (fromSpeechConfig != null) {
    setValueByPath(toObject, ["speechConfig"], speechConfigToVertex(tSpeechConfig(fromSpeechConfig)));
  }
  const fromAudioTimestamp = getValueByPath(fromObject, [
    "audioTimestamp"
  ]);
  if (fromAudioTimestamp != null) {
    setValueByPath(toObject, ["audioTimestamp"], fromAudioTimestamp);
  }
  const fromThinkingConfig = getValueByPath(fromObject, [
    "thinkingConfig"
  ]);
  if (fromThinkingConfig != null) {
    setValueByPath(toObject, ["thinkingConfig"], thinkingConfigToVertex(fromThinkingConfig));
  }
  return toObject;
}
function generateContentParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return contentToVertex(item);
      });
    }
    setValueByPath(toObject, ["contents"], transformedList);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["generationConfig"], generateContentConfigToVertex(apiClient, fromConfig, toObject));
  }
  return toObject;
}
function embedContentConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromTaskType = getValueByPath(fromObject, ["taskType"]);
  if (parentObject !== void 0 && fromTaskType != null) {
    setValueByPath(parentObject, ["instances[]", "task_type"], fromTaskType);
  }
  const fromTitle = getValueByPath(fromObject, ["title"]);
  if (parentObject !== void 0 && fromTitle != null) {
    setValueByPath(parentObject, ["instances[]", "title"], fromTitle);
  }
  const fromOutputDimensionality = getValueByPath(fromObject, [
    "outputDimensionality"
  ]);
  if (parentObject !== void 0 && fromOutputDimensionality != null) {
    setValueByPath(parentObject, ["parameters", "outputDimensionality"], fromOutputDimensionality);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (parentObject !== void 0 && fromMimeType != null) {
    setValueByPath(parentObject, ["instances[]", "mimeType"], fromMimeType);
  }
  const fromAutoTruncate = getValueByPath(fromObject, ["autoTruncate"]);
  if (parentObject !== void 0 && fromAutoTruncate != null) {
    setValueByPath(parentObject, ["parameters", "autoTruncate"], fromAutoTruncate);
  }
  return toObject;
}
function embedContentParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    setValueByPath(toObject, ["instances[]", "content"], tContentsForEmbed(apiClient, fromContents));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], embedContentConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function generateImagesConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
  if (parentObject !== void 0 && fromOutputGcsUri != null) {
    setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
  }
  const fromNegativePrompt = getValueByPath(fromObject, [
    "negativePrompt"
  ]);
  if (parentObject !== void 0 && fromNegativePrompt != null) {
    setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
  }
  const fromNumberOfImages = getValueByPath(fromObject, [
    "numberOfImages"
  ]);
  if (parentObject !== void 0 && fromNumberOfImages != null) {
    setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
  }
  const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
  if (parentObject !== void 0 && fromAspectRatio != null) {
    setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
  }
  const fromGuidanceScale = getValueByPath(fromObject, [
    "guidanceScale"
  ]);
  if (parentObject !== void 0 && fromGuidanceScale != null) {
    setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (parentObject !== void 0 && fromSeed != null) {
    setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
  }
  const fromSafetyFilterLevel = getValueByPath(fromObject, [
    "safetyFilterLevel"
  ]);
  if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
    setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
  }
  const fromPersonGeneration = getValueByPath(fromObject, [
    "personGeneration"
  ]);
  if (parentObject !== void 0 && fromPersonGeneration != null) {
    setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
  }
  const fromIncludeSafetyAttributes = getValueByPath(fromObject, [
    "includeSafetyAttributes"
  ]);
  if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) {
    setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
  }
  const fromIncludeRaiReason = getValueByPath(fromObject, [
    "includeRaiReason"
  ]);
  if (parentObject !== void 0 && fromIncludeRaiReason != null) {
    setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
  }
  const fromLanguage = getValueByPath(fromObject, ["language"]);
  if (parentObject !== void 0 && fromLanguage != null) {
    setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
  }
  const fromOutputMimeType = getValueByPath(fromObject, [
    "outputMimeType"
  ]);
  if (parentObject !== void 0 && fromOutputMimeType != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
  }
  const fromOutputCompressionQuality = getValueByPath(fromObject, [
    "outputCompressionQuality"
  ]);
  if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
  }
  const fromAddWatermark = getValueByPath(fromObject, ["addWatermark"]);
  if (parentObject !== void 0 && fromAddWatermark != null) {
    setValueByPath(parentObject, ["parameters", "addWatermark"], fromAddWatermark);
  }
  const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
  if (parentObject !== void 0 && fromImageSize != null) {
    setValueByPath(parentObject, ["parameters", "sampleImageSize"], fromImageSize);
  }
  const fromEnhancePrompt = getValueByPath(fromObject, [
    "enhancePrompt"
  ]);
  if (parentObject !== void 0 && fromEnhancePrompt != null) {
    setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
  }
  return toObject;
}
function generateImagesParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromPrompt = getValueByPath(fromObject, ["prompt"]);
  if (fromPrompt != null) {
    setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], generateImagesConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function imageToVertex(fromObject) {
  const toObject = {};
  const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
  if (fromGcsUri != null) {
    setValueByPath(toObject, ["gcsUri"], fromGcsUri);
  }
  const fromImageBytes = getValueByPath(fromObject, ["imageBytes"]);
  if (fromImageBytes != null) {
    setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(fromImageBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function maskReferenceConfigToVertex(fromObject) {
  const toObject = {};
  const fromMaskMode = getValueByPath(fromObject, ["maskMode"]);
  if (fromMaskMode != null) {
    setValueByPath(toObject, ["maskMode"], fromMaskMode);
  }
  const fromSegmentationClasses = getValueByPath(fromObject, [
    "segmentationClasses"
  ]);
  if (fromSegmentationClasses != null) {
    setValueByPath(toObject, ["maskClasses"], fromSegmentationClasses);
  }
  const fromMaskDilation = getValueByPath(fromObject, ["maskDilation"]);
  if (fromMaskDilation != null) {
    setValueByPath(toObject, ["dilation"], fromMaskDilation);
  }
  return toObject;
}
function controlReferenceConfigToVertex(fromObject) {
  const toObject = {};
  const fromControlType = getValueByPath(fromObject, ["controlType"]);
  if (fromControlType != null) {
    setValueByPath(toObject, ["controlType"], fromControlType);
  }
  const fromEnableControlImageComputation = getValueByPath(fromObject, [
    "enableControlImageComputation"
  ]);
  if (fromEnableControlImageComputation != null) {
    setValueByPath(toObject, ["computeControl"], fromEnableControlImageComputation);
  }
  return toObject;
}
function styleReferenceConfigToVertex(fromObject) {
  const toObject = {};
  const fromStyleDescription = getValueByPath(fromObject, [
    "styleDescription"
  ]);
  if (fromStyleDescription != null) {
    setValueByPath(toObject, ["styleDescription"], fromStyleDescription);
  }
  return toObject;
}
function subjectReferenceConfigToVertex(fromObject) {
  const toObject = {};
  const fromSubjectType = getValueByPath(fromObject, ["subjectType"]);
  if (fromSubjectType != null) {
    setValueByPath(toObject, ["subjectType"], fromSubjectType);
  }
  const fromSubjectDescription = getValueByPath(fromObject, [
    "subjectDescription"
  ]);
  if (fromSubjectDescription != null) {
    setValueByPath(toObject, ["subjectDescription"], fromSubjectDescription);
  }
  return toObject;
}
function referenceImageAPIInternalToVertex(fromObject) {
  const toObject = {};
  const fromReferenceImage = getValueByPath(fromObject, [
    "referenceImage"
  ]);
  if (fromReferenceImage != null) {
    setValueByPath(toObject, ["referenceImage"], imageToVertex(fromReferenceImage));
  }
  const fromReferenceId = getValueByPath(fromObject, ["referenceId"]);
  if (fromReferenceId != null) {
    setValueByPath(toObject, ["referenceId"], fromReferenceId);
  }
  const fromReferenceType = getValueByPath(fromObject, [
    "referenceType"
  ]);
  if (fromReferenceType != null) {
    setValueByPath(toObject, ["referenceType"], fromReferenceType);
  }
  const fromMaskImageConfig = getValueByPath(fromObject, [
    "maskImageConfig"
  ]);
  if (fromMaskImageConfig != null) {
    setValueByPath(toObject, ["maskImageConfig"], maskReferenceConfigToVertex(fromMaskImageConfig));
  }
  const fromControlImageConfig = getValueByPath(fromObject, [
    "controlImageConfig"
  ]);
  if (fromControlImageConfig != null) {
    setValueByPath(toObject, ["controlImageConfig"], controlReferenceConfigToVertex(fromControlImageConfig));
  }
  const fromStyleImageConfig = getValueByPath(fromObject, [
    "styleImageConfig"
  ]);
  if (fromStyleImageConfig != null) {
    setValueByPath(toObject, ["styleImageConfig"], styleReferenceConfigToVertex(fromStyleImageConfig));
  }
  const fromSubjectImageConfig = getValueByPath(fromObject, [
    "subjectImageConfig"
  ]);
  if (fromSubjectImageConfig != null) {
    setValueByPath(toObject, ["subjectImageConfig"], subjectReferenceConfigToVertex(fromSubjectImageConfig));
  }
  return toObject;
}
function editImageConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
  if (parentObject !== void 0 && fromOutputGcsUri != null) {
    setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
  }
  const fromNegativePrompt = getValueByPath(fromObject, [
    "negativePrompt"
  ]);
  if (parentObject !== void 0 && fromNegativePrompt != null) {
    setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
  }
  const fromNumberOfImages = getValueByPath(fromObject, [
    "numberOfImages"
  ]);
  if (parentObject !== void 0 && fromNumberOfImages != null) {
    setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
  }
  const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
  if (parentObject !== void 0 && fromAspectRatio != null) {
    setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
  }
  const fromGuidanceScale = getValueByPath(fromObject, [
    "guidanceScale"
  ]);
  if (parentObject !== void 0 && fromGuidanceScale != null) {
    setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (parentObject !== void 0 && fromSeed != null) {
    setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
  }
  const fromSafetyFilterLevel = getValueByPath(fromObject, [
    "safetyFilterLevel"
  ]);
  if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
    setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
  }
  const fromPersonGeneration = getValueByPath(fromObject, [
    "personGeneration"
  ]);
  if (parentObject !== void 0 && fromPersonGeneration != null) {
    setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
  }
  const fromIncludeSafetyAttributes = getValueByPath(fromObject, [
    "includeSafetyAttributes"
  ]);
  if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) {
    setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
  }
  const fromIncludeRaiReason = getValueByPath(fromObject, [
    "includeRaiReason"
  ]);
  if (parentObject !== void 0 && fromIncludeRaiReason != null) {
    setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
  }
  const fromLanguage = getValueByPath(fromObject, ["language"]);
  if (parentObject !== void 0 && fromLanguage != null) {
    setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
  }
  const fromOutputMimeType = getValueByPath(fromObject, [
    "outputMimeType"
  ]);
  if (parentObject !== void 0 && fromOutputMimeType != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
  }
  const fromOutputCompressionQuality = getValueByPath(fromObject, [
    "outputCompressionQuality"
  ]);
  if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
  }
  const fromAddWatermark = getValueByPath(fromObject, ["addWatermark"]);
  if (parentObject !== void 0 && fromAddWatermark != null) {
    setValueByPath(parentObject, ["parameters", "addWatermark"], fromAddWatermark);
  }
  const fromEditMode = getValueByPath(fromObject, ["editMode"]);
  if (parentObject !== void 0 && fromEditMode != null) {
    setValueByPath(parentObject, ["parameters", "editMode"], fromEditMode);
  }
  const fromBaseSteps = getValueByPath(fromObject, ["baseSteps"]);
  if (parentObject !== void 0 && fromBaseSteps != null) {
    setValueByPath(parentObject, ["parameters", "editConfig", "baseSteps"], fromBaseSteps);
  }
  return toObject;
}
function editImageParametersInternalToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromPrompt = getValueByPath(fromObject, ["prompt"]);
  if (fromPrompt != null) {
    setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
  }
  const fromReferenceImages = getValueByPath(fromObject, [
    "referenceImages"
  ]);
  if (fromReferenceImages != null) {
    let transformedList = fromReferenceImages;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return referenceImageAPIInternalToVertex(item);
      });
    }
    setValueByPath(toObject, ["instances[0]", "referenceImages"], transformedList);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], editImageConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function upscaleImageAPIConfigInternalToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromIncludeRaiReason = getValueByPath(fromObject, [
    "includeRaiReason"
  ]);
  if (parentObject !== void 0 && fromIncludeRaiReason != null) {
    setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
  }
  const fromOutputMimeType = getValueByPath(fromObject, [
    "outputMimeType"
  ]);
  if (parentObject !== void 0 && fromOutputMimeType != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
  }
  const fromOutputCompressionQuality = getValueByPath(fromObject, [
    "outputCompressionQuality"
  ]);
  if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
  }
  const fromEnhanceInputImage = getValueByPath(fromObject, [
    "enhanceInputImage"
  ]);
  if (parentObject !== void 0 && fromEnhanceInputImage != null) {
    setValueByPath(parentObject, ["parameters", "upscaleConfig", "enhanceInputImage"], fromEnhanceInputImage);
  }
  const fromImagePreservationFactor = getValueByPath(fromObject, [
    "imagePreservationFactor"
  ]);
  if (parentObject !== void 0 && fromImagePreservationFactor != null) {
    setValueByPath(parentObject, ["parameters", "upscaleConfig", "imagePreservationFactor"], fromImagePreservationFactor);
  }
  const fromNumberOfImages = getValueByPath(fromObject, [
    "numberOfImages"
  ]);
  if (parentObject !== void 0 && fromNumberOfImages != null) {
    setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
  }
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (parentObject !== void 0 && fromMode != null) {
    setValueByPath(parentObject, ["parameters", "mode"], fromMode);
  }
  return toObject;
}
function upscaleImageAPIParametersInternalToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromImage = getValueByPath(fromObject, ["image"]);
  if (fromImage != null) {
    setValueByPath(toObject, ["instances[0]", "image"], imageToVertex(fromImage));
  }
  const fromUpscaleFactor = getValueByPath(fromObject, [
    "upscaleFactor"
  ]);
  if (fromUpscaleFactor != null) {
    setValueByPath(toObject, ["parameters", "upscaleConfig", "upscaleFactor"], fromUpscaleFactor);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], upscaleImageAPIConfigInternalToVertex(fromConfig, toObject));
  }
  return toObject;
}
function productImageToVertex(fromObject) {
  const toObject = {};
  const fromProductImage = getValueByPath(fromObject, ["productImage"]);
  if (fromProductImage != null) {
    setValueByPath(toObject, ["image"], imageToVertex(fromProductImage));
  }
  return toObject;
}
function recontextImageSourceToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromPrompt = getValueByPath(fromObject, ["prompt"]);
  if (parentObject !== void 0 && fromPrompt != null) {
    setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
  }
  const fromPersonImage = getValueByPath(fromObject, ["personImage"]);
  if (parentObject !== void 0 && fromPersonImage != null) {
    setValueByPath(parentObject, ["instances[0]", "personImage", "image"], imageToVertex(fromPersonImage));
  }
  const fromProductImages = getValueByPath(fromObject, [
    "productImages"
  ]);
  if (parentObject !== void 0 && fromProductImages != null) {
    let transformedList = fromProductImages;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return productImageToVertex(item);
      });
    }
    setValueByPath(parentObject, ["instances[0]", "productImages"], transformedList);
  }
  return toObject;
}
function recontextImageConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromNumberOfImages = getValueByPath(fromObject, [
    "numberOfImages"
  ]);
  if (parentObject !== void 0 && fromNumberOfImages != null) {
    setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
  }
  const fromBaseSteps = getValueByPath(fromObject, ["baseSteps"]);
  if (parentObject !== void 0 && fromBaseSteps != null) {
    setValueByPath(parentObject, ["parameters", "editConfig", "baseSteps"], fromBaseSteps);
  }
  const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
  if (parentObject !== void 0 && fromOutputGcsUri != null) {
    setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (parentObject !== void 0 && fromSeed != null) {
    setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
  }
  const fromSafetyFilterLevel = getValueByPath(fromObject, [
    "safetyFilterLevel"
  ]);
  if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
    setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
  }
  const fromPersonGeneration = getValueByPath(fromObject, [
    "personGeneration"
  ]);
  if (parentObject !== void 0 && fromPersonGeneration != null) {
    setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
  }
  const fromOutputMimeType = getValueByPath(fromObject, [
    "outputMimeType"
  ]);
  if (parentObject !== void 0 && fromOutputMimeType != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
  }
  const fromOutputCompressionQuality = getValueByPath(fromObject, [
    "outputCompressionQuality"
  ]);
  if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
  }
  const fromEnhancePrompt = getValueByPath(fromObject, [
    "enhancePrompt"
  ]);
  if (parentObject !== void 0 && fromEnhancePrompt != null) {
    setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
  }
  return toObject;
}
function recontextImageParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromSource = getValueByPath(fromObject, ["source"]);
  if (fromSource != null) {
    setValueByPath(toObject, ["config"], recontextImageSourceToVertex(fromSource, toObject));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], recontextImageConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function getModelParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function listModelsConfigToVertex(apiClient, fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  const fromFilter = getValueByPath(fromObject, ["filter"]);
  if (parentObject !== void 0 && fromFilter != null) {
    setValueByPath(parentObject, ["_query", "filter"], fromFilter);
  }
  const fromQueryBase = getValueByPath(fromObject, ["queryBase"]);
  if (parentObject !== void 0 && fromQueryBase != null) {
    setValueByPath(parentObject, ["_url", "models_url"], tModelsUrl(apiClient, fromQueryBase));
  }
  return toObject;
}
function listModelsParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], listModelsConfigToVertex(apiClient, fromConfig, toObject));
  }
  return toObject;
}
function updateModelConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (parentObject !== void 0 && fromDisplayName != null) {
    setValueByPath(parentObject, ["displayName"], fromDisplayName);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (parentObject !== void 0 && fromDescription != null) {
    setValueByPath(parentObject, ["description"], fromDescription);
  }
  const fromDefaultCheckpointId = getValueByPath(fromObject, [
    "defaultCheckpointId"
  ]);
  if (parentObject !== void 0 && fromDefaultCheckpointId != null) {
    setValueByPath(parentObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
  }
  return toObject;
}
function updateModelParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], updateModelConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function deleteModelParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function countTokensConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== void 0 && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["systemInstruction"], contentToVertex(tContent(fromSystemInstruction)));
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== void 0 && fromTools != null) {
    let transformedList = fromTools;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToVertex(item);
      });
    }
    setValueByPath(parentObject, ["tools"], transformedList);
  }
  const fromGenerationConfig = getValueByPath(fromObject, [
    "generationConfig"
  ]);
  if (parentObject !== void 0 && fromGenerationConfig != null) {
    setValueByPath(parentObject, ["generationConfig"], fromGenerationConfig);
  }
  return toObject;
}
function countTokensParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return contentToVertex(item);
      });
    }
    setValueByPath(toObject, ["contents"], transformedList);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], countTokensConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function computeTokensParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return contentToVertex(item);
      });
    }
    setValueByPath(toObject, ["contents"], transformedList);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function videoToVertex(fromObject) {
  const toObject = {};
  const fromUri = getValueByPath(fromObject, ["uri"]);
  if (fromUri != null) {
    setValueByPath(toObject, ["gcsUri"], fromUri);
  }
  const fromVideoBytes = getValueByPath(fromObject, ["videoBytes"]);
  if (fromVideoBytes != null) {
    setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(fromVideoBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function generateVideosConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromNumberOfVideos = getValueByPath(fromObject, [
    "numberOfVideos"
  ]);
  if (parentObject !== void 0 && fromNumberOfVideos != null) {
    setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfVideos);
  }
  const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
  if (parentObject !== void 0 && fromOutputGcsUri != null) {
    setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
  }
  const fromFps = getValueByPath(fromObject, ["fps"]);
  if (parentObject !== void 0 && fromFps != null) {
    setValueByPath(parentObject, ["parameters", "fps"], fromFps);
  }
  const fromDurationSeconds = getValueByPath(fromObject, [
    "durationSeconds"
  ]);
  if (parentObject !== void 0 && fromDurationSeconds != null) {
    setValueByPath(parentObject, ["parameters", "durationSeconds"], fromDurationSeconds);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (parentObject !== void 0 && fromSeed != null) {
    setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
  }
  const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
  if (parentObject !== void 0 && fromAspectRatio != null) {
    setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
  }
  const fromResolution = getValueByPath(fromObject, ["resolution"]);
  if (parentObject !== void 0 && fromResolution != null) {
    setValueByPath(parentObject, ["parameters", "resolution"], fromResolution);
  }
  const fromPersonGeneration = getValueByPath(fromObject, [
    "personGeneration"
  ]);
  if (parentObject !== void 0 && fromPersonGeneration != null) {
    setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
  }
  const fromPubsubTopic = getValueByPath(fromObject, ["pubsubTopic"]);
  if (parentObject !== void 0 && fromPubsubTopic != null) {
    setValueByPath(parentObject, ["parameters", "pubsubTopic"], fromPubsubTopic);
  }
  const fromNegativePrompt = getValueByPath(fromObject, [
    "negativePrompt"
  ]);
  if (parentObject !== void 0 && fromNegativePrompt != null) {
    setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
  }
  const fromEnhancePrompt = getValueByPath(fromObject, [
    "enhancePrompt"
  ]);
  if (parentObject !== void 0 && fromEnhancePrompt != null) {
    setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
  }
  const fromGenerateAudio = getValueByPath(fromObject, [
    "generateAudio"
  ]);
  if (parentObject !== void 0 && fromGenerateAudio != null) {
    setValueByPath(parentObject, ["parameters", "generateAudio"], fromGenerateAudio);
  }
  const fromLastFrame = getValueByPath(fromObject, ["lastFrame"]);
  if (parentObject !== void 0 && fromLastFrame != null) {
    setValueByPath(parentObject, ["instances[0]", "lastFrame"], imageToVertex(fromLastFrame));
  }
  const fromCompressionQuality = getValueByPath(fromObject, [
    "compressionQuality"
  ]);
  if (parentObject !== void 0 && fromCompressionQuality != null) {
    setValueByPath(parentObject, ["parameters", "compressionQuality"], fromCompressionQuality);
  }
  return toObject;
}
function generateVideosParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromPrompt = getValueByPath(fromObject, ["prompt"]);
  if (fromPrompt != null) {
    setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
  }
  const fromImage = getValueByPath(fromObject, ["image"]);
  if (fromImage != null) {
    setValueByPath(toObject, ["instances[0]", "image"], imageToVertex(fromImage));
  }
  const fromVideo = getValueByPath(fromObject, ["video"]);
  if (fromVideo != null) {
    setValueByPath(toObject, ["instances[0]", "video"], videoToVertex(fromVideo));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], generateVideosConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function videoMetadataFromMldev(fromObject) {
  const toObject = {};
  const fromFps = getValueByPath(fromObject, ["fps"]);
  if (fromFps != null) {
    setValueByPath(toObject, ["fps"], fromFps);
  }
  const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
  if (fromEndOffset != null) {
    setValueByPath(toObject, ["endOffset"], fromEndOffset);
  }
  const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
  if (fromStartOffset != null) {
    setValueByPath(toObject, ["startOffset"], fromStartOffset);
  }
  return toObject;
}
function blobFromMldev(fromObject) {
  const toObject = {};
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function fileDataFromMldev(fromObject) {
  const toObject = {};
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function partFromMldev(fromObject) {
  const toObject = {};
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], videoMetadataFromMldev(fromVideoMetadata));
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobFromMldev(fromInlineData));
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataFromMldev(fromFileData));
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], fromFunctionCall);
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  return toObject;
}
function contentFromMldev(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partFromMldev(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function citationMetadataFromMldev(fromObject) {
  const toObject = {};
  const fromCitations = getValueByPath(fromObject, ["citationSources"]);
  if (fromCitations != null) {
    setValueByPath(toObject, ["citations"], fromCitations);
  }
  return toObject;
}
function urlMetadataFromMldev(fromObject) {
  const toObject = {};
  const fromRetrievedUrl = getValueByPath(fromObject, ["retrievedUrl"]);
  if (fromRetrievedUrl != null) {
    setValueByPath(toObject, ["retrievedUrl"], fromRetrievedUrl);
  }
  const fromUrlRetrievalStatus = getValueByPath(fromObject, [
    "urlRetrievalStatus"
  ]);
  if (fromUrlRetrievalStatus != null) {
    setValueByPath(toObject, ["urlRetrievalStatus"], fromUrlRetrievalStatus);
  }
  return toObject;
}
function urlContextMetadataFromMldev(fromObject) {
  const toObject = {};
  const fromUrlMetadata = getValueByPath(fromObject, ["urlMetadata"]);
  if (fromUrlMetadata != null) {
    let transformedList = fromUrlMetadata;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return urlMetadataFromMldev(item);
      });
    }
    setValueByPath(toObject, ["urlMetadata"], transformedList);
  }
  return toObject;
}
function candidateFromMldev(fromObject) {
  const toObject = {};
  const fromContent = getValueByPath(fromObject, ["content"]);
  if (fromContent != null) {
    setValueByPath(toObject, ["content"], contentFromMldev(fromContent));
  }
  const fromCitationMetadata = getValueByPath(fromObject, [
    "citationMetadata"
  ]);
  if (fromCitationMetadata != null) {
    setValueByPath(toObject, ["citationMetadata"], citationMetadataFromMldev(fromCitationMetadata));
  }
  const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
  if (fromTokenCount != null) {
    setValueByPath(toObject, ["tokenCount"], fromTokenCount);
  }
  const fromFinishReason = getValueByPath(fromObject, ["finishReason"]);
  if (fromFinishReason != null) {
    setValueByPath(toObject, ["finishReason"], fromFinishReason);
  }
  const fromUrlContextMetadata = getValueByPath(fromObject, [
    "urlContextMetadata"
  ]);
  if (fromUrlContextMetadata != null) {
    setValueByPath(toObject, ["urlContextMetadata"], urlContextMetadataFromMldev(fromUrlContextMetadata));
  }
  const fromAvgLogprobs = getValueByPath(fromObject, ["avgLogprobs"]);
  if (fromAvgLogprobs != null) {
    setValueByPath(toObject, ["avgLogprobs"], fromAvgLogprobs);
  }
  const fromGroundingMetadata = getValueByPath(fromObject, [
    "groundingMetadata"
  ]);
  if (fromGroundingMetadata != null) {
    setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
  }
  const fromIndex = getValueByPath(fromObject, ["index"]);
  if (fromIndex != null) {
    setValueByPath(toObject, ["index"], fromIndex);
  }
  const fromLogprobsResult = getValueByPath(fromObject, [
    "logprobsResult"
  ]);
  if (fromLogprobsResult != null) {
    setValueByPath(toObject, ["logprobsResult"], fromLogprobsResult);
  }
  const fromSafetyRatings = getValueByPath(fromObject, [
    "safetyRatings"
  ]);
  if (fromSafetyRatings != null) {
    setValueByPath(toObject, ["safetyRatings"], fromSafetyRatings);
  }
  return toObject;
}
function generateContentResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromCandidates = getValueByPath(fromObject, ["candidates"]);
  if (fromCandidates != null) {
    let transformedList = fromCandidates;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return candidateFromMldev(item);
      });
    }
    setValueByPath(toObject, ["candidates"], transformedList);
  }
  const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
  if (fromModelVersion != null) {
    setValueByPath(toObject, ["modelVersion"], fromModelVersion);
  }
  const fromPromptFeedback = getValueByPath(fromObject, [
    "promptFeedback"
  ]);
  if (fromPromptFeedback != null) {
    setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
  }
  const fromResponseId = getValueByPath(fromObject, ["responseId"]);
  if (fromResponseId != null) {
    setValueByPath(toObject, ["responseId"], fromResponseId);
  }
  const fromUsageMetadata = getValueByPath(fromObject, [
    "usageMetadata"
  ]);
  if (fromUsageMetadata != null) {
    setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
  }
  return toObject;
}
function contentEmbeddingFromMldev(fromObject) {
  const toObject = {};
  const fromValues = getValueByPath(fromObject, ["values"]);
  if (fromValues != null) {
    setValueByPath(toObject, ["values"], fromValues);
  }
  return toObject;
}
function embedContentMetadataFromMldev() {
  const toObject = {};
  return toObject;
}
function embedContentResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromEmbeddings = getValueByPath(fromObject, ["embeddings"]);
  if (fromEmbeddings != null) {
    let transformedList = fromEmbeddings;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return contentEmbeddingFromMldev(item);
      });
    }
    setValueByPath(toObject, ["embeddings"], transformedList);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], embedContentMetadataFromMldev());
  }
  return toObject;
}
function imageFromMldev(fromObject) {
  const toObject = {};
  const fromImageBytes = getValueByPath(fromObject, [
    "bytesBase64Encoded"
  ]);
  if (fromImageBytes != null) {
    setValueByPath(toObject, ["imageBytes"], tBytes(fromImageBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function safetyAttributesFromMldev(fromObject) {
  const toObject = {};
  const fromCategories = getValueByPath(fromObject, [
    "safetyAttributes",
    "categories"
  ]);
  if (fromCategories != null) {
    setValueByPath(toObject, ["categories"], fromCategories);
  }
  const fromScores = getValueByPath(fromObject, [
    "safetyAttributes",
    "scores"
  ]);
  if (fromScores != null) {
    setValueByPath(toObject, ["scores"], fromScores);
  }
  const fromContentType = getValueByPath(fromObject, ["contentType"]);
  if (fromContentType != null) {
    setValueByPath(toObject, ["contentType"], fromContentType);
  }
  return toObject;
}
function generatedImageFromMldev(fromObject) {
  const toObject = {};
  const fromImage = getValueByPath(fromObject, ["_self"]);
  if (fromImage != null) {
    setValueByPath(toObject, ["image"], imageFromMldev(fromImage));
  }
  const fromRaiFilteredReason = getValueByPath(fromObject, [
    "raiFilteredReason"
  ]);
  if (fromRaiFilteredReason != null) {
    setValueByPath(toObject, ["raiFilteredReason"], fromRaiFilteredReason);
  }
  const fromSafetyAttributes = getValueByPath(fromObject, ["_self"]);
  if (fromSafetyAttributes != null) {
    setValueByPath(toObject, ["safetyAttributes"], safetyAttributesFromMldev(fromSafetyAttributes));
  }
  return toObject;
}
function generateImagesResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromGeneratedImages = getValueByPath(fromObject, [
    "predictions"
  ]);
  if (fromGeneratedImages != null) {
    let transformedList = fromGeneratedImages;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedImageFromMldev(item);
      });
    }
    setValueByPath(toObject, ["generatedImages"], transformedList);
  }
  const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [
    "positivePromptSafetyAttributes"
  ]);
  if (fromPositivePromptSafetyAttributes != null) {
    setValueByPath(toObject, ["positivePromptSafetyAttributes"], safetyAttributesFromMldev(fromPositivePromptSafetyAttributes));
  }
  return toObject;
}
function tunedModelInfoFromMldev(fromObject) {
  const toObject = {};
  const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
  if (fromBaseModel != null) {
    setValueByPath(toObject, ["baseModel"], fromBaseModel);
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  return toObject;
}
function modelFromMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromVersion = getValueByPath(fromObject, ["version"]);
  if (fromVersion != null) {
    setValueByPath(toObject, ["version"], fromVersion);
  }
  const fromTunedModelInfo = getValueByPath(fromObject, ["_self"]);
  if (fromTunedModelInfo != null) {
    setValueByPath(toObject, ["tunedModelInfo"], tunedModelInfoFromMldev(fromTunedModelInfo));
  }
  const fromInputTokenLimit = getValueByPath(fromObject, [
    "inputTokenLimit"
  ]);
  if (fromInputTokenLimit != null) {
    setValueByPath(toObject, ["inputTokenLimit"], fromInputTokenLimit);
  }
  const fromOutputTokenLimit = getValueByPath(fromObject, [
    "outputTokenLimit"
  ]);
  if (fromOutputTokenLimit != null) {
    setValueByPath(toObject, ["outputTokenLimit"], fromOutputTokenLimit);
  }
  const fromSupportedActions = getValueByPath(fromObject, [
    "supportedGenerationMethods"
  ]);
  if (fromSupportedActions != null) {
    setValueByPath(toObject, ["supportedActions"], fromSupportedActions);
  }
  return toObject;
}
function listModelsResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromModels = getValueByPath(fromObject, ["_self"]);
  if (fromModels != null) {
    let transformedList = tExtractModels(fromModels);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return modelFromMldev(item);
      });
    }
    setValueByPath(toObject, ["models"], transformedList);
  }
  return toObject;
}
function deleteModelResponseFromMldev() {
  const toObject = {};
  return toObject;
}
function countTokensResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromTotalTokens = getValueByPath(fromObject, ["totalTokens"]);
  if (fromTotalTokens != null) {
    setValueByPath(toObject, ["totalTokens"], fromTotalTokens);
  }
  const fromCachedContentTokenCount = getValueByPath(fromObject, [
    "cachedContentTokenCount"
  ]);
  if (fromCachedContentTokenCount != null) {
    setValueByPath(toObject, ["cachedContentTokenCount"], fromCachedContentTokenCount);
  }
  return toObject;
}
function videoFromMldev(fromObject) {
  const toObject = {};
  const fromUri = getValueByPath(fromObject, ["video", "uri"]);
  if (fromUri != null) {
    setValueByPath(toObject, ["uri"], fromUri);
  }
  const fromVideoBytes = getValueByPath(fromObject, [
    "video",
    "encodedVideo"
  ]);
  if (fromVideoBytes != null) {
    setValueByPath(toObject, ["videoBytes"], tBytes(fromVideoBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["encoding"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function generatedVideoFromMldev(fromObject) {
  const toObject = {};
  const fromVideo = getValueByPath(fromObject, ["_self"]);
  if (fromVideo != null) {
    setValueByPath(toObject, ["video"], videoFromMldev(fromVideo));
  }
  return toObject;
}
function generateVideosResponseFromMldev(fromObject) {
  const toObject = {};
  const fromGeneratedVideos = getValueByPath(fromObject, [
    "generatedSamples"
  ]);
  if (fromGeneratedVideos != null) {
    let transformedList = fromGeneratedVideos;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedVideoFromMldev(item);
      });
    }
    setValueByPath(toObject, ["generatedVideos"], transformedList);
  }
  const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
    "raiMediaFilteredCount"
  ]);
  if (fromRaiMediaFilteredCount != null) {
    setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
  }
  const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
    "raiMediaFilteredReasons"
  ]);
  if (fromRaiMediaFilteredReasons != null) {
    setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
  }
  return toObject;
}
function generateVideosOperationFromMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], fromMetadata);
  }
  const fromDone = getValueByPath(fromObject, ["done"]);
  if (fromDone != null) {
    setValueByPath(toObject, ["done"], fromDone);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  const fromResponse = getValueByPath(fromObject, [
    "response",
    "generateVideoResponse"
  ]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], generateVideosResponseFromMldev(fromResponse));
  }
  return toObject;
}
function videoMetadataFromVertex(fromObject) {
  const toObject = {};
  const fromFps = getValueByPath(fromObject, ["fps"]);
  if (fromFps != null) {
    setValueByPath(toObject, ["fps"], fromFps);
  }
  const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
  if (fromEndOffset != null) {
    setValueByPath(toObject, ["endOffset"], fromEndOffset);
  }
  const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
  if (fromStartOffset != null) {
    setValueByPath(toObject, ["startOffset"], fromStartOffset);
  }
  return toObject;
}
function blobFromVertex(fromObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function fileDataFromVertex(fromObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function partFromVertex(fromObject) {
  const toObject = {};
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], videoMetadataFromVertex(fromVideoMetadata));
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobFromVertex(fromInlineData));
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataFromVertex(fromFileData));
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], fromFunctionCall);
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  return toObject;
}
function contentFromVertex(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partFromVertex(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function citationMetadataFromVertex(fromObject) {
  const toObject = {};
  const fromCitations = getValueByPath(fromObject, ["citations"]);
  if (fromCitations != null) {
    setValueByPath(toObject, ["citations"], fromCitations);
  }
  return toObject;
}
function urlMetadataFromVertex(fromObject) {
  const toObject = {};
  const fromRetrievedUrl = getValueByPath(fromObject, ["retrievedUrl"]);
  if (fromRetrievedUrl != null) {
    setValueByPath(toObject, ["retrievedUrl"], fromRetrievedUrl);
  }
  const fromUrlRetrievalStatus = getValueByPath(fromObject, [
    "urlRetrievalStatus"
  ]);
  if (fromUrlRetrievalStatus != null) {
    setValueByPath(toObject, ["urlRetrievalStatus"], fromUrlRetrievalStatus);
  }
  return toObject;
}
function urlContextMetadataFromVertex(fromObject) {
  const toObject = {};
  const fromUrlMetadata = getValueByPath(fromObject, ["urlMetadata"]);
  if (fromUrlMetadata != null) {
    let transformedList = fromUrlMetadata;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return urlMetadataFromVertex(item);
      });
    }
    setValueByPath(toObject, ["urlMetadata"], transformedList);
  }
  return toObject;
}
function candidateFromVertex(fromObject) {
  const toObject = {};
  const fromContent = getValueByPath(fromObject, ["content"]);
  if (fromContent != null) {
    setValueByPath(toObject, ["content"], contentFromVertex(fromContent));
  }
  const fromCitationMetadata = getValueByPath(fromObject, [
    "citationMetadata"
  ]);
  if (fromCitationMetadata != null) {
    setValueByPath(toObject, ["citationMetadata"], citationMetadataFromVertex(fromCitationMetadata));
  }
  const fromFinishMessage = getValueByPath(fromObject, [
    "finishMessage"
  ]);
  if (fromFinishMessage != null) {
    setValueByPath(toObject, ["finishMessage"], fromFinishMessage);
  }
  const fromFinishReason = getValueByPath(fromObject, ["finishReason"]);
  if (fromFinishReason != null) {
    setValueByPath(toObject, ["finishReason"], fromFinishReason);
  }
  const fromUrlContextMetadata = getValueByPath(fromObject, [
    "urlContextMetadata"
  ]);
  if (fromUrlContextMetadata != null) {
    setValueByPath(toObject, ["urlContextMetadata"], urlContextMetadataFromVertex(fromUrlContextMetadata));
  }
  const fromAvgLogprobs = getValueByPath(fromObject, ["avgLogprobs"]);
  if (fromAvgLogprobs != null) {
    setValueByPath(toObject, ["avgLogprobs"], fromAvgLogprobs);
  }
  const fromGroundingMetadata = getValueByPath(fromObject, [
    "groundingMetadata"
  ]);
  if (fromGroundingMetadata != null) {
    setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
  }
  const fromIndex = getValueByPath(fromObject, ["index"]);
  if (fromIndex != null) {
    setValueByPath(toObject, ["index"], fromIndex);
  }
  const fromLogprobsResult = getValueByPath(fromObject, [
    "logprobsResult"
  ]);
  if (fromLogprobsResult != null) {
    setValueByPath(toObject, ["logprobsResult"], fromLogprobsResult);
  }
  const fromSafetyRatings = getValueByPath(fromObject, [
    "safetyRatings"
  ]);
  if (fromSafetyRatings != null) {
    setValueByPath(toObject, ["safetyRatings"], fromSafetyRatings);
  }
  return toObject;
}
function generateContentResponseFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromCandidates = getValueByPath(fromObject, ["candidates"]);
  if (fromCandidates != null) {
    let transformedList = fromCandidates;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return candidateFromVertex(item);
      });
    }
    setValueByPath(toObject, ["candidates"], transformedList);
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
  if (fromModelVersion != null) {
    setValueByPath(toObject, ["modelVersion"], fromModelVersion);
  }
  const fromPromptFeedback = getValueByPath(fromObject, [
    "promptFeedback"
  ]);
  if (fromPromptFeedback != null) {
    setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
  }
  const fromResponseId = getValueByPath(fromObject, ["responseId"]);
  if (fromResponseId != null) {
    setValueByPath(toObject, ["responseId"], fromResponseId);
  }
  const fromUsageMetadata = getValueByPath(fromObject, [
    "usageMetadata"
  ]);
  if (fromUsageMetadata != null) {
    setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
  }
  return toObject;
}
function contentEmbeddingStatisticsFromVertex(fromObject) {
  const toObject = {};
  const fromTruncated = getValueByPath(fromObject, ["truncated"]);
  if (fromTruncated != null) {
    setValueByPath(toObject, ["truncated"], fromTruncated);
  }
  const fromTokenCount = getValueByPath(fromObject, ["token_count"]);
  if (fromTokenCount != null) {
    setValueByPath(toObject, ["tokenCount"], fromTokenCount);
  }
  return toObject;
}
function contentEmbeddingFromVertex(fromObject) {
  const toObject = {};
  const fromValues = getValueByPath(fromObject, ["values"]);
  if (fromValues != null) {
    setValueByPath(toObject, ["values"], fromValues);
  }
  const fromStatistics = getValueByPath(fromObject, ["statistics"]);
  if (fromStatistics != null) {
    setValueByPath(toObject, ["statistics"], contentEmbeddingStatisticsFromVertex(fromStatistics));
  }
  return toObject;
}
function embedContentMetadataFromVertex(fromObject) {
  const toObject = {};
  const fromBillableCharacterCount = getValueByPath(fromObject, [
    "billableCharacterCount"
  ]);
  if (fromBillableCharacterCount != null) {
    setValueByPath(toObject, ["billableCharacterCount"], fromBillableCharacterCount);
  }
  return toObject;
}
function embedContentResponseFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromEmbeddings = getValueByPath(fromObject, [
    "predictions[]",
    "embeddings"
  ]);
  if (fromEmbeddings != null) {
    let transformedList = fromEmbeddings;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return contentEmbeddingFromVertex(item);
      });
    }
    setValueByPath(toObject, ["embeddings"], transformedList);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], embedContentMetadataFromVertex(fromMetadata));
  }
  return toObject;
}
function imageFromVertex(fromObject) {
  const toObject = {};
  const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
  if (fromGcsUri != null) {
    setValueByPath(toObject, ["gcsUri"], fromGcsUri);
  }
  const fromImageBytes = getValueByPath(fromObject, [
    "bytesBase64Encoded"
  ]);
  if (fromImageBytes != null) {
    setValueByPath(toObject, ["imageBytes"], tBytes(fromImageBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function safetyAttributesFromVertex(fromObject) {
  const toObject = {};
  const fromCategories = getValueByPath(fromObject, [
    "safetyAttributes",
    "categories"
  ]);
  if (fromCategories != null) {
    setValueByPath(toObject, ["categories"], fromCategories);
  }
  const fromScores = getValueByPath(fromObject, [
    "safetyAttributes",
    "scores"
  ]);
  if (fromScores != null) {
    setValueByPath(toObject, ["scores"], fromScores);
  }
  const fromContentType = getValueByPath(fromObject, ["contentType"]);
  if (fromContentType != null) {
    setValueByPath(toObject, ["contentType"], fromContentType);
  }
  return toObject;
}
function generatedImageFromVertex(fromObject) {
  const toObject = {};
  const fromImage = getValueByPath(fromObject, ["_self"]);
  if (fromImage != null) {
    setValueByPath(toObject, ["image"], imageFromVertex(fromImage));
  }
  const fromRaiFilteredReason = getValueByPath(fromObject, [
    "raiFilteredReason"
  ]);
  if (fromRaiFilteredReason != null) {
    setValueByPath(toObject, ["raiFilteredReason"], fromRaiFilteredReason);
  }
  const fromSafetyAttributes = getValueByPath(fromObject, ["_self"]);
  if (fromSafetyAttributes != null) {
    setValueByPath(toObject, ["safetyAttributes"], safetyAttributesFromVertex(fromSafetyAttributes));
  }
  const fromEnhancedPrompt = getValueByPath(fromObject, ["prompt"]);
  if (fromEnhancedPrompt != null) {
    setValueByPath(toObject, ["enhancedPrompt"], fromEnhancedPrompt);
  }
  return toObject;
}
function generateImagesResponseFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromGeneratedImages = getValueByPath(fromObject, [
    "predictions"
  ]);
  if (fromGeneratedImages != null) {
    let transformedList = fromGeneratedImages;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedImageFromVertex(item);
      });
    }
    setValueByPath(toObject, ["generatedImages"], transformedList);
  }
  const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [
    "positivePromptSafetyAttributes"
  ]);
  if (fromPositivePromptSafetyAttributes != null) {
    setValueByPath(toObject, ["positivePromptSafetyAttributes"], safetyAttributesFromVertex(fromPositivePromptSafetyAttributes));
  }
  return toObject;
}
function editImageResponseFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromGeneratedImages = getValueByPath(fromObject, [
    "predictions"
  ]);
  if (fromGeneratedImages != null) {
    let transformedList = fromGeneratedImages;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedImageFromVertex(item);
      });
    }
    setValueByPath(toObject, ["generatedImages"], transformedList);
  }
  return toObject;
}
function upscaleImageResponseFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromGeneratedImages = getValueByPath(fromObject, [
    "predictions"
  ]);
  if (fromGeneratedImages != null) {
    let transformedList = fromGeneratedImages;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedImageFromVertex(item);
      });
    }
    setValueByPath(toObject, ["generatedImages"], transformedList);
  }
  return toObject;
}
function recontextImageResponseFromVertex(fromObject) {
  const toObject = {};
  const fromGeneratedImages = getValueByPath(fromObject, [
    "predictions"
  ]);
  if (fromGeneratedImages != null) {
    let transformedList = fromGeneratedImages;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedImageFromVertex(item);
      });
    }
    setValueByPath(toObject, ["generatedImages"], transformedList);
  }
  return toObject;
}
function endpointFromVertex(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["endpoint"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDeployedModelId = getValueByPath(fromObject, [
    "deployedModelId"
  ]);
  if (fromDeployedModelId != null) {
    setValueByPath(toObject, ["deployedModelId"], fromDeployedModelId);
  }
  return toObject;
}
function tunedModelInfoFromVertex(fromObject) {
  const toObject = {};
  const fromBaseModel = getValueByPath(fromObject, [
    "labels",
    "google-vertex-llm-tuning-base-model-id"
  ]);
  if (fromBaseModel != null) {
    setValueByPath(toObject, ["baseModel"], fromBaseModel);
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  return toObject;
}
function checkpointFromVertex(fromObject) {
  const toObject = {};
  const fromCheckpointId = getValueByPath(fromObject, ["checkpointId"]);
  if (fromCheckpointId != null) {
    setValueByPath(toObject, ["checkpointId"], fromCheckpointId);
  }
  const fromEpoch = getValueByPath(fromObject, ["epoch"]);
  if (fromEpoch != null) {
    setValueByPath(toObject, ["epoch"], fromEpoch);
  }
  const fromStep = getValueByPath(fromObject, ["step"]);
  if (fromStep != null) {
    setValueByPath(toObject, ["step"], fromStep);
  }
  return toObject;
}
function modelFromVertex(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromVersion = getValueByPath(fromObject, ["versionId"]);
  if (fromVersion != null) {
    setValueByPath(toObject, ["version"], fromVersion);
  }
  const fromEndpoints = getValueByPath(fromObject, ["deployedModels"]);
  if (fromEndpoints != null) {
    let transformedList = fromEndpoints;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return endpointFromVertex(item);
      });
    }
    setValueByPath(toObject, ["endpoints"], transformedList);
  }
  const fromLabels = getValueByPath(fromObject, ["labels"]);
  if (fromLabels != null) {
    setValueByPath(toObject, ["labels"], fromLabels);
  }
  const fromTunedModelInfo = getValueByPath(fromObject, ["_self"]);
  if (fromTunedModelInfo != null) {
    setValueByPath(toObject, ["tunedModelInfo"], tunedModelInfoFromVertex(fromTunedModelInfo));
  }
  const fromDefaultCheckpointId = getValueByPath(fromObject, [
    "defaultCheckpointId"
  ]);
  if (fromDefaultCheckpointId != null) {
    setValueByPath(toObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
  }
  const fromCheckpoints = getValueByPath(fromObject, ["checkpoints"]);
  if (fromCheckpoints != null) {
    let transformedList = fromCheckpoints;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return checkpointFromVertex(item);
      });
    }
    setValueByPath(toObject, ["checkpoints"], transformedList);
  }
  return toObject;
}
function listModelsResponseFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromModels = getValueByPath(fromObject, ["_self"]);
  if (fromModels != null) {
    let transformedList = tExtractModels(fromModels);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return modelFromVertex(item);
      });
    }
    setValueByPath(toObject, ["models"], transformedList);
  }
  return toObject;
}
function deleteModelResponseFromVertex() {
  const toObject = {};
  return toObject;
}
function countTokensResponseFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromTotalTokens = getValueByPath(fromObject, ["totalTokens"]);
  if (fromTotalTokens != null) {
    setValueByPath(toObject, ["totalTokens"], fromTotalTokens);
  }
  return toObject;
}
function computeTokensResponseFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromTokensInfo = getValueByPath(fromObject, ["tokensInfo"]);
  if (fromTokensInfo != null) {
    setValueByPath(toObject, ["tokensInfo"], fromTokensInfo);
  }
  return toObject;
}
function videoFromVertex(fromObject) {
  const toObject = {};
  const fromUri = getValueByPath(fromObject, ["gcsUri"]);
  if (fromUri != null) {
    setValueByPath(toObject, ["uri"], fromUri);
  }
  const fromVideoBytes = getValueByPath(fromObject, [
    "bytesBase64Encoded"
  ]);
  if (fromVideoBytes != null) {
    setValueByPath(toObject, ["videoBytes"], tBytes(fromVideoBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function generatedVideoFromVertex(fromObject) {
  const toObject = {};
  const fromVideo = getValueByPath(fromObject, ["_self"]);
  if (fromVideo != null) {
    setValueByPath(toObject, ["video"], videoFromVertex(fromVideo));
  }
  return toObject;
}
function generateVideosResponseFromVertex(fromObject) {
  const toObject = {};
  const fromGeneratedVideos = getValueByPath(fromObject, ["videos"]);
  if (fromGeneratedVideos != null) {
    let transformedList = fromGeneratedVideos;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedVideoFromVertex(item);
      });
    }
    setValueByPath(toObject, ["generatedVideos"], transformedList);
  }
  const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
    "raiMediaFilteredCount"
  ]);
  if (fromRaiMediaFilteredCount != null) {
    setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
  }
  const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
    "raiMediaFilteredReasons"
  ]);
  if (fromRaiMediaFilteredReasons != null) {
    setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
  }
  return toObject;
}
function generateVideosOperationFromVertex(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], fromMetadata);
  }
  const fromDone = getValueByPath(fromObject, ["done"]);
  if (fromDone != null) {
    setValueByPath(toObject, ["done"], fromDone);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], generateVideosResponseFromVertex(fromResponse));
  }
  return toObject;
}
var CONTENT_TYPE_HEADER = "Content-Type";
var SERVER_TIMEOUT_HEADER = "X-Server-Timeout";
var USER_AGENT_HEADER = "User-Agent";
var GOOGLE_API_CLIENT_HEADER = "x-goog-api-client";
var SDK_VERSION = "1.13.0";
var LIBRARY_LABEL = `google-genai-sdk/${SDK_VERSION}`;
var VERTEX_AI_API_DEFAULT_VERSION = "v1beta1";
var GOOGLE_AI_API_DEFAULT_VERSION = "v1beta";
var responseLineRE = /^data: (.*)(?:\n\n|\r\r|\r\n\r\n)/;
var ApiClient = class {
  constructor(opts) {
    var _a3, _b;
    this.clientOptions = Object.assign(Object.assign({}, opts), { project: opts.project, location: opts.location, apiKey: opts.apiKey, vertexai: opts.vertexai });
    const initHttpOptions = {};
    if (this.clientOptions.vertexai) {
      initHttpOptions.apiVersion = (_a3 = this.clientOptions.apiVersion) !== null && _a3 !== void 0 ? _a3 : VERTEX_AI_API_DEFAULT_VERSION;
      initHttpOptions.baseUrl = this.baseUrlFromProjectLocation();
      this.normalizeAuthParameters();
    } else {
      initHttpOptions.apiVersion = (_b = this.clientOptions.apiVersion) !== null && _b !== void 0 ? _b : GOOGLE_AI_API_DEFAULT_VERSION;
      initHttpOptions.baseUrl = `https://generativelanguage.googleapis.com/`;
    }
    initHttpOptions.headers = this.getDefaultHeaders();
    this.clientOptions.httpOptions = initHttpOptions;
    if (opts.httpOptions) {
      this.clientOptions.httpOptions = this.patchHttpOptions(initHttpOptions, opts.httpOptions);
    }
  }
  /**
   * Determines the base URL for Vertex AI based on project and location.
   * Uses the global endpoint if location is 'global' or if project/location
   * are not specified (implying API key usage).
   * @private
   */
  baseUrlFromProjectLocation() {
    if (this.clientOptions.project && this.clientOptions.location && this.clientOptions.location !== "global") {
      return `https://${this.clientOptions.location}-aiplatform.googleapis.com/`;
    }
    return `https://aiplatform.googleapis.com/`;
  }
  /**
   * Normalizes authentication parameters for Vertex AI.
   * If project and location are provided, API key is cleared.
   * If project and location are not provided (implying API key usage),
   * project and location are cleared.
   * @private
   */
  normalizeAuthParameters() {
    if (this.clientOptions.project && this.clientOptions.location) {
      this.clientOptions.apiKey = void 0;
      return;
    }
    this.clientOptions.project = void 0;
    this.clientOptions.location = void 0;
  }
  isVertexAI() {
    var _a3;
    return (_a3 = this.clientOptions.vertexai) !== null && _a3 !== void 0 ? _a3 : false;
  }
  getProject() {
    return this.clientOptions.project;
  }
  getLocation() {
    return this.clientOptions.location;
  }
  getApiVersion() {
    if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.apiVersion !== void 0) {
      return this.clientOptions.httpOptions.apiVersion;
    }
    throw new Error("API version is not set.");
  }
  getBaseUrl() {
    if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.baseUrl !== void 0) {
      return this.clientOptions.httpOptions.baseUrl;
    }
    throw new Error("Base URL is not set.");
  }
  getRequestUrl() {
    return this.getRequestUrlInternal(this.clientOptions.httpOptions);
  }
  getHeaders() {
    if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.headers !== void 0) {
      return this.clientOptions.httpOptions.headers;
    } else {
      throw new Error("Headers are not set.");
    }
  }
  getRequestUrlInternal(httpOptions) {
    if (!httpOptions || httpOptions.baseUrl === void 0 || httpOptions.apiVersion === void 0) {
      throw new Error("HTTP options are not correctly set.");
    }
    const baseUrl = httpOptions.baseUrl.endsWith("/") ? httpOptions.baseUrl.slice(0, -1) : httpOptions.baseUrl;
    const urlElement = [baseUrl];
    if (httpOptions.apiVersion && httpOptions.apiVersion !== "") {
      urlElement.push(httpOptions.apiVersion);
    }
    return urlElement.join("/");
  }
  getBaseResourcePath() {
    return `projects/${this.clientOptions.project}/locations/${this.clientOptions.location}`;
  }
  getApiKey() {
    return this.clientOptions.apiKey;
  }
  getWebsocketBaseUrl() {
    const baseUrl = this.getBaseUrl();
    const urlParts = new URL(baseUrl);
    urlParts.protocol = urlParts.protocol == "http:" ? "ws" : "wss";
    return urlParts.toString();
  }
  setBaseUrl(url) {
    if (this.clientOptions.httpOptions) {
      this.clientOptions.httpOptions.baseUrl = url;
    } else {
      throw new Error("HTTP options are not correctly set.");
    }
  }
  constructUrl(path2, httpOptions, prependProjectLocation) {
    const urlElement = [this.getRequestUrlInternal(httpOptions)];
    if (prependProjectLocation) {
      urlElement.push(this.getBaseResourcePath());
    }
    if (path2 !== "") {
      urlElement.push(path2);
    }
    const url = new URL(`${urlElement.join("/")}`);
    return url;
  }
  shouldPrependVertexProjectPath(request) {
    if (this.clientOptions.apiKey) {
      return false;
    }
    if (!this.clientOptions.vertexai) {
      return false;
    }
    if (request.path.startsWith("projects/")) {
      return false;
    }
    if (request.httpMethod === "GET" && request.path.startsWith("publishers/google/models")) {
      return false;
    }
    return true;
  }
  async request(request) {
    let patchedHttpOptions = this.clientOptions.httpOptions;
    if (request.httpOptions) {
      patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);
    }
    const prependProjectLocation = this.shouldPrependVertexProjectPath(request);
    const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);
    if (request.queryParams) {
      for (const [key, value] of Object.entries(request.queryParams)) {
        url.searchParams.append(key, String(value));
      }
    }
    let requestInit = {};
    if (request.httpMethod === "GET") {
      if (request.body && request.body !== "{}") {
        throw new Error("Request body should be empty for GET request, but got non empty request body");
      }
    } else {
      requestInit.body = request.body;
    }
    requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, request.abortSignal);
    return this.unaryApiCall(url, requestInit, request.httpMethod);
  }
  patchHttpOptions(baseHttpOptions, requestHttpOptions) {
    const patchedHttpOptions = JSON.parse(JSON.stringify(baseHttpOptions));
    for (const [key, value] of Object.entries(requestHttpOptions)) {
      if (typeof value === "object") {
        patchedHttpOptions[key] = Object.assign(Object.assign({}, patchedHttpOptions[key]), value);
      } else if (value !== void 0) {
        patchedHttpOptions[key] = value;
      }
    }
    return patchedHttpOptions;
  }
  async requestStream(request) {
    let patchedHttpOptions = this.clientOptions.httpOptions;
    if (request.httpOptions) {
      patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);
    }
    const prependProjectLocation = this.shouldPrependVertexProjectPath(request);
    const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);
    if (!url.searchParams.has("alt") || url.searchParams.get("alt") !== "sse") {
      url.searchParams.set("alt", "sse");
    }
    let requestInit = {};
    requestInit.body = request.body;
    requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, request.abortSignal);
    return this.streamApiCall(url, requestInit, request.httpMethod);
  }
  async includeExtraHttpOptionsToRequestInit(requestInit, httpOptions, abortSignal) {
    if (httpOptions && httpOptions.timeout || abortSignal) {
      const abortController = new AbortController();
      const signal = abortController.signal;
      if (httpOptions.timeout && (httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.timeout) > 0) {
        const timeoutHandle = setTimeout(() => abortController.abort(), httpOptions.timeout);
        if (timeoutHandle && typeof timeoutHandle.unref === "function") {
          timeoutHandle.unref();
        }
      }
      if (abortSignal) {
        abortSignal.addEventListener("abort", () => {
          abortController.abort();
        });
      }
      requestInit.signal = signal;
    }
    if (httpOptions && httpOptions.extraBody !== null) {
      includeExtraBodyToRequestInit(requestInit, httpOptions.extraBody);
    }
    requestInit.headers = await this.getHeadersInternal(httpOptions);
    return requestInit;
  }
  async unaryApiCall(url, requestInit, httpMethod) {
    return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod })).then(async (response) => {
      await throwErrorIfNotOK(response);
      return new HttpResponse(response);
    }).catch((e2) => {
      if (e2 instanceof Error) {
        throw e2;
      } else {
        throw new Error(JSON.stringify(e2));
      }
    });
  }
  async streamApiCall(url, requestInit, httpMethod) {
    return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod })).then(async (response) => {
      await throwErrorIfNotOK(response);
      return this.processStreamResponse(response);
    }).catch((e2) => {
      if (e2 instanceof Error) {
        throw e2;
      } else {
        throw new Error(JSON.stringify(e2));
      }
    });
  }
  processStreamResponse(response) {
    var _a3;
    return __asyncGenerator(this, arguments, function* processStreamResponse_1() {
      const reader = (_a3 = response === null || response === void 0 ? void 0 : response.body) === null || _a3 === void 0 ? void 0 : _a3.getReader();
      const decoder = new TextDecoder("utf-8");
      if (!reader) {
        throw new Error("Response body is empty");
      }
      try {
        let buffer = "";
        while (true) {
          const { done, value } = yield __await(reader.read());
          if (done) {
            if (buffer.trim().length > 0) {
              throw new Error("Incomplete JSON segment at the end");
            }
            break;
          }
          const chunkString = decoder.decode(value, { stream: true });
          try {
            const chunkJson = JSON.parse(chunkString);
            if ("error" in chunkJson) {
              const errorJson = JSON.parse(JSON.stringify(chunkJson["error"]));
              const status = errorJson["status"];
              const code = errorJson["code"];
              const errorMessage = `got status: ${status}. ${JSON.stringify(chunkJson)}`;
              if (code >= 400 && code < 600) {
                const apiError = new ApiError({
                  message: errorMessage,
                  status: code
                });
                throw apiError;
              }
            }
          } catch (e2) {
            const error = e2;
            if (error.name === "ApiError") {
              throw e2;
            }
          }
          buffer += chunkString;
          let match7 = buffer.match(responseLineRE);
          while (match7) {
            const processedChunkString = match7[1];
            try {
              const partialResponse = new Response(processedChunkString, {
                headers: response === null || response === void 0 ? void 0 : response.headers,
                status: response === null || response === void 0 ? void 0 : response.status,
                statusText: response === null || response === void 0 ? void 0 : response.statusText
              });
              yield yield __await(new HttpResponse(partialResponse));
              buffer = buffer.slice(match7[0].length);
              match7 = buffer.match(responseLineRE);
            } catch (e2) {
              throw new Error(`exception parsing stream chunk ${processedChunkString}. ${e2}`);
            }
          }
        }
      } finally {
        reader.releaseLock();
      }
    });
  }
  async apiCall(url, requestInit) {
    return fetch(url, requestInit).catch((e2) => {
      throw new Error(`exception ${e2} sending request`);
    });
  }
  getDefaultHeaders() {
    const headers = {};
    const versionHeaderValue = LIBRARY_LABEL + " " + this.clientOptions.userAgentExtra;
    headers[USER_AGENT_HEADER] = versionHeaderValue;
    headers[GOOGLE_API_CLIENT_HEADER] = versionHeaderValue;
    headers[CONTENT_TYPE_HEADER] = "application/json";
    return headers;
  }
  async getHeadersInternal(httpOptions) {
    const headers = new Headers();
    if (httpOptions && httpOptions.headers) {
      for (const [key, value] of Object.entries(httpOptions.headers)) {
        headers.append(key, value);
      }
      if (httpOptions.timeout && httpOptions.timeout > 0) {
        headers.append(SERVER_TIMEOUT_HEADER, String(Math.ceil(httpOptions.timeout / 1e3)));
      }
    }
    await this.clientOptions.auth.addAuthHeaders(headers);
    return headers;
  }
  /**
   * Uploads a file asynchronously using Gemini API only, this is not supported
   * in Vertex AI.
   *
   * @param file The string path to the file to be uploaded or a Blob object.
   * @param config Optional parameters specified in the `UploadFileConfig`
   *     interface. @see {@link UploadFileConfig}
   * @return A promise that resolves to a `File` object.
   * @throws An error if called on a Vertex AI client.
   * @throws An error if the `mimeType` is not provided and can not be inferred,
   */
  async uploadFile(file, config) {
    var _a3;
    const fileToUpload = {};
    if (config != null) {
      fileToUpload.mimeType = config.mimeType;
      fileToUpload.name = config.name;
      fileToUpload.displayName = config.displayName;
    }
    if (fileToUpload.name && !fileToUpload.name.startsWith("files/")) {
      fileToUpload.name = `files/${fileToUpload.name}`;
    }
    const uploader = this.clientOptions.uploader;
    const fileStat = await uploader.stat(file);
    fileToUpload.sizeBytes = String(fileStat.size);
    const mimeType = (_a3 = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a3 !== void 0 ? _a3 : fileStat.type;
    if (mimeType === void 0 || mimeType === "") {
      throw new Error("Can not determine mimeType. Please provide mimeType in the config.");
    }
    fileToUpload.mimeType = mimeType;
    const uploadUrl = await this.fetchUploadUrl(fileToUpload, config);
    return uploader.upload(file, uploadUrl, this);
  }
  /**
   * Downloads a file asynchronously to the specified path.
   *
   * @params params - The parameters for the download request, see {@link
   * DownloadFileParameters}
   */
  async downloadFile(params) {
    const downloader = this.clientOptions.downloader;
    await downloader.download(params, this);
  }
  async fetchUploadUrl(file, config) {
    var _a3;
    let httpOptions = {};
    if (config === null || config === void 0 ? void 0 : config.httpOptions) {
      httpOptions = config.httpOptions;
    } else {
      httpOptions = {
        apiVersion: "",
        headers: {
          "Content-Type": "application/json",
          "X-Goog-Upload-Protocol": "resumable",
          "X-Goog-Upload-Command": "start",
          "X-Goog-Upload-Header-Content-Length": `${file.sizeBytes}`,
          "X-Goog-Upload-Header-Content-Type": `${file.mimeType}`
        }
      };
    }
    const body = {
      "file": file
    };
    const httpResponse = await this.request({
      path: formatMap("upload/v1beta/files", body["_url"]),
      body: JSON.stringify(body),
      httpMethod: "POST",
      httpOptions
    });
    if (!httpResponse || !(httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers)) {
      throw new Error("Server did not return an HttpResponse or the returned HttpResponse did not have headers.");
    }
    const uploadUrl = (_a3 = httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers) === null || _a3 === void 0 ? void 0 : _a3["x-goog-upload-url"];
    if (uploadUrl === void 0) {
      throw new Error("Failed to get upload url. Server did not return the x-google-upload-url in the headers");
    }
    return uploadUrl;
  }
};
async function throwErrorIfNotOK(response) {
  var _a3;
  if (response === void 0) {
    throw new Error("response is undefined");
  }
  if (!response.ok) {
    const status = response.status;
    let errorBody;
    if ((_a3 = response.headers.get("content-type")) === null || _a3 === void 0 ? void 0 : _a3.includes("application/json")) {
      errorBody = await response.json();
    } else {
      errorBody = {
        error: {
          message: await response.text(),
          code: response.status,
          status: response.statusText
        }
      };
    }
    const errorMessage = JSON.stringify(errorBody);
    if (status >= 400 && status < 600) {
      const apiError = new ApiError({
        message: errorMessage,
        status
      });
      throw apiError;
    }
    throw new Error(errorMessage);
  }
}
function includeExtraBodyToRequestInit(requestInit, extraBody) {
  if (!extraBody || Object.keys(extraBody).length === 0) {
    return;
  }
  if (requestInit.body instanceof Blob) {
    console.warn("includeExtraBodyToRequestInit: extraBody provided but current request body is a Blob. extraBody will be ignored as merging is not supported for Blob bodies.");
    return;
  }
  let currentBodyObject = {};
  if (typeof requestInit.body === "string" && requestInit.body.length > 0) {
    try {
      const parsedBody = JSON.parse(requestInit.body);
      if (typeof parsedBody === "object" && parsedBody !== null && !Array.isArray(parsedBody)) {
        currentBodyObject = parsedBody;
      } else {
        console.warn("includeExtraBodyToRequestInit: Original request body is valid JSON but not a non-array object. Skip applying extraBody to the request body.");
        return;
      }
    } catch (e2) {
      console.warn("includeExtraBodyToRequestInit: Original request body is not valid JSON. Skip applying extraBody to the request body.");
      return;
    }
  }
  function deepMerge(target, source) {
    const output = Object.assign({}, target);
    for (const key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        const sourceValue = source[key];
        const targetValue = output[key];
        if (sourceValue && typeof sourceValue === "object" && !Array.isArray(sourceValue) && targetValue && typeof targetValue === "object" && !Array.isArray(targetValue)) {
          output[key] = deepMerge(targetValue, sourceValue);
        } else {
          if (targetValue && sourceValue && typeof targetValue !== typeof sourceValue) {
            console.warn(`includeExtraBodyToRequestInit:deepMerge: Type mismatch for key "${key}". Original type: ${typeof targetValue}, New type: ${typeof sourceValue}. Overwriting.`);
          }
          output[key] = sourceValue;
        }
      }
    }
    return output;
  }
  const mergedBody = deepMerge(currentBodyObject, extraBody);
  requestInit.body = JSON.stringify(mergedBody);
}
var MCP_LABEL = "mcp_used/unknown";
var hasMcpToolUsageFromMcpToTool = false;
function hasMcpToolUsage(tools) {
  for (const tool of tools) {
    if (isMcpCallableTool(tool)) {
      return true;
    }
    if (typeof tool === "object" && "inputSchema" in tool) {
      return true;
    }
  }
  return hasMcpToolUsageFromMcpToTool;
}
function setMcpUsageHeader(headers) {
  var _a3;
  const existingHeader = (_a3 = headers[GOOGLE_API_CLIENT_HEADER]) !== null && _a3 !== void 0 ? _a3 : "";
  headers[GOOGLE_API_CLIENT_HEADER] = (existingHeader + ` ${MCP_LABEL}`).trimStart();
}
function isMcpCallableTool(object) {
  return object !== null && typeof object === "object" && object instanceof McpCallableTool;
}
function listAllTools(mcpClient, maxTools = 100) {
  return __asyncGenerator(this, arguments, function* listAllTools_1() {
    let cursor = void 0;
    let numTools = 0;
    while (numTools < maxTools) {
      const t2 = yield __await(mcpClient.listTools({ cursor }));
      for (const tool of t2.tools) {
        yield yield __await(tool);
        numTools++;
      }
      if (!t2.nextCursor) {
        break;
      }
      cursor = t2.nextCursor;
    }
  });
}
var McpCallableTool = class _McpCallableTool {
  constructor(mcpClients = [], config) {
    this.mcpTools = [];
    this.functionNameToMcpClient = {};
    this.mcpClients = mcpClients;
    this.config = config;
  }
  /**
   * Creates a McpCallableTool.
   */
  static create(mcpClients, config) {
    return new _McpCallableTool(mcpClients, config);
  }
  /**
   * Validates the function names are not duplicate and initialize the function
   * name to MCP client mapping.
   *
   * @throws {Error} if the MCP tools from the MCP clients have duplicate tool
   *     names.
   */
  async initialize() {
    var _a3, e_1, _b, _c;
    if (this.mcpTools.length > 0) {
      return;
    }
    const functionMap = {};
    const mcpTools = [];
    for (const mcpClient of this.mcpClients) {
      try {
        for (var _d = true, _e2 = (e_1 = void 0, __asyncValues(listAllTools(mcpClient))), _f; _f = await _e2.next(), _a3 = _f.done, !_a3; _d = true) {
          _c = _f.value;
          _d = false;
          const mcpTool = _c;
          mcpTools.push(mcpTool);
          const mcpToolName = mcpTool.name;
          if (functionMap[mcpToolName]) {
            throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);
          }
          functionMap[mcpToolName] = mcpClient;
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_d && !_a3 && (_b = _e2.return)) await _b.call(_e2);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
    }
    this.mcpTools = mcpTools;
    this.functionNameToMcpClient = functionMap;
  }
  async tool() {
    await this.initialize();
    return mcpToolsToGeminiTool(this.mcpTools, this.config);
  }
  async callTool(functionCalls) {
    await this.initialize();
    const functionCallResponseParts = [];
    for (const functionCall of functionCalls) {
      if (functionCall.name in this.functionNameToMcpClient) {
        const mcpClient = this.functionNameToMcpClient[functionCall.name];
        let requestOptions = void 0;
        if (this.config.timeout) {
          requestOptions = {
            timeout: this.config.timeout
          };
        }
        const callToolResponse = await mcpClient.callTool(
          {
            name: functionCall.name,
            arguments: functionCall.args
          },
          // Set the result schema to undefined to allow MCP to rely on the
          // default schema.
          void 0,
          requestOptions
        );
        functionCallResponseParts.push({
          functionResponse: {
            name: functionCall.name,
            response: callToolResponse.isError ? { error: callToolResponse } : callToolResponse
          }
        });
      }
    }
    return functionCallResponseParts;
  }
};
async function handleWebSocketMessage$1(apiClient, onmessage, event) {
  const serverMessage = new LiveMusicServerMessage();
  let data;
  if (event.data instanceof Blob) {
    data = JSON.parse(await event.data.text());
  } else {
    data = JSON.parse(event.data);
  }
  const response = liveMusicServerMessageFromMldev(data);
  Object.assign(serverMessage, response);
  onmessage(serverMessage);
}
var LiveMusic = class {
  constructor(apiClient, auth, webSocketFactory) {
    this.apiClient = apiClient;
    this.auth = auth;
    this.webSocketFactory = webSocketFactory;
  }
  /**
       Establishes a connection to the specified model and returns a
       LiveMusicSession object representing that connection.
  
       @experimental
  
       @remarks
  
       @param params - The parameters for establishing a connection to the model.
       @return A live session.
  
       @example
       ```ts
       let model = 'models/lyria-realtime-exp';
       const session = await ai.live.music.connect({
         model: model,
         callbacks: {
           onmessage: (e: MessageEvent) => {
             console.log('Received message from the server: %s\n', debug(e.data));
           },
           onerror: (e: ErrorEvent) => {
             console.log('Error occurred: %s\n', debug(e.error));
           },
           onclose: (e: CloseEvent) => {
             console.log('Connection closed.');
           },
         },
       });
       ```
      */
  async connect(params) {
    var _a3, _b;
    if (this.apiClient.isVertexAI()) {
      throw new Error("Live music is not supported for Vertex AI.");
    }
    console.warn("Live music generation is experimental and may change in future versions.");
    const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();
    const apiVersion = this.apiClient.getApiVersion();
    const headers = mapToHeaders$1(this.apiClient.getDefaultHeaders());
    const apiKey = this.apiClient.getApiKey();
    const url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.BidiGenerateMusic?key=${apiKey}`;
    let onopenResolve = () => {
    };
    const onopenPromise = new Promise((resolve) => {
      onopenResolve = resolve;
    });
    const callbacks = params.callbacks;
    const onopenAwaitedCallback = function() {
      onopenResolve({});
    };
    const apiClient = this.apiClient;
    const websocketCallbacks = {
      onopen: onopenAwaitedCallback,
      onmessage: (event) => {
        void handleWebSocketMessage$1(apiClient, callbacks.onmessage, event);
      },
      onerror: (_a3 = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a3 !== void 0 ? _a3 : function(e2) {
      },
      onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e2) {
      }
    };
    const conn = this.webSocketFactory.create(url, headersToMap$1(headers), websocketCallbacks);
    conn.connect();
    await onopenPromise;
    const model = tModel(this.apiClient, params.model);
    const setup = liveMusicClientSetupToMldev({
      model
    });
    const clientMessage = liveMusicClientMessageToMldev({ setup });
    conn.send(JSON.stringify(clientMessage));
    return new LiveMusicSession(conn, this.apiClient);
  }
};
var LiveMusicSession = class {
  constructor(conn, apiClient) {
    this.conn = conn;
    this.apiClient = apiClient;
  }
  /**
      Sets inputs to steer music generation. Updates the session's current
      weighted prompts.
  
      @param params - Contains one property, `weightedPrompts`.
  
        - `weightedPrompts` to send to the model; weights are normalized to
          sum to 1.0.
  
      @experimental
     */
  async setWeightedPrompts(params) {
    if (!params.weightedPrompts || Object.keys(params.weightedPrompts).length === 0) {
      throw new Error("Weighted prompts must be set and contain at least one entry.");
    }
    const setWeightedPromptsParameters = liveMusicSetWeightedPromptsParametersToMldev(params);
    const clientContent = liveMusicClientContentToMldev(setWeightedPromptsParameters);
    this.conn.send(JSON.stringify({ clientContent }));
  }
  /**
      Sets a configuration to the model. Updates the session's current
      music generation config.
  
      @param params - Contains one property, `musicGenerationConfig`.
  
        - `musicGenerationConfig` to set in the model. Passing an empty or
      undefined config to the model will reset the config to defaults.
  
      @experimental
     */
  async setMusicGenerationConfig(params) {
    if (!params.musicGenerationConfig) {
      params.musicGenerationConfig = {};
    }
    const setConfigParameters = liveMusicSetConfigParametersToMldev(params);
    const clientMessage = liveMusicClientMessageToMldev(setConfigParameters);
    this.conn.send(JSON.stringify(clientMessage));
  }
  sendPlaybackControl(playbackControl) {
    const clientMessage = liveMusicClientMessageToMldev({
      playbackControl
    });
    this.conn.send(JSON.stringify(clientMessage));
  }
  /**
   * Start the music stream.
   *
   * @experimental
   */
  play() {
    this.sendPlaybackControl(LiveMusicPlaybackControl.PLAY);
  }
  /**
   * Temporarily halt the music stream. Use `play` to resume from the current
   * position.
   *
   * @experimental
   */
  pause() {
    this.sendPlaybackControl(LiveMusicPlaybackControl.PAUSE);
  }
  /**
   * Stop the music stream and reset the state. Retains the current prompts
   * and config.
   *
   * @experimental
   */
  stop() {
    this.sendPlaybackControl(LiveMusicPlaybackControl.STOP);
  }
  /**
   * Resets the context of the music generation without stopping it.
   * Retains the current prompts and config.
   *
   * @experimental
   */
  resetContext() {
    this.sendPlaybackControl(LiveMusicPlaybackControl.RESET_CONTEXT);
  }
  /**
       Terminates the WebSocket connection.
  
       @experimental
     */
  close() {
    this.conn.close();
  }
};
function headersToMap$1(headers) {
  const headerMap = {};
  headers.forEach((value, key) => {
    headerMap[key] = value;
  });
  return headerMap;
}
function mapToHeaders$1(map) {
  const headers = new Headers();
  for (const [key, value] of Object.entries(map)) {
    headers.append(key, value);
  }
  return headers;
}
var FUNCTION_RESPONSE_REQUIRES_ID = "FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI.";
async function handleWebSocketMessage(apiClient, onmessage, event) {
  const serverMessage = new LiveServerMessage();
  let jsonData;
  if (event.data instanceof Blob) {
    jsonData = await event.data.text();
  } else if (event.data instanceof ArrayBuffer) {
    jsonData = new TextDecoder().decode(event.data);
  } else {
    jsonData = event.data;
  }
  const data = JSON.parse(jsonData);
  if (apiClient.isVertexAI()) {
    const resp = liveServerMessageFromVertex(data);
    Object.assign(serverMessage, resp);
  } else {
    const resp = liveServerMessageFromMldev(data);
    Object.assign(serverMessage, resp);
  }
  onmessage(serverMessage);
}
var Live = class {
  constructor(apiClient, auth, webSocketFactory) {
    this.apiClient = apiClient;
    this.auth = auth;
    this.webSocketFactory = webSocketFactory;
    this.music = new LiveMusic(this.apiClient, this.auth, this.webSocketFactory);
  }
  /**
       Establishes a connection to the specified model with the given
       configuration and returns a Session object representing that connection.
  
       @experimental Built-in MCP support is an experimental feature, may change in
       future versions.
  
       @remarks
  
       @param params - The parameters for establishing a connection to the model.
       @return A live session.
  
       @example
       ```ts
       let model: string;
       if (GOOGLE_GENAI_USE_VERTEXAI) {
         model = 'gemini-2.0-flash-live-preview-04-09';
       } else {
         model = 'gemini-live-2.5-flash-preview';
       }
       const session = await ai.live.connect({
         model: model,
         config: {
           responseModalities: [Modality.AUDIO],
         },
         callbacks: {
           onopen: () => {
             console.log('Connected to the socket.');
           },
           onmessage: (e: MessageEvent) => {
             console.log('Received message from the server: %s\n', debug(e.data));
           },
           onerror: (e: ErrorEvent) => {
             console.log('Error occurred: %s\n', debug(e.error));
           },
           onclose: (e: CloseEvent) => {
             console.log('Connection closed.');
           },
         },
       });
       ```
      */
  async connect(params) {
    var _a3, _b, _c, _d, _e2, _f;
    if (params.config && params.config.httpOptions) {
      throw new Error("The Live module does not support httpOptions at request-level in LiveConnectConfig yet. Please use the client-level httpOptions configuration instead.");
    }
    const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();
    const apiVersion = this.apiClient.getApiVersion();
    let url;
    const clientHeaders = this.apiClient.getHeaders();
    if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {
      setMcpUsageHeader(clientHeaders);
    }
    const headers = mapToHeaders(clientHeaders);
    if (this.apiClient.isVertexAI()) {
      url = `${websocketBaseUrl}/ws/google.cloud.aiplatform.${apiVersion}.LlmBidiService/BidiGenerateContent`;
      await this.auth.addAuthHeaders(headers);
    } else {
      const apiKey = this.apiClient.getApiKey();
      let method = "BidiGenerateContent";
      let keyName = "key";
      if (apiKey === null || apiKey === void 0 ? void 0 : apiKey.startsWith("auth_tokens/")) {
        console.warn("Warning: Ephemeral token support is experimental and may change in future versions.");
        if (apiVersion !== "v1alpha") {
          console.warn("Warning: The SDK's ephemeral token support is in v1alpha only. Please use const ai = new GoogleGenAI({apiKey: token.name, httpOptions: { apiVersion: 'v1alpha' }}); before session connection.");
        }
        method = "BidiGenerateContentConstrained";
        keyName = "access_token";
      }
      url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.${method}?${keyName}=${apiKey}`;
    }
    let onopenResolve = () => {
    };
    const onopenPromise = new Promise((resolve) => {
      onopenResolve = resolve;
    });
    const callbacks = params.callbacks;
    const onopenAwaitedCallback = function() {
      var _a4;
      (_a4 = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onopen) === null || _a4 === void 0 ? void 0 : _a4.call(callbacks);
      onopenResolve({});
    };
    const apiClient = this.apiClient;
    const websocketCallbacks = {
      onopen: onopenAwaitedCallback,
      onmessage: (event) => {
        void handleWebSocketMessage(apiClient, callbacks.onmessage, event);
      },
      onerror: (_a3 = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a3 !== void 0 ? _a3 : function(e2) {
      },
      onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e2) {
      }
    };
    const conn = this.webSocketFactory.create(url, headersToMap(headers), websocketCallbacks);
    conn.connect();
    await onopenPromise;
    let transformedModel = tModel(this.apiClient, params.model);
    if (this.apiClient.isVertexAI() && transformedModel.startsWith("publishers/")) {
      const project = this.apiClient.getProject();
      const location = this.apiClient.getLocation();
      transformedModel = `projects/${project}/locations/${location}/` + transformedModel;
    }
    let clientMessage = {};
    if (this.apiClient.isVertexAI() && ((_c = params.config) === null || _c === void 0 ? void 0 : _c.responseModalities) === void 0) {
      if (params.config === void 0) {
        params.config = { responseModalities: [Modality.AUDIO] };
      } else {
        params.config.responseModalities = [Modality.AUDIO];
      }
    }
    if ((_d = params.config) === null || _d === void 0 ? void 0 : _d.generationConfig) {
      console.warn("Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025).");
    }
    const inputTools = (_f = (_e2 = params.config) === null || _e2 === void 0 ? void 0 : _e2.tools) !== null && _f !== void 0 ? _f : [];
    const convertedTools = [];
    for (const tool of inputTools) {
      if (this.isCallableTool(tool)) {
        const callableTool = tool;
        convertedTools.push(await callableTool.tool());
      } else {
        convertedTools.push(tool);
      }
    }
    if (convertedTools.length > 0) {
      params.config.tools = convertedTools;
    }
    const liveConnectParameters = {
      model: transformedModel,
      config: params.config,
      callbacks: params.callbacks
    };
    if (this.apiClient.isVertexAI()) {
      clientMessage = liveConnectParametersToVertex(this.apiClient, liveConnectParameters);
    } else {
      clientMessage = liveConnectParametersToMldev(this.apiClient, liveConnectParameters);
    }
    delete clientMessage["config"];
    conn.send(JSON.stringify(clientMessage));
    return new Session(conn, this.apiClient);
  }
  // TODO: b/416041229 - Abstract this method to a common place.
  isCallableTool(tool) {
    return "callTool" in tool && typeof tool.callTool === "function";
  }
};
var defaultLiveSendClientContentParamerters = {
  turnComplete: true
};
var Session = class {
  constructor(conn, apiClient) {
    this.conn = conn;
    this.apiClient = apiClient;
  }
  tLiveClientContent(apiClient, params) {
    if (params.turns !== null && params.turns !== void 0) {
      let contents = [];
      try {
        contents = tContents(params.turns);
        if (apiClient.isVertexAI()) {
          contents = contents.map((item) => contentToVertex(item));
        } else {
          contents = contents.map((item) => contentToMldev$1(item));
        }
      } catch (_a3) {
        throw new Error(`Failed to parse client content "turns", type: '${typeof params.turns}'`);
      }
      return {
        clientContent: { turns: contents, turnComplete: params.turnComplete }
      };
    }
    return {
      clientContent: { turnComplete: params.turnComplete }
    };
  }
  tLiveClienttToolResponse(apiClient, params) {
    let functionResponses = [];
    if (params.functionResponses == null) {
      throw new Error("functionResponses is required.");
    }
    if (!Array.isArray(params.functionResponses)) {
      functionResponses = [params.functionResponses];
    } else {
      functionResponses = params.functionResponses;
    }
    if (functionResponses.length === 0) {
      throw new Error("functionResponses is required.");
    }
    for (const functionResponse of functionResponses) {
      if (typeof functionResponse !== "object" || functionResponse === null || !("name" in functionResponse) || !("response" in functionResponse)) {
        throw new Error(`Could not parse function response, type '${typeof functionResponse}'.`);
      }
      if (!apiClient.isVertexAI() && !("id" in functionResponse)) {
        throw new Error(FUNCTION_RESPONSE_REQUIRES_ID);
      }
    }
    const clientMessage = {
      toolResponse: { functionResponses }
    };
    return clientMessage;
  }
  /**
      Send a message over the established connection.
  
      @param params - Contains two **optional** properties, `turns` and
          `turnComplete`.
  
        - `turns` will be converted to a `Content[]`
        - `turnComplete: true` [default] indicates that you are done sending
          content and expect a response. If `turnComplete: false`, the server
          will wait for additional messages before starting generation.
  
      @experimental
  
      @remarks
      There are two ways to send messages to the live API:
      `sendClientContent` and `sendRealtimeInput`.
  
      `sendClientContent` messages are added to the model context **in order**.
      Having a conversation using `sendClientContent` messages is roughly
      equivalent to using the `Chat.sendMessageStream`, except that the state of
      the `chat` history is stored on the API server instead of locally.
  
      Because of `sendClientContent`'s order guarantee, the model cannot respons
      as quickly to `sendClientContent` messages as to `sendRealtimeInput`
      messages. This makes the biggest difference when sending objects that have
      significant preprocessing time (typically images).
  
      The `sendClientContent` message sends a `Content[]`
      which has more options than the `Blob` sent by `sendRealtimeInput`.
  
      So the main use-cases for `sendClientContent` over `sendRealtimeInput` are:
  
      - Sending anything that can't be represented as a `Blob` (text,
      `sendClientContent({turns="Hello?"}`)).
      - Managing turns when not using audio input and voice activity detection.
        (`sendClientContent({turnComplete:true})` or the short form
      `sendClientContent()`)
      - Prefilling a conversation context
        ```
        sendClientContent({
            turns: [
              Content({role:user, parts:...}),
              Content({role:user, parts:...}),
              ...
            ]
        })
        ```
      @experimental
     */
  sendClientContent(params) {
    params = Object.assign(Object.assign({}, defaultLiveSendClientContentParamerters), params);
    const clientMessage = this.tLiveClientContent(this.apiClient, params);
    this.conn.send(JSON.stringify(clientMessage));
  }
  /**
      Send a realtime message over the established connection.
  
      @param params - Contains one property, `media`.
  
        - `media` will be converted to a `Blob`
  
      @experimental
  
      @remarks
      Use `sendRealtimeInput` for realtime audio chunks and video frames (images).
  
      With `sendRealtimeInput` the api will respond to audio automatically
      based on voice activity detection (VAD).
  
      `sendRealtimeInput` is optimized for responsivness at the expense of
      deterministic ordering guarantees. Audio and video tokens are to the
      context when they become available.
  
      Note: The Call signature expects a `Blob` object, but only a subset
      of audio and image mimetypes are allowed.
     */
  sendRealtimeInput(params) {
    let clientMessage = {};
    if (this.apiClient.isVertexAI()) {
      clientMessage = {
        "realtimeInput": liveSendRealtimeInputParametersToVertex(params)
      };
    } else {
      clientMessage = {
        "realtimeInput": liveSendRealtimeInputParametersToMldev(params)
      };
    }
    this.conn.send(JSON.stringify(clientMessage));
  }
  /**
      Send a function response message over the established connection.
  
      @param params - Contains property `functionResponses`.
  
        - `functionResponses` will be converted to a `functionResponses[]`
  
      @remarks
      Use `sendFunctionResponse` to reply to `LiveServerToolCall` from the server.
  
      Use {@link types.LiveConnectConfig#tools} to configure the callable functions.
  
      @experimental
     */
  sendToolResponse(params) {
    if (params.functionResponses == null) {
      throw new Error("Tool response parameters are required.");
    }
    const clientMessage = this.tLiveClienttToolResponse(this.apiClient, params);
    this.conn.send(JSON.stringify(clientMessage));
  }
  /**
       Terminates the WebSocket connection.
  
       @experimental
  
       @example
       ```ts
       let model: string;
       if (GOOGLE_GENAI_USE_VERTEXAI) {
         model = 'gemini-2.0-flash-live-preview-04-09';
       } else {
         model = 'gemini-live-2.5-flash-preview';
       }
       const session = await ai.live.connect({
         model: model,
         config: {
           responseModalities: [Modality.AUDIO],
         }
       });
  
       session.close();
       ```
     */
  close() {
    this.conn.close();
  }
};
function headersToMap(headers) {
  const headerMap = {};
  headers.forEach((value, key) => {
    headerMap[key] = value;
  });
  return headerMap;
}
function mapToHeaders(map) {
  const headers = new Headers();
  for (const [key, value] of Object.entries(map)) {
    headers.append(key, value);
  }
  return headers;
}
var DEFAULT_MAX_REMOTE_CALLS = 10;
function shouldDisableAfc(config) {
  var _a3, _b, _c;
  if ((_a3 = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a3 === void 0 ? void 0 : _a3.disable) {
    return true;
  }
  let callableToolsPresent = false;
  for (const tool of (_b = config === null || config === void 0 ? void 0 : config.tools) !== null && _b !== void 0 ? _b : []) {
    if (isCallableTool(tool)) {
      callableToolsPresent = true;
      break;
    }
  }
  if (!callableToolsPresent) {
    return true;
  }
  const maxCalls = (_c = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _c === void 0 ? void 0 : _c.maximumRemoteCalls;
  if (maxCalls && (maxCalls < 0 || !Number.isInteger(maxCalls)) || maxCalls == 0) {
    console.warn("Invalid maximumRemoteCalls value provided for automatic function calling. Disabled automatic function calling. Please provide a valid integer value greater than 0. maximumRemoteCalls provided:", maxCalls);
    return true;
  }
  return false;
}
function isCallableTool(tool) {
  return "callTool" in tool && typeof tool.callTool === "function";
}
function hasCallableTools(params) {
  var _a3, _b, _c;
  return (_c = (_b = (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.tools) === null || _b === void 0 ? void 0 : _b.some((tool) => isCallableTool(tool))) !== null && _c !== void 0 ? _c : false;
}
function hasNonCallableTools(params) {
  var _a3, _b, _c;
  return (_c = (_b = (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.tools) === null || _b === void 0 ? void 0 : _b.some((tool) => !isCallableTool(tool))) !== null && _c !== void 0 ? _c : false;
}
function shouldAppendAfcHistory(config) {
  var _a3;
  return !((_a3 = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a3 === void 0 ? void 0 : _a3.ignoreCallHistory);
}
var Models3 = class extends BaseModule {
  constructor(apiClient) {
    super();
    this.apiClient = apiClient;
    this.generateContent = async (params) => {
      var _a3, _b, _c, _d, _e2;
      const transformedParams = await this.processParamsMaybeAddMcpUsage(params);
      this.maybeMoveToResponseJsonSchem(params);
      if (!hasCallableTools(params) || shouldDisableAfc(params.config)) {
        return await this.generateContentInternal(transformedParams);
      }
      if (hasNonCallableTools(params)) {
        throw new Error("Automatic function calling with CallableTools and Tools is not yet supported.");
      }
      let response;
      let functionResponseContent;
      const automaticFunctionCallingHistory = tContents(transformedParams.contents);
      const maxRemoteCalls = (_c = (_b = (_a3 = transformedParams.config) === null || _a3 === void 0 ? void 0 : _a3.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;
      let remoteCalls = 0;
      while (remoteCalls < maxRemoteCalls) {
        response = await this.generateContentInternal(transformedParams);
        if (!response.functionCalls || response.functionCalls.length === 0) {
          break;
        }
        const responseContent = response.candidates[0].content;
        const functionResponseParts = [];
        for (const tool of (_e2 = (_d = params.config) === null || _d === void 0 ? void 0 : _d.tools) !== null && _e2 !== void 0 ? _e2 : []) {
          if (isCallableTool(tool)) {
            const callableTool = tool;
            const parts = await callableTool.callTool(response.functionCalls);
            functionResponseParts.push(...parts);
          }
        }
        remoteCalls++;
        functionResponseContent = {
          role: "user",
          parts: functionResponseParts
        };
        transformedParams.contents = tContents(transformedParams.contents);
        transformedParams.contents.push(responseContent);
        transformedParams.contents.push(functionResponseContent);
        if (shouldAppendAfcHistory(transformedParams.config)) {
          automaticFunctionCallingHistory.push(responseContent);
          automaticFunctionCallingHistory.push(functionResponseContent);
        }
      }
      if (shouldAppendAfcHistory(transformedParams.config)) {
        response.automaticFunctionCallingHistory = automaticFunctionCallingHistory;
      }
      return response;
    };
    this.generateContentStream = async (params) => {
      this.maybeMoveToResponseJsonSchem(params);
      if (shouldDisableAfc(params.config)) {
        const transformedParams = await this.processParamsMaybeAddMcpUsage(params);
        return await this.generateContentStreamInternal(transformedParams);
      } else {
        return await this.processAfcStream(params);
      }
    };
    this.generateImages = async (params) => {
      return await this.generateImagesInternal(params).then((apiResponse) => {
        var _a3;
        let positivePromptSafetyAttributes;
        const generatedImages = [];
        if (apiResponse === null || apiResponse === void 0 ? void 0 : apiResponse.generatedImages) {
          for (const generatedImage of apiResponse.generatedImages) {
            if (generatedImage && (generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) && ((_a3 = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) === null || _a3 === void 0 ? void 0 : _a3.contentType) === "Positive Prompt") {
              positivePromptSafetyAttributes = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes;
            } else {
              generatedImages.push(generatedImage);
            }
          }
        }
        let response;
        if (positivePromptSafetyAttributes) {
          response = {
            generatedImages,
            positivePromptSafetyAttributes,
            sdkHttpResponse: apiResponse.sdkHttpResponse
          };
        } else {
          response = {
            generatedImages,
            sdkHttpResponse: apiResponse.sdkHttpResponse
          };
        }
        return response;
      });
    };
    this.list = async (params) => {
      var _a3;
      const defaultConfig = {
        queryBase: true
      };
      const actualConfig = Object.assign(Object.assign({}, defaultConfig), params === null || params === void 0 ? void 0 : params.config);
      const actualParams = {
        config: actualConfig
      };
      if (this.apiClient.isVertexAI()) {
        if (!actualParams.config.queryBase) {
          if ((_a3 = actualParams.config) === null || _a3 === void 0 ? void 0 : _a3.filter) {
            throw new Error("Filtering tuned models list for Vertex AI is not currently supported");
          } else {
            actualParams.config.filter = "labels.tune-type:*";
          }
        }
      }
      return new Pager(PagedItem.PAGED_ITEM_MODELS, (x2) => this.listInternal(x2), await this.listInternal(actualParams), actualParams);
    };
    this.editImage = async (params) => {
      const paramsInternal = {
        model: params.model,
        prompt: params.prompt,
        referenceImages: [],
        config: params.config
      };
      if (params.referenceImages) {
        if (params.referenceImages) {
          paramsInternal.referenceImages = params.referenceImages.map((img) => img.toReferenceImageAPI());
        }
      }
      return await this.editImageInternal(paramsInternal);
    };
    this.upscaleImage = async (params) => {
      let apiConfig = {
        numberOfImages: 1,
        mode: "upscale"
      };
      if (params.config) {
        apiConfig = Object.assign(Object.assign({}, apiConfig), params.config);
      }
      const apiParams = {
        model: params.model,
        image: params.image,
        upscaleFactor: params.upscaleFactor,
        config: apiConfig
      };
      return await this.upscaleImageInternal(apiParams);
    };
    this.generateVideos = async (params) => {
      return await this.generateVideosInternal(params);
    };
  }
  /**
   * This logic is needed for GenerateContentConfig only.
   * Previously we made GenerateContentConfig.responseSchema field to accept
   * unknown. Since v1.9.0, we switch to use backend JSON schema support.
   * To maintain backward compatibility, we move the data that was treated as
   * JSON schema from the responseSchema field to the responseJsonSchema field.
   */
  maybeMoveToResponseJsonSchem(params) {
    if (params.config && params.config.responseSchema) {
      if (!params.config.responseJsonSchema) {
        if (Object.keys(params.config.responseSchema).includes("$schema")) {
          params.config.responseJsonSchema = params.config.responseSchema;
          delete params.config.responseSchema;
        }
      }
    }
    return;
  }
  /**
   * Transforms the CallableTools in the parameters to be simply Tools, it
   * copies the params into a new object and replaces the tools, it does not
   * modify the original params. Also sets the MCP usage header if there are
   * MCP tools in the parameters.
   */
  async processParamsMaybeAddMcpUsage(params) {
    var _a3, _b, _c;
    const tools = (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.tools;
    if (!tools) {
      return params;
    }
    const transformedTools = await Promise.all(tools.map(async (tool) => {
      if (isCallableTool(tool)) {
        const callableTool = tool;
        return await callableTool.tool();
      }
      return tool;
    }));
    const newParams = {
      model: params.model,
      contents: params.contents,
      config: Object.assign(Object.assign({}, params.config), { tools: transformedTools })
    };
    newParams.config.tools = transformedTools;
    if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {
      const headers = (_c = (_b = params.config.httpOptions) === null || _b === void 0 ? void 0 : _b.headers) !== null && _c !== void 0 ? _c : {};
      let newHeaders = Object.assign({}, headers);
      if (Object.keys(newHeaders).length === 0) {
        newHeaders = this.apiClient.getDefaultHeaders();
      }
      setMcpUsageHeader(newHeaders);
      newParams.config.httpOptions = Object.assign(Object.assign({}, params.config.httpOptions), { headers: newHeaders });
    }
    return newParams;
  }
  async initAfcToolsMap(params) {
    var _a3, _b, _c;
    const afcTools = /* @__PURE__ */ new Map();
    for (const tool of (_b = (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.tools) !== null && _b !== void 0 ? _b : []) {
      if (isCallableTool(tool)) {
        const callableTool = tool;
        const toolDeclaration = await callableTool.tool();
        for (const declaration of (_c = toolDeclaration.functionDeclarations) !== null && _c !== void 0 ? _c : []) {
          if (!declaration.name) {
            throw new Error("Function declaration name is required.");
          }
          if (afcTools.has(declaration.name)) {
            throw new Error(`Duplicate tool declaration name: ${declaration.name}`);
          }
          afcTools.set(declaration.name, callableTool);
        }
      }
    }
    return afcTools;
  }
  async processAfcStream(params) {
    var _a3, _b, _c;
    const maxRemoteCalls = (_c = (_b = (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;
    let wereFunctionsCalled = false;
    let remoteCallCount = 0;
    const afcToolsMap = await this.initAfcToolsMap(params);
    return function(models, afcTools, params2) {
      var _a4, _b2;
      return __asyncGenerator(this, arguments, function* () {
        var _c2, e_1, _d, _e2;
        while (remoteCallCount < maxRemoteCalls) {
          if (wereFunctionsCalled) {
            remoteCallCount++;
            wereFunctionsCalled = false;
          }
          const transformedParams = yield __await(models.processParamsMaybeAddMcpUsage(params2));
          const response = yield __await(models.generateContentStreamInternal(transformedParams));
          const functionResponses = [];
          const responseContents = [];
          try {
            for (var _f = true, response_1 = (e_1 = void 0, __asyncValues(response)), response_1_1; response_1_1 = yield __await(response_1.next()), _c2 = response_1_1.done, !_c2; _f = true) {
              _e2 = response_1_1.value;
              _f = false;
              const chunk = _e2;
              yield yield __await(chunk);
              if (chunk.candidates && ((_a4 = chunk.candidates[0]) === null || _a4 === void 0 ? void 0 : _a4.content)) {
                responseContents.push(chunk.candidates[0].content);
                for (const part of (_b2 = chunk.candidates[0].content.parts) !== null && _b2 !== void 0 ? _b2 : []) {
                  if (remoteCallCount < maxRemoteCalls && part.functionCall) {
                    if (!part.functionCall.name) {
                      throw new Error("Function call name was not returned by the model.");
                    }
                    if (!afcTools.has(part.functionCall.name)) {
                      throw new Error(`Automatic function calling was requested, but not all the tools the model used implement the CallableTool interface. Available tools: ${afcTools.keys()}, mising tool: ${part.functionCall.name}`);
                    } else {
                      const responseParts = yield __await(afcTools.get(part.functionCall.name).callTool([part.functionCall]));
                      functionResponses.push(...responseParts);
                    }
                  }
                }
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (!_f && !_c2 && (_d = response_1.return)) yield __await(_d.call(response_1));
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          if (functionResponses.length > 0) {
            wereFunctionsCalled = true;
            const typedResponseChunk = new GenerateContentResponse();
            typedResponseChunk.candidates = [
              {
                content: {
                  role: "user",
                  parts: functionResponses
                }
              }
            ];
            yield yield __await(typedResponseChunk);
            const newContents = [];
            newContents.push(...responseContents);
            newContents.push({
              role: "user",
              parts: functionResponses
            });
            const updatedContents = tContents(params2.contents).concat(newContents);
            params2.contents = updatedContents;
          } else {
            break;
          }
        }
      });
    }(this, afcToolsMap, params);
  }
  async generateContentInternal(params) {
    var _a3, _b, _c, _d;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = generateContentParametersToVertex(this.apiClient, params);
      path2 = formatMap("{model}:generateContent", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = generateContentResponseFromVertex(apiResponse);
        const typedResp = new GenerateContentResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = generateContentParametersToMldev(this.apiClient, params);
      path2 = formatMap("{model}:generateContent", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = generateContentResponseFromMldev(apiResponse);
        const typedResp = new GenerateContentResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  async generateContentStreamInternal(params) {
    var _a3, _b, _c, _d;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = generateContentParametersToVertex(this.apiClient, params);
      path2 = formatMap("{model}:streamGenerateContent?alt=sse", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      const apiClient = this.apiClient;
      response = apiClient.requestStream({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      });
      return response.then(function(apiResponse) {
        return __asyncGenerator(this, arguments, function* () {
          var _a4, e_2, _b2, _c2;
          try {
            for (var _d2 = true, apiResponse_1 = __asyncValues(apiResponse), apiResponse_1_1; apiResponse_1_1 = yield __await(apiResponse_1.next()), _a4 = apiResponse_1_1.done, !_a4; _d2 = true) {
              _c2 = apiResponse_1_1.value;
              _d2 = false;
              const chunk = _c2;
              const resp = generateContentResponseFromVertex(yield __await(chunk.json()));
              resp["sdkHttpResponse"] = {
                headers: chunk.headers
              };
              const typedResp = new GenerateContentResponse();
              Object.assign(typedResp, resp);
              yield yield __await(typedResp);
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (!_d2 && !_a4 && (_b2 = apiResponse_1.return)) yield __await(_b2.call(apiResponse_1));
            } finally {
              if (e_2) throw e_2.error;
            }
          }
        });
      });
    } else {
      const body = generateContentParametersToMldev(this.apiClient, params);
      path2 = formatMap("{model}:streamGenerateContent?alt=sse", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      const apiClient = this.apiClient;
      response = apiClient.requestStream({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      });
      return response.then(function(apiResponse) {
        return __asyncGenerator(this, arguments, function* () {
          var _a4, e_3, _b2, _c2;
          try {
            for (var _d2 = true, apiResponse_2 = __asyncValues(apiResponse), apiResponse_2_1; apiResponse_2_1 = yield __await(apiResponse_2.next()), _a4 = apiResponse_2_1.done, !_a4; _d2 = true) {
              _c2 = apiResponse_2_1.value;
              _d2 = false;
              const chunk = _c2;
              const resp = generateContentResponseFromMldev(yield __await(chunk.json()));
              resp["sdkHttpResponse"] = {
                headers: chunk.headers
              };
              const typedResp = new GenerateContentResponse();
              Object.assign(typedResp, resp);
              yield yield __await(typedResp);
            }
          } catch (e_3_1) {
            e_3 = { error: e_3_1 };
          } finally {
            try {
              if (!_d2 && !_a4 && (_b2 = apiResponse_2.return)) yield __await(_b2.call(apiResponse_2));
            } finally {
              if (e_3) throw e_3.error;
            }
          }
        });
      });
    }
  }
  /**
   * Calculates embeddings for the given contents. Only text is supported.
   *
   * @param params - The parameters for embedding contents.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response = await ai.models.embedContent({
   *  model: 'text-embedding-004',
   *  contents: [
   *    'What is your name?',
   *    'What is your favorite color?',
   *  ],
   *  config: {
   *    outputDimensionality: 64,
   *  },
   * });
   * console.log(response);
   * ```
   */
  async embedContent(params) {
    var _a3, _b, _c, _d;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = embedContentParametersToVertex(this.apiClient, params);
      path2 = formatMap("{model}:predict", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = embedContentResponseFromVertex(apiResponse);
        const typedResp = new EmbedContentResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = embedContentParametersToMldev(this.apiClient, params);
      path2 = formatMap("{model}:batchEmbedContents", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = embedContentResponseFromMldev(apiResponse);
        const typedResp = new EmbedContentResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  /**
   * Generates an image based on a text description and configuration.
   *
   * @param params - The parameters for generating images.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response = await ai.models.generateImages({
   *  model: 'imagen-3.0-generate-002',
   *  prompt: 'Robot holding a red skateboard',
   *  config: {
   *    numberOfImages: 1,
   *    includeRaiReason: true,
   *  },
   * });
   * console.log(response?.generatedImages?.[0]?.image?.imageBytes);
   * ```
   */
  async generateImagesInternal(params) {
    var _a3, _b, _c, _d;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = generateImagesParametersToVertex(this.apiClient, params);
      path2 = formatMap("{model}:predict", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = generateImagesResponseFromVertex(apiResponse);
        const typedResp = new GenerateImagesResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = generateImagesParametersToMldev(this.apiClient, params);
      path2 = formatMap("{model}:predict", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = generateImagesResponseFromMldev(apiResponse);
        const typedResp = new GenerateImagesResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  async editImageInternal(params) {
    var _a3, _b;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = editImageParametersInternalToVertex(this.apiClient, params);
      path2 = formatMap("{model}:predict", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = editImageResponseFromVertex(apiResponse);
        const typedResp = new EditImageResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      throw new Error("This method is only supported by the Vertex AI.");
    }
  }
  async upscaleImageInternal(params) {
    var _a3, _b;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = upscaleImageAPIParametersInternalToVertex(this.apiClient, params);
      path2 = formatMap("{model}:predict", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = upscaleImageResponseFromVertex(apiResponse);
        const typedResp = new UpscaleImageResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      throw new Error("This method is only supported by the Vertex AI.");
    }
  }
  /**
   * Recontextualizes an image.
   *
   * There are two types of recontextualization currently supported:
   * 1) Imagen Product Recontext - Generate images of products in new scenes
   *    and contexts.
   * 2) Virtual Try-On: Generate images of persons modeling fashion products.
   *
   * @param params - The parameters for recontextualizing an image.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response1 = await ai.models.recontextImage({
   *  model: 'imagen-product-recontext-preview-06-30',
   *  source: {
   *    prompt: 'In a modern kitchen setting.',
   *    productImages: [productImage],
   *  },
   *  config: {
   *    numberOfImages: 1,
   *  },
   * });
   * console.log(response1?.generatedImages?.[0]?.image?.imageBytes);
   *
   * const response2 = await ai.models.recontextImage({
   *  model: 'virtual-try-on-preview-08-04',
   *  source: {
   *    personImage: personImage,
   *    productImages: [productImage],
   *  },
   *  config: {
   *    numberOfImages: 1,
   *  },
   * });
   * console.log(response2?.generatedImages?.[0]?.image?.imageBytes);
   * ```
   */
  async recontextImage(params) {
    var _a3, _b;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = recontextImageParametersToVertex(this.apiClient, params);
      path2 = formatMap("{model}:predict", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = recontextImageResponseFromVertex(apiResponse);
        const typedResp = new RecontextImageResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      throw new Error("This method is only supported by the Vertex AI.");
    }
  }
  /**
   * Fetches information about a model by name.
   *
   * @example
   * ```ts
   * const modelInfo = await ai.models.get({model: 'gemini-2.0-flash'});
   * ```
   */
  async get(params) {
    var _a3, _b, _c, _d;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = getModelParametersToVertex(this.apiClient, params);
      path2 = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = modelFromVertex(apiResponse);
        return resp;
      });
    } else {
      const body = getModelParametersToMldev(this.apiClient, params);
      path2 = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = modelFromMldev(apiResponse);
        return resp;
      });
    }
  }
  async listInternal(params) {
    var _a3, _b, _c, _d;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = listModelsParametersToVertex(this.apiClient, params);
      path2 = formatMap("{models_url}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = listModelsResponseFromVertex(apiResponse);
        const typedResp = new ListModelsResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = listModelsParametersToMldev(this.apiClient, params);
      path2 = formatMap("{models_url}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = listModelsResponseFromMldev(apiResponse);
        const typedResp = new ListModelsResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  /**
   * Updates a tuned model by its name.
   *
   * @param params - The parameters for updating the model.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response = await ai.models.update({
   *   model: 'tuned-model-name',
   *   config: {
   *     displayName: 'New display name',
   *     description: 'New description',
   *   },
   * });
   * ```
   */
  async update(params) {
    var _a3, _b, _c, _d;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = updateModelParametersToVertex(this.apiClient, params);
      path2 = formatMap("{model}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "PATCH",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = modelFromVertex(apiResponse);
        return resp;
      });
    } else {
      const body = updateModelParametersToMldev(this.apiClient, params);
      path2 = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "PATCH",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = modelFromMldev(apiResponse);
        return resp;
      });
    }
  }
  /**
   * Deletes a tuned model by its name.
   *
   * @param params - The parameters for deleting the model.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response = await ai.models.delete({model: 'tuned-model-name'});
   * ```
   */
  async delete(params) {
    var _a3, _b, _c, _d;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = deleteModelParametersToVertex(this.apiClient, params);
      path2 = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "DELETE",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then(() => {
        const resp = deleteModelResponseFromVertex();
        const typedResp = new DeleteModelResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = deleteModelParametersToMldev(this.apiClient, params);
      path2 = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "DELETE",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then(() => {
        const resp = deleteModelResponseFromMldev();
        const typedResp = new DeleteModelResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  /**
   * Counts the number of tokens in the given contents. Multimodal input is
   * supported for Gemini models.
   *
   * @param params - The parameters for counting tokens.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response = await ai.models.countTokens({
   *  model: 'gemini-2.0-flash',
   *  contents: 'The quick brown fox jumps over the lazy dog.'
   * });
   * console.log(response);
   * ```
   */
  async countTokens(params) {
    var _a3, _b, _c, _d;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = countTokensParametersToVertex(this.apiClient, params);
      path2 = formatMap("{model}:countTokens", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = countTokensResponseFromVertex(apiResponse);
        const typedResp = new CountTokensResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = countTokensParametersToMldev(this.apiClient, params);
      path2 = formatMap("{model}:countTokens", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = countTokensResponseFromMldev(apiResponse);
        const typedResp = new CountTokensResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  /**
   * Given a list of contents, returns a corresponding TokensInfo containing
   * the list of tokens and list of token ids.
   *
   * This method is not supported by the Gemini Developer API.
   *
   * @param params - The parameters for computing tokens.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response = await ai.models.computeTokens({
   *  model: 'gemini-2.0-flash',
   *  contents: 'What is your name?'
   * });
   * console.log(response);
   * ```
   */
  async computeTokens(params) {
    var _a3, _b;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = computeTokensParametersToVertex(this.apiClient, params);
      path2 = formatMap("{model}:computeTokens", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = computeTokensResponseFromVertex(apiResponse);
        const typedResp = new ComputeTokensResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      throw new Error("This method is only supported by the Vertex AI.");
    }
  }
  /**
   *  Generates videos based on a text description and configuration.
   *
   * @param params - The parameters for generating videos.
   * @return A Promise<GenerateVideosOperation> which allows you to track the progress and eventually retrieve the generated videos using the operations.get method.
   *
   * @example
   * ```ts
   * const operation = await ai.models.generateVideos({
   *  model: 'veo-2.0-generate-001',
   *  prompt: 'A neon hologram of a cat driving at top speed',
   *  config: {
   *    numberOfVideos: 1
   * });
   *
   * while (!operation.done) {
   *   await new Promise(resolve => setTimeout(resolve, 10000));
   *   operation = await ai.operations.getVideosOperation({operation: operation});
   * }
   *
   * console.log(operation.response?.generatedVideos?.[0]?.video?.uri);
   * ```
   */
  async generateVideosInternal(params) {
    var _a3, _b, _c, _d;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = generateVideosParametersToVertex(this.apiClient, params);
      path2 = formatMap("{model}:predictLongRunning", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = generateVideosOperationFromVertex(apiResponse);
        const typedResp = new GenerateVideosOperation();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = generateVideosParametersToMldev(this.apiClient, params);
      path2 = formatMap("{model}:predictLongRunning", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = generateVideosOperationFromMldev(apiResponse);
        const typedResp = new GenerateVideosOperation();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
};
function getOperationParametersToMldev(fromObject) {
  const toObject = {};
  const fromOperationName = getValueByPath(fromObject, [
    "operationName"
  ]);
  if (fromOperationName != null) {
    setValueByPath(toObject, ["_url", "operationName"], fromOperationName);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function getOperationParametersToVertex(fromObject) {
  const toObject = {};
  const fromOperationName = getValueByPath(fromObject, [
    "operationName"
  ]);
  if (fromOperationName != null) {
    setValueByPath(toObject, ["_url", "operationName"], fromOperationName);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function fetchPredictOperationParametersToVertex(fromObject) {
  const toObject = {};
  const fromOperationName = getValueByPath(fromObject, [
    "operationName"
  ]);
  if (fromOperationName != null) {
    setValueByPath(toObject, ["operationName"], fromOperationName);
  }
  const fromResourceName = getValueByPath(fromObject, ["resourceName"]);
  if (fromResourceName != null) {
    setValueByPath(toObject, ["_url", "resourceName"], fromResourceName);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
var Operations = class extends BaseModule {
  constructor(apiClient) {
    super();
    this.apiClient = apiClient;
  }
  /**
   * Gets the status of a long-running operation.
   *
   * @param parameters The parameters for the get operation request.
   * @return The updated Operation object, with the latest status or result.
   */
  async getVideosOperation(parameters) {
    const operation = parameters.operation;
    const config = parameters.config;
    if (operation.name === void 0 || operation.name === "") {
      throw new Error("Operation name is required.");
    }
    if (this.apiClient.isVertexAI()) {
      const resourceName2 = operation.name.split("/operations/")[0];
      let httpOptions = void 0;
      if (config && "httpOptions" in config) {
        httpOptions = config.httpOptions;
      }
      const rawOperation = await this.fetchPredictVideosOperationInternal({
        operationName: operation.name,
        resourceName: resourceName2,
        config: { httpOptions }
      });
      return operation._fromAPIResponse({
        apiResponse: rawOperation,
        isVertexAI: true
      });
    } else {
      const rawOperation = await this.getVideosOperationInternal({
        operationName: operation.name,
        config
      });
      return operation._fromAPIResponse({
        apiResponse: rawOperation,
        isVertexAI: false
      });
    }
  }
  /**
   * Gets the status of a long-running operation.
   *
   * @param parameters The parameters for the get operation request.
   * @return The updated Operation object, with the latest status or result.
   */
  async get(parameters) {
    const operation = parameters.operation;
    const config = parameters.config;
    if (operation.name === void 0 || operation.name === "") {
      throw new Error("Operation name is required.");
    }
    if (this.apiClient.isVertexAI()) {
      const resourceName2 = operation.name.split("/operations/")[0];
      let httpOptions = void 0;
      if (config && "httpOptions" in config) {
        httpOptions = config.httpOptions;
      }
      const rawOperation = await this.fetchPredictVideosOperationInternal({
        operationName: operation.name,
        resourceName: resourceName2,
        config: { httpOptions }
      });
      return operation._fromAPIResponse({
        apiResponse: rawOperation,
        isVertexAI: true
      });
    } else {
      const rawOperation = await this.getVideosOperationInternal({
        operationName: operation.name,
        config
      });
      return operation._fromAPIResponse({
        apiResponse: rawOperation,
        isVertexAI: false
      });
    }
  }
  async getVideosOperationInternal(params) {
    var _a3, _b, _c, _d;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = getOperationParametersToVertex(params);
      path2 = formatMap("{operationName}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response;
    } else {
      const body = getOperationParametersToMldev(params);
      path2 = formatMap("{operationName}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response;
    }
  }
  async fetchPredictVideosOperationInternal(params) {
    var _a3, _b;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = fetchPredictOperationParametersToVertex(params);
      path2 = formatMap("{resourceName}:fetchPredictOperation", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response;
    } else {
      throw new Error("This method is only supported by the Vertex AI.");
    }
  }
};
function prebuiltVoiceConfigToMldev(fromObject) {
  const toObject = {};
  const fromVoiceName = getValueByPath(fromObject, ["voiceName"]);
  if (fromVoiceName != null) {
    setValueByPath(toObject, ["voiceName"], fromVoiceName);
  }
  return toObject;
}
function voiceConfigToMldev(fromObject) {
  const toObject = {};
  const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [
    "prebuiltVoiceConfig"
  ]);
  if (fromPrebuiltVoiceConfig != null) {
    setValueByPath(toObject, ["prebuiltVoiceConfig"], prebuiltVoiceConfigToMldev(fromPrebuiltVoiceConfig));
  }
  return toObject;
}
function speakerVoiceConfigToMldev(fromObject) {
  const toObject = {};
  const fromSpeaker = getValueByPath(fromObject, ["speaker"]);
  if (fromSpeaker != null) {
    setValueByPath(toObject, ["speaker"], fromSpeaker);
  }
  const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
  if (fromVoiceConfig != null) {
    setValueByPath(toObject, ["voiceConfig"], voiceConfigToMldev(fromVoiceConfig));
  }
  return toObject;
}
function multiSpeakerVoiceConfigToMldev(fromObject) {
  const toObject = {};
  const fromSpeakerVoiceConfigs = getValueByPath(fromObject, [
    "speakerVoiceConfigs"
  ]);
  if (fromSpeakerVoiceConfigs != null) {
    let transformedList = fromSpeakerVoiceConfigs;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return speakerVoiceConfigToMldev(item);
      });
    }
    setValueByPath(toObject, ["speakerVoiceConfigs"], transformedList);
  }
  return toObject;
}
function speechConfigToMldev(fromObject) {
  const toObject = {};
  const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
  if (fromVoiceConfig != null) {
    setValueByPath(toObject, ["voiceConfig"], voiceConfigToMldev(fromVoiceConfig));
  }
  const fromMultiSpeakerVoiceConfig = getValueByPath(fromObject, [
    "multiSpeakerVoiceConfig"
  ]);
  if (fromMultiSpeakerVoiceConfig != null) {
    setValueByPath(toObject, ["multiSpeakerVoiceConfig"], multiSpeakerVoiceConfigToMldev(fromMultiSpeakerVoiceConfig));
  }
  const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
  if (fromLanguageCode != null) {
    setValueByPath(toObject, ["languageCode"], fromLanguageCode);
  }
  return toObject;
}
function videoMetadataToMldev(fromObject) {
  const toObject = {};
  const fromFps = getValueByPath(fromObject, ["fps"]);
  if (fromFps != null) {
    setValueByPath(toObject, ["fps"], fromFps);
  }
  const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
  if (fromEndOffset != null) {
    setValueByPath(toObject, ["endOffset"], fromEndOffset);
  }
  const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
  if (fromStartOffset != null) {
    setValueByPath(toObject, ["startOffset"], fromStartOffset);
  }
  return toObject;
}
function blobToMldev(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function fileDataToMldev(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function partToMldev(fromObject) {
  const toObject = {};
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], videoMetadataToMldev(fromVideoMetadata));
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobToMldev(fromInlineData));
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataToMldev(fromFileData));
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], fromFunctionCall);
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  return toObject;
}
function contentToMldev(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partToMldev(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function functionDeclarationToMldev(fromObject) {
  const toObject = {};
  const fromBehavior = getValueByPath(fromObject, ["behavior"]);
  if (fromBehavior != null) {
    setValueByPath(toObject, ["behavior"], fromBehavior);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromParameters = getValueByPath(fromObject, ["parameters"]);
  if (fromParameters != null) {
    setValueByPath(toObject, ["parameters"], fromParameters);
  }
  const fromParametersJsonSchema = getValueByPath(fromObject, [
    "parametersJsonSchema"
  ]);
  if (fromParametersJsonSchema != null) {
    setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], fromResponse);
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  return toObject;
}
function intervalToMldev(fromObject) {
  const toObject = {};
  const fromStartTime = getValueByPath(fromObject, ["startTime"]);
  if (fromStartTime != null) {
    setValueByPath(toObject, ["startTime"], fromStartTime);
  }
  const fromEndTime = getValueByPath(fromObject, ["endTime"]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  return toObject;
}
function googleSearchToMldev(fromObject) {
  const toObject = {};
  const fromTimeRangeFilter = getValueByPath(fromObject, [
    "timeRangeFilter"
  ]);
  if (fromTimeRangeFilter != null) {
    setValueByPath(toObject, ["timeRangeFilter"], intervalToMldev(fromTimeRangeFilter));
  }
  return toObject;
}
function dynamicRetrievalConfigToMldev(fromObject) {
  const toObject = {};
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  const fromDynamicThreshold = getValueByPath(fromObject, [
    "dynamicThreshold"
  ]);
  if (fromDynamicThreshold != null) {
    setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
  }
  return toObject;
}
function googleSearchRetrievalToMldev(fromObject) {
  const toObject = {};
  const fromDynamicRetrievalConfig = getValueByPath(fromObject, [
    "dynamicRetrievalConfig"
  ]);
  if (fromDynamicRetrievalConfig != null) {
    setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToMldev(fromDynamicRetrievalConfig));
  }
  return toObject;
}
function urlContextToMldev() {
  const toObject = {};
  return toObject;
}
function toolToMldev(fromObject) {
  const toObject = {};
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return functionDeclarationToMldev(item);
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
    throw new Error("retrieval parameter is not supported in Gemini API.");
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], googleSearchToMldev(fromGoogleSearch));
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToMldev(fromGoogleSearchRetrieval));
  }
  if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
    throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["googleMaps"]) !== void 0) {
    throw new Error("googleMaps parameter is not supported in Gemini API.");
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], urlContextToMldev());
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  return toObject;
}
function sessionResumptionConfigToMldev(fromObject) {
  const toObject = {};
  const fromHandle = getValueByPath(fromObject, ["handle"]);
  if (fromHandle != null) {
    setValueByPath(toObject, ["handle"], fromHandle);
  }
  if (getValueByPath(fromObject, ["transparent"]) !== void 0) {
    throw new Error("transparent parameter is not supported in Gemini API.");
  }
  return toObject;
}
function audioTranscriptionConfigToMldev() {
  const toObject = {};
  return toObject;
}
function automaticActivityDetectionToMldev(fromObject) {
  const toObject = {};
  const fromDisabled = getValueByPath(fromObject, ["disabled"]);
  if (fromDisabled != null) {
    setValueByPath(toObject, ["disabled"], fromDisabled);
  }
  const fromStartOfSpeechSensitivity = getValueByPath(fromObject, [
    "startOfSpeechSensitivity"
  ]);
  if (fromStartOfSpeechSensitivity != null) {
    setValueByPath(toObject, ["startOfSpeechSensitivity"], fromStartOfSpeechSensitivity);
  }
  const fromEndOfSpeechSensitivity = getValueByPath(fromObject, [
    "endOfSpeechSensitivity"
  ]);
  if (fromEndOfSpeechSensitivity != null) {
    setValueByPath(toObject, ["endOfSpeechSensitivity"], fromEndOfSpeechSensitivity);
  }
  const fromPrefixPaddingMs = getValueByPath(fromObject, [
    "prefixPaddingMs"
  ]);
  if (fromPrefixPaddingMs != null) {
    setValueByPath(toObject, ["prefixPaddingMs"], fromPrefixPaddingMs);
  }
  const fromSilenceDurationMs = getValueByPath(fromObject, [
    "silenceDurationMs"
  ]);
  if (fromSilenceDurationMs != null) {
    setValueByPath(toObject, ["silenceDurationMs"], fromSilenceDurationMs);
  }
  return toObject;
}
function realtimeInputConfigToMldev(fromObject) {
  const toObject = {};
  const fromAutomaticActivityDetection = getValueByPath(fromObject, [
    "automaticActivityDetection"
  ]);
  if (fromAutomaticActivityDetection != null) {
    setValueByPath(toObject, ["automaticActivityDetection"], automaticActivityDetectionToMldev(fromAutomaticActivityDetection));
  }
  const fromActivityHandling = getValueByPath(fromObject, [
    "activityHandling"
  ]);
  if (fromActivityHandling != null) {
    setValueByPath(toObject, ["activityHandling"], fromActivityHandling);
  }
  const fromTurnCoverage = getValueByPath(fromObject, ["turnCoverage"]);
  if (fromTurnCoverage != null) {
    setValueByPath(toObject, ["turnCoverage"], fromTurnCoverage);
  }
  return toObject;
}
function slidingWindowToMldev(fromObject) {
  const toObject = {};
  const fromTargetTokens = getValueByPath(fromObject, ["targetTokens"]);
  if (fromTargetTokens != null) {
    setValueByPath(toObject, ["targetTokens"], fromTargetTokens);
  }
  return toObject;
}
function contextWindowCompressionConfigToMldev(fromObject) {
  const toObject = {};
  const fromTriggerTokens = getValueByPath(fromObject, [
    "triggerTokens"
  ]);
  if (fromTriggerTokens != null) {
    setValueByPath(toObject, ["triggerTokens"], fromTriggerTokens);
  }
  const fromSlidingWindow = getValueByPath(fromObject, [
    "slidingWindow"
  ]);
  if (fromSlidingWindow != null) {
    setValueByPath(toObject, ["slidingWindow"], slidingWindowToMldev(fromSlidingWindow));
  }
  return toObject;
}
function proactivityConfigToMldev(fromObject) {
  const toObject = {};
  const fromProactiveAudio = getValueByPath(fromObject, [
    "proactiveAudio"
  ]);
  if (fromProactiveAudio != null) {
    setValueByPath(toObject, ["proactiveAudio"], fromProactiveAudio);
  }
  return toObject;
}
function liveConnectConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromGenerationConfig = getValueByPath(fromObject, [
    "generationConfig"
  ]);
  if (parentObject !== void 0 && fromGenerationConfig != null) {
    setValueByPath(parentObject, ["setup", "generationConfig"], fromGenerationConfig);
  }
  const fromResponseModalities = getValueByPath(fromObject, [
    "responseModalities"
  ]);
  if (parentObject !== void 0 && fromResponseModalities != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "responseModalities"], fromResponseModalities);
  }
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (parentObject !== void 0 && fromTemperature != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "temperature"], fromTemperature);
  }
  const fromTopP = getValueByPath(fromObject, ["topP"]);
  if (parentObject !== void 0 && fromTopP != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "topP"], fromTopP);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (parentObject !== void 0 && fromTopK != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "topK"], fromTopK);
  }
  const fromMaxOutputTokens = getValueByPath(fromObject, [
    "maxOutputTokens"
  ]);
  if (parentObject !== void 0 && fromMaxOutputTokens != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "maxOutputTokens"], fromMaxOutputTokens);
  }
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (parentObject !== void 0 && fromMediaResolution != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "mediaResolution"], fromMediaResolution);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (parentObject !== void 0 && fromSeed != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "seed"], fromSeed);
  }
  const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
  if (parentObject !== void 0 && fromSpeechConfig != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "speechConfig"], speechConfigToMldev(tLiveSpeechConfig(fromSpeechConfig)));
  }
  const fromEnableAffectiveDialog = getValueByPath(fromObject, [
    "enableAffectiveDialog"
  ]);
  if (parentObject !== void 0 && fromEnableAffectiveDialog != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "enableAffectiveDialog"], fromEnableAffectiveDialog);
  }
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== void 0 && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["setup", "systemInstruction"], contentToMldev(tContent(fromSystemInstruction)));
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== void 0 && fromTools != null) {
    let transformedList = tTools(fromTools);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToMldev(tTool(item));
      });
    }
    setValueByPath(parentObject, ["setup", "tools"], transformedList);
  }
  const fromSessionResumption = getValueByPath(fromObject, [
    "sessionResumption"
  ]);
  if (parentObject !== void 0 && fromSessionResumption != null) {
    setValueByPath(parentObject, ["setup", "sessionResumption"], sessionResumptionConfigToMldev(fromSessionResumption));
  }
  const fromInputAudioTranscription = getValueByPath(fromObject, [
    "inputAudioTranscription"
  ]);
  if (parentObject !== void 0 && fromInputAudioTranscription != null) {
    setValueByPath(parentObject, ["setup", "inputAudioTranscription"], audioTranscriptionConfigToMldev());
  }
  const fromOutputAudioTranscription = getValueByPath(fromObject, [
    "outputAudioTranscription"
  ]);
  if (parentObject !== void 0 && fromOutputAudioTranscription != null) {
    setValueByPath(parentObject, ["setup", "outputAudioTranscription"], audioTranscriptionConfigToMldev());
  }
  const fromRealtimeInputConfig = getValueByPath(fromObject, [
    "realtimeInputConfig"
  ]);
  if (parentObject !== void 0 && fromRealtimeInputConfig != null) {
    setValueByPath(parentObject, ["setup", "realtimeInputConfig"], realtimeInputConfigToMldev(fromRealtimeInputConfig));
  }
  const fromContextWindowCompression = getValueByPath(fromObject, [
    "contextWindowCompression"
  ]);
  if (parentObject !== void 0 && fromContextWindowCompression != null) {
    setValueByPath(parentObject, ["setup", "contextWindowCompression"], contextWindowCompressionConfigToMldev(fromContextWindowCompression));
  }
  const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
  if (parentObject !== void 0 && fromProactivity != null) {
    setValueByPath(parentObject, ["setup", "proactivity"], proactivityConfigToMldev(fromProactivity));
  }
  return toObject;
}
function liveConnectConstraintsToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], liveConnectConfigToMldev(fromConfig, toObject));
  }
  return toObject;
}
function createAuthTokenConfigToMldev(apiClient, fromObject, parentObject) {
  const toObject = {};
  const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
  if (parentObject !== void 0 && fromExpireTime != null) {
    setValueByPath(parentObject, ["expireTime"], fromExpireTime);
  }
  const fromNewSessionExpireTime = getValueByPath(fromObject, [
    "newSessionExpireTime"
  ]);
  if (parentObject !== void 0 && fromNewSessionExpireTime != null) {
    setValueByPath(parentObject, ["newSessionExpireTime"], fromNewSessionExpireTime);
  }
  const fromUses = getValueByPath(fromObject, ["uses"]);
  if (parentObject !== void 0 && fromUses != null) {
    setValueByPath(parentObject, ["uses"], fromUses);
  }
  const fromLiveConnectConstraints = getValueByPath(fromObject, [
    "liveConnectConstraints"
  ]);
  if (parentObject !== void 0 && fromLiveConnectConstraints != null) {
    setValueByPath(parentObject, ["bidiGenerateContentSetup"], liveConnectConstraintsToMldev(apiClient, fromLiveConnectConstraints));
  }
  const fromLockAdditionalFields = getValueByPath(fromObject, [
    "lockAdditionalFields"
  ]);
  if (parentObject !== void 0 && fromLockAdditionalFields != null) {
    setValueByPath(parentObject, ["fieldMask"], fromLockAdditionalFields);
  }
  return toObject;
}
function createAuthTokenParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], createAuthTokenConfigToMldev(apiClient, fromConfig, toObject));
  }
  return toObject;
}
function authTokenFromMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  return toObject;
}
function getFieldMasks(setup) {
  const fields = [];
  for (const key in setup) {
    if (Object.prototype.hasOwnProperty.call(setup, key)) {
      const value = setup[key];
      if (typeof value === "object" && value != null && Object.keys(value).length > 0) {
        const field = Object.keys(value).map((kk) => `${key}.${kk}`);
        fields.push(...field);
      } else {
        fields.push(key);
      }
    }
  }
  return fields.join(",");
}
function convertBidiSetupToTokenSetup(requestDict, config) {
  let setupForMaskGeneration = null;
  const bidiGenerateContentSetupValue = requestDict["bidiGenerateContentSetup"];
  if (typeof bidiGenerateContentSetupValue === "object" && bidiGenerateContentSetupValue !== null && "setup" in bidiGenerateContentSetupValue) {
    const innerSetup = bidiGenerateContentSetupValue.setup;
    if (typeof innerSetup === "object" && innerSetup !== null) {
      requestDict["bidiGenerateContentSetup"] = innerSetup;
      setupForMaskGeneration = innerSetup;
    } else {
      delete requestDict["bidiGenerateContentSetup"];
    }
  } else if (bidiGenerateContentSetupValue !== void 0) {
    delete requestDict["bidiGenerateContentSetup"];
  }
  const preExistingFieldMask = requestDict["fieldMask"];
  if (setupForMaskGeneration) {
    const generatedMaskFromBidi = getFieldMasks(setupForMaskGeneration);
    if (Array.isArray(config === null || config === void 0 ? void 0 : config.lockAdditionalFields) && (config === null || config === void 0 ? void 0 : config.lockAdditionalFields.length) === 0) {
      if (generatedMaskFromBidi) {
        requestDict["fieldMask"] = generatedMaskFromBidi;
      } else {
        delete requestDict["fieldMask"];
      }
    } else if ((config === null || config === void 0 ? void 0 : config.lockAdditionalFields) && config.lockAdditionalFields.length > 0 && preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {
      const generationConfigFields = [
        "temperature",
        "topK",
        "topP",
        "maxOutputTokens",
        "responseModalities",
        "seed",
        "speechConfig"
      ];
      let mappedFieldsFromPreExisting = [];
      if (preExistingFieldMask.length > 0) {
        mappedFieldsFromPreExisting = preExistingFieldMask.map((field) => {
          if (generationConfigFields.includes(field)) {
            return `generationConfig.${field}`;
          }
          return field;
        });
      }
      const finalMaskParts = [];
      if (generatedMaskFromBidi) {
        finalMaskParts.push(generatedMaskFromBidi);
      }
      if (mappedFieldsFromPreExisting.length > 0) {
        finalMaskParts.push(...mappedFieldsFromPreExisting);
      }
      if (finalMaskParts.length > 0) {
        requestDict["fieldMask"] = finalMaskParts.join(",");
      } else {
        delete requestDict["fieldMask"];
      }
    } else {
      delete requestDict["fieldMask"];
    }
  } else {
    if (preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {
      requestDict["fieldMask"] = preExistingFieldMask.join(",");
    } else {
      delete requestDict["fieldMask"];
    }
  }
  return requestDict;
}
var Tokens = class extends BaseModule {
  constructor(apiClient) {
    super();
    this.apiClient = apiClient;
  }
  /**
   * Creates an ephemeral auth token resource.
   *
   * @experimental
   *
   * @remarks
   * Ephemeral auth tokens is only supported in the Gemini Developer API.
   * It can be used for the session connection to the Live constrained API.
   * Support in v1alpha only.
   *
   * @param params - The parameters for the create request.
   * @return The created auth token.
   *
   * @example
   * ```ts
   * const ai = new GoogleGenAI({
   *     apiKey: token.name,
   *     httpOptions: { apiVersion: 'v1alpha' }  // Support in v1alpha only.
   * });
   *
   * // Case 1: If LiveEphemeralParameters is unset, unlock LiveConnectConfig
   * // when using the token in Live API sessions. Each session connection can
   * // use a different configuration.
   * const config: CreateAuthTokenConfig = {
   *     uses: 3,
   *     expireTime: '2025-05-01T00:00:00Z',
   * }
   * const token = await ai.tokens.create(config);
   *
   * // Case 2: If LiveEphemeralParameters is set, lock all fields in
   * // LiveConnectConfig when using the token in Live API sessions. For
   * // example, changing `outputAudioTranscription` in the Live API
   * // connection will be ignored by the API.
   * const config: CreateAuthTokenConfig =
   *     uses: 3,
   *     expireTime: '2025-05-01T00:00:00Z',
   *     LiveEphemeralParameters: {
   *        model: 'gemini-2.0-flash-001',
   *        config: {
   *           'responseModalities': ['AUDIO'],
   *           'systemInstruction': 'Always answer in English.',
   *        }
   *     }
   * }
   * const token = await ai.tokens.create(config);
   *
   * // Case 3: If LiveEphemeralParameters is set and lockAdditionalFields is
   * // set, lock LiveConnectConfig with set and additional fields (e.g.
   * // responseModalities, systemInstruction, temperature in this example) when
   * // using the token in Live API sessions.
   * const config: CreateAuthTokenConfig =
   *     uses: 3,
   *     expireTime: '2025-05-01T00:00:00Z',
   *     LiveEphemeralParameters: {
   *        model: 'gemini-2.0-flash-001',
   *        config: {
   *           'responseModalities': ['AUDIO'],
   *           'systemInstruction': 'Always answer in English.',
   *        }
   *     },
   *     lockAdditionalFields: ['temperature'],
   * }
   * const token = await ai.tokens.create(config);
   *
   * // Case 4: If LiveEphemeralParameters is set and lockAdditionalFields is
   * // empty array, lock LiveConnectConfig with set fields (e.g.
   * // responseModalities, systemInstruction in this example) when using the
   * // token in Live API sessions.
   * const config: CreateAuthTokenConfig =
   *     uses: 3,
   *     expireTime: '2025-05-01T00:00:00Z',
   *     LiveEphemeralParameters: {
   *        model: 'gemini-2.0-flash-001',
   *        config: {
   *           'responseModalities': ['AUDIO'],
   *           'systemInstruction': 'Always answer in English.',
   *        }
   *     },
   *     lockAdditionalFields: [],
   * }
   * const token = await ai.tokens.create(config);
   * ```
   */
  async create(params) {
    var _a3, _b;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error("The client.tokens.create method is only supported by the Gemini Developer API.");
    } else {
      const body = createAuthTokenParametersToMldev(this.apiClient, params);
      path2 = formatMap("auth_tokens", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      const transformedBody = convertBidiSetupToTokenSetup(body, params.config);
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(transformedBody),
        httpMethod: "POST",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = authTokenFromMldev(apiResponse);
        return resp;
      });
    }
  }
};
var GOOGLE_API_KEY_HEADER = "x-goog-api-key";
var REQUIRED_VERTEX_AI_SCOPE = "https://www.googleapis.com/auth/cloud-platform";
var NodeAuth = class {
  constructor(opts) {
    if (opts.apiKey !== void 0) {
      this.apiKey = opts.apiKey;
      return;
    }
    const vertexAuthOptions = buildGoogleAuthOptions(opts.googleAuthOptions);
    this.googleAuth = new import_google_auth_library.GoogleAuth(vertexAuthOptions);
  }
  async addAuthHeaders(headers) {
    if (this.apiKey !== void 0) {
      if (this.apiKey.startsWith("auth_tokens/")) {
        throw new Error("Ephemeral tokens are only supported by the live API.");
      }
      this.addKeyHeader(headers);
      return;
    }
    return this.addGoogleAuthHeaders(headers);
  }
  addKeyHeader(headers) {
    if (headers.get(GOOGLE_API_KEY_HEADER) !== null) {
      return;
    }
    if (this.apiKey === void 0) {
      throw new Error("Trying to set API key header but apiKey is not set");
    }
    headers.append(GOOGLE_API_KEY_HEADER, this.apiKey);
  }
  async addGoogleAuthHeaders(headers) {
    if (this.googleAuth === void 0) {
      throw new Error("Trying to set google-auth headers but googleAuth is unset");
    }
    const authHeaders = await this.googleAuth.getRequestHeaders();
    for (const key in authHeaders) {
      if (headers.get(key) !== null) {
        continue;
      }
      headers.append(key, authHeaders[key]);
    }
  }
};
function buildGoogleAuthOptions(googleAuthOptions) {
  let authOptions;
  if (!googleAuthOptions) {
    authOptions = {
      scopes: [REQUIRED_VERTEX_AI_SCOPE]
    };
    return authOptions;
  } else {
    authOptions = googleAuthOptions;
    if (!authOptions.scopes) {
      authOptions.scopes = [REQUIRED_VERTEX_AI_SCOPE];
      return authOptions;
    } else if (typeof authOptions.scopes === "string" && authOptions.scopes !== REQUIRED_VERTEX_AI_SCOPE || Array.isArray(authOptions.scopes) && authOptions.scopes.indexOf(REQUIRED_VERTEX_AI_SCOPE) < 0) {
      throw new Error(`Invalid auth scopes. Scopes must include: ${REQUIRED_VERTEX_AI_SCOPE}`);
    }
    return authOptions;
  }
}
var NodeDownloader = class {
  async download(params, apiClient) {
    if (params.downloadPath) {
      const response = await downloadFile(params, apiClient);
      if (response instanceof HttpResponse) {
        const writer = createWriteStream(params.downloadPath);
        Readable3.fromWeb(response.responseInternal.body).pipe(writer);
      } else {
        writeFile(params.downloadPath, response, { encoding: "base64" }, (error) => {
          if (error) {
            throw new Error(`Failed to write file to ${params.downloadPath}: ${error}`);
          }
        });
      }
    }
  }
};
async function downloadFile(params, apiClient) {
  var _a3, _b, _c;
  const name = tFileName(params.file);
  if (name !== void 0) {
    return await apiClient.request({
      path: `files/${name}:download`,
      httpMethod: "GET",
      queryParams: {
        "alt": "media"
      },
      httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
      abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
    });
  } else if (isGeneratedVideo(params.file)) {
    const videoBytes = (_c = params.file.video) === null || _c === void 0 ? void 0 : _c.videoBytes;
    if (typeof videoBytes === "string") {
      return videoBytes;
    } else {
      throw new Error("Failed to download generated video, Uri or videoBytes not found.");
    }
  } else if (isVideo(params.file)) {
    const videoBytes = params.file.videoBytes;
    if (typeof videoBytes === "string") {
      return videoBytes;
    } else {
      throw new Error("Failed to download video, Uri or videoBytes not found.");
    }
  } else {
    throw new Error("Unsupported file type");
  }
}
var NodeWebSocketFactory = class {
  create(url, headers, callbacks) {
    return new NodeWebSocket(url, headers, callbacks);
  }
};
var NodeWebSocket = class {
  constructor(url, headers, callbacks) {
    this.url = url;
    this.headers = headers;
    this.callbacks = callbacks;
  }
  connect() {
    this.ws = new import_websocket.default(this.url, { headers: this.headers });
    this.ws.onopen = this.callbacks.onopen;
    this.ws.onerror = this.callbacks.onerror;
    this.ws.onclose = this.callbacks.onclose;
    this.ws.onmessage = this.callbacks.onmessage;
  }
  send(message) {
    if (this.ws === void 0) {
      throw new Error("WebSocket is not connected");
    }
    this.ws.send(message);
  }
  close() {
    if (this.ws === void 0) {
      throw new Error("WebSocket is not connected");
    }
    this.ws.close();
  }
};
function getTuningJobParametersToMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], fromName);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function listTuningJobsConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  const fromFilter = getValueByPath(fromObject, ["filter"]);
  if (parentObject !== void 0 && fromFilter != null) {
    setValueByPath(parentObject, ["_query", "filter"], fromFilter);
  }
  return toObject;
}
function listTuningJobsParametersToMldev(fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], listTuningJobsConfigToMldev(fromConfig, toObject));
  }
  return toObject;
}
function tuningExampleToMldev(fromObject) {
  const toObject = {};
  const fromTextInput = getValueByPath(fromObject, ["textInput"]);
  if (fromTextInput != null) {
    setValueByPath(toObject, ["textInput"], fromTextInput);
  }
  const fromOutput = getValueByPath(fromObject, ["output"]);
  if (fromOutput != null) {
    setValueByPath(toObject, ["output"], fromOutput);
  }
  return toObject;
}
function tuningDatasetToMldev(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["gcsUri"]) !== void 0) {
    throw new Error("gcsUri parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["vertexDatasetResource"]) !== void 0) {
    throw new Error("vertexDatasetResource parameter is not supported in Gemini API.");
  }
  const fromExamples = getValueByPath(fromObject, ["examples"]);
  if (fromExamples != null) {
    let transformedList = fromExamples;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return tuningExampleToMldev(item);
      });
    }
    setValueByPath(toObject, ["examples", "examples"], transformedList);
  }
  return toObject;
}
function createTuningJobConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["validationDataset"]) !== void 0) {
    throw new Error("validationDataset parameter is not supported in Gemini API.");
  }
  const fromTunedModelDisplayName = getValueByPath(fromObject, [
    "tunedModelDisplayName"
  ]);
  if (parentObject !== void 0 && fromTunedModelDisplayName != null) {
    setValueByPath(parentObject, ["displayName"], fromTunedModelDisplayName);
  }
  if (getValueByPath(fromObject, ["description"]) !== void 0) {
    throw new Error("description parameter is not supported in Gemini API.");
  }
  const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
  if (parentObject !== void 0 && fromEpochCount != null) {
    setValueByPath(parentObject, ["tuningTask", "hyperparameters", "epochCount"], fromEpochCount);
  }
  const fromLearningRateMultiplier = getValueByPath(fromObject, [
    "learningRateMultiplier"
  ]);
  if (fromLearningRateMultiplier != null) {
    setValueByPath(toObject, ["tuningTask", "hyperparameters", "learningRateMultiplier"], fromLearningRateMultiplier);
  }
  if (getValueByPath(fromObject, ["exportLastCheckpointOnly"]) !== void 0) {
    throw new Error("exportLastCheckpointOnly parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["adapterSize"]) !== void 0) {
    throw new Error("adapterSize parameter is not supported in Gemini API.");
  }
  const fromBatchSize = getValueByPath(fromObject, ["batchSize"]);
  if (parentObject !== void 0 && fromBatchSize != null) {
    setValueByPath(parentObject, ["tuningTask", "hyperparameters", "batchSize"], fromBatchSize);
  }
  const fromLearningRate = getValueByPath(fromObject, ["learningRate"]);
  if (parentObject !== void 0 && fromLearningRate != null) {
    setValueByPath(parentObject, ["tuningTask", "hyperparameters", "learningRate"], fromLearningRate);
  }
  return toObject;
}
function createTuningJobParametersToMldev(fromObject) {
  const toObject = {};
  const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
  if (fromBaseModel != null) {
    setValueByPath(toObject, ["baseModel"], fromBaseModel);
  }
  const fromTrainingDataset = getValueByPath(fromObject, [
    "trainingDataset"
  ]);
  if (fromTrainingDataset != null) {
    setValueByPath(toObject, ["tuningTask", "trainingData"], tuningDatasetToMldev(fromTrainingDataset));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], createTuningJobConfigToMldev(fromConfig, toObject));
  }
  return toObject;
}
function getTuningJobParametersToVertex(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], fromName);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function listTuningJobsConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  const fromFilter = getValueByPath(fromObject, ["filter"]);
  if (parentObject !== void 0 && fromFilter != null) {
    setValueByPath(parentObject, ["_query", "filter"], fromFilter);
  }
  return toObject;
}
function listTuningJobsParametersToVertex(fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], listTuningJobsConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function tuningDatasetToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
  if (parentObject !== void 0 && fromGcsUri != null) {
    setValueByPath(parentObject, ["supervisedTuningSpec", "trainingDatasetUri"], fromGcsUri);
  }
  const fromVertexDatasetResource = getValueByPath(fromObject, [
    "vertexDatasetResource"
  ]);
  if (parentObject !== void 0 && fromVertexDatasetResource != null) {
    setValueByPath(parentObject, ["supervisedTuningSpec", "trainingDatasetUri"], fromVertexDatasetResource);
  }
  if (getValueByPath(fromObject, ["examples"]) !== void 0) {
    throw new Error("examples parameter is not supported in Vertex AI.");
  }
  return toObject;
}
function tuningValidationDatasetToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
  if (fromGcsUri != null) {
    setValueByPath(toObject, ["validationDatasetUri"], fromGcsUri);
  }
  const fromVertexDatasetResource = getValueByPath(fromObject, [
    "vertexDatasetResource"
  ]);
  if (parentObject !== void 0 && fromVertexDatasetResource != null) {
    setValueByPath(parentObject, ["supervisedTuningSpec", "trainingDatasetUri"], fromVertexDatasetResource);
  }
  return toObject;
}
function createTuningJobConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromValidationDataset = getValueByPath(fromObject, [
    "validationDataset"
  ]);
  if (parentObject !== void 0 && fromValidationDataset != null) {
    setValueByPath(parentObject, ["supervisedTuningSpec"], tuningValidationDatasetToVertex(fromValidationDataset, toObject));
  }
  const fromTunedModelDisplayName = getValueByPath(fromObject, [
    "tunedModelDisplayName"
  ]);
  if (parentObject !== void 0 && fromTunedModelDisplayName != null) {
    setValueByPath(parentObject, ["tunedModelDisplayName"], fromTunedModelDisplayName);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (parentObject !== void 0 && fromDescription != null) {
    setValueByPath(parentObject, ["description"], fromDescription);
  }
  const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
  if (parentObject !== void 0 && fromEpochCount != null) {
    setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "epochCount"], fromEpochCount);
  }
  const fromLearningRateMultiplier = getValueByPath(fromObject, [
    "learningRateMultiplier"
  ]);
  if (parentObject !== void 0 && fromLearningRateMultiplier != null) {
    setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "learningRateMultiplier"], fromLearningRateMultiplier);
  }
  const fromExportLastCheckpointOnly = getValueByPath(fromObject, [
    "exportLastCheckpointOnly"
  ]);
  if (parentObject !== void 0 && fromExportLastCheckpointOnly != null) {
    setValueByPath(parentObject, ["supervisedTuningSpec", "exportLastCheckpointOnly"], fromExportLastCheckpointOnly);
  }
  const fromAdapterSize = getValueByPath(fromObject, ["adapterSize"]);
  if (parentObject !== void 0 && fromAdapterSize != null) {
    setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "adapterSize"], fromAdapterSize);
  }
  if (getValueByPath(fromObject, ["batchSize"]) !== void 0) {
    throw new Error("batchSize parameter is not supported in Vertex AI.");
  }
  if (getValueByPath(fromObject, ["learningRate"]) !== void 0) {
    throw new Error("learningRate parameter is not supported in Vertex AI.");
  }
  return toObject;
}
function createTuningJobParametersToVertex(fromObject) {
  const toObject = {};
  const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
  if (fromBaseModel != null) {
    setValueByPath(toObject, ["baseModel"], fromBaseModel);
  }
  const fromTrainingDataset = getValueByPath(fromObject, [
    "trainingDataset"
  ]);
  if (fromTrainingDataset != null) {
    setValueByPath(toObject, ["supervisedTuningSpec", "trainingDatasetUri"], tuningDatasetToVertex(fromTrainingDataset, toObject));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], createTuningJobConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function tunedModelFromMldev(fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["name"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], fromModel);
  }
  const fromEndpoint = getValueByPath(fromObject, ["name"]);
  if (fromEndpoint != null) {
    setValueByPath(toObject, ["endpoint"], fromEndpoint);
  }
  return toObject;
}
function tuningJobFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromState = getValueByPath(fromObject, ["state"]);
  if (fromState != null) {
    setValueByPath(toObject, ["state"], tTuningJobStatus(fromState));
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromStartTime = getValueByPath(fromObject, [
    "tuningTask",
    "startTime"
  ]);
  if (fromStartTime != null) {
    setValueByPath(toObject, ["startTime"], fromStartTime);
  }
  const fromEndTime = getValueByPath(fromObject, [
    "tuningTask",
    "completeTime"
  ]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
  if (fromBaseModel != null) {
    setValueByPath(toObject, ["baseModel"], fromBaseModel);
  }
  const fromTunedModel = getValueByPath(fromObject, ["_self"]);
  if (fromTunedModel != null) {
    setValueByPath(toObject, ["tunedModel"], tunedModelFromMldev(fromTunedModel));
  }
  const fromDistillationSpec = getValueByPath(fromObject, [
    "distillationSpec"
  ]);
  if (fromDistillationSpec != null) {
    setValueByPath(toObject, ["distillationSpec"], fromDistillationSpec);
  }
  const fromExperiment = getValueByPath(fromObject, ["experiment"]);
  if (fromExperiment != null) {
    setValueByPath(toObject, ["experiment"], fromExperiment);
  }
  const fromLabels = getValueByPath(fromObject, ["labels"]);
  if (fromLabels != null) {
    setValueByPath(toObject, ["labels"], fromLabels);
  }
  const fromPipelineJob = getValueByPath(fromObject, ["pipelineJob"]);
  if (fromPipelineJob != null) {
    setValueByPath(toObject, ["pipelineJob"], fromPipelineJob);
  }
  const fromSatisfiesPzi = getValueByPath(fromObject, ["satisfiesPzi"]);
  if (fromSatisfiesPzi != null) {
    setValueByPath(toObject, ["satisfiesPzi"], fromSatisfiesPzi);
  }
  const fromSatisfiesPzs = getValueByPath(fromObject, ["satisfiesPzs"]);
  if (fromSatisfiesPzs != null) {
    setValueByPath(toObject, ["satisfiesPzs"], fromSatisfiesPzs);
  }
  const fromServiceAccount = getValueByPath(fromObject, [
    "serviceAccount"
  ]);
  if (fromServiceAccount != null) {
    setValueByPath(toObject, ["serviceAccount"], fromServiceAccount);
  }
  const fromTunedModelDisplayName = getValueByPath(fromObject, [
    "tunedModelDisplayName"
  ]);
  if (fromTunedModelDisplayName != null) {
    setValueByPath(toObject, ["tunedModelDisplayName"], fromTunedModelDisplayName);
  }
  return toObject;
}
function listTuningJobsResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromTuningJobs = getValueByPath(fromObject, ["tunedModels"]);
  if (fromTuningJobs != null) {
    let transformedList = fromTuningJobs;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return tuningJobFromMldev(item);
      });
    }
    setValueByPath(toObject, ["tuningJobs"], transformedList);
  }
  return toObject;
}
function tuningOperationFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], fromMetadata);
  }
  const fromDone = getValueByPath(fromObject, ["done"]);
  if (fromDone != null) {
    setValueByPath(toObject, ["done"], fromDone);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  return toObject;
}
function tunedModelCheckpointFromVertex(fromObject) {
  const toObject = {};
  const fromCheckpointId = getValueByPath(fromObject, ["checkpointId"]);
  if (fromCheckpointId != null) {
    setValueByPath(toObject, ["checkpointId"], fromCheckpointId);
  }
  const fromEpoch = getValueByPath(fromObject, ["epoch"]);
  if (fromEpoch != null) {
    setValueByPath(toObject, ["epoch"], fromEpoch);
  }
  const fromStep = getValueByPath(fromObject, ["step"]);
  if (fromStep != null) {
    setValueByPath(toObject, ["step"], fromStep);
  }
  const fromEndpoint = getValueByPath(fromObject, ["endpoint"]);
  if (fromEndpoint != null) {
    setValueByPath(toObject, ["endpoint"], fromEndpoint);
  }
  return toObject;
}
function tunedModelFromVertex(fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], fromModel);
  }
  const fromEndpoint = getValueByPath(fromObject, ["endpoint"]);
  if (fromEndpoint != null) {
    setValueByPath(toObject, ["endpoint"], fromEndpoint);
  }
  const fromCheckpoints = getValueByPath(fromObject, ["checkpoints"]);
  if (fromCheckpoints != null) {
    let transformedList = fromCheckpoints;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return tunedModelCheckpointFromVertex(item);
      });
    }
    setValueByPath(toObject, ["checkpoints"], transformedList);
  }
  return toObject;
}
function tuningJobFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromState = getValueByPath(fromObject, ["state"]);
  if (fromState != null) {
    setValueByPath(toObject, ["state"], tTuningJobStatus(fromState));
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromStartTime = getValueByPath(fromObject, ["startTime"]);
  if (fromStartTime != null) {
    setValueByPath(toObject, ["startTime"], fromStartTime);
  }
  const fromEndTime = getValueByPath(fromObject, ["endTime"]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
  if (fromBaseModel != null) {
    setValueByPath(toObject, ["baseModel"], fromBaseModel);
  }
  const fromTunedModel = getValueByPath(fromObject, ["tunedModel"]);
  if (fromTunedModel != null) {
    setValueByPath(toObject, ["tunedModel"], tunedModelFromVertex(fromTunedModel));
  }
  const fromSupervisedTuningSpec = getValueByPath(fromObject, [
    "supervisedTuningSpec"
  ]);
  if (fromSupervisedTuningSpec != null) {
    setValueByPath(toObject, ["supervisedTuningSpec"], fromSupervisedTuningSpec);
  }
  const fromTuningDataStats = getValueByPath(fromObject, [
    "tuningDataStats"
  ]);
  if (fromTuningDataStats != null) {
    setValueByPath(toObject, ["tuningDataStats"], fromTuningDataStats);
  }
  const fromEncryptionSpec = getValueByPath(fromObject, [
    "encryptionSpec"
  ]);
  if (fromEncryptionSpec != null) {
    setValueByPath(toObject, ["encryptionSpec"], fromEncryptionSpec);
  }
  const fromPartnerModelTuningSpec = getValueByPath(fromObject, [
    "partnerModelTuningSpec"
  ]);
  if (fromPartnerModelTuningSpec != null) {
    setValueByPath(toObject, ["partnerModelTuningSpec"], fromPartnerModelTuningSpec);
  }
  const fromDistillationSpec = getValueByPath(fromObject, [
    "distillationSpec"
  ]);
  if (fromDistillationSpec != null) {
    setValueByPath(toObject, ["distillationSpec"], fromDistillationSpec);
  }
  const fromExperiment = getValueByPath(fromObject, ["experiment"]);
  if (fromExperiment != null) {
    setValueByPath(toObject, ["experiment"], fromExperiment);
  }
  const fromLabels = getValueByPath(fromObject, ["labels"]);
  if (fromLabels != null) {
    setValueByPath(toObject, ["labels"], fromLabels);
  }
  const fromPipelineJob = getValueByPath(fromObject, ["pipelineJob"]);
  if (fromPipelineJob != null) {
    setValueByPath(toObject, ["pipelineJob"], fromPipelineJob);
  }
  const fromSatisfiesPzi = getValueByPath(fromObject, ["satisfiesPzi"]);
  if (fromSatisfiesPzi != null) {
    setValueByPath(toObject, ["satisfiesPzi"], fromSatisfiesPzi);
  }
  const fromSatisfiesPzs = getValueByPath(fromObject, ["satisfiesPzs"]);
  if (fromSatisfiesPzs != null) {
    setValueByPath(toObject, ["satisfiesPzs"], fromSatisfiesPzs);
  }
  const fromServiceAccount = getValueByPath(fromObject, [
    "serviceAccount"
  ]);
  if (fromServiceAccount != null) {
    setValueByPath(toObject, ["serviceAccount"], fromServiceAccount);
  }
  const fromTunedModelDisplayName = getValueByPath(fromObject, [
    "tunedModelDisplayName"
  ]);
  if (fromTunedModelDisplayName != null) {
    setValueByPath(toObject, ["tunedModelDisplayName"], fromTunedModelDisplayName);
  }
  return toObject;
}
function listTuningJobsResponseFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromTuningJobs = getValueByPath(fromObject, ["tuningJobs"]);
  if (fromTuningJobs != null) {
    let transformedList = fromTuningJobs;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return tuningJobFromVertex(item);
      });
    }
    setValueByPath(toObject, ["tuningJobs"], transformedList);
  }
  return toObject;
}
var Tunings = class extends BaseModule {
  constructor(apiClient) {
    super();
    this.apiClient = apiClient;
    this.get = async (params) => {
      return await this.getInternal(params);
    };
    this.list = async (params = {}) => {
      return new Pager(PagedItem.PAGED_ITEM_TUNING_JOBS, (x2) => this.listInternal(x2), await this.listInternal(params), params);
    };
    this.tune = async (params) => {
      if (this.apiClient.isVertexAI()) {
        return await this.tuneInternal(params);
      } else {
        const operation = await this.tuneMldevInternal(params);
        let tunedModelName = "";
        if (operation["metadata"] !== void 0 && operation["metadata"]["tunedModel"] !== void 0) {
          tunedModelName = operation["metadata"]["tunedModel"];
        } else if (operation["name"] !== void 0 && operation["name"].includes("/operations/")) {
          tunedModelName = operation["name"].split("/operations/")[0];
        }
        const tuningJob = {
          name: tunedModelName,
          state: JobState.JOB_STATE_QUEUED
        };
        return tuningJob;
      }
    };
  }
  async getInternal(params) {
    var _a3, _b, _c, _d;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = getTuningJobParametersToVertex(params);
      path2 = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = tuningJobFromVertex(apiResponse);
        return resp;
      });
    } else {
      const body = getTuningJobParametersToMldev(params);
      path2 = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = tuningJobFromMldev(apiResponse);
        return resp;
      });
    }
  }
  async listInternal(params) {
    var _a3, _b, _c, _d;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = listTuningJobsParametersToVertex(params);
      path2 = formatMap("tuningJobs", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = listTuningJobsResponseFromVertex(apiResponse);
        const typedResp = new ListTuningJobsResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = listTuningJobsParametersToMldev(params);
      path2 = formatMap("tunedModels", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = listTuningJobsResponseFromMldev(apiResponse);
        const typedResp = new ListTuningJobsResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  async tuneInternal(params) {
    var _a3, _b;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = createTuningJobParametersToVertex(params);
      path2 = formatMap("tuningJobs", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = tuningJobFromVertex(apiResponse);
        return resp;
      });
    } else {
      throw new Error("This method is only supported by the Vertex AI.");
    }
  }
  async tuneMldevInternal(params) {
    var _a3, _b;
    let response;
    let path2 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error("This method is only supported by the Gemini Developer API.");
    } else {
      const body = createTuningJobParametersToMldev(params);
      path2 = formatMap("tunedModels", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path2,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a3 = params.config) === null || _a3 === void 0 ? void 0 : _a3.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = tuningOperationFromMldev(apiResponse);
        return resp;
      });
    }
  }
};
var MAX_CHUNK_SIZE = 1024 * 1024 * 8;
var MAX_RETRY_COUNT = 3;
var INITIAL_RETRY_DELAY_MS = 1e3;
var DELAY_MULTIPLIER = 2;
var X_GOOG_UPLOAD_STATUS_HEADER_FIELD = "x-goog-upload-status";
async function uploadBlob(file, uploadUrl, apiClient) {
  var _a3, _b, _c;
  let fileSize = 0;
  let offset = 0;
  let response = new HttpResponse(new Response());
  let uploadCommand = "upload";
  fileSize = file.size;
  while (offset < fileSize) {
    const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);
    const chunk = file.slice(offset, offset + chunkSize);
    if (offset + chunkSize >= fileSize) {
      uploadCommand += ", finalize";
    }
    let retryCount = 0;
    let currentDelayMs = INITIAL_RETRY_DELAY_MS;
    while (retryCount < MAX_RETRY_COUNT) {
      response = await apiClient.request({
        path: "",
        body: chunk,
        httpMethod: "POST",
        httpOptions: {
          apiVersion: "",
          baseUrl: uploadUrl,
          headers: {
            "X-Goog-Upload-Command": uploadCommand,
            "X-Goog-Upload-Offset": String(offset),
            "Content-Length": String(chunkSize)
          }
        }
      });
      if ((_a3 = response === null || response === void 0 ? void 0 : response.headers) === null || _a3 === void 0 ? void 0 : _a3[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) {
        break;
      }
      retryCount++;
      await sleep2(currentDelayMs);
      currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;
    }
    offset += chunkSize;
    if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "active") {
      break;
    }
    if (fileSize <= offset) {
      throw new Error("All content has been uploaded, but the upload status is not finalized.");
    }
  }
  const responseJson = await (response === null || response === void 0 ? void 0 : response.json());
  if (((_c = response === null || response === void 0 ? void 0 : response.headers) === null || _c === void 0 ? void 0 : _c[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "final") {
    throw new Error("Failed to upload file: Upload status is not finalized.");
  }
  return responseJson["file"];
}
async function getBlobStat(file) {
  const fileStat = { size: file.size, type: file.type };
  return fileStat;
}
function sleep2(ms) {
  return new Promise((resolvePromise) => setTimeout(resolvePromise, ms));
}
var NodeUploader = class {
  async stat(file) {
    const fileStat = { size: 0, type: void 0 };
    if (typeof file === "string") {
      const originalStat = await fs2.stat(file);
      fileStat.size = originalStat.size;
      fileStat.type = this.inferMimeType(file);
      return fileStat;
    } else {
      return await getBlobStat(file);
    }
  }
  async upload(file, uploadUrl, apiClient) {
    if (typeof file === "string") {
      return await this.uploadFileFromPath(file, uploadUrl, apiClient);
    } else {
      return uploadBlob(file, uploadUrl, apiClient);
    }
  }
  /**
   * Infers the MIME type of a file based on its extension.
   *
   * @param filePath The path to the file.
   * @returns The MIME type of the file, or undefined if it cannot be inferred.
   */
  inferMimeType(filePath) {
    const fileExtension = filePath.slice(filePath.lastIndexOf(".") + 1);
    const mimeTypes = {
      "aac": "audio/aac",
      "abw": "application/x-abiword",
      "arc": "application/x-freearc",
      "avi": "video/x-msvideo",
      "azw": "application/vnd.amazon.ebook",
      "bin": "application/octet-stream",
      "bmp": "image/bmp",
      "bz": "application/x-bzip",
      "bz2": "application/x-bzip2",
      "csh": "application/x-csh",
      "css": "text/css",
      "csv": "text/csv",
      "doc": "application/msword",
      "docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      "eot": "application/vnd.ms-fontobject",
      "epub": "application/epub+zip",
      "gz": "application/gzip",
      "gif": "image/gif",
      "htm": "text/html",
      "html": "text/html",
      "ico": "image/vnd.microsoft.icon",
      "ics": "text/calendar",
      "jar": "application/java-archive",
      "jpeg": "image/jpeg",
      "jpg": "image/jpeg",
      "js": "text/javascript",
      "json": "application/json",
      "jsonld": "application/ld+json",
      "kml": "application/vnd.google-earth.kml+xml",
      "kmz": "application/vnd.google-earth.kmz+xml",
      "mjs": "text/javascript",
      "mp3": "audio/mpeg",
      "mp4": "video/mp4",
      "mpeg": "video/mpeg",
      "mpkg": "application/vnd.apple.installer+xml",
      "odt": "application/vnd.oasis.opendocument.text",
      "oga": "audio/ogg",
      "ogv": "video/ogg",
      "ogx": "application/ogg",
      "opus": "audio/opus",
      "otf": "font/otf",
      "png": "image/png",
      "pdf": "application/pdf",
      "php": "application/x-httpd-php",
      "ppt": "application/vnd.ms-powerpoint",
      "pptx": "application/vnd.openxmlformats-officedocument.presentationml.presentation",
      "rar": "application/vnd.rar",
      "rtf": "application/rtf",
      "sh": "application/x-sh",
      "svg": "image/svg+xml",
      "swf": "application/x-shockwave-flash",
      "tar": "application/x-tar",
      "tif": "image/tiff",
      "tiff": "image/tiff",
      "ts": "video/mp2t",
      "ttf": "font/ttf",
      "txt": "text/plain",
      "vsd": "application/vnd.visio",
      "wav": "audio/wav",
      "weba": "audio/webm",
      "webm": "video/webm",
      "webp": "image/webp",
      "woff": "font/woff",
      "woff2": "font/woff2",
      "xhtml": "application/xhtml+xml",
      "xls": "application/vnd.ms-excel",
      "xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      "xml": "application/xml",
      "xul": "application/vnd.mozilla.xul+xml",
      "zip": "application/zip",
      "3gp": "video/3gpp",
      "3g2": "video/3gpp2",
      "7z": "application/x-7z-compressed"
    };
    const mimeType = mimeTypes[fileExtension.toLowerCase()];
    return mimeType;
  }
  async uploadFileFromPath(file, uploadUrl, apiClient) {
    var _a3, _b, _c;
    let fileSize = 0;
    let offset = 0;
    let response = new HttpResponse(new Response());
    let uploadCommand = "upload";
    let fileHandle;
    try {
      fileHandle = await fs2.open(file, "r");
      if (!fileHandle) {
        throw new Error(`Failed to open file`);
      }
      fileSize = (await fileHandle.stat()).size;
      while (offset < fileSize) {
        const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);
        if (offset + chunkSize >= fileSize) {
          uploadCommand += ", finalize";
        }
        const buffer = new Uint8Array(chunkSize);
        const { bytesRead } = await fileHandle.read(buffer, 0, chunkSize, offset);
        if (bytesRead !== chunkSize) {
          throw new Error(`Failed to read ${chunkSize} bytes from file at offset ${offset}. bytes actually read: ${bytesRead}`);
        }
        const chunk = new Blob([buffer]);
        let retryCount = 0;
        let currentDelayMs = INITIAL_RETRY_DELAY_MS;
        while (retryCount < MAX_RETRY_COUNT) {
          response = await apiClient.request({
            path: "",
            body: chunk,
            httpMethod: "POST",
            httpOptions: {
              apiVersion: "",
              baseUrl: uploadUrl,
              headers: {
                "X-Goog-Upload-Command": uploadCommand,
                "X-Goog-Upload-Offset": String(offset),
                "Content-Length": String(bytesRead)
              }
            }
          });
          if ((_a3 = response === null || response === void 0 ? void 0 : response.headers) === null || _a3 === void 0 ? void 0 : _a3[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) {
            break;
          }
          retryCount++;
          await sleep2(currentDelayMs);
          currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;
        }
        offset += bytesRead;
        if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "active") {
          break;
        }
        if (fileSize <= offset) {
          throw new Error("All content has been uploaded, but the upload status is not finalized.");
        }
      }
      const responseJson = await (response === null || response === void 0 ? void 0 : response.json());
      if (((_c = response === null || response === void 0 ? void 0 : response.headers) === null || _c === void 0 ? void 0 : _c[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "final") {
        throw new Error("Failed to upload file: Upload status is not finalized.");
      }
      return responseJson["file"];
    } finally {
      if (fileHandle) {
        await fileHandle.close();
      }
    }
  }
};
var LANGUAGE_LABEL_PREFIX = "gl-node/";
var GoogleGenAI = class {
  constructor(options) {
    var _a3, _b, _c, _d, _e2, _f;
    if ((options.project || options.location) && options.apiKey) {
      throw new Error("Project/location and API key are mutually exclusive in the client initializer.");
    }
    this.vertexai = (_b = (_a3 = options.vertexai) !== null && _a3 !== void 0 ? _a3 : getBooleanEnv("GOOGLE_GENAI_USE_VERTEXAI")) !== null && _b !== void 0 ? _b : false;
    const envApiKey = getApiKeyFromEnv();
    const envProject = getEnv("GOOGLE_CLOUD_PROJECT");
    const envLocation = getEnv("GOOGLE_CLOUD_LOCATION");
    this.apiKey = (_c = options.apiKey) !== null && _c !== void 0 ? _c : envApiKey;
    this.project = (_d = options.project) !== null && _d !== void 0 ? _d : envProject;
    this.location = (_e2 = options.location) !== null && _e2 !== void 0 ? _e2 : envLocation;
    if (options.vertexai) {
      if ((_f = options.googleAuthOptions) === null || _f === void 0 ? void 0 : _f.credentials) {
        console.debug("The user provided Google Cloud credentials will take precedence over the API key from the environment variable.");
        this.apiKey = void 0;
      }
      if ((envProject || envLocation) && options.apiKey) {
        console.debug("The user provided Vertex AI API key will take precedence over the project/location from the environment variables.");
        this.project = void 0;
        this.location = void 0;
      } else if ((options.project || options.location) && envApiKey) {
        console.debug("The user provided project/location will take precedence over the API key from the environment variables.");
        this.apiKey = void 0;
      } else if ((envProject || envLocation) && envApiKey) {
        console.debug("The project/location from the environment variables will take precedence over the API key from the environment variables.");
        this.apiKey = void 0;
      }
    }
    const baseUrl = getBaseUrl(options.httpOptions, options.vertexai, getEnv("GOOGLE_VERTEX_BASE_URL"), getEnv("GOOGLE_GEMINI_BASE_URL"));
    if (baseUrl) {
      if (options.httpOptions) {
        options.httpOptions.baseUrl = baseUrl;
      } else {
        options.httpOptions = { baseUrl };
      }
    }
    this.apiVersion = options.apiVersion;
    const auth = new NodeAuth({
      apiKey: this.apiKey,
      googleAuthOptions: options.googleAuthOptions
    });
    this.apiClient = new ApiClient({
      auth,
      project: this.project,
      location: this.location,
      apiVersion: this.apiVersion,
      apiKey: this.apiKey,
      vertexai: this.vertexai,
      httpOptions: options.httpOptions,
      userAgentExtra: LANGUAGE_LABEL_PREFIX + process.version,
      uploader: new NodeUploader(),
      downloader: new NodeDownloader()
    });
    this.models = new Models3(this.apiClient);
    this.live = new Live(this.apiClient, auth, new NodeWebSocketFactory());
    this.batches = new Batches3(this.apiClient);
    this.chats = new Chats(this.models, this.apiClient);
    this.caches = new Caches(this.apiClient);
    this.files = new Files(this.apiClient);
    this.operations = new Operations(this.apiClient);
    this.authTokens = new Tokens(this.apiClient);
    this.tunings = new Tunings(this.apiClient);
  }
};
function getEnv(env) {
  var _a3, _b, _c;
  return (_c = (_b = (_a3 = process === null || process === void 0 ? void 0 : process.env) === null || _a3 === void 0 ? void 0 : _a3[env]) === null || _b === void 0 ? void 0 : _b.trim()) !== null && _c !== void 0 ? _c : void 0;
}
function getBooleanEnv(env) {
  return stringToBoolean(getEnv(env));
}
function stringToBoolean(str) {
  if (str === void 0) {
    return false;
  }
  return str.toLowerCase() === "true";
}
function getApiKeyFromEnv() {
  const envGoogleApiKey = getEnv("GOOGLE_API_KEY");
  const envGeminiApiKey = getEnv("GEMINI_API_KEY");
  if (envGoogleApiKey && envGeminiApiKey) {
    console.warn("Both GOOGLE_API_KEY and GEMINI_API_KEY are set. Using GOOGLE_API_KEY.");
  }
  return envGoogleApiKey || envGeminiApiKey;
}

// ../node_modules/zod-to-json-schema/dist/esm/Options.js
var ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
var defaultOptions2 = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  markdownDescription: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref",
  openAiAnyTypeName: "OpenAiAnyType"
};
var getDefaultOptions = (options) => typeof options === "string" ? {
  ...defaultOptions2,
  name: options
} : {
  ...defaultOptions2,
  ...options
};

// ../node_modules/zod-to-json-schema/dist/esm/Refs.js
var getRefs = (options) => {
  const _options = getDefaultOptions(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    flags: { hasReferencedOpenAiAnyType: false },
    currentPath,
    propertyPath: void 0,
    seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [
      def._def,
      {
        def: def._def,
        path: [..._options.basePath, _options.definitionPath, name],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
};

// ../node_modules/zod-to-json-schema/dist/esm/errorMessages.js
function addErrorMessage(res, key, errorMessage, refs) {
  if (!refs?.errorMessages)
    return;
  if (errorMessage) {
    res.errorMessage = {
      ...res.errorMessage,
      [key]: errorMessage
    };
  }
}
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
  res[key] = value;
  addErrorMessage(res, key, errorMessage, refs);
}

// ../node_modules/zod-to-json-schema/dist/esm/getRelativePath.js
var getRelativePath = (pathA, pathB) => {
  let i2 = 0;
  for (; i2 < pathA.length && i2 < pathB.length; i2++) {
    if (pathA[i2] !== pathB[i2])
      break;
  }
  return [(pathA.length - i2).toString(), ...pathB.slice(i2)].join("/");
};

// ../node_modules/zod-to-json-schema/dist/esm/selectParser.js
import { ZodFirstPartyTypeKind as ZodFirstPartyTypeKind3 } from "zod";

// ../node_modules/zod-to-json-schema/dist/esm/parsers/any.js
function parseAnyDef(refs) {
  if (refs.target !== "openAi") {
    return {};
  }
  const anyDefinitionPath = [
    ...refs.basePath,
    refs.definitionPath,
    refs.openAiAnyTypeName
  ];
  refs.flags.hasReferencedOpenAiAnyType = true;
  return {
    $ref: refs.$refStrategy === "relative" ? getRelativePath(anyDefinitionPath, refs.currentPath) : anyDefinitionPath.join("/")
  };
}

// ../node_modules/zod-to-json-schema/dist/esm/parsers/array.js
import { ZodFirstPartyTypeKind } from "zod";
function parseArrayDef(def, refs) {
  const res = {
    type: "array"
  };
  if (def.type?._def && def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}

// ../node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js
function parseBigintDef(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}

// ../node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js
function parseBooleanDef() {
  return {
    type: "boolean"
  };
}

// ../node_modules/zod-to-json-schema/dist/esm/parsers/branded.js
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}

// ../node_modules/zod-to-json-schema/dist/esm/parsers/catch.js
var parseCatchDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};

// ../node_modules/zod-to-json-schema/dist/esm/parsers/date.js
function parseDateDef(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy ?? refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i2) => parseDateDef(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser(def, refs);
  }
}
var integerDateParser = (def, refs) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  if (refs.target === "openApi3") {
    return res;
  }
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        setResponseValueAndErrors(
          res,
          "minimum",
          check.value,
          // This is in milliseconds
          check.message,
          refs
        );
        break;
      case "max":
        setResponseValueAndErrors(
          res,
          "maximum",
          check.value,
          // This is in milliseconds
          check.message,
          refs
        );
        break;
    }
  }
  return res;
};

// ../node_modules/zod-to-json-schema/dist/esm/parsers/default.js
function parseDefaultDef(_def, refs) {
  return {
    ...parseDef(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}

// ../node_modules/zod-to-json-schema/dist/esm/parsers/effects.js
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : parseAnyDef(refs);
}

// ../node_modules/zod-to-json-schema/dist/esm/parsers/enum.js
function parseEnumDef(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}

// ../node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js
var isJsonSchema7AllOfType = (type) => {
  if ("type" in type && type.type === "string")
    return false;
  return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
  const allOf = [
    parseDef(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x2) => !!x2);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === void 0) {
        unevaluatedProperties = void 0;
      }
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      } else {
        unevaluatedProperties = void 0;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? {
    allOf: mergedAllOf,
    ...unevaluatedProperties
  } : void 0;
}

// ../node_modules/zod-to-json-schema/dist/esm/parsers/literal.js
function parseLiteralDef(def, refs) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      enum: [def.value]
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}

// ../node_modules/zod-to-json-schema/dist/esm/parsers/record.js
import { ZodFirstPartyTypeKind as ZodFirstPartyTypeKind2 } from "zod";

// ../node_modules/zod-to-json-schema/dist/esm/parsers/string.js
var emojiRegex = void 0;
var zodPatterns = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => {
    if (emojiRegex === void 0) {
      emojiRegex = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
    }
    return emojiRegex;
  },
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          break;
        case "max":
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);
          break;
        case "endsWith":
          addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);
          break;
        case "datetime":
          addFormat(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat(res, "date", check.message, refs);
          break;
        case "time":
          addFormat(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat(res, "duration", check.message, refs);
          break;
        case "length":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "includes": {
          addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern(res, zodPatterns.base64url, check.message, refs);
          break;
        case "jwt":
          addPattern(res, zodPatterns.jwt, check.message, refs);
          break;
        case "cidr": {
          if (check.version !== "v6") {
            addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);
          }
          if (check.version !== "v4") {
            addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji(), check.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat(res, "binary", check.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              setResponseValueAndErrors(res, "contentEncoding", "base64", check.message, refs);
              break;
            }
            case "pattern:zod": {
              addPattern(res, zodPatterns.base64, check.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern(res, zodPatterns.nanoid, check.message, refs);
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          /* @__PURE__ */ ((_2) => {
          })(check);
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue(literal, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal) : literal;
}
var ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric(source) {
  let result = "";
  for (let i2 = 0; i2 < source.length; i2++) {
    if (!ALPHA_NUMERIC.has(source[i2])) {
      result += "\\";
    }
    result += source[i2];
  }
  return result;
}
function addFormat(schema, value, message, refs) {
  if (schema.format || schema.anyOf?.some((x2) => x2.format)) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { format: schema.errorMessage.format }
        }
      });
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "format", value, message, refs);
  }
}
function addPattern(schema, regex, message, refs) {
  if (schema.pattern || schema.allOf?.some((x2) => x2.pattern)) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { pattern: schema.errorMessage.pattern }
        }
      });
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "pattern", stringifyRegExpWithFlags(regex, refs), message, refs);
  }
}
function stringifyRegExpWithFlags(regex, refs) {
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    m: regex.flags.includes("m"),
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i2 = 0; i2 < source.length; i2++) {
    if (isEscaped) {
      pattern += source[i2];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i2].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i2];
            pattern += `${source[i2 - 2]}-${source[i2]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i2 + 1] === "-" && source[i2 + 2]?.match(/[a-z]/)) {
            pattern += source[i2];
            inCharRange = true;
          } else {
            pattern += `${source[i2]}${source[i2].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i2].match(/[a-z]/)) {
        pattern += `[${source[i2]}${source[i2].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i2] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i2] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i2] === ".") {
      pattern += inCharGroup ? `${source[i2]}\r
` : `[${source[i2]}\r
]`;
      continue;
    }
    pattern += source[i2];
    if (source[i2] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i2] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i2] === "[") {
      inCharGroup = true;
    }
  }
  try {
    new RegExp(pattern);
  } catch {
    console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
    return regex.source;
  }
  return pattern;
}

// ../node_modules/zod-to-json-schema/dist/esm/parsers/record.js
function parseRecordDef(def, refs) {
  if (refs.target === "openAi") {
    console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
  }
  if (refs.target === "openApi3" && def.keyType?._def.typeName === ZodFirstPartyTypeKind2.ZodEnum) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce((acc, key) => ({
        ...acc,
        [key]: parseDef(def.valueType._def, {
          ...refs,
          currentPath: [...refs.currentPath, "properties", key]
        }) ?? parseAnyDef(refs)
      }), {}),
      additionalProperties: refs.rejectedAdditionalProperties
    };
  }
  const schema = {
    type: "object",
    additionalProperties: parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? refs.allowedAdditionalProperties
  };
  if (refs.target === "openApi3") {
    return schema;
  }
  if (def.keyType?._def.typeName === ZodFirstPartyTypeKind2.ZodString && def.keyType._def.checks?.length) {
    const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind2.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind2.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind2.ZodString && def.keyType._def.type._def.checks?.length) {
    const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}

// ../node_modules/zod-to-json-schema/dist/esm/parsers/map.js
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef(def, refs);
  }
  const keys = parseDef(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || parseAnyDef(refs);
  const values = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || parseAnyDef(refs);
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}

// ../node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js
function parseNativeEnumDef(def) {
  const object = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object[object[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}

// ../node_modules/zod-to-json-schema/dist/esm/parsers/never.js
function parseNeverDef(refs) {
  return refs.target === "openAi" ? void 0 : {
    not: parseAnyDef({
      ...refs,
      currentPath: [...refs.currentPath, "not"]
    })
  };
}

// ../node_modules/zod-to-json-schema/dist/esm/parsers/null.js
function parseNullDef(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}

// ../node_modules/zod-to-json-schema/dist/esm/parsers/union.js
var primitiveMappings = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef(def, refs) {
  if (refs.target === "openApi3")
    return asAnyOf(def, refs);
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every((x2) => x2._def.typeName in primitiveMappings && (!x2._def.checks || !x2._def.checks.length))) {
    const types2 = options.reduce((types3, x2) => {
      const type = primitiveMappings[x2._def.typeName];
      return type && !types3.includes(type) ? [...types3, type] : types3;
    }, []);
    return {
      type: types2.length > 1 ? types2 : types2[0]
    };
  } else if (options.every((x2) => x2._def.typeName === "ZodLiteral" && !x2.description)) {
    const types2 = options.reduce((acc, x2) => {
      const type = typeof x2._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x2._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types2.length === options.length) {
      const uniqueTypes = types2.filter((x2, i2, a2) => a2.indexOf(x2) === i2);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce((acc, x2) => {
          return acc.includes(x2._def.value) ? acc : [...acc, x2._def.value];
        }, [])
      };
    }
  } else if (options.every((x2) => x2._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce((acc, x2) => [
        ...acc,
        ...x2._def.values.filter((x3) => !acc.includes(x3))
      ], [])
    };
  }
  return asAnyOf(def, refs);
}
var asAnyOf = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x2, i2) => parseDef(x2._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", `${i2}`]
  })).filter((x2) => !!x2 && (!refs.strictUnions || typeof x2 === "object" && Object.keys(x2).length > 0));
  return anyOf.length ? { anyOf } : void 0;
};

// ../node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js
function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3") {
      return {
        type: primitiveMappings[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [
        primitiveMappings[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  if (refs.target === "openApi3") {
    const base2 = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath]
    });
    if (base2 && "$ref" in base2)
      return { allOf: [base2], nullable: true };
    return base2 && { ...base2, nullable: true };
  }
  const base = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}

// ../node_modules/zod-to-json-schema/dist/esm/parsers/number.js
function parseNumberDef(def, refs) {
  const res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage(res, "type", check.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}

// ../node_modules/zod-to-json-schema/dist/esm/parsers/object.js
function parseObjectDef(def, refs) {
  const forceOptionalIntoNullable = refs.target === "openAi";
  const result = {
    type: "object",
    properties: {}
  };
  const required = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    let propOptional = safeIsOptional(propDef);
    if (propOptional && forceOptionalIntoNullable) {
      if (propDef._def.typeName === "ZodOptional") {
        propDef = propDef._def.innerType;
      }
      if (!propDef.isNullable()) {
        propDef = propDef.nullable();
      }
      propOptional = false;
    }
    const parsedDef = parseDef(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required.push(propName);
    }
  }
  if (required.length) {
    result.required = required;
  }
  const additionalProperties = decideAdditionalProperties(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional(schema) {
  try {
    return schema.isOptional();
  } catch {
    return true;
  }
}

// ../node_modules/zod-to-json-schema/dist/esm/parsers/optional.js
var parseOptionalDef = (def, refs) => {
  if (refs.currentPath.toString() === refs.propertyPath?.toString()) {
    return parseDef(def.innerType._def, refs);
  }
  const innerSchema = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? {
    anyOf: [
      {
        not: parseAnyDef(refs)
      },
      innerSchema
    ]
  } : parseAnyDef(refs);
};

// ../node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js
var parsePipelineDef = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef(def.out._def, refs);
  }
  const a2 = parseDef(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b2 = parseDef(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a2 ? "1" : "0"]
  });
  return {
    allOf: [a2, b2].filter((x2) => x2 !== void 0)
  };
};

// ../node_modules/zod-to-json-schema/dist/esm/parsers/promise.js
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}

// ../node_modules/zod-to-json-schema/dist/esm/parsers/set.js
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema;
}

// ../node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js
function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map((x2, i2) => parseDef(x2._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i2}`]
      })).reduce((acc, x2) => x2 === void 0 ? acc : [...acc, x2], []),
      additionalItems: parseDef(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map((x2, i2) => parseDef(x2._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i2}`]
      })).reduce((acc, x2) => x2 === void 0 ? acc : [...acc, x2], [])
    };
  }
}

// ../node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js
function parseUndefinedDef(refs) {
  return {
    not: parseAnyDef(refs)
  };
}

// ../node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js
function parseUnknownDef(refs) {
  return parseAnyDef(refs);
}

// ../node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js
var parseReadonlyDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};

// ../node_modules/zod-to-json-schema/dist/esm/selectParser.js
var selectParser = (def, typeName, refs) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind3.ZodString:
      return parseStringDef(def, refs);
    case ZodFirstPartyTypeKind3.ZodNumber:
      return parseNumberDef(def, refs);
    case ZodFirstPartyTypeKind3.ZodObject:
      return parseObjectDef(def, refs);
    case ZodFirstPartyTypeKind3.ZodBigInt:
      return parseBigintDef(def, refs);
    case ZodFirstPartyTypeKind3.ZodBoolean:
      return parseBooleanDef();
    case ZodFirstPartyTypeKind3.ZodDate:
      return parseDateDef(def, refs);
    case ZodFirstPartyTypeKind3.ZodUndefined:
      return parseUndefinedDef(refs);
    case ZodFirstPartyTypeKind3.ZodNull:
      return parseNullDef(refs);
    case ZodFirstPartyTypeKind3.ZodArray:
      return parseArrayDef(def, refs);
    case ZodFirstPartyTypeKind3.ZodUnion:
    case ZodFirstPartyTypeKind3.ZodDiscriminatedUnion:
      return parseUnionDef(def, refs);
    case ZodFirstPartyTypeKind3.ZodIntersection:
      return parseIntersectionDef(def, refs);
    case ZodFirstPartyTypeKind3.ZodTuple:
      return parseTupleDef(def, refs);
    case ZodFirstPartyTypeKind3.ZodRecord:
      return parseRecordDef(def, refs);
    case ZodFirstPartyTypeKind3.ZodLiteral:
      return parseLiteralDef(def, refs);
    case ZodFirstPartyTypeKind3.ZodEnum:
      return parseEnumDef(def);
    case ZodFirstPartyTypeKind3.ZodNativeEnum:
      return parseNativeEnumDef(def);
    case ZodFirstPartyTypeKind3.ZodNullable:
      return parseNullableDef(def, refs);
    case ZodFirstPartyTypeKind3.ZodOptional:
      return parseOptionalDef(def, refs);
    case ZodFirstPartyTypeKind3.ZodMap:
      return parseMapDef(def, refs);
    case ZodFirstPartyTypeKind3.ZodSet:
      return parseSetDef(def, refs);
    case ZodFirstPartyTypeKind3.ZodLazy:
      return () => def.getter()._def;
    case ZodFirstPartyTypeKind3.ZodPromise:
      return parsePromiseDef(def, refs);
    case ZodFirstPartyTypeKind3.ZodNaN:
    case ZodFirstPartyTypeKind3.ZodNever:
      return parseNeverDef(refs);
    case ZodFirstPartyTypeKind3.ZodEffects:
      return parseEffectsDef(def, refs);
    case ZodFirstPartyTypeKind3.ZodAny:
      return parseAnyDef(refs);
    case ZodFirstPartyTypeKind3.ZodUnknown:
      return parseUnknownDef(refs);
    case ZodFirstPartyTypeKind3.ZodDefault:
      return parseDefaultDef(def, refs);
    case ZodFirstPartyTypeKind3.ZodBranded:
      return parseBrandedDef(def, refs);
    case ZodFirstPartyTypeKind3.ZodReadonly:
      return parseReadonlyDef(def, refs);
    case ZodFirstPartyTypeKind3.ZodCatch:
      return parseCatchDef(def, refs);
    case ZodFirstPartyTypeKind3.ZodPipeline:
      return parsePipelineDef(def, refs);
    case ZodFirstPartyTypeKind3.ZodFunction:
    case ZodFirstPartyTypeKind3.ZodVoid:
    case ZodFirstPartyTypeKind3.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_2) => void 0)(typeName);
  }
};

// ../node_modules/zod-to-json-schema/dist/esm/parseDef.js
function parseDef(def, refs, forceResolution = false) {
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
  const jsonSchema = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema) {
    addMeta(def, refs, jsonSchema);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema, def, refs);
    newItem.jsonSchema = jsonSchema;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema;
  return jsonSchema;
}
var get$ref = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
        return parseAnyDef(refs);
      }
      return refs.$refStrategy === "seen" ? parseAnyDef(refs) : void 0;
    }
  }
};
var addMeta = (def, refs, jsonSchema) => {
  if (def.description) {
    jsonSchema.description = def.description;
    if (refs.markdownDescription) {
      jsonSchema.markdownDescription = def.description;
    }
  }
  return jsonSchema;
};

// ../node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js
var zodToJsonSchema = (schema, options) => {
  const refs = getRefs(options);
  let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name2, schema2]) => ({
    ...acc,
    [name2]: parseDef(schema2._def, {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name2]
    }, true) ?? parseAnyDef(refs)
  }), {}) : void 0;
  const name = typeof options === "string" ? options : options?.nameStrategy === "title" ? void 0 : options?.name;
  const main = parseDef(schema._def, name === void 0 ? refs : {
    ...refs,
    currentPath: [...refs.basePath, refs.definitionPath, name]
  }, false) ?? parseAnyDef(refs);
  const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
  if (title !== void 0) {
    main.title = title;
  }
  if (refs.flags.hasReferencedOpenAiAnyType) {
    if (!definitions) {
      definitions = {};
    }
    if (!definitions[refs.openAiAnyTypeName]) {
      definitions[refs.openAiAnyTypeName] = {
        // Skipping "object" as no properties can be defined and additionalProperties must be "false"
        type: ["string", "number", "integer", "boolean", "array", "null"],
        items: {
          $ref: refs.$refStrategy === "relative" ? "1" : [
            ...refs.basePath,
            refs.definitionPath,
            refs.openAiAnyTypeName
          ].join("/")
        }
      };
    }
  }
  const combined = name === void 0 ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name]: main
    }
  };
  if (refs.target === "jsonSchema7") {
    combined.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") {
    combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  }
  if (refs.target === "openAi" && ("anyOf" in combined || "oneOf" in combined || "allOf" in combined || "type" in combined && Array.isArray(combined.type))) {
    console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
  }
  return combined;
};

// ../node_modules/groq-sdk/version.mjs
var VERSION2 = "0.16.0";

// ../node_modules/groq-sdk/_shims/registry.mjs
var auto2 = false;
var kind2 = void 0;
var fetch4 = void 0;
var Request4 = void 0;
var Response4 = void 0;
var Headers4 = void 0;
var FormData4 = void 0;
var Blob5 = void 0;
var File3 = void 0;
var ReadableStream5 = void 0;
var getMultipartRequestOptions3 = void 0;
var getDefaultAgent2 = void 0;
var fileFromPath4 = void 0;
var isFsReadStream2 = void 0;
function setShims2(shims, options = { auto: false }) {
  if (auto2) {
    throw new Error(`you must \`import 'groq-sdk/shims/${shims.kind}'\` before importing anything else from groq-sdk`);
  }
  if (kind2) {
    throw new Error(`can't \`import 'groq-sdk/shims/${shims.kind}'\` after \`import 'groq-sdk/shims/${kind2}'\``);
  }
  auto2 = options.auto;
  kind2 = shims.kind;
  fetch4 = shims.fetch;
  Request4 = shims.Request;
  Response4 = shims.Response;
  Headers4 = shims.Headers;
  FormData4 = shims.FormData;
  Blob5 = shims.Blob;
  File3 = shims.File;
  ReadableStream5 = shims.ReadableStream;
  getMultipartRequestOptions3 = shims.getMultipartRequestOptions;
  getDefaultAgent2 = shims.getDefaultAgent;
  fileFromPath4 = shims.fileFromPath;
  isFsReadStream2 = shims.isFsReadStream;
}

// ../node_modules/groq-sdk/_shims/node-runtime.mjs
init_lib();
var import_agentkeepalive2 = __toESM(require_agentkeepalive(), 1);
var import_abort_controller2 = __toESM(require_abort_controller(), 1);
import { ReadStream as FsReadStream2 } from "fs";
import { Readable as Readable4 } from "stream";

// ../node_modules/groq-sdk/_shims/MultipartBody.mjs
var MultipartBody2 = class {
  constructor(body) {
    this.body = body;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
};

// ../node_modules/groq-sdk/_shims/node-runtime.mjs
import { ReadableStream as ReadableStream6 } from "stream/web";
var fileFromPathWarned2 = false;
async function fileFromPath5(path2, ...args) {
  const { fileFromPath: _fileFromPath } = await Promise.resolve().then(() => (init_fileFromPath(), fileFromPath_exports));
  if (!fileFromPathWarned2) {
    console.warn(`fileFromPath is deprecated; use fs.createReadStream(${JSON.stringify(path2)}) instead`);
    fileFromPathWarned2 = true;
  }
  return await _fileFromPath(path2, ...args);
}
var defaultHttpAgent2 = new import_agentkeepalive2.default({ keepAlive: true, timeout: 5 * 60 * 1e3 });
var defaultHttpsAgent2 = new import_agentkeepalive2.default.HttpsAgent({ keepAlive: true, timeout: 5 * 60 * 1e3 });
async function getMultipartRequestOptions4(form, opts) {
  const encoder = new FormDataEncoder(form);
  const readable = Readable4.from(encoder);
  const body = new MultipartBody2(readable);
  const headers = {
    ...opts.headers,
    ...encoder.headers,
    "Content-Length": encoder.contentLength
  };
  return { ...opts, body, headers };
}
function getRuntime2() {
  if (typeof AbortController === "undefined") {
    globalThis.AbortController = import_abort_controller2.AbortController;
  }
  return {
    kind: "node",
    fetch: lib_default,
    Request: Request3,
    Response: Response3,
    Headers: Headers3,
    FormData: FormData3,
    Blob: Blob4,
    File: File2,
    ReadableStream: ReadableStream6,
    getMultipartRequestOptions: getMultipartRequestOptions4,
    getDefaultAgent: (url) => url.startsWith("https") ? defaultHttpsAgent2 : defaultHttpAgent2,
    fileFromPath: fileFromPath5,
    isFsReadStream: (value) => value instanceof FsReadStream2
  };
}

// ../node_modules/groq-sdk/_shims/index.mjs
if (!kind2) setShims2(getRuntime2(), { auto: true });

// ../node_modules/groq-sdk/error.mjs
var GroqError = class extends Error {
};
var APIError2 = class _APIError extends GroqError {
  constructor(status, error, message, headers) {
    super(`${_APIError.makeMessage(status, error, message)}`);
    this.status = status;
    this.headers = headers;
    this.error = error;
  }
  static makeMessage(status, error, message) {
    const msg = error?.message ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status || !headers) {
      return new APIConnectionError2({ message, cause: castToError2(errorResponse) });
    }
    const error = errorResponse;
    if (status === 400) {
      return new BadRequestError2(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError2(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError2(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError2(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError2(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError2(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError2(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError2(status, error, message, headers);
    }
    return new _APIError(status, error, message, headers);
  }
};
var APIUserAbortError2 = class extends APIError2 {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
  }
};
var APIConnectionError2 = class extends APIError2 {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    if (cause)
      this.cause = cause;
  }
};
var APIConnectionTimeoutError2 = class extends APIConnectionError2 {
  constructor({ message } = {}) {
    super({ message: message ?? "Request timed out." });
  }
};
var BadRequestError2 = class extends APIError2 {
};
var AuthenticationError2 = class extends APIError2 {
};
var PermissionDeniedError2 = class extends APIError2 {
};
var NotFoundError2 = class extends APIError2 {
};
var ConflictError2 = class extends APIError2 {
};
var UnprocessableEntityError2 = class extends APIError2 {
};
var RateLimitError2 = class extends APIError2 {
};
var InternalServerError2 = class extends APIError2 {
};

// ../node_modules/groq-sdk/lib/streaming.mjs
var Stream3 = class _Stream {
  constructor(iterator, controller) {
    this.iterator = iterator;
    this.controller = controller;
  }
  static fromSSEResponse(response, controller) {
    let consumed = false;
    const decoder = new SSEDecoder2();
    async function* iterMessages() {
      if (!response.body) {
        controller.abort();
        throw new GroqError(`Attempted to iterate over a response with no body`);
      }
      const lineDecoder = new LineDecoder2();
      const iter = readableStreamAsyncIterable(response.body);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          const sse = decoder.decode(line);
          if (sse)
            yield sse;
        }
      }
      for (const line of lineDecoder.flush()) {
        const sse = decoder.decode(line);
        if (sse)
          yield sse;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of iterMessages()) {
          if (done)
            continue;
          if (sse.data.startsWith("[DONE]")) {
            done = true;
            continue;
          }
          if (sse.event === null || sse.event === "error") {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e2) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e2;
            }
            if (data && data.error) {
              throw new APIError2(data.error.status_code, data.error, data.error.message, void 0);
            }
            yield data;
          }
        }
        done = true;
      } catch (e2) {
        if (e2 instanceof Error && e2.name === "AbortError")
          return;
        throw e2;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new _Stream(iterator, controller);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(readableStream, controller) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder2();
      const iter = readableStreamAsyncIterable(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done)
            continue;
          if (line)
            yield JSON.parse(line);
        }
        done = true;
      } catch (e2) {
        if (e2 instanceof Error && e2.name === "AbortError")
          return;
        throw e2;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new _Stream(iterator, controller);
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const left = [];
    const right = [];
    const iterator = this.iterator();
    const teeIterator = (queue) => {
      return {
        next: () => {
          if (queue.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue.shift();
        }
      };
    };
    return [
      new _Stream(() => teeIterator(left), this.controller),
      new _Stream(() => teeIterator(right), this.controller)
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const self2 = this;
    let iter;
    const encoder = new TextEncoder();
    return new ReadableStream5({
      async start() {
        iter = self2[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done)
            return ctrl.close();
          const bytes = encoder.encode(JSON.stringify(value) + "\n");
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        await iter.return?.();
      }
    });
  }
};
var SSEDecoder2 = class {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _2, value] = partition2(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
};
var LineDecoder2 = class _LineDecoder {
  constructor() {
    this.buffer = [];
    this.trailingCR = false;
  }
  decode(chunk) {
    let text = this.decodeText(chunk);
    if (this.trailingCR) {
      text = "\r" + text;
      this.trailingCR = false;
    }
    if (text.endsWith("\r")) {
      this.trailingCR = true;
      text = text.slice(0, -1);
    }
    if (!text) {
      return [];
    }
    const trailingNewline = _LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || "");
    let lines = text.split(_LineDecoder.NEWLINE_REGEXP);
    if (lines.length === 1 && !trailingNewline) {
      this.buffer.push(lines[0]);
      return [];
    }
    if (this.buffer.length > 0) {
      lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
      this.buffer = [];
    }
    if (!trailingNewline) {
      this.buffer = [lines.pop() || ""];
    }
    return lines;
  }
  decodeText(bytes) {
    if (bytes == null)
      return "";
    if (typeof bytes === "string")
      return bytes;
    if (typeof Buffer !== "undefined") {
      if (bytes instanceof Buffer) {
        return bytes.toString();
      }
      if (bytes instanceof Uint8Array) {
        return Buffer.from(bytes).toString();
      }
      throw new GroqError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
    }
    if (typeof TextDecoder !== "undefined") {
      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
        this.textDecoder ?? (this.textDecoder = new TextDecoder("utf8"));
        return this.textDecoder.decode(bytes);
      }
      throw new GroqError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
    }
    throw new GroqError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);
  }
  flush() {
    if (!this.buffer.length && !this.trailingCR) {
      return [];
    }
    const lines = [this.buffer.join("")];
    this.buffer = [];
    this.trailingCR = false;
    return lines;
  }
};
LineDecoder2.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r", "\v", "\f", "", "", "", "\x85", "\u2028", "\u2029"]);
LineDecoder2.NEWLINE_REGEXP = /\r\n|[\n\r\x0b\x0c\x1c\x1d\x1e\x85\u2028\u2029]/g;
function partition2(str, delimiter) {
  const index = str.indexOf(delimiter);
  if (index !== -1) {
    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];
  }
  return [str, "", ""];
}
function readableStreamAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result?.done)
          reader.releaseLock();
        return result;
      } catch (e2) {
        reader.releaseLock();
        throw e2;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}

// ../node_modules/groq-sdk/uploads.mjs
var isResponseLike2 = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
var isFileLike3 = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike2(value);
var isBlobLike2 = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
var isUploadable = (value) => {
  return isFileLike3(value) || isResponseLike2(value) || isFsReadStream2(value);
};
async function toFile2(value, name, options) {
  value = await value;
  if (isFileLike3(value)) {
    return value;
  }
  if (isResponseLike2(value)) {
    const blob = await value.blob();
    name || (name = new URL(value.url).pathname.split(/[\\/]/).pop() ?? "unknown_file");
    const data = isBlobLike2(blob) ? [await blob.arrayBuffer()] : [blob];
    return new File3(data, name, options);
  }
  const bits = await getBytes2(value);
  name || (name = getName2(value) ?? "unknown_file");
  if (!options?.type) {
    const type = bits[0]?.type;
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return new File3(bits, name, options);
}
async function getBytes2(value) {
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike2(value)) {
    parts.push(await value.arrayBuffer());
  } else if (isAsyncIterableIterator2(value)) {
    for await (const chunk of value) {
      parts.push(chunk);
    }
  } else {
    throw new Error(`Unexpected data type: ${typeof value}; constructor: ${value?.constructor?.name}; props: ${propsForError2(value)}`);
  }
  return parts;
}
function propsForError2(value) {
  const props = Object.getOwnPropertyNames(value);
  return `[${props.map((p2) => `"${p2}"`).join(", ")}]`;
}
function getName2(value) {
  return getStringFromMaybeBuffer2(value.name) || getStringFromMaybeBuffer2(value.filename) || // For fs.ReadStream
  getStringFromMaybeBuffer2(value.path)?.split(/[\\/]/).pop();
}
var getStringFromMaybeBuffer2 = (x2) => {
  if (typeof x2 === "string")
    return x2;
  if (typeof Buffer !== "undefined" && x2 instanceof Buffer)
    return String(x2);
  return void 0;
};
var isAsyncIterableIterator2 = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
var isMultipartBody2 = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";
var multipartFormRequestOptions = async (opts) => {
  const form = await createForm(opts.body);
  return getMultipartRequestOptions3(form, opts);
};
var createForm = async (body) => {
  const form = new FormData4();
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
  return form;
};
var addFormValue = async (form, key, value) => {
  if (value === void 0)
    return;
  if (value == null) {
    throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (isUploadable(value)) {
    const file = await toFile2(value);
    form.append(key, file);
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
  } else if (typeof value === "object") {
    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));
  } else {
    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
  }
};

// ../node_modules/groq-sdk/core.mjs
var __classPrivateFieldSet9 = function(receiver, state, value, kind3, f2) {
  if (kind3 === "m") throw new TypeError("Private method is not writable");
  if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind3 === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet10 = function(receiver, state, kind3, f2) {
  if (kind3 === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind3 === "m" ? f2 : kind3 === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _AbstractPage_client2;
async function defaultParseResponse2(props) {
  const { response } = props;
  if (props.options.stream) {
    debug2("response", response.status, response.url, response.headers, response.body);
    if (props.options.__streamClass) {
      return props.options.__streamClass.fromSSEResponse(response, props.controller);
    }
    return Stream3.fromSSEResponse(response, props.controller);
  }
  if (response.status === 204) {
    return null;
  }
  if (props.options.__binaryResponse) {
    return response;
  }
  const contentType = response.headers.get("content-type");
  const mediaType = contentType?.split(";")[0]?.trim();
  const isJSON = mediaType?.includes("application/json") || mediaType?.endsWith("+json");
  if (isJSON) {
    const json = await response.json();
    debug2("response", response.status, response.url, response.headers, json);
    return json;
  }
  const text = await response.text();
  debug2("response", response.status, response.url, response.headers, text);
  return text;
}
var APIPromise2 = class _APIPromise extends Promise {
  constructor(responsePromise, parseResponse = defaultParseResponse2) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse;
  }
  _thenUnwrap(transform) {
    return new _APIPromise(this.responsePromise, async (props) => transform(await this.parseResponse(props), props));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import  from 'groq-sdk'`:
   * - `import 'groq-sdk/shims/node'` (if you're running on Node)
   * - `import 'groq-sdk/shims/web'` (otherwise)
   */
  asResponse() {
    return this.responsePromise.then((p2) => p2.response);
  }
  /**
   * Gets the parsed response data and the raw `Response` instance.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import  from 'groq-sdk'`:
   * - `import 'groq-sdk/shims/node'` (if you're running on Node)
   * - `import 'groq-sdk/shims/web'` (otherwise)
   */
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then(this.parseResponse);
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
};
var APIClient2 = class {
  constructor({
    baseURL,
    maxRetries = 2,
    timeout = 6e4,
    // 1 minute
    httpAgent,
    fetch: overriddenFetch
  }) {
    this.baseURL = baseURL;
    this.maxRetries = validatePositiveInteger2("maxRetries", maxRetries);
    this.timeout = validatePositiveInteger2("timeout", timeout);
    this.httpAgent = httpAgent;
    this.fetch = overriddenFetch ?? fetch4;
  }
  authHeaders(opts) {
    return {};
  }
  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */
  defaultHeaders(opts) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...getPlatformHeaders2(),
      ...this.authHeaders(opts)
    };
  }
  /**
   * Override this to add your own headers validation:
   */
  validateHeaders(headers, customHeaders) {
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid42()}`;
  }
  get(path2, opts) {
    return this.methodRequest("get", path2, opts);
  }
  post(path2, opts) {
    return this.methodRequest("post", path2, opts);
  }
  patch(path2, opts) {
    return this.methodRequest("patch", path2, opts);
  }
  put(path2, opts) {
    return this.methodRequest("put", path2, opts);
  }
  delete(path2, opts) {
    return this.methodRequest("delete", path2, opts);
  }
  methodRequest(method, path2, opts) {
    return this.request(Promise.resolve(opts).then(async (opts2) => {
      const body = opts2 && isBlobLike2(opts2?.body) ? new DataView(await opts2.body.arrayBuffer()) : opts2?.body instanceof DataView ? opts2.body : opts2?.body instanceof ArrayBuffer ? new DataView(opts2.body) : opts2 && ArrayBuffer.isView(opts2?.body) ? new DataView(opts2.body.buffer) : opts2?.body;
      return { method, path: path2, ...opts2, body };
    }));
  }
  getAPIList(path2, Page2, opts) {
    return this.requestAPIList(Page2, { method: "get", path: path2, ...opts });
  }
  calculateContentLength(body) {
    if (typeof body === "string") {
      if (typeof Buffer !== "undefined") {
        return Buffer.byteLength(body, "utf8").toString();
      }
      if (typeof TextEncoder !== "undefined") {
        const encoder = new TextEncoder();
        const encoded = encoder.encode(body);
        return encoded.length.toString();
      }
    } else if (ArrayBuffer.isView(body)) {
      return body.byteLength.toString();
    }
    return null;
  }
  buildRequest(options, { retryCount = 0 } = {}) {
    options = { ...options };
    const { method, path: path2, query, headers = {} } = options;
    const body = ArrayBuffer.isView(options.body) || options.__binaryRequest && typeof options.body === "string" ? options.body : isMultipartBody2(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
    const contentLength = this.calculateContentLength(body);
    const url = this.buildURL(path2, query);
    if ("timeout" in options)
      validatePositiveInteger2("timeout", options.timeout);
    options.timeout = options.timeout ?? this.timeout;
    const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent2(url);
    const minAgentTimeout = options.timeout + 1e3;
    if (typeof httpAgent?.options?.timeout === "number" && minAgentTimeout > (httpAgent.options.timeout ?? 0)) {
      httpAgent.options.timeout = minAgentTimeout;
    }
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      headers[this.idempotencyHeader] = options.idempotencyKey;
    }
    const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });
    const req = {
      method,
      ...body && { body },
      headers: reqHeaders,
      ...httpAgent && { agent: httpAgent },
      // @ts-ignore node-fetch uses a custom AbortSignal type that is
      // not compatible with standard web types
      signal: options.signal ?? null
    };
    return { req, url, timeout: options.timeout };
  }
  buildHeaders({ options, headers, contentLength, retryCount }) {
    const reqHeaders = {};
    if (contentLength) {
      reqHeaders["content-length"] = contentLength;
    }
    const defaultHeaders = this.defaultHeaders(options);
    applyHeadersMut2(reqHeaders, defaultHeaders);
    applyHeadersMut2(reqHeaders, headers);
    if (isMultipartBody2(options.body) && kind2 !== "node") {
      delete reqHeaders["content-type"];
    }
    if (getHeader2(defaultHeaders, "x-stainless-retry-count") === void 0 && getHeader2(headers, "x-stainless-retry-count") === void 0) {
      reqHeaders["x-stainless-retry-count"] = String(retryCount);
    }
    if (getHeader2(defaultHeaders, "x-stainless-timeout") === void 0 && getHeader2(headers, "x-stainless-timeout") === void 0 && options.timeout) {
      reqHeaders["x-stainless-timeout"] = String(options.timeout);
    }
    this.validateHeaders(reqHeaders, headers);
    return reqHeaders;
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(options) {
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(request, { url, options }) {
  }
  parseHeaders(headers) {
    return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
  }
  makeStatusError(status, error, message, headers) {
    return APIError2.generate(status, error, message, headers);
  }
  request(options, remainingRetries = null) {
    return new APIPromise2(this.makeRequest(options, remainingRetries));
  }
  async makeRequest(optionsInput, retriesRemaining) {
    const options = await optionsInput;
    const maxRetries = options.maxRetries ?? this.maxRetries;
    if (retriesRemaining == null) {
      retriesRemaining = maxRetries;
    }
    await this.prepareOptions(options);
    const { req, url, timeout } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });
    await this.prepareRequest(req, { url, options });
    debug2("request", url, options, req.headers);
    if (options.signal?.aborted) {
      throw new APIUserAbortError2();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError2);
    if (response instanceof Error) {
      if (options.signal?.aborted) {
        throw new APIUserAbortError2();
      }
      if (retriesRemaining) {
        return this.retryRequest(options, retriesRemaining);
      }
      if (response.name === "AbortError") {
        throw new APIConnectionTimeoutError2();
      }
      throw new APIConnectionError2({ cause: response });
    }
    const responseHeaders = createResponseHeaders2(response.headers);
    if (!response.ok) {
      if (retriesRemaining && this.shouldRetry(response)) {
        const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
        debug2(`response (error; ${retryMessage2})`, response.status, url, responseHeaders);
        return this.retryRequest(options, retriesRemaining, responseHeaders);
      }
      const errText = await response.text().catch((e2) => castToError2(e2).message);
      const errJSON = safeJSON2(errText);
      const errMessage = errJSON ? void 0 : errText;
      const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;
      debug2(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);
      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
      throw err;
    }
    return { response, options, controller };
  }
  requestAPIList(Page2, options) {
    const request = this.makeRequest(options, null);
    return new PagePromise2(this, request, Page2);
  }
  buildURL(path2, query) {
    const url = isAbsoluteURL2(path2) ? new URL(path2) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path2.startsWith("/") ? path2.slice(1) : path2));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj2(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  stringifyQuery(query) {
    return Object.entries(query).filter(([_2, value]) => typeof value !== "undefined").map(([key, value]) => {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      }
      if (value === null) {
        return `${encodeURIComponent(key)}=`;
      }
      throw new GroqError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  async fetchWithTimeout(url, init, ms, controller) {
    const { signal, ...options } = init || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    const fetchOptions = {
      signal: controller.signal,
      ...options
    };
    if (fetchOptions.method) {
      fetchOptions.method = fetchOptions.method.toUpperCase();
    }
    return (
      // use undefined this binding; fetch errors if bound to something else in browser/cloudflare
      this.fetch.call(void 0, url, fetchOptions).finally(() => {
        clearTimeout(timeout);
      })
    );
  }
  shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, responseHeaders) {
    let timeoutMillis;
    const retryAfterMillisHeader = responseHeaders?.["retry-after-ms"];
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }
    const retryAfterHeader = responseHeaders?.["retry-after"];
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1e3;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
      const maxRetries = options.maxRetries ?? this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep3(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1e3;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION2}`;
  }
};
var AbstractPage2 = class {
  constructor(client, response, body, options) {
    _AbstractPage_client2.set(this, void 0);
    __classPrivateFieldSet9(this, _AbstractPage_client2, client, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageInfo() != null;
  }
  async getNextPage() {
    const nextInfo = this.nextPageInfo();
    if (!nextInfo) {
      throw new GroqError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    }
    const nextOptions = { ...this.options };
    if ("params" in nextInfo && typeof nextOptions.query === "object") {
      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
    } else if ("url" in nextInfo) {
      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
      for (const [key, value] of params) {
        nextInfo.url.searchParams.set(key, value);
      }
      nextOptions.query = void 0;
      nextOptions.path = nextInfo.url.toString();
    }
    return await __classPrivateFieldGet10(this, _AbstractPage_client2, "f").requestAPIList(this.constructor, nextOptions);
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[(_AbstractPage_client2 = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
};
var PagePromise2 = class extends APIPromise2 {
  constructor(client, request, Page2) {
    super(request, async (props) => new Page2(client, props.response, await defaultParseResponse2(props), props.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
};
var createResponseHeaders2 = (headers) => {
  return new Proxy(Object.fromEntries(
    // @ts-ignore
    headers.entries()
  ), {
    get(target, name) {
      const key = name.toString();
      return target[key.toLowerCase()] || target[key];
    }
  });
};
var getPlatformProperties2 = () => {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION2,
      "X-Stainless-OS": normalizePlatform2(Deno.build.os),
      "X-Stainless-Arch": normalizeArch2(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : Deno.version?.deno ?? "unknown"
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION2,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION2,
      "X-Stainless-OS": normalizePlatform2(process.platform),
      "X-Stainless-Arch": normalizeArch2(process.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  const browserInfo = getBrowserInfo2();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION2,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION2,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo2() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match7 = pattern.exec(navigator.userAgent);
    if (match7) {
      const major = match7[1] || 0;
      const minor = match7[2] || 0;
      const patch = match7[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch2 = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
var normalizePlatform2 = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
};
var _platformHeaders2;
var getPlatformHeaders2 = () => {
  return _platformHeaders2 ?? (_platformHeaders2 = getPlatformProperties2());
};
var safeJSON2 = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};
var startsWithSchemeRegexp2 = /^[a-z][a-z0-9+.-]*:/i;
var isAbsoluteURL2 = (url) => {
  return startsWithSchemeRegexp2.test(url);
};
var sleep3 = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var validatePositiveInteger2 = (name, n2) => {
  if (typeof n2 !== "number" || !Number.isInteger(n2)) {
    throw new GroqError(`${name} must be an integer`);
  }
  if (n2 < 0) {
    throw new GroqError(`${name} must be a positive integer`);
  }
  return n2;
};
var castToError2 = (err) => {
  if (err instanceof Error)
    return err;
  if (typeof err === "object" && err !== null) {
    try {
      return new Error(JSON.stringify(err));
    } catch {
    }
  }
  return new Error(err);
};
var readEnv2 = (env) => {
  if (typeof process !== "undefined") {
    return process.env?.[env]?.trim() ?? void 0;
  }
  if (typeof Deno !== "undefined") {
    return Deno.env?.get?.(env)?.trim();
  }
  return void 0;
};
function isEmptyObj2(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn2(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function applyHeadersMut2(targetHeaders, newHeaders) {
  for (const k2 in newHeaders) {
    if (!hasOwn2(newHeaders, k2))
      continue;
    const lowerKey = k2.toLowerCase();
    if (!lowerKey)
      continue;
    const val = newHeaders[k2];
    if (val === null) {
      delete targetHeaders[lowerKey];
    } else if (val !== void 0) {
      targetHeaders[lowerKey] = val;
    }
  }
}
function debug2(action, ...args) {
  if (typeof process !== "undefined" && process?.env?.["DEBUG"] === "true") {
    console.log(`Groq:DEBUG:${action}`, ...args);
  }
}
var uuid42 = () => {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c2) => {
    const r2 = Math.random() * 16 | 0;
    const v2 = c2 === "x" ? r2 : r2 & 3 | 8;
    return v2.toString(16);
  });
};
var isRunningInBrowser2 = () => {
  return (
    // @ts-ignore
    typeof window !== "undefined" && // @ts-ignore
    typeof window.document !== "undefined" && // @ts-ignore
    typeof navigator !== "undefined"
  );
};
var isHeadersProtocol2 = (headers) => {
  return typeof headers?.get === "function";
};
var getHeader2 = (headers, header) => {
  const lowerCasedHeader = header.toLowerCase();
  if (isHeadersProtocol2(headers)) {
    const intercapsHeader = header[0]?.toUpperCase() + header.substring(1).replace(/([^\w])(\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());
    for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {
      const value = headers.get(key);
      if (value) {
        return value;
      }
    }
  }
  for (const [key, value] of Object.entries(headers)) {
    if (key.toLowerCase() === lowerCasedHeader) {
      if (Array.isArray(value)) {
        if (value.length <= 1)
          return value[0];
        console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);
        return value[0];
      }
      return value;
    }
  }
  return void 0;
};

// ../node_modules/groq-sdk/resource.mjs
var APIResource2 = class {
  constructor(client) {
    this._client = client;
  }
};

// ../node_modules/groq-sdk/resources/audio/transcriptions.mjs
var Transcriptions = class extends APIResource2 {
  /**
   * Transcribes audio into the input language.
   */
  create(body, options) {
    return this._client.post("/openai/v1/audio/transcriptions", multipartFormRequestOptions({ body, ...options }));
  }
};

// ../node_modules/groq-sdk/resources/audio/translations.mjs
var Translations = class extends APIResource2 {
  /**
   * Translates audio into English.
   */
  create(body, options) {
    return this._client.post("/openai/v1/audio/translations", multipartFormRequestOptions({ body, ...options }));
  }
};

// ../node_modules/groq-sdk/resources/audio/audio.mjs
var Audio = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.transcriptions = new Transcriptions(this._client);
    this.translations = new Translations(this._client);
  }
};
Audio.Transcriptions = Transcriptions;
Audio.Translations = Translations;

// ../node_modules/groq-sdk/resources/batches.mjs
var Batches4 = class extends APIResource2 {
  /**
   * Creates and executes a batch from an uploaded file of requests
   */
  create(body, options) {
    return this._client.post("/openai/v1/batches", { body, ...options });
  }
  /**
   * Retrieves a batch.
   */
  retrieve(batchId, options) {
    return this._client.get(`/openai/v1/batches/${batchId}`, options);
  }
  /**
   * List your organization's batches.
   */
  list(options) {
    return this._client.get("/openai/v1/batches", options);
  }
};

// ../node_modules/groq-sdk/resources/chat/completions.mjs
var Completions2 = class extends APIResource2 {
  create(body, options) {
    return this._client.post("/openai/v1/chat/completions", {
      body,
      ...options,
      stream: body.stream ?? false
    });
  }
};

// ../node_modules/groq-sdk/resources/chat/chat.mjs
var Chat2 = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.completions = new Completions2(this._client);
  }
};
Chat2.Completions = Completions2;

// ../node_modules/groq-sdk/resources/completions.mjs
var Completions3 = class extends APIResource2 {
};

// ../node_modules/groq-sdk/resources/embeddings.mjs
var Embeddings = class extends APIResource2 {
  /**
   * Creates an embedding vector representing the input text.
   */
  create(body, options) {
    return this._client.post("/openai/v1/embeddings", { body, ...options });
  }
};

// ../node_modules/groq-sdk/resources/files.mjs
var Files2 = class extends APIResource2 {
  /**
   * Upload a file that can be used across various endpoints.
   *
   * The Batch API only supports `.jsonl` files up to 100 MB in size. The input also
   * has a specific required [format](/docs/batch).
   *
   * Please contact us if you need to increase these storage limits.
   */
  create(body, options) {
    return this._client.post("/openai/v1/files", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Returns a list of files.
   */
  list(options) {
    return this._client.get("/openai/v1/files", options);
  }
  /**
   * Delete a file.
   */
  delete(fileId, options) {
    return this._client.delete(`/openai/v1/files/${fileId}`, options);
  }
  /**
   * Returns the contents of the specified file.
   */
  content(fileId, options) {
    return this._client.get(`/openai/v1/files/${fileId}/content`, options);
  }
  /**
   * Returns information about a file.
   */
  info(fileId, options) {
    return this._client.get(`/openai/v1/files/${fileId}`, options);
  }
};

// ../node_modules/groq-sdk/resources/models.mjs
var Models4 = class extends APIResource2 {
  /**
   * Get a specific model
   */
  retrieve(model, options) {
    return this._client.get(`/openai/v1/models/${model}`, options);
  }
  /**
   * get all available models
   */
  list(options) {
    return this._client.get("/openai/v1/models", options);
  }
  /**
   * Delete a model
   */
  delete(model, options) {
    return this._client.delete(`/openai/v1/models/${model}`, options);
  }
};

// ../node_modules/groq-sdk/index.mjs
var _a2;
var Groq = class extends APIClient2 {
  /**
   * API Client for interfacing with the Groq API.
   *
   * @param {string | undefined} [opts.apiKey=process.env['GROQ_API_KEY'] ?? undefined]
   * @param {string} [opts.baseURL=process.env['GROQ_BASE_URL'] ?? https://api.groq.com] - Override the default base URL for the API.
   * @param {number} [opts.timeout=1 minute] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL = readEnv2("GROQ_BASE_URL"), apiKey = readEnv2("GROQ_API_KEY"), ...opts } = {}) {
    if (apiKey === void 0) {
      throw new GroqError("The GROQ_API_KEY environment variable is missing or empty; either provide it, or instantiate the Groq client with an apiKey option, like new Groq({ apiKey: 'My API Key' }).");
    }
    const options = {
      apiKey,
      ...opts,
      baseURL: baseURL || `https://api.groq.com`
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser2()) {
      throw new GroqError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew Groq({ apiKey, dangerouslyAllowBrowser: true })");
    }
    super({
      baseURL: options.baseURL,
      timeout: options.timeout ?? 6e4,
      httpAgent: options.httpAgent,
      maxRetries: options.maxRetries,
      fetch: options.fetch
    });
    this.completions = new Completions3(this);
    this.chat = new Chat2(this);
    this.embeddings = new Embeddings(this);
    this.audio = new Audio(this);
    this.models = new Models4(this);
    this.batches = new Batches4(this);
    this.files = new Files2(this);
    this._options = options;
    this.apiKey = apiKey;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(opts) {
    return {
      ...super.defaultHeaders(opts),
      ...this._options.defaultHeaders
    };
  }
  authHeaders(opts) {
    return { Authorization: `Bearer ${this.apiKey}` };
  }
};
_a2 = Groq;
Groq.Groq = _a2;
Groq.DEFAULT_TIMEOUT = 6e4;
Groq.GroqError = GroqError;
Groq.APIError = APIError2;
Groq.APIConnectionError = APIConnectionError2;
Groq.APIConnectionTimeoutError = APIConnectionTimeoutError2;
Groq.APIUserAbortError = APIUserAbortError2;
Groq.NotFoundError = NotFoundError2;
Groq.ConflictError = ConflictError2;
Groq.RateLimitError = RateLimitError2;
Groq.BadRequestError = BadRequestError2;
Groq.AuthenticationError = AuthenticationError2;
Groq.InternalServerError = InternalServerError2;
Groq.PermissionDeniedError = PermissionDeniedError2;
Groq.UnprocessableEntityError = UnprocessableEntityError2;
Groq.toFile = toFile2;
Groq.fileFromPath = fileFromPath4;
Groq.Completions = Completions3;
Groq.Chat = Chat2;
Groq.Embeddings = Embeddings;
Groq.Audio = Audio;
Groq.Models = Models4;
Groq.Batches = Batches4;
Groq.Files = Files2;
var groq_sdk_default = Groq;

// ../node_modules/multi-llm-ts/dist/index.mjs
var import_mistralai = __toESM(require_mistralai(), 1);
import { Ollama } from "ollama/dist/browser.cjs";
var Message = class {
  role;
  content;
  reasoning;
  attachments;
  get contentForModel() {
    return this.content;
  }
  constructor(role, content = null, attachment) {
    this.role = role;
    this.reasoning = null;
    this.content = content !== null ? content : "";
    this.attachments = attachment ? [attachment] : [];
  }
  attach(attachment) {
    this.attachments.push(attachment);
  }
  detach(attachment) {
    const index = this.attachments.indexOf(attachment);
    if (index > -1) {
      this.attachments.splice(index, 1);
    }
  }
  appendText(chunk) {
    if (chunk?.text) {
      if (chunk?.type === "reasoning") {
        this.reasoning = (this.reasoning || "") + chunk.text;
      } else {
        this.content += chunk.text;
      }
    }
  }
};
var Plugin = class {
  serializeInTools() {
    return true;
  }
  isEnabled() {
    return false;
  }
  getName() {
    throw new Error("Not implemented");
  }
  getDescription() {
    throw new Error("Not implemented");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getPreparationDescription(tool) {
    return "";
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getRunningDescription(tool, args) {
    throw new Error("Not implemented");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getCompletedDescription(tool, args, results) {
    return void 0;
  }
  getParameters() {
    throw new Error("Not implemented");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async execute(context, parameters) {
    throw new Error("Not implemented");
  }
  // this is optional so not implemented by default
  // executeWithUpdates?(context: PluginExecutionContext , parameters: any): AsyncGenerator<PluginExecutionUpdate> {}
};
var MultiToolPlugin = class extends Plugin {
  // this allows for only specific tools of a multi-tool plugin to be enabled
  // if null, all tools are enabled
  // if empty, no tools are enabled
  // implementation should make sure that getTools and handlesTool
  // check toolsEnabled when responding
  // example:
  // handlesTool(name: string): boolean {
  //   const handled = ...
  //   return handled && (!this.toolsEnabled || this.toolsEnabled.includes(name))
  // }
  toolsEnabled = null;
  enableTool(name) {
    if (!this.toolsEnabled) {
      this.toolsEnabled = [];
    }
    if (!this.toolsEnabled.includes(name)) {
      this.toolsEnabled.push(name);
    }
  }
  getTools() {
    throw new Error("Not implemented");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  handlesTool(name) {
    return false;
  }
};
var zeroUsage = () => ({
  prompt_tokens: 0,
  completion_tokens: 0,
  prompt_tokens_details: {
    cached_tokens: 0,
    audio_tokens: 0
  },
  completion_tokens_details: {
    reasoning_tokens: 0,
    audio_tokens: 0
  }
});
var LlmEngine = class _LlmEngine {
  config;
  plugins;
  static isConfigured = (opts) => {
    return opts?.apiKey != null && opts.apiKey.length > 0;
  };
  static isReady = (opts, models) => {
    return _LlmEngine.isConfigured(opts) && models?.chat?.length > 0;
  };
  constructor(config) {
    this.config = config;
    this.plugins = [];
  }
  getName() {
    return this.getId();
  }
  addTextToPayload(message, attachment, payload, opts) {
    if (Array.isArray(payload.content)) {
      if (this.requiresFlatTextPayload(message)) {
        const existingText = payload.content.find((c2) => c2.type === "text");
        if (existingText) {
          existingText.text = `${existingText.text}

${attachment.content}`;
          return;
        }
      }
      payload.content.push({
        type: "text",
        text: attachment.content
      });
    } else if (typeof payload.content === "string") {
      payload.content = `${payload.content}

${attachment.content}`;
    }
  }
  addImageToPayload(attachment, payload, opts) {
    if (typeof payload.content === "string") {
      payload.content = [{
        type: "text",
        text: payload.content
      }];
    }
    if (Array.isArray(payload.content)) {
      payload.content.push({
        type: "image_url",
        image_url: { url: `data:${attachment.mimeType};base64,${attachment.content}` }
      });
    }
  }
  clearPlugins() {
    this.plugins = [];
  }
  addPlugin(plugin) {
    this.plugins = this.plugins.filter((p2) => p2.getName() !== plugin.getName());
    this.plugins.push(plugin);
  }
  async complete(model, thread, opts) {
    const chatModel = this.toModel(model);
    const messages = this.buildPayload(chatModel, thread, opts);
    return await this.chat(chatModel, messages, opts);
  }
  async *generate(model, thread, opts) {
    const chatModel = this.toModel(model);
    const response = await this.stream(chatModel, thread, opts);
    let currentStream = response.stream;
    while (true) {
      let nextStream = null;
      for await (const chunk of currentStream) {
        if (opts?.abortSignal?.aborted) {
          await currentStream.controller?.abort(opts?.abortSignal?.reason);
          return;
        }
        const llmChunkStream = this.nativeChunkToLlmChunk(chunk, response.context);
        for await (const msg of llmChunkStream) {
          if (opts?.abortSignal?.aborted) {
            await this.stop(currentStream);
            return;
          }
          if (msg.type === "stream") {
            nextStream = msg.stream;
          } else {
            if (nextStream !== null && msg.type === "content" && msg.done) {
              msg.done = false;
            }
            yield msg;
          }
        }
      }
      if (!nextStream) break;
      currentStream = nextStream;
    }
  }
  requiresVisionModelSwitch(thread, currentModel) {
    if (currentModel.capabilities.vision) {
      return false;
    }
    return thread.some((msg) => msg.attachments.some((a2) => a2.isImage()));
  }
  selectModel(model, thread, opts) {
    if (!opts) {
      return model;
    }
    if (this.requiresVisionModelSwitch(thread, model)) {
      if (!opts.visionFallbackModel) {
        console.debug("Cannot switch to vision model as no models provided in LlmCompletionOpts");
        return model;
      }
      return opts.visionFallbackModel;
    }
    return model;
  }
  requiresFlatTextPayload(msg) {
    return ["system", "assistant"].includes(msg.role);
  }
  buildPayload(model, thread, opts) {
    if (typeof thread === "string") {
      return [{ role: "user", content: [{ type: "text", text: thread }] }];
    } else {
      return thread.filter((msg) => msg.contentForModel !== null).map((msg) => {
        const payload = {
          role: msg.role,
          content: this.requiresFlatTextPayload(msg) ? msg.contentForModel : [{
            type: "text",
            text: msg.contentForModel
          }]
        };
        const atts = Array.isArray(msg.attachments) ? msg.attachments : [];
        for (const attachment of atts) {
          if (attachment.content === null || attachment.content === void 0) {
            console.warn("Attachment contents not available. Skipping attachment.");
            continue;
          }
          if (attachment.isText()) {
            this.addTextToPayload(msg, attachment, payload, opts);
          }
          if (attachment.isImage() && model.capabilities.vision) {
            this.addImageToPayload(attachment, payload, opts);
          }
        }
        return payload;
      });
    }
  }
  async getAvailableTools() {
    const tools = [];
    for (const plugin of this.plugins) {
      if (!plugin.isEnabled()) {
        continue;
      }
      if (!plugin.serializeInTools()) {
        continue;
      }
      if ("getTools" in plugin) {
        const pluginAsTool = await plugin.getTools();
        if (Array.isArray(pluginAsTool)) {
          tools.push(...pluginAsTool);
        } else if (pluginAsTool) {
          tools.push(pluginAsTool);
        }
      } else {
        tools.push(this.getPluginAsTool(plugin));
      }
    }
    return tools;
  }
  // this is the default implementation as per OpenAI API
  // it is now almost a de facto standard and other providers
  // are following it such as MistralAI and others
  getPluginAsTool(plugin) {
    return {
      type: "function",
      function: {
        name: plugin.getName(),
        description: plugin.getDescription(),
        parameters: {
          type: "object",
          properties: plugin.getParameters().reduce((obj, param) => {
            obj[param.name] = {
              type: param.type || (param.items ? "array" : "string"),
              description: param.description
            };
            if (param.enum) {
              obj[param.name].enum = param.enum;
            }
            if (obj[param.name].type === "array") {
              if (!param.items) {
                obj[param.name].items = { type: "string" };
              } else if (!param.items.properties) {
                obj[param.name].items = { type: param.items.type };
              } else {
                obj[param.name].items = {
                  type: param.items.type || "object",
                  properties: param.items.properties.reduce((obj2, prop) => {
                    obj2[prop.name] = {
                      type: prop.type,
                      description: prop.description
                    };
                    return obj2;
                  }, {}),
                  required: param.items.properties.filter((prop) => prop.required).map((prop) => prop.name)
                };
              }
            }
            return obj;
          }, {}),
          required: plugin.getParameters().filter((param) => param.required).map((param) => param.name)
        }
      }
    };
  }
  getPluginForTool(tool) {
    const plugin = this.plugins.find((plugin2) => plugin2.getName() === tool);
    if (plugin) {
      return plugin;
    }
    for (const plugin2 of Object.values(this.plugins)) {
      if (plugin2 instanceof MultiToolPlugin) {
        const multiToolPlugin = plugin2;
        if (multiToolPlugin.handlesTool(tool)) {
          return plugin2;
        }
      }
    }
    return null;
  }
  getToolPreparationDescription(tool) {
    const plugin = this.getPluginForTool(tool);
    return plugin?.getPreparationDescription(tool) || "";
  }
  getToolRunningDescription(tool, args) {
    const plugin = this.getPluginForTool(tool);
    return plugin?.getRunningDescription(tool, args) || "";
  }
  getToolCompletedDescription(tool, args, results) {
    const plugin = this.getPluginForTool(tool);
    return plugin?.getCompletedDescription(tool, args, results);
  }
  async *callTool(context, tool, args) {
    let payload = args;
    let toolOwner = this.plugins.find((plugin) => plugin.getName() === tool);
    if (!toolOwner) {
      for (const plugin of Object.values(this.plugins)) {
        if (plugin instanceof MultiToolPlugin) {
          const multiToolPlugin = plugin;
          if (multiToolPlugin.handlesTool(tool)) {
            toolOwner = plugin;
            payload = { tool, parameters: args };
            break;
          }
        }
      }
    }
    if (!toolOwner) {
      yield {
        type: "result",
        result: { error: `Tool ${tool} does not exist. Check the tool list and try again.` }
      };
      return;
    }
    if ("executeWithUpdates" in toolOwner) {
      for await (const update of toolOwner.executeWithUpdates(args, payload)) {
        yield update;
      }
    } else {
      const result = await toolOwner.execute(context, payload);
      yield {
        type: "result",
        result
      };
    }
  }
  toModel(model) {
    if (typeof model === "object") {
      return model;
    } else {
      return this.buildModel(model);
    }
  }
  buildModel(model) {
    return {
      id: model,
      name: model,
      capabilities: this.getModelCapabilities({
        id: model,
        name: model
      })
    };
  }
};
var _log = console.log;
var logger_default = {
  // Standard log method  for general info-level logging
  log: (...args) => _log(...args),
  // Debug helper  emits only when DEBUG flag is set
  debug: (...args) => {
    if (typeof process !== "undefined" && process.env.DEBUG) {
      _log(...args);
    }
  },
  // Allow callers to replace the underlying logger implementation (e.g. pino)
  setLogger: (logger2) => {
    _log = logger2;
  },
  // Disable all logging (both log & debug)
  disableLogger: () => {
    _log = () => {
    };
  }
};
var defaultBaseUrl = "https://api.openai.com/v1";
var openai_default = class extends LlmEngine {
  client;
  constructor(config, opts) {
    super(config);
    this.client = new OpenAI({
      apiKey: opts?.apiKey || config.apiKey,
      baseURL: opts?.baseURL || config.baseURL || defaultBaseUrl,
      timeout: opts?.timeout || config.timeout || void 0,
      dangerouslyAllowBrowser: true
    });
  }
  getId() {
    return "openai";
  }
  // https://openai.com/api/pricing/
  getModelCapabilities(model) {
    const visionGlobs = [
      "*vision*",
      "gpt-4-turbo*",
      "gpt-4-0125*",
      "gpt-4-1106-vision-preview",
      "gpt-4o*",
      "chatgpt-4o",
      "gpt-4.1*",
      "gpt-4.5*",
      "gpt-5*",
      "o1*",
      "o3*",
      "o4*"
    ];
    const excludeVisionGlobs = [
      "gpt-4o-mini-audio*",
      "o1-mini*",
      "o3-mini*"
    ];
    const modelId = model.id;
    return {
      tools: !modelId.includes("chat") && !modelId.startsWith("o1-mini"),
      vision: visionGlobs.some((m2) => minimatch(modelId, m2)) && !excludeVisionGlobs.some((m2) => minimatch(modelId, m2)),
      reasoning: modelId.startsWith("o") || modelId.startsWith("gpt-5"),
      caching: false
    };
  }
  modelAcceptsSystemRole(model) {
    return !model.startsWith("o1");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  modelSupportsMaxTokens(model) {
    return true;
  }
  modelSupportsTemperature(model) {
    return !model.capabilities.reasoning;
  }
  modelSupportsTopP(model) {
    return !model.capabilities.reasoning;
  }
  modelSupportsTopK(model) {
    return !model.capabilities.reasoning;
  }
  modelSupportsReasoningEffort(model) {
    return model.capabilities.reasoning;
  }
  modelSupportsVerbosity(model) {
    return model.id.startsWith("gpt-5");
  }
  modelRequiresResponsesApi(model) {
    return ["o3-pro*", "codex*"].some((m2) => minimatch(model.id, m2));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  modelSupportsStructuredOutput(model) {
    return true;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  doesNotSendToolCallFinishReason(model) {
    return false;
  }
  get systemRole() {
    return "system";
  }
  async getModels() {
    try {
      const response = await this.client.models.list();
      let models = response.data;
      if (models === null || models.length === 0) {
        if (response.body && Array.isArray(response.body)) {
          models = response.body;
        }
      }
      return models;
    } catch (error) {
      console.error("Error listing models:", error);
      return [];
    }
  }
  setBaseURL() {
    if (this.client) {
      this.client.baseURL = this.config.baseURL || defaultBaseUrl;
    }
  }
  shouldUseResponsesApi(model, opts) {
    return this.modelRequiresResponsesApi(model) || (opts?.useOpenAIResponsesApi ?? false) || (this.config.useOpenAIResponsesApi ?? false);
  }
  buildPayload(model, thread, opts) {
    let payload = super.buildPayload(model, thread, opts);
    if (!this.modelAcceptsSystemRole(model.id)) {
      payload = payload.filter((msg) => msg.role !== "system");
    } else if (this.systemRole !== "system") {
      payload = payload.map((msg) => {
        if (msg.role === "system") {
          msg.role = this.systemRole;
        }
        return msg;
      });
    }
    return payload;
  }
  async chat(model, thread, opts) {
    if (this.shouldUseResponsesApi(model, opts)) {
      return this.responsesChat(model, thread, opts);
    }
    this.setBaseURL();
    const toolCallInfo = [];
    logger_default.log(`[${this.getName()}] prompting model ${model.id}`);
    const response = await this.client.chat.completions.create({
      model: model.id,
      messages: thread,
      ...this.getCompletionOpts(model, opts),
      ...await this.getToolsOpts(model, opts)
    });
    const choice = response.choices?.[0];
    if (choice.message.tool_calls && (choice?.finish_reason === "tool_calls" || this.doesNotSendToolCallFinishReason(model))) {
      thread.push(choice.message);
      for (const tool_call of choice.message.tool_calls) {
        logger_default.log(`[openai] tool call ${tool_call.function.name} with ${tool_call.function.arguments}`);
        let args = null;
        try {
          args = JSON.parse(tool_call.function.arguments);
        } catch (err) {
          throw new Error(`[openai] tool call ${tool_call.function.name} with invalid JSON args: "${tool_call.function.arguments}"`, { cause: err });
        }
        let content = void 0;
        for await (const update of this.callTool({ model: model.id }, tool_call.function.name, args)) {
          if (update.type === "result") {
            content = update.result;
          }
        }
        logger_default.log(`[openai] tool call ${tool_call.function.name} => ${JSON.stringify(content).substring(0, 128)}`);
        thread.push({
          role: "tool",
          tool_call_id: tool_call.id,
          name: tool_call.function.name,
          content: JSON.stringify(content)
        });
        toolCallInfo.push({
          name: tool_call.function.name,
          params: args,
          result: content
        });
      }
      const completion = await this.chat(model, thread, opts);
      completion.toolCalls = [
        ...toolCallInfo,
        ...completion.toolCalls ?? []
      ];
      if (opts?.usage && response.usage && completion.usage) {
        this.accumulateUsage(completion.usage, response.usage);
      }
      return completion;
    }
    if (response.usage?.total_tokens) {
      delete response.usage.total_tokens;
    }
    return {
      type: "text",
      content: choice.message.content || "",
      toolCalls: toolCallInfo,
      ...opts?.usage && response.usage ? { usage: response.usage } : {}
    };
  }
  async stream(model, thread, opts) {
    if (this.shouldUseResponsesApi(model, opts)) {
      return this.responsesStream(model, thread, opts);
    }
    this.setBaseURL();
    model = this.selectModel(model, thread, opts);
    const context = {
      model,
      responsesApi: false,
      thread: this.buildPayload(model, thread, opts),
      opts: opts || {},
      toolCalls: [],
      usage: zeroUsage(),
      thinking: false,
      done: false
    };
    return {
      stream: await this.doStream(context),
      context
    };
  }
  async doStream(context) {
    context.toolCalls = [];
    logger_default.log(`[${this.getName()}] prompting model ${context.model.id}`);
    const stream = this.client.chat.completions.create({
      model: context.model.id,
      messages: context.thread,
      ...this.getCompletionOpts(context.model, context.opts),
      ...await this.getToolsOpts(context.model, context.opts),
      stream_options: { include_usage: context.opts.usage || false },
      stream: true
    });
    return stream;
  }
  getCompletionOpts(model, opts) {
    return {
      ...this.modelSupportsMaxTokens(model) && opts?.maxTokens ? { max_completion_tokens: opts?.maxTokens } : {},
      ...this.modelSupportsTemperature(model) && opts?.temperature ? { temperature: opts?.temperature } : {},
      ...this.modelSupportsTopK(model) && opts?.top_k ? { logprobs: true, top_logprobs: opts?.top_k } : {},
      ...this.modelSupportsTopP(model) && opts?.top_p ? { top_p: opts?.top_p } : {},
      ...this.modelSupportsReasoningEffort(model) && opts?.reasoningEffort ? { reasoning_effort: opts?.reasoningEffort } : {},
      ...this.modelSupportsVerbosity(model) && opts?.verbosity ? { verbosity: opts.verbosity } : {},
      ...this.modelSupportsStructuredOutput(model) && opts?.structuredOutput ? { response_format: zodResponseFormat(opts.structuredOutput.structure, opts.structuredOutput.name) } : {},
      ...opts?.customOpts ? opts.customOpts : {}
    };
  }
  async getToolsOpts(model, opts) {
    if (opts?.tools === false || !model.capabilities?.tools) {
      return {};
    }
    const tools = await this.getAvailableTools();
    if (!tools.length) return {};
    return {
      tools,
      tool_choice: opts?.toolChoice?.type === "tool" ? {
        type: "function",
        function: { name: opts.toolChoice.name }
      } : opts?.toolChoice?.type ?? "auto"
    };
  }
  async stop(stream) {
    stream?.controller?.abort();
  }
  async *nativeChunkToLlmChunk(chunk, context) {
    if (context.responsesApi) {
      yield chunk;
      return;
    }
    if (!chunk?.choices || !Array.isArray(chunk.choices)) {
      return;
    }
    if (chunk.usage && context.opts?.usage) {
      this.accumulateUsage(context.usage, chunk.usage);
    }
    for (const tool_call of chunk.choices[0]?.delta?.tool_calls || []) {
      if (tool_call?.function) {
        if (tool_call.id !== null && tool_call.id !== void 0 && tool_call.id !== "") {
          const existingToolCall = context.toolCalls.find((tc) => tc.id === tool_call.id);
          if (existingToolCall) {
            existingToolCall.args += tool_call.function.arguments;
          } else {
            const toolCall = {
              id: tool_call.id,
              message: chunk.choices[0].delta.tool_calls.map((tc) => {
                delete tc.index;
                return tc;
              }),
              function: tool_call.function.name || "",
              args: tool_call.function.arguments || ""
            };
            context.toolCalls.push(toolCall);
            yield {
              type: "tool",
              id: toolCall.id,
              name: toolCall.function,
              status: this.getToolPreparationDescription(toolCall.function),
              done: false
            };
          }
        } else {
          const toolCall = context.toolCalls[context.toolCalls.length - 1];
          toolCall.args += tool_call.function.arguments;
          toolCall.message[toolCall.message.length - 1].function.arguments = toolCall.args;
        }
      }
    }
    if (context.toolCalls.length && this.doesNotSendToolCallFinishReason(context.model)) {
      chunk.choices[0].finish_reason = chunk.choices[0].finish_reason || "tool_calls";
    }
    if (["tool_calls", "function_call", "stop"].includes(chunk.choices[0]?.finish_reason || "") && context.toolCalls?.length) {
      for (const toolCall of context.toolCalls) {
        logger_default.log(`[openai] tool call ${toolCall.function} with ${toolCall.args}`);
        let args = null;
        try {
          args = JSON.parse(toolCall.args);
        } catch (err) {
          throw new Error(`[openai] tool call ${toolCall.function} with invalid JSON args: "${toolCall.args}"`, { cause: err });
        }
        yield {
          type: "tool",
          id: toolCall.id,
          name: toolCall.function,
          status: this.getToolRunningDescription(toolCall.function, args),
          call: {
            params: args,
            result: void 0
          },
          done: false
        };
        let content = void 0;
        for await (const update of this.callTool({ model: context.model.id }, toolCall.function, args)) {
          if (update.type === "status") {
            yield {
              type: "tool",
              id: toolCall.id,
              name: toolCall.function,
              status: update.status,
              call: {
                params: args,
                result: void 0
              },
              done: false
            };
          } else if (update.type === "result") {
            content = update.result;
          }
        }
        logger_default.log(`[openai] tool call ${toolCall.function} => ${JSON.stringify(content).substring(0, 128)}`);
        context.thread.push({
          role: "assistant",
          content: "",
          tool_calls: toolCall.message
        });
        context.thread.push({
          role: "tool",
          tool_call_id: toolCall.id,
          name: toolCall.function,
          content: JSON.stringify(content)
        });
        yield {
          type: "tool",
          id: toolCall.id,
          name: toolCall.function,
          status: this.getToolCompletedDescription(toolCall.function, args, content),
          done: true,
          call: {
            params: args,
            result: content
          }
        };
      }
      if (context.opts.toolChoice?.type === "tool") {
        delete context.opts.toolChoice;
      }
      yield {
        type: "stream",
        stream: await this.doStream(context)
      };
      return;
    }
    const done = ["stop", "length", "content_filter", "eos"].includes(chunk.choices?.[0]?.finish_reason || "");
    if (done) {
      context.done = true;
    }
    if (chunk.choices?.length && chunk.choices?.[0]?.delta?.reasoning_content) {
      yield {
        type: "reasoning",
        text: chunk.choices?.[0]?.delta?.reasoning_content || "",
        done
      };
    }
    if (chunk.choices?.length && (chunk.choices?.[0]?.delta?.content || done)) {
      yield {
        type: context.thinking ? "reasoning" : "content",
        text: chunk.choices?.[0]?.delta?.content || "",
        done
      };
    }
    if (context.opts?.usage && context.done && context.usage) {
      yield { type: "usage", usage: context.usage };
    }
  }
  defaultRequiresFlatTextPayload(msg) {
    return super.requiresFlatTextPayload(msg);
  }
  requiresFlatTextPayload(msg) {
    return this.defaultRequiresFlatTextPayload(msg) || this.client.baseURL?.length > 0 && this.client.baseURL !== defaultBaseUrl;
  }
  accumulateUsage(cumulate, usage) {
    cumulate.prompt_tokens += usage.prompt_tokens ?? 0;
    cumulate.completion_tokens += usage.completion_tokens ?? 0;
    if (usage.prompt_tokens_details?.cached_tokens) {
      cumulate.prompt_tokens_details.cached_tokens += usage.prompt_tokens_details?.cached_tokens;
    }
    if (usage.prompt_tokens_details?.audio_tokens) {
      cumulate.prompt_tokens_details.audio_tokens += usage.prompt_tokens_details?.audio_tokens;
    }
    if (usage.completion_tokens_details?.reasoning_tokens) {
      cumulate.completion_tokens_details.reasoning_tokens += usage.completion_tokens_details?.reasoning_tokens;
    }
    if (usage.completion_tokens_details?.audio_tokens) {
      cumulate.completion_tokens_details.audio_tokens += usage.completion_tokens_details?.audio_tokens;
    }
  }
  //
  // Response API stuff
  //
  // ---------------------------------------------------------------------------
  // Responses API  via official SDK with automatic tool execution
  async responsesChat(model, thread, opts) {
    logger_default.log(`[${this.getName()}] prompting model ${model.id}`);
    const request = await this.buildResponsesRequest(model, thread, opts, false);
    let text = "";
    const toolCallInfo = [];
    const usage = zeroUsage();
    logger_default.debug("[responses] REQUEST", JSON.stringify(request, null, 2));
    let response = await this.client.responses.create(request);
    while (true) {
      logger_default.debug("[responses] RESPONSE", response);
      if (opts?.usage && response.usage) {
        this.accumulateResponsesUsage(usage, response.usage);
      }
      const messages = response.output.filter((o2) => o2.type === "message");
      for (const message of messages) {
        for (const content of message.content) {
          if (content.type === "output_text") {
            text += content.text || "";
          }
        }
      }
      const toolCalls = response.output?.filter((o2) => o2.type === "function_call");
      if (toolCalls.length) {
        const followReqInput = [];
        for (const toolCall of toolCalls) {
          logger_default.log(`[openai] tool call ${toolCall.name} with ${toolCall.arguments}`);
          let args = null;
          try {
            args = JSON.parse(toolCall.arguments);
          } catch (err) {
            throw new Error(`[openai] tool call ${toolCall.name} with invalid JSON args: "${toolCall.arguments}"`, { cause: err });
          }
          let content = void 0;
          for await (const update of this.callTool({ model: model.id }, toolCall.name, args)) {
            if (update.type === "result") {
              content = update.result;
            }
          }
          logger_default.log(`[openai] tool call ${toolCall.name} => ${JSON.stringify(content).substring(0, 128)}`);
          followReqInput.push({
            type: "function_call_output",
            call_id: toolCall.call_id,
            output: typeof content === "string" ? content : JSON.stringify(content)
          });
          toolCallInfo.push({
            name: toolCall.name,
            params: args,
            result: content
          });
        }
        const followUpReq = {
          model: model.id,
          previous_response_id: response.id,
          input: followReqInput,
          stream: false
        };
        logger_default.debug("[responses] FOLLOW-UP REQUEST", JSON.stringify(followUpReq, null, 2));
        response = await this.client.responses.create(followUpReq);
        continue;
      }
      return {
        type: "text",
        content: text,
        toolCalls: toolCallInfo,
        openAIResponseId: response?.id,
        ...opts?.usage ? { usage } : {}
      };
    }
  }
  async responsesStream(model, thread, opts) {
    logger_default.log(`[${this.getName()}] prompting model ${model.id}`);
    const request = await this.buildResponsesRequestFromMessages(model, thread, opts, true);
    const stream = await this.client.responses.create(request);
    logger_default.debug("[responsesStream] subscribed");
    async function* generator() {
      let responseId = "";
      const usage = zeroUsage();
      let currentStream = stream;
      while (true) {
        const pendingCalls = [];
        let thinking = false;
        for await (const ev of currentStream) {
          switch (ev.type) {
            case "response.created":
              responseId = ev.response.id;
              break;
            case "response.in_progress":
              yield {
                type: "openai_message_id",
                id: ev.response.id
              };
              break;
            case "response.completed": {
              if (opts?.usage && ev.response.usage) {
                this.accumulateResponsesUsage(usage, ev.response.usage);
              }
              break;
            }
            case "response.output_item.added":
              switch (ev.item.type) {
                case "message":
                  thinking = false;
                  break;
                case "reasoning":
                  thinking = true;
                  break;
                case "function_call":
                  pendingCalls.push(ev.item);
                  yield {
                    type: "tool",
                    id: ev.item.id,
                    name: ev.item.name,
                    status: this.getToolPreparationDescription(ev.item.name),
                    done: false
                  };
                  break;
              }
              break;
            case "response.output_item.done":
              switch (ev.item.type) {
                case "reasoning":
                  thinking = false;
                  break;
              }
              break;
            case "response.output_text.delta": {
              if (ev.delta) {
                yield {
                  type: thinking ? "reasoning" : "content",
                  text: ev.delta,
                  done: false
                };
              }
              break;
            }
            case "response.function_call_arguments.delta": {
              const call = pendingCalls.find((c2) => c2.id == ev.item_id);
              if (call) {
                call.arguments += ev.delta;
              }
              break;
            }
            case "response.function_call_arguments.done": {
              const call = pendingCalls.find((c2) => c2.id == ev.item_id);
              if (call) {
              }
              break;
            }
          }
        }
        if (!pendingCalls.length) {
          if (opts?.usage) {
            yield { type: "usage", usage };
          }
          yield { type: "content", text: "", done: true };
          break;
        }
        const followReqInput = [];
        for (const toolCall of pendingCalls) {
          let args = null;
          try {
            args = JSON.parse(toolCall.arguments);
          } catch (err) {
            throw new Error(`[openai] tool call ${toolCall.name} with invalid JSON args: "${args}"`, { cause: err });
          }
          yield {
            type: "tool",
            id: toolCall.id,
            name: toolCall.name,
            status: this.getToolRunningDescription(toolCall.name, args),
            call: {
              params: args,
              result: void 0
            },
            done: false
          };
          let content = void 0;
          for await (const update of this.callTool({ model: model.id }, toolCall.name, args)) {
            if (update.type === "status") {
              yield {
                type: "tool",
                id: toolCall.id,
                name: toolCall.name,
                status: update.status,
                call: {
                  params: args,
                  result: void 0
                },
                done: false
              };
            } else if (update.type === "result") {
              content = update.result;
            }
          }
          logger_default.log(`[openai] tool call ${toolCall.name} => ${JSON.stringify(content).substring(0, 128)}`);
          followReqInput.push({
            type: "function_call_output",
            call_id: toolCall.call_id,
            output: typeof content === "string" ? content : JSON.stringify(content)
          });
          yield {
            type: "tool",
            id: toolCall.id,
            name: toolCall.name,
            status: this.getToolCompletedDescription(toolCall.name, args, content),
            done: true,
            call: {
              params: args,
              result: content
            }
          };
        }
        const followReq = {
          model: model.id,
          previous_response_id: responseId,
          input: followReqInput,
          tools: request.tools,
          tool_choice: request.tool_choice,
          stream: true
        };
        logger_default.debug("[responsesStream] FOLLOW-UP STREAM REQ", JSON.stringify(followReq, null, 2));
        currentStream = await this.client.responses.create(followReq);
      }
    }
    return {
      stream: generator.bind(this)(),
      context: {
        responsesApi: true
      }
    };
  }
  async buildResponsesRequestFromMessages(model, thread, opts, stream) {
    return this.buildResponsesRequest(model, this.buildPayload(model, thread, opts), opts, stream);
  }
  async buildResponsesRequest(model, payload, opts, stream) {
    function extractText(msg) {
      const c2 = msg?.content;
      if (typeof c2 === "string") return c2;
      if (Array.isArray(c2)) {
        return c2.map((p2) => typeof p2 === "string" ? p2 : p2.text ?? "").join("");
      }
      if (c2 && typeof c2 === "object" && typeof c2.text === "string") return c2.text;
      return JSON.stringify(c2);
    }
    const instructions = payload.filter((m2) => m2.role === "system").map(extractText).join("\n").trim();
    let input = "";
    if (opts?.openAIResponseId) {
      input = extractText(payload[payload.length - 1]);
    } else {
      input = [];
      for (const msg of payload) {
        if (msg.role === "user") {
          input.push({
            type: "message",
            role: "user",
            content: typeof msg.content === "string" ? msg.content : msg.content.map((c2) => {
              if (c2.type === "text") {
                return {
                  type: "input_text",
                  text: c2.text
                };
              } else if (c2.type === "image_url") {
                return {
                  type: "input_image",
                  detail: "auto",
                  image_url: c2.image_url.url
                };
              } else if (c2.type === "image") {
                return {
                  type: "input_image",
                  detail: "auto",
                  image_url: c2.source?.data
                };
              } else if (c2.type === "document") {
                return {
                  type: "input_file",
                  file_data: c2.source?.data
                };
              } else {
                console.log(`[openai] unknown content type ${c2.type} in user message, using JSON.stringify`);
                return {
                  type: "input_text",
                  text: JSON.stringify(c2)
                };
              }
            })
          });
        } else if (msg.role === "assistant") {
          input.push({
            role: "assistant",
            content: extractText(msg)
          });
        } else if (msg.role === "tool") {
          input.push({
            type: "function_call",
            call_id: msg.tool_call_id,
            name: msg.tool_calls?.[0].name || "",
            arguments: ""
          });
        }
      }
    }
    const req = {
      model: model.id,
      ...instructions ? { instructions } : {},
      ...opts?.openAIResponseId ? { previous_response_id: opts.openAIResponseId } : {},
      input,
      stream
    };
    const tools = await this.getResponsesTools(model, opts);
    if (tools.length) {
      req.tools = tools;
      req.tool_choice = this.getResponsesToolChoice(opts?.toolChoice);
    }
    return req;
  }
  async getResponsesTools(model, opts) {
    if (opts?.tools === false || !model.capabilities?.tools) {
      return [];
    }
    const tools = await this.getAvailableTools();
    if (!tools.length) return [];
    return tools.map((t2) => {
      if (t2.type === "function") {
        const parameters = t2.function.parameters ? {
          ...JSON.parse(JSON.stringify(t2.function.parameters)),
          required: Object.keys(t2.function.parameters.properties || {}),
          additionalProperties: false
        } : {
          type: "object",
          properties: {},
          required: [],
          additionalProperties: false
        };
        for (const value of Object.values(parameters.properties)) {
          if (value.type === "array" && value.items && typeof value.items === "object" && value.items.type === "object") {
            value.items.required = Object.keys(value.items.properties);
            value.items.additionalProperties = false;
          }
        }
        return {
          type: "function",
          name: t2.function.name,
          description: t2.function.description,
          parameters,
          strict: true
        };
      } else {
        throw new Error(`[openai] tool type ${t2.type} is not supported in Responses API`);
      }
    });
  }
  getResponsesToolChoice(toolChoice) {
    if (!toolChoice) {
      return "auto";
    }
    switch (toolChoice.type) {
      case "none":
        return "none";
      case "auto":
        return "auto";
      case "required":
        return "required";
      case "tool":
        return {
          type: "function",
          name: toolChoice.name
        };
    }
  }
  async continueResponse(model, previousId, input, opts) {
    const req = {
      model: model.id,
      input: [{ type: "message", role: "user", content: input }],
      previous_response_id: previousId,
      stream: false
    };
    const toolOpts = await this.getToolsOpts(model, opts);
    if (toolOpts.tools) req.tools = toolOpts.tools;
    const resp = await this.client.responses.create(req);
    return {
      type: "text",
      content: resp.output?.text ?? "",
      ...opts?.usage && resp.usage ? { usage: resp.usage } : {}
    };
  }
  async forkResponse(model, previousId, input, opts) {
    return await this.continueResponse(model, previousId, input, opts);
  }
  accumulateResponsesUsage(cumulate, usage) {
    cumulate.prompt_tokens += usage.input_tokens;
    cumulate.completion_tokens += usage.output_tokens;
    cumulate.prompt_tokens_details.cached_tokens += usage.input_tokens_details.cached_tokens;
    cumulate.completion_tokens_details.reasoning_tokens += usage.output_tokens_details.reasoning_tokens;
  }
};
var azure_default = class extends openai_default {
  constructor(config) {
    super(config, { apiKey: config.apiKey });
    this.client = new AzureOpenAI({
      endpoint: config.baseURL,
      apiKey: config.apiKey,
      deployment: config.deployment,
      apiVersion: config.apiVersion,
      dangerouslyAllowBrowser: true
    });
  }
  getId() {
    return "azure";
  }
  async getModels() {
    return [
      { id: "default", object: "model", created: 0, owned_by: "system" }
    ];
  }
  setBaseURL() {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  requiresFlatTextPayload(msg) {
    return true;
  }
};
var kAnthropicCachedItems = 4;
var anthropic_default = class extends LlmEngine {
  client;
  computerInfo = null;
  constructor(config, computerInfo = null) {
    super(config);
    this.client = new sdk_default({
      apiKey: config.apiKey,
      dangerouslyAllowBrowser: true
    });
    this.computerInfo = computerInfo;
  }
  getId() {
    return "anthropic";
  }
  // https://docs.anthropic.com/en/docs/about-claude/models
  getModelCapabilities(model) {
    const visionGlobs = [
      "claude-3-*",
      "claude-*-4-*",
      "computer-use"
    ];
    const reasoning = model.id === "claude-3-7-sonnet-thinking" || model.id.includes("claude-3-7") || model.id.includes("claude-3.7") || minimatch(model.id, "claude-*-4-*");
    const cachingGlobs = [
      "claude-opus-4-*",
      "claude-sonnet-4-*",
      "claude-3-7-sonnet-*",
      "claude-3-5-sonnet-*",
      "claude-3-5-haiku-*",
      "claude-3-opus-*",
      "claude-3-haiku-*"
    ];
    return {
      tools: true,
      vision: visionGlobs.some((m2) => minimatch(model.id, m2)),
      reasoning,
      caching: cachingGlobs.some((m2) => minimatch(model.id, m2))
    };
  }
  getComputerUseRealModel() {
    return "claude-3-5-sonnet-20241022";
  }
  getMaxTokens(model) {
    if (model === "computer-use") return this.getMaxTokens(this.getComputerUseRealModel());
    if (model.includes("claude-opus-4")) return 32e3;
    if (model.includes("claude-sonnet-4")) return 64e3;
    if (model.includes("claude-3-7-")) return 64e3;
    if (model.includes("claude-3-5-")) return 8192;
    else return 4096;
  }
  async getModels() {
    if (!this.client.apiKey) {
      return [];
    }
    const models = await this.client.models.list({ limit: 1e3 });
    return [
      ...models.data,
      ...this.computerInfo ? [{
        "type": "model",
        id: "computer-use",
        display_name: "Computer Use",
        created_at: "1970-01-01T00:00:00Z"
      }] : []
    ];
  }
  async complete(model, thread, opts) {
    return await this.chat(model, [
      thread[0],
      ...this.buildPayload(model, thread, opts)
    ], opts);
  }
  async chat(model, thread, opts) {
    if (model.id === "computer-use") {
      model = this.toModel(this.getComputerUseRealModel());
    }
    const toolCallInfo = [];
    logger_default.log(`[anthropic] prompting model ${model.id}`);
    const response = await this.client.messages.create(this.cacheRequest(model, opts ?? {}, {
      model: model.id,
      system: thread[0].contentForModel,
      messages: thread.slice(1),
      ...this.getCompletionOpts(model, opts),
      ...await this.getToolOpts(model, opts)
    }));
    if (response.stop_reason === "tool_use") {
      const toolCall = response.content[response.content.length - 1];
      logger_default.log(`[anthropic] tool call ${toolCall.name} with ${JSON.stringify(toolCall.input)}`);
      let content2 = void 0;
      for await (const update of this.callTool({ model: model.id }, toolCall.name, toolCall.input)) {
        if (update.type === "result") {
          content2 = update.result;
        }
      }
      logger_default.log(`[anthropic] tool call ${toolCall.name} => ${JSON.stringify(content2).substring(0, 128)}`);
      thread.push(...response.content.map((c2) => ({
        role: "assistant",
        content: [c2]
      })));
      if (toolCall.name === "computer") {
        thread.push({
          role: "user",
          content: [{
            type: "tool_result",
            tool_use_id: toolCall.id,
            ...content2
          }]
        });
      } else {
        thread.push({
          role: "user",
          content: [{
            type: "tool_result",
            tool_use_id: toolCall.id,
            content: JSON.stringify(content2)
          }]
        });
      }
      toolCallInfo.push({
        name: toolCall.name,
        params: toolCall.input,
        result: content2
      });
      const completion = await this.chat(model, thread, opts);
      completion.toolCalls = [
        ...toolCallInfo,
        ...completion.toolCalls ?? []
      ];
      if (opts?.usage && response.usage && completion.usage) {
        completion.usage.prompt_tokens += response.usage.input_tokens;
        completion.usage.completion_tokens += response.usage.output_tokens;
      }
      return completion;
    }
    const content = response.content[0];
    return {
      type: "text",
      content: content.text,
      toolCalls: toolCallInfo,
      ...opts?.usage && response.usage ? { usage: {
        prompt_tokens: response.usage.input_tokens,
        completion_tokens: response.usage.output_tokens
      } } : {}
    };
  }
  async stream(model, thread, opts) {
    model = this.selectModel(model, thread, opts);
    if (this.computerInfo && model.id === "computer-use") {
      const computerUse = this.plugins.find((p2) => p2.getName() === this.computerInfo.plugin.getName());
      if (!computerUse) {
        this.plugins.push(this.computerInfo.plugin);
      }
    }
    const context = {
      model,
      system: thread[0].contentForModel,
      thread: this.buildPayload(model, thread, opts),
      opts: opts || {},
      usage: zeroUsage(),
      firstTextBlockStart: true
    };
    return {
      stream: await this.doStream(context),
      context
    };
  }
  async doStream(context) {
    context.toolCall = void 0;
    context.thinkingBlock = void 0;
    context.thinkingSignature = "";
    const tools = (await this.getAvailableTools()).map((tool) => {
      return {
        name: tool.function.name,
        description: tool.function.description,
        input_schema: {
          type: "object",
          properties: tool.function.parameters.properties,
          required: tool.function.parameters.required
        }
      };
    });
    if (this.computerInfo && context.model.id === "computer-use") {
      const scaledScreenSize = this.computerInfo.screenSize();
      tools.push({
        name: "computer",
        type: "computer_20241022",
        display_width_px: scaledScreenSize.width,
        display_height_px: scaledScreenSize.height,
        display_number: this.computerInfo.screenNumber()
      });
    }
    if (context.model.id === "computer-use") {
      return this.doStreamBeta(context);
    } else {
      return this.doStreamNormal(context);
    }
  }
  async doStreamNormal(context) {
    logger_default.log(`[anthropic] prompting model ${context.model.id}`);
    return this.client.messages.create(this.cacheRequest(context.model, context.opts, {
      model: context.model.id,
      system: context.system,
      messages: context.thread,
      ...this.getCompletionOpts(context.model, context.opts),
      ...await this.getToolOpts(context.model, context.opts),
      stream: true
    }));
  }
  async doStreamBeta(context) {
    logger_default.log(`[anthropic] prompting model ${context.model.id}`);
    return this.client.beta.messages.create(this.cacheRequest(context.model, context.opts, {
      model: this.getComputerUseRealModel(),
      betas: ["computer-use-2024-10-22"],
      system: context.system,
      messages: context.thread,
      ...this.getCompletionOpts(context.model, context.opts),
      ...await this.getToolOpts(context.model, context.opts),
      stream: true
    }));
  }
  getCompletionOpts(model, opts) {
    const isThinkingEnabled = model.capabilities?.reasoning && opts?.reasoning;
    return {
      max_tokens: opts?.maxTokens ?? this.getMaxTokens(model.id),
      ...opts?.temperature ? { temperature: opts.temperature } : isThinkingEnabled ? { temperature: 1 } : {},
      ...opts?.top_k ? { top_k: opts?.top_k } : {},
      ...opts?.top_p ? { top_p: opts?.top_p } : {},
      ...isThinkingEnabled ? {
        thinking: {
          type: "enabled",
          budget_tokens: opts.reasoningBudget || (opts?.maxTokens || this.getMaxTokens(model.id)) / 2
        }
      } : {}
    };
  }
  async getToolOpts(model, opts) {
    if (opts?.tools === false) {
      return {};
    }
    const tools = (await this.getAvailableTools()).map((tool) => {
      return {
        name: tool.function.name,
        description: tool.function.description,
        input_schema: {
          type: "object",
          properties: tool.function.parameters.properties,
          required: tool.function.parameters.required
        }
      };
    });
    let toolChoice = { type: "auto" };
    if (opts?.toolChoice?.type === "auto" || opts?.toolChoice?.type === "none") {
      toolChoice = opts.toolChoice;
    } else if (opts?.toolChoice?.type === "required") {
      toolChoice = { type: "any" };
    } else if (opts?.toolChoice?.type === "tool") {
      toolChoice = { type: "tool", name: opts.toolChoice.name };
    }
    return tools.length ? {
      tool_choice: toolChoice,
      tools
    } : {};
  }
  cacheRequest(model, opts, params) {
    if (!opts.caching) {
      return params;
    }
    if (!model.capabilities.caching) {
      return params;
    }
    const itemsSizes = [];
    for (const tool of params.tools || []) {
      if (!("description" in tool)) continue;
      const descriptionLength = tool.description ? tool.description.length : 0;
      const propertiesLength = "input_schema" in tool ? Object.values(tool.input_schema.properties || {}).reduce((propAcc, prop) => {
        return propAcc + (prop.description ? prop.description.length : 0);
      }, 0) : 0;
      if (descriptionLength + propertiesLength === 0) continue;
      itemsSizes.push({ name: tool.name, size: descriptionLength + propertiesLength });
    }
    const systemPromptName = "__system__prompt__";
    if (typeof params.system === "string") {
      itemsSizes.push({ name: systemPromptName, size: params.system.length });
    }
    const sortedItems = itemsSizes.sort((a2, b2) => b2.size - a2.size).slice(0, kAnthropicCachedItems).map((tool) => tool.name);
    for (const item of sortedItems) {
      if (item === systemPromptName) {
        params.system = [{
          type: "text",
          text: params.system,
          cache_control: { type: "ephemeral" }
        }];
      } else {
        const tool = params.tools?.find((t2) => t2.name === item);
        if (tool) {
          tool.cache_control = { type: "ephemeral" };
        }
      }
    }
    return params;
  }
  async stop(stream) {
    stream.controller?.abort();
  }
  async *nativeChunkToLlmChunk(chunk, context) {
    const usage = chunk.message?.usage ?? chunk.usage;
    if (context.usage && usage) {
      if ("input_tokens" in usage) {
        context.usage.prompt_tokens += usage.input_tokens ?? 0;
      }
      if ("cache_read_input_tokens" in usage && context.usage.prompt_tokens_details?.cached_tokens !== void 0) {
        context.usage.prompt_tokens_details.cached_tokens += usage.cache_read_input_tokens ?? 0;
      }
      context.usage.completion_tokens += usage.output_tokens ?? 0;
    }
    if (chunk.type == "message_stop") {
      yield { type: "content", text: "", done: true };
      if (context.opts.usage) {
        yield { type: "usage", usage: context.usage };
      }
    }
    if (chunk.type == "content_block_start") {
      if (chunk.content_block.type == "text") {
        if (!context.firstTextBlockStart) {
          yield { type: "content", text: "\n\n", done: false };
        }
        context.firstTextBlockStart = false;
      }
      if (chunk.content_block.type == "thinking") {
        context.thinkingBlock = "";
      }
      if (chunk.content_block.type == "tool_use") {
        context.toolCall = {
          id: chunk.content_block.id,
          message: "",
          function: chunk.content_block.name,
          args: ""
        };
        yield {
          type: "tool",
          id: context.toolCall.id,
          name: context.toolCall.function,
          status: this.getToolPreparationDescription(context.toolCall.function),
          done: false
        };
      } else {
        context.toolCall = void 0;
      }
    }
    if (chunk.type == "content_block_delta") {
      if (context.toolCall !== void 0) {
        const toolDelta = chunk.delta;
        context.toolCall.args += toolDelta.partial_json;
      }
      if (context.toolCall === void 0 && chunk.delta.type === "thinking_delta") {
        context.thinkingBlock += chunk.delta.thinking;
        yield { type: "reasoning", text: chunk.delta.thinking, done: false };
      }
      if (context.toolCall === void 0 && chunk.delta.type === "signature_delta") {
        context.thinkingSignature = chunk.delta.signature;
      }
      if (context.toolCall === void 0 && chunk.delta.type === "citations_delta") {
        yield { type: "content", text: chunk.delta.citation.cited_text, done: false };
      }
      if (context.toolCall === void 0 && chunk.delta.type === "text_delta") {
        yield { type: "content", text: chunk.delta.text, done: false };
      }
    }
    if (chunk.type == "message_delta") {
      if (chunk.delta.stop_reason == "tool_use" && context.toolCall !== void 0) {
        logger_default.log(`[anthropic] tool call ${context.toolCall.function} with ${context.toolCall.args}`);
        const args = context.toolCall.args?.length ? JSON.parse(context.toolCall.args) : {};
        yield {
          type: "tool",
          id: context.toolCall.id,
          name: context.toolCall.function,
          status: this.getToolRunningDescription(context.toolCall.function, args),
          call: {
            params: args,
            result: void 0
          },
          done: false
        };
        let content = void 0;
        for await (const update of this.callTool({ model: context.model.id }, context.toolCall.function, args)) {
          if (update.type === "status") {
            yield {
              type: "tool",
              id: context.toolCall.id,
              name: context.toolCall.function,
              status: update.status,
              call: {
                params: args,
                result: void 0
              },
              done: false
            };
          } else if (update.type === "result") {
            content = update.result;
          }
        }
        logger_default.log(`[anthropic] tool call ${context.toolCall.function} => ${JSON.stringify(content).substring(0, 128)}`);
        if (context.thinkingBlock) {
          context.thread.push({
            role: "assistant",
            content: [{
              type: "thinking",
              thinking: context.thinkingBlock,
              signature: context.thinkingSignature
            }]
          });
        }
        context.thread.push({
          role: "assistant",
          content: [{
            type: "tool_use",
            id: context.toolCall.id,
            name: context.toolCall.function,
            input: args
          }]
        });
        if (context.toolCall.function === "computer") {
          context.thread.push({
            role: "user",
            content: [{
              type: "tool_result",
              tool_use_id: context.toolCall.id,
              ...content
            }]
          });
        } else {
          context.thread.push({
            role: "user",
            content: [{
              type: "tool_result",
              tool_use_id: context.toolCall.id,
              content: JSON.stringify(content)
            }]
          });
        }
        yield {
          type: "tool",
          id: context.toolCall.id,
          name: context.toolCall.function,
          status: this.getToolCompletedDescription(context.toolCall.function, args, content),
          done: true,
          call: {
            params: args,
            result: content
          }
        };
        if (context.opts.toolChoice?.type === "tool") {
          delete context.opts.toolChoice;
        }
        yield {
          type: "stream",
          stream: await this.doStream(context)
        };
      }
    }
  }
  addTextToPayload(message, attachment, payload, opts) {
    if (Array.isArray(payload.content)) {
      payload.content.push({
        type: "document",
        source: {
          type: "text",
          media_type: "text/plain",
          data: attachment.content
        },
        ...attachment.title.length ? { title: attachment.title } : {},
        ...attachment.context.length ? { context: attachment.context } : {},
        ...opts ? { citations: { enabled: opts?.citations ?? false } } : {}
      });
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  addImageToPayload(attachment, payload, opts) {
    if (Array.isArray(payload.content)) {
      payload.content.push({
        type: "image",
        source: {
          type: "base64",
          media_type: attachment.mimeType,
          data: attachment.content
        }
      });
    }
  }
  buildPayload(model, thread, opts) {
    const payload = super.buildPayload(model, thread, opts);
    return payload.filter((payload2) => payload2.role != "system").map((payload2) => {
      if (typeof payload2.content == "string") {
        return {
          role: payload2.role,
          content: payload2.content
        };
      } else {
        return {
          role: payload2.role,
          content: payload2.content
        };
      }
    });
  }
};
var cerebras_default = class extends openai_default {
  constructor(config) {
    super(config, {
      apiKey: config.apiKey,
      baseURL: "https://api.cerebras.ai/v1"
    });
  }
  getId() {
    return "cerebras";
  }
  getVisionModels() {
    return [];
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  modelSupportsTopK(model) {
    return false;
  }
  get systemRole() {
    return "system";
  }
  async getModels() {
    if (!this.client.apiKey) {
      return [];
    }
    return await super.getModels();
  }
  setBaseURL() {
  }
  async getAvailableTools() {
    return [];
  }
  // cerebras supports multiparts for some models but not all
  // especially qwen-3-32b will fail with
  // {
  //   "message": "Failed to apply chat template to messages due to error: 'list object' has no attribute 'startswith'",
  //   "type": "invalid_request_error",
  //   "param": "messages",
  //   "code": "wrong_api_format"
  // }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  requiresFlatTextPayload(msg) {
    return true;
  }
};
var deepseek_default = class extends openai_default {
  constructor(config) {
    super(config, {
      apiKey: config.apiKey,
      baseURL: "https://api.deepseek.com/v1"
    });
  }
  getId() {
    return "deepseek";
  }
  getVisionModels() {
    return [];
  }
  getModelCapabilities(model) {
    return {
      tools: true,
      vision: false,
      reasoning: model.id.includes("reason"),
      caching: false
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  modelSupportsReasoningEffort(model) {
    return false;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  modelSupportsStructuredOutput(model) {
    return false;
  }
  get systemRole() {
    return "system";
  }
  async getModels() {
    if (!this.client.apiKey) {
      return [];
    }
    return await super.getModels();
  }
  setBaseURL() {
  }
  requiresFlatTextPayload(msg) {
    return super.defaultRequiresFlatTextPayload(msg);
  }
};
var google_default = class extends LlmEngine {
  client;
  constructor(config) {
    super(config);
    this.client = new GoogleGenAI({
      apiKey: config.apiKey
    });
  }
  getId() {
    return "google";
  }
  // https://ai.google.dev/gemini-api/docs/models/gemini
  getModelCapabilities(model) {
    const visionGlobs = [
      "gemma-3*",
      "gemini-1.5-pro-latest",
      "gemini-1.5-flash-*",
      "gemini-2.0-flash-*",
      "gemini-exp-1206",
      "gemini-2.0-flash-thinking-*",
      "gemini-2.5-*"
    ];
    const excludeVisionGlobs = [
      "gemma-3-1b*",
      "*tts"
    ];
    const reasoningGlobs = [
      "gemini-2.5-flash*",
      "gemini-2.5-pro*",
      "*thinking*"
    ];
    if (!model.name) {
      return {
        tools: true,
        vision: false,
        reasoning: false,
        caching: false
      };
    }
    const modelName = model.name.replace("models/", "");
    return {
      tools: !modelName.includes("gemma") && !modelName.includes("dialog") && !modelName.includes("tts"),
      vision: visionGlobs.some((m2) => minimatch(modelName, m2)) && !excludeVisionGlobs.some((m2) => minimatch(modelName, m2)),
      reasoning: reasoningGlobs.some((m2) => minimatch(modelName, m2)),
      caching: false
    };
  }
  async getModels() {
    if (!this.config.apiKey) {
      return [];
    }
    const models = [];
    const pager = await this.client.models.list();
    for await (const model of pager) {
      if (!model.name) continue;
      if (model.name.includes("tuning")) continue;
      if (model.description?.includes("deprecated")) continue;
      if (model.description?.includes("discontinued")) continue;
      models.push(model);
    }
    models.reverse();
    return models;
  }
  async complete(model, thread, opts) {
    const messages = this.threadToHistory(thread, model, opts);
    const instruction = this.getInstructions(model, thread);
    return await this.chat(model, messages, {
      ...opts,
      instruction
    });
  }
  async chat(model, thread, opts) {
    const toolCallInfo = [];
    logger_default.log(`[google] prompting model ${model.id}`);
    const response = await this.client.models.generateContent({
      model: model.id,
      contents: thread,
      config: await this.getGenerationConfig(model, opts)
    });
    const toolCalls = response.functionCalls;
    if (toolCalls?.length) {
      const results = [];
      for (const toolCall of toolCalls) {
        logger_default.log(`[google] tool call ${toolCall.name} with ${JSON.stringify(toolCall.args)}`);
        let content = void 0;
        for await (const update of this.callTool({ model: model.id }, toolCall.name, toolCall.args)) {
          if (update.type === "result") {
            content = update.result;
          }
        }
        logger_default.log(`[google] tool call ${toolCall.name} => ${JSON.stringify(content).substring(0, 128)}`);
        results.push({
          name: toolCall.name,
          response: content
        });
        toolCallInfo.push({
          name: toolCall.name,
          params: toolCall.args,
          result: content
        });
      }
      thread.push({
        role: "assistant",
        parts: response.candidates[0].content.parts
      });
      thread.push({
        role: "tool",
        parts: results.map((r2) => ({ functionResponse: r2 }))
      });
      const completion = await this.chat(model, thread, opts);
      completion.toolCalls = [
        ...toolCallInfo,
        ...completion.toolCalls ?? []
      ];
      if (opts?.usage && response.usageMetadata && completion.usage) {
        completion.usage.prompt_tokens += response.usageMetadata.promptTokenCount ?? 0;
        completion.usage.completion_tokens += response.usageMetadata.candidatesTokenCount ?? 0;
      }
      return completion;
    }
    return {
      type: "text",
      content: response.text,
      toolCalls: toolCallInfo,
      ...opts?.usage && response.usageMetadata ? { usage: {
        prompt_tokens: response.usageMetadata.promptTokenCount ?? 0,
        completion_tokens: response.usageMetadata.candidatesTokenCount ?? 0
      } } : {}
    };
  }
  async stream(model, thread, opts) {
    model = this.selectModel(model, thread, opts);
    const context = {
      model,
      content: this.threadToHistory(thread, model, opts),
      opts: {
        ...opts,
        instruction: this.getInstructions(model, thread)
      },
      toolCalls: [],
      usage: zeroUsage()
    };
    return {
      stream: await this.doStream(context),
      context
    };
  }
  async doStream(context) {
    context.toolCalls = [];
    logger_default.log(`[google] prompting model ${context.model.id}`);
    const response = await this.client.models.generateContentStream({
      model: context.model.id,
      contents: context.content,
      config: await this.getGenerationConfig(context.model, context.opts)
    });
    return response;
  }
  supportsInstructions(model) {
    return ["gemini"].some((m2) => model.id.includes(m2));
  }
  supportsStructuredOutput(model) {
    return ["gemini"].some((m2) => model.id.includes(m2));
  }
  getInstructions(model, thread) {
    return this.supportsInstructions(model) && thread.length > 1 && thread[0].role === "system" ? thread[0].content : void 0;
  }
  typeToSchemaType(type, properties) {
    if (type === "string") return Type.STRING;
    if (type === "number") return Type.NUMBER;
    if (type === "boolean") return Type.BOOLEAN;
    if (type === "array") return Type.ARRAY;
    return properties ? Type.OBJECT : Type.STRING;
  }
  async getGenerationConfig(model, opts) {
    const config = {
      ...opts?.maxTokens ? { maxOutputTokens: opts?.maxTokens } : {},
      ...opts?.temperature ? { temperature: opts?.temperature } : {},
      ...opts?.top_k ? { topK: opts?.top_k } : {},
      ...opts?.top_p ? { topP: opts?.top_p } : {}
    };
    if (opts?.instruction) {
      config.systemInstruction = opts.instruction;
    }
    if (this.supportsStructuredOutput(model) && opts?.structuredOutput) {
      config.responseMimeType = "application/json";
      config.responseJsonSchema = zodToJsonSchema(opts.structuredOutput.structure);
    }
    if (opts?.tools !== false && model.capabilities.tools) {
      const tools = await this.getAvailableTools();
      if (tools.length) {
        const functionDeclarations = [];
        for (const tool of tools) {
          const googleProps = {};
          for (const name of Object.keys(tool.function.parameters.properties)) {
            const props = tool.function.parameters.properties[name];
            googleProps[name] = {
              type: this.typeToSchemaType(props.type),
              description: props.description,
              ...props.enum ? { enum: props.enum } : {},
              ...props.items ? {
                items: {
                  type: this.typeToSchemaType(props.items.type, props.items?.properties),
                  properties: props.items?.properties
                }
              } : {}
            };
          }
          functionDeclarations.push({
            name: tool.function.name,
            description: tool.function.description,
            ...Object.keys(tool.function.parameters.properties).length == 0 ? {} : {
              parameters: {
                type: Type.OBJECT,
                properties: googleProps,
                required: tool.function.parameters.required
              }
            }
          });
        }
        config.tools = [{ functionDeclarations }];
        if (opts?.toolChoice?.type === "none") {
          config.toolConfig = { functionCallingConfig: { mode: FunctionCallingConfigMode.NONE } };
        } else if (opts?.toolChoice?.type === "required") {
          config.toolConfig = { functionCallingConfig: { mode: FunctionCallingConfigMode.ANY } };
        } else if (opts?.toolChoice?.type === "tool") {
          config.toolConfig = { functionCallingConfig: {
            mode: FunctionCallingConfigMode.ANY,
            allowedFunctionNames: [opts.toolChoice.name]
          } };
        } else {
          config.toolConfig = { functionCallingConfig: { mode: FunctionCallingConfigMode.AUTO } };
        }
      }
    }
    return Object.keys(config).length ? config : void 0;
  }
  threadToHistory(thread, model, opts) {
    const supportsInstructions = this.supportsInstructions(model);
    const payload = this.buildPayload(model, thread.filter((m2) => supportsInstructions ? m2.role !== "system" : true), opts).map((p2) => {
      if (p2.role === "system") p2.role = "user";
      return p2;
    });
    return payload.map((message) => this.messageToContent(message));
  }
  messageToContent(payload) {
    const content = {
      role: payload.role == "assistant" ? "model" : payload.role,
      parts: Array.isArray(payload.content) ? payload.content.map((c2) => ({ text: c2.text })) : [{ text: payload.content }]
    };
    for (const index in payload.images) {
      content.parts.push({
        inlineData: {
          mimeType: "image/png",
          data: payload.images[Number(index)]
        }
      });
    }
    return content;
  }
  addAttachment(parts, attachment) {
    if (attachment.content === null || attachment.content === void 0) {
      console.warn("[google] attachment contents not available. Skipping attachment.");
    }
    if (attachment.isImage()) {
      parts.push({
        inlineData: {
          mimeType: attachment.mimeType,
          data: attachment.content
        }
      });
    } else if (attachment.isText()) {
      parts.push(attachment.content);
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async stop(stream) {
  }
  async *nativeChunkToLlmChunk(chunk, context) {
    if (context.opts.usage && chunk.usageMetadata) {
      context.usage.prompt_tokens += chunk.usageMetadata.promptTokenCount ?? 0;
      context.usage.completion_tokens += chunk.usageMetadata.candidatesTokenCount ?? 0;
    }
    const toolCalls = chunk.functionCalls;
    if (toolCalls?.length) {
      context.toolCalls = toolCalls.filter((tc) => tc.name).map((tc) => {
        return {
          id: tc.id || tc.name,
          message: "",
          function: tc.name,
          args: JSON.stringify(tc.args)
        };
      });
      const results = [];
      for (const toolCall of context.toolCalls) {
        yield {
          type: "tool",
          id: toolCall.id,
          name: toolCall.function,
          status: this.getToolPreparationDescription(toolCall.function),
          done: false
        };
        logger_default.log(`[google] tool call ${toolCall.function} with ${toolCall.args}`);
        const args = JSON.parse(toolCall.args);
        yield {
          type: "tool",
          id: toolCall.id,
          name: toolCall.function,
          status: this.getToolRunningDescription(toolCall.function, args),
          call: {
            params: args,
            result: void 0
          },
          done: false
        };
        let content = void 0;
        for await (const update of this.callTool({ model: context.model.id }, toolCall.function, args)) {
          if (update.type === "status") {
            yield {
              type: "tool",
              id: toolCall.id,
              name: toolCall.function,
              status: update.status,
              call: {
                params: args,
                result: void 0
              },
              done: false
            };
          } else if (update.type === "result") {
            content = update.result;
          }
        }
        logger_default.log(`[google] tool call ${toolCall.function} => ${JSON.stringify(content).substring(0, 128)}`);
        results.push({
          id: toolCall.id,
          name: toolCall.function,
          response: content
        });
        yield {
          type: "tool",
          id: toolCall.id,
          name: toolCall.function,
          status: this.getToolCompletedDescription(toolCall.function, args, content),
          done: true,
          call: {
            params: args,
            result: content
          }
        };
      }
      context.content.push({
        role: "assistant",
        parts: chunk.candidates[0].content.parts
      });
      context.content.push({
        role: "tool",
        parts: results.map((r2) => ({ functionResponse: r2 }))
      });
      if (context.opts.toolChoice?.type === "tool") {
        delete context.opts.toolChoice;
      }
      yield {
        type: "stream",
        stream: await this.doStream(context)
      };
      return;
    }
    const done = !!chunk.candidates?.[0].finishReason;
    yield {
      type: "content",
      text: chunk.text || "",
      done
    };
    if (done && context.opts.usage) {
      yield { type: "usage", usage: context.usage };
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  addImageToPayload(attachment, payload, opts) {
    if (!payload.images) payload.images = [];
    payload.images.push(attachment.content);
  }
};
var groq_default = class extends LlmEngine {
  client;
  constructor(config) {
    super(config);
    this.client = new groq_sdk_default({
      apiKey: config.apiKey || "",
      dangerouslyAllowBrowser: true,
      maxRetries: config.maxRetries
    });
  }
  getId() {
    return "groq";
  }
  // https://console.groq.com/docs/models
  getModelCapabilities(model) {
    const visionGlobs = [
      "meta-llama/llama-4-scout-17b-16e-instruct",
      "meta-llama/llama-4-maverick-17b-128e-instruct"
    ];
    return {
      tools: true,
      vision: visionGlobs.some((m2) => minimatch(model.id, m2)),
      reasoning: model.id.startsWith("o"),
      caching: false
    };
  }
  async getModels() {
    if (!this.client.apiKey) {
      return [];
    }
    const models = await this.client.models.list();
    return models.data.filter((model) => model.active).filter((model) => !model.id.includes("guard")).filter((model) => !model.id.includes("whisper")).sort((a2, b2) => b2.created - a2.created);
  }
  async chat(model, thread, opts) {
    const toolCallInfo = [];
    logger_default.log(`[groq] prompting model ${model.id}`);
    const response = await this.client.chat.completions.create({
      model: model.id,
      messages: thread,
      ...this.getCompletionOpts(model, opts),
      ...await this.getToolOpts(model, opts)
    });
    const choice = response.choices?.[0];
    if (choice?.finish_reason === "tool_calls") {
      const toolCalls = choice.message.tool_calls;
      for (const toolCall of toolCalls) {
        logger_default.log(`[groq] tool call ${toolCall.function.name} with ${toolCall.function.arguments}`);
        let args = null;
        try {
          args = JSON.parse(toolCall.function.arguments);
        } catch (err) {
          throw new Error(`[groq] tool call ${toolCall.function.name} with invalid JSON args: "${toolCall.function.arguments}"`, { cause: err });
        }
        let content = void 0;
        for await (const update of this.callTool({ model: model.id }, toolCall.function.name, args)) {
          if (update.type === "result") {
            content = update.result;
          }
        }
        logger_default.log(`[groq] tool call ${toolCall.function.name} => ${JSON.stringify(content).substring(0, 128)}`);
        thread.push(choice.message);
        thread.push({
          role: "tool",
          tool_call_id: toolCall.id,
          name: toolCall.function.name,
          content: JSON.stringify(content)
        });
        toolCallInfo.push({
          name: toolCall.function.name,
          params: args,
          result: content
        });
      }
      const completion = await this.chat(model, thread, opts);
      completion.toolCalls = [
        ...toolCallInfo,
        ...completion.toolCalls ?? []
      ];
      if (opts?.usage && response.usage && completion.usage) {
        completion.usage.prompt_tokens += response.usage.prompt_tokens;
        completion.usage.completion_tokens += response.usage.completion_tokens;
      }
      return completion;
    }
    if (response.usage?.total_tokens) {
      delete response.usage.total_tokens;
    }
    return {
      type: "text",
      content: response.choices?.[0].message.content || "",
      toolCalls: toolCallInfo,
      ...opts?.usage && response.usage ? { usage: response.usage } : {}
    };
  }
  async stream(model, thread, opts) {
    model = this.selectModel(model, thread, opts);
    const context = {
      model,
      thread: this.buildPayload(model, thread, opts),
      opts: opts || {},
      toolCalls: [],
      usage: zeroUsage()
    };
    return {
      stream: await this.doStream(context),
      context
    };
  }
  async doStream(context) {
    context.toolCalls = [];
    logger_default.log(`[groq] prompting model ${context.model.id}`);
    const stream = this.client.chat.completions.create({
      model: context.model.id,
      messages: context.thread,
      ...this.getCompletionOpts(context.model, context.opts),
      ...await this.getToolOpts(context.model, context.opts),
      stream: true
    });
    return stream;
  }
  getCompletionOpts(model, opts) {
    return {
      ...opts?.maxTokens ? { max_tokens: opts?.maxTokens } : {},
      ...opts?.temperature ? { temperature: opts?.temperature } : {},
      //...(opts?.top_k ? { logprobs: true, top_logprobs: opts?.top_k } : {} ),
      ...opts?.top_p ? { top_p: opts?.top_p } : {},
      ...opts?.structuredOutput ? { response_format: { type: "json_object" } } : {}
    };
  }
  async getToolOpts(model, opts) {
    if (opts?.tools === false) {
      return {};
    }
    const tools = await this.getAvailableTools();
    return tools.length ? {
      tools,
      tool_choice: opts?.toolChoice?.type === "tool" ? {
        type: "function",
        function: { name: opts.toolChoice.name }
      } : opts?.toolChoice?.type ?? "auto"
    } : {};
  }
  async stop(stream) {
    stream.controller?.abort();
  }
  async *nativeChunkToLlmChunk(chunk, context) {
    if (context.opts?.usage && chunk.x_groq?.usage) {
      context.usage.prompt_tokens += chunk.x_groq.usage.prompt_tokens ?? 0;
      context.usage.completion_tokens += chunk.x_groq.usage.completion_tokens ?? 0;
    }
    if (chunk.choices[0]?.delta?.tool_calls?.[0].function) {
      if (chunk.choices[0].delta.tool_calls[0].id !== null && chunk.choices[0].delta.tool_calls[0].id !== void 0) {
        const toolCall = {
          id: chunk.choices[0].delta.tool_calls[0].id,
          message: chunk.choices[0].delta.tool_calls.map((tc) => {
            delete tc.index;
            return tc;
          }),
          function: chunk.choices[0].delta.tool_calls[0].function.name || "",
          args: chunk.choices[0].delta.tool_calls[0].function.arguments || ""
        };
        context.toolCalls.push(toolCall);
        yield {
          type: "tool",
          id: toolCall.id,
          name: toolCall.function,
          status: this.getToolPreparationDescription(toolCall.function),
          done: false
        };
      } else {
        const toolCall = context.toolCalls[context.toolCalls.length - 1];
        toolCall.args += chunk.choices[0].delta.tool_calls[0].function.arguments;
        toolCall.message[toolCall.message.length - 1].function.arguments = toolCall.args;
      }
    }
    if (["tool_calls", "function_call", "stop"].includes(chunk.choices[0]?.finish_reason || "") && context.toolCalls?.length) {
      for (const toolCall of context.toolCalls) {
        logger_default.log(`[groq] tool call ${toolCall.function} with ${toolCall.args}`);
        const args = JSON.parse(toolCall.args);
        yield {
          type: "tool",
          id: toolCall.id,
          name: toolCall.function,
          status: this.getToolRunningDescription(toolCall.function, args),
          call: {
            params: args,
            result: void 0
          },
          done: false
        };
        let content = void 0;
        for await (const update of this.callTool({ model: context.model.id }, toolCall.function, args)) {
          if (update.type === "status") {
            yield {
              type: "tool",
              id: toolCall.id,
              name: toolCall.function,
              status: update.status,
              call: {
                params: args,
                result: void 0
              },
              done: false
            };
          } else if (update.type === "result") {
            content = update.result;
          }
        }
        logger_default.log(`[groq] tool call ${toolCall.function} => ${JSON.stringify(content).substring(0, 128)}`);
        context.thread.push({
          role: "assistant",
          content: "",
          tool_calls: toolCall.message
        });
        context.thread.push({
          role: "tool",
          tool_call_id: toolCall.id,
          name: toolCall.function,
          content: JSON.stringify(content)
        });
        yield {
          type: "tool",
          id: toolCall.id,
          name: toolCall.function,
          status: this.getToolCompletedDescription(toolCall.function, args, content),
          done: true,
          call: {
            params: args,
            result: content
          }
        };
      }
      if (context.opts.toolChoice?.type === "tool") {
        delete context.opts.toolChoice;
      }
      yield {
        type: "stream",
        stream: await this.doStream(context)
      };
      return;
    }
    if (["stop", "length"].includes(chunk.choices[0].finish_reason || "")) {
      yield { type: "content", text: "", done: true };
      if (context.opts?.usage) {
        yield { type: "usage", usage: context.usage };
      }
    } else {
      yield {
        type: "content",
        text: chunk.choices[0].delta.content || "",
        done: false
      };
    }
  }
  buildPayload(model, thread, opts) {
    let payload = super.buildPayload(model, thread, opts);
    let hasImages = false;
    for (const p2 of payload) {
      if (Array.isArray(p2.content)) {
        for (const m2 of p2.content) {
          if (m2.type == "image_url") {
            hasImages = true;
            break;
          }
        }
      }
    }
    if (hasImages) {
      payload = payload.filter((p2) => p2.role != "system");
    }
    return payload.map((payload2) => {
      return {
        role: payload2.role,
        content: payload2.content
      };
    });
  }
};
var lmStudioBaseURL = "http://localhost:1234/v1";
var lmstudio_default = class extends openai_default {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static isConfigured = (engineConfig) => {
    return true;
  };
  static isReady = (opts, models) => {
    return models?.chat?.length > 0;
  };
  constructor(config) {
    super(config, {
      apiKey: config.apiKey || "dummy",
      baseURL: config.baseURL || lmStudioBaseURL
    });
  }
  getId() {
    return "lmstudio";
  }
  getModelCapabilities(model) {
    const visionModels = [
      "llava",
      "llama3.2-vision",
      "qwen2.5vl",
      "minicpm-v",
      "moondream"
    ];
    const reasoningModels = [
      "qwq",
      "thinking",
      "reasoning",
      "cogito"
    ];
    return {
      tools: true,
      //toolModels.some(m => model.id.includes(m)),
      vision: visionModels.some((m2) => model.id.includes(m2)),
      reasoning: reasoningModels.some((m2) => model.id.includes(m2)),
      caching: false
    };
  }
  get systemRole() {
    return "system";
  }
  async getModels() {
    return await super.getModels();
  }
  setBaseURL() {
  }
  requiresFlatTextPayload(msg) {
    return super.defaultRequiresFlatTextPayload(msg);
  }
  async *nativeChunkToLlmChunk(chunk, context) {
    if (Array.isArray(chunk.choices) && chunk.choices.length > 0 && chunk.choices[0].delta) {
      if (chunk.choices[0].delta.content === "<think>") {
        context.thinking = true;
        return;
      } else if (chunk.choices[0].delta.content === "</think>") {
        context.thinking = false;
        return;
      }
    }
    for await (const c2 of super.nativeChunkToLlmChunk(chunk, context)) {
      yield c2;
    }
  }
};
var metaBaseURL = "https://api.llama.com/compat/v1/";
var meta_default = class extends openai_default {
  constructor(config) {
    super(config, {
      apiKey: config.apiKey,
      baseURL: metaBaseURL
    });
  }
  getId() {
    return "meta";
  }
  getModelCapabilities(model) {
    const visionGlobs = ["*Llama-4-*"];
    return {
      tools: true,
      vision: visionGlobs.some((m2) => minimatch(model.id, m2)),
      reasoning: false,
      caching: false
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  modelSupportsStructuredOutput(model) {
    return false;
  }
  get systemRole() {
    return "system";
  }
  async getModels() {
    if (!this.client.apiKey) {
      return [];
    }
    return await super.getModels();
  }
  setBaseURL() {
  }
  requiresFlatTextPayload(msg) {
    return super.defaultRequiresFlatTextPayload(msg);
  }
};
var mistralai_default = class extends LlmEngine {
  client;
  constructor(config) {
    super(config);
    this.client = new import_mistralai.Mistral({
      apiKey: config.apiKey || ""
    });
  }
  getId() {
    return "mistralai";
  }
  getModelCapabilities(model) {
    return {
      tools: model.capabilities?.functionCalling ?? false,
      vision: model.capabilities?.vision ?? false,
      reasoning: model.id.includes("magistral"),
      caching: false
    };
  }
  async getModels() {
    try {
      const models = await this.client.models.list();
      return models.data ?? [];
    } catch (error) {
      console.error("Error listing models:", error);
      return [];
    }
  }
  async chat(model, thread, opts) {
    const toolCallInfo = [];
    logger_default.log(`[mistralai] prompting model ${model.id}`);
    const response = await this.client.chat.complete({
      model: model.id,
      messages: thread,
      ...this.getCompletionOpts(model, opts),
      ...await this.getToolOpts(model, opts)
    });
    const choice = response.choices?.[0];
    if (choice?.finishReason === "tool_calls") {
      const toolCalls = choice.message.toolCalls;
      for (const toolCall of toolCalls) {
        logger_default.log(`[mistralai] tool call ${toolCall.function.name} with ${toolCall.function.arguments}`);
        let content = void 0;
        for await (const update of this.callTool({ model: model.id }, toolCall.function.name, toolCall.function.arguments)) {
          if (update.type === "result") {
            content = update.result;
          }
        }
        logger_default.log(`[mistralai] tool call ${toolCall.function.name} => ${JSON.stringify(content).substring(0, 128)}`);
        thread.push(choice.message);
        thread.push({
          role: "tool",
          tool_call_id: toolCall.id,
          name: toolCall.function.name,
          content: JSON.stringify(content)
        });
        toolCallInfo.push({
          name: toolCall.function.name,
          params: toolCall.function.arguments,
          result: content
        });
      }
      const completion = await this.chat(model, thread, opts);
      completion.toolCalls = [
        ...toolCallInfo,
        ...completion.toolCalls ?? []
      ];
      if (opts?.usage && response.usage && completion.usage) {
        completion.usage.prompt_tokens += response.usage.promptTokens;
        completion.usage.completion_tokens += response.usage.completionTokens;
      }
      return completion;
    }
    return {
      type: "text",
      content: response.choices?.[0].message.content || "",
      toolCalls: toolCallInfo,
      ...opts?.usage ? { usage: {
        prompt_tokens: response.usage.promptTokens,
        completion_tokens: response.usage.completionTokens
      } } : {}
    };
  }
  async stream(model, thread, opts) {
    model = this.selectModel(model, thread, opts);
    const context = {
      model,
      thread: this.buildPayload(model, thread, opts),
      opts: opts || {},
      toolCalls: [],
      usage: zeroUsage()
    };
    return {
      stream: await this.doStream(context),
      context
    };
  }
  async doStream(context) {
    context.toolCalls = [];
    logger_default.log(`[mistralai] prompting model ${context.model.id}`);
    const stream = this.client.chat.stream({
      model: context.model.id,
      messages: context.thread,
      ...this.getCompletionOpts(context.model, context.opts),
      ...await this.getToolOpts(context.model, context.opts)
    });
    return stream;
  }
  getCompletionOpts(model, opts) {
    return {
      maxTokens: opts?.maxTokens,
      temperature: opts?.temperature,
      topP: opts?.top_p,
      ...opts?.structuredOutput ? { responseFormat: { type: "json_object" } } : {}
    };
  }
  async getToolOpts(model, opts) {
    if (opts?.tools === false || !model.capabilities?.tools) {
      return {};
    }
    const tools = await this.getAvailableTools();
    return tools.length ? {
      tools,
      toolChoice: opts?.toolChoice?.type === "tool" ? {
        type: "function",
        function: { name: opts.toolChoice.name }
      } : opts?.toolChoice?.type ?? "auto"
    } : {};
  }
  async stop() {
  }
  async *nativeChunkToLlmChunk(chunk, context) {
    if (context.opts.usage && chunk.data.usage) {
      context.usage.prompt_tokens += chunk.data.usage.promptTokens ?? 0;
      context.usage.completion_tokens += chunk.data.usage.completionTokens ?? 0;
    }
    if (chunk.data.choices[0]?.delta?.toolCalls) {
      if (chunk.data.choices[0].delta.toolCalls[0].id) {
        const toolCall = {
          id: chunk.data.choices[0].delta.toolCalls[0].id,
          message: chunk.data.choices[0].delta.toolCalls.map((tc) => {
            delete tc.index;
            return tc;
          }),
          function: chunk.data.choices[0].delta.toolCalls[0].function.name,
          args: chunk.data.choices[0].delta.toolCalls[0].function.arguments
        };
        context.toolCalls.push(toolCall);
        yield {
          type: "tool",
          id: toolCall.id,
          name: toolCall.function,
          status: this.getToolPreparationDescription(toolCall.function),
          done: false
        };
      } else {
        const toolCall = context.toolCalls[context.toolCalls.length - 1];
        toolCall.args += chunk.data.choices[0].delta.toolCalls[0].function.arguments;
        toolCall.message[toolCall.message.length - 1].function.arguments = toolCall.args;
      }
    }
    if (chunk.data.choices[0]?.finishReason === "tool_calls") {
      for (const toolCall of context.toolCalls) {
        logger_default.log(`[mistralai] tool call ${toolCall.function} with ${toolCall.args}`);
        const args = JSON.parse(toolCall.args);
        yield {
          type: "tool",
          id: toolCall.id,
          name: toolCall.function,
          status: this.getToolRunningDescription(toolCall.function, args),
          call: {
            params: args,
            result: void 0
          },
          done: false
        };
        let content = void 0;
        for await (const update of this.callTool({ model: context.model.id }, toolCall.function, args)) {
          if (update.type === "status") {
            yield {
              type: "tool",
              id: toolCall.id,
              name: toolCall.function,
              status: update.status,
              call: {
                params: args,
                result: void 0
              },
              done: false
            };
          } else if (update.type === "result") {
            content = update.result;
          }
        }
        logger_default.log(`[mistralai] tool call ${toolCall.function} => ${JSON.stringify(content).substring(0, 128)}`);
        context.thread.push({
          role: "assistant",
          toolCalls: toolCall.message
        });
        context.thread.push({
          role: "tool",
          toolCallId: toolCall.id,
          name: toolCall.function,
          content: JSON.stringify(content)
        });
        yield {
          type: "tool",
          id: toolCall.id,
          name: toolCall.function,
          status: this.getToolCompletedDescription(toolCall.function, args, content),
          done: true,
          call: {
            params: args,
            result: content
          }
        };
      }
      if (context.opts.toolChoice?.type === "tool") {
        delete context.opts.toolChoice;
      }
      yield {
        type: "stream",
        stream: await this.doStream(context)
      };
      return;
    }
    yield {
      type: "content",
      text: chunk.data.choices[0].delta.content || "",
      done: chunk.data.choices[0].finishReason != null
    };
    if (context.opts.usage) {
      yield { type: "usage", usage: context.usage };
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  addImageToPayload(attachment, payload, opts) {
    if (typeof payload.content === "string") {
      payload.content = [{
        type: "text",
        text: payload.content
      }];
    }
    if (Array.isArray(payload.content)) {
      payload.content.push({
        type: "image_url",
        imageUrl: { url: `data:${attachment.mimeType};base64,${attachment.content}` }
      });
    }
  }
};
var ollama_default = class extends LlmEngine {
  client;
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static isConfigured = (engineConfig) => {
    return true;
  };
  static isReady = (opts, models) => {
    return models?.chat?.length > 0;
  };
  constructor(config) {
    super(config);
    this.client = new Ollama({
      host: config.baseURL
    });
  }
  getId() {
    return "ollama";
  }
  getModelCapabilities(model) {
    const toolModels = [
      "athene-v2",
      "aya-expanse",
      "cogito",
      "command-a",
      "command-r",
      "command-r-plus",
      "command-r7b",
      "command-r7b-arabic",
      "deepseek-r1",
      "devstral",
      "firefunction-v2",
      "granite3-dense",
      "granite3-moe",
      "granite3.1-dense",
      "granite3.1-moe",
      "granite3.2",
      "granite3.2-vision",
      "granite3.3",
      "hermes3",
      "llama3-groq-tool-use",
      "llama3.1",
      "llama3.2",
      "llama3.3",
      "llama4",
      "magistral",
      "mistral",
      "mistral-large",
      "mistral-nemo",
      "mistral-small",
      "mistral-small3.1",
      "mistral-small3.2",
      "mixtral",
      "nemotron",
      "nemotron-mini",
      "phi4-mini",
      "qwen2",
      "qwen2.5",
      "qwen2.5-coder",
      "qwen3",
      "qwq",
      "smollm2"
    ];
    const visionModels = [
      "bakllava",
      "gemma3",
      "granite3.2-vision",
      "llama3.2-vision",
      "llama4",
      "llava",
      "llava-llama3",
      "llava-phi3",
      "minicpm-v",
      "mistral-small3.1",
      "mistral-small3.2",
      "moondream",
      "qwen2.5vl"
    ];
    const reasoningModels = [
      "cogito:*",
      "deepseek-r1:*",
      "openthinker:*",
      "phi:*",
      "qwq:*",
      "*thinking*",
      "*reasoning*"
    ];
    return {
      tools: toolModels.includes(model.name.split(":")[0]),
      vision: visionModels.some((m2) => model.name.match(m2)),
      reasoning: reasoningModels.some((m2) => minimatch(model.name, m2)),
      caching: false
    };
  }
  async getModels() {
    try {
      const response = await this.client.list();
      return response.models;
    } catch (error) {
      console.error("Error listing models:", error);
      return [];
    }
  }
  async getModelInfo(model) {
    try {
      return await this.client.show({ model });
    } catch (error) {
      console.error("Error listing models:", error);
      return null;
    }
  }
  async pullModel(model) {
    try {
      return this.client.pull({
        model,
        stream: true
      });
    } catch (error) {
      console.error("Error pulling models:", error);
      return null;
    }
  }
  async deleteModel(model) {
    try {
      await this.client.delete({ model });
    } catch (error) {
      console.error("Error deleting model:", error);
    }
  }
  async chat(model, thread, opts) {
    const toolCallInfo = [];
    logger_default.log(`[ollama] prompting model ${model.id}`);
    const response = await this.client.chat({
      ...this.buildChatOptions({
        model: model.id,
        messages: thread,
        opts: opts || null
      }),
      ...await this.getToolOpts(model, opts || {}),
      stream: false
    });
    if (response.message.tool_calls?.length) {
      for (const toolCall of response.message.tool_calls) {
        logger_default.log(`[ollama] tool call ${toolCall.function.name} with ${JSON.stringify(toolCall.function.arguments)}`);
        let content = void 0;
        for await (const update of this.callTool({ model: model.id }, toolCall.function.name, toolCall.function.arguments)) {
          if (update.type === "result") {
            content = update.result;
          }
        }
        logger_default.log(`[ollama] tool call ${toolCall.function} => ${JSON.stringify(content).substring(0, 128)}`);
        thread.push(response.message);
        thread.push({
          role: "tool",
          content: JSON.stringify(content)
        });
        toolCallInfo.push({
          name: toolCall.function.name,
          params: toolCall.function.arguments,
          result: content
        });
      }
      const completion = await this.chat(model, thread, opts);
      completion.toolCalls = [
        ...toolCallInfo,
        ...completion.toolCalls ?? []
      ];
      if (opts?.usage && completion.usage) {
        completion.usage.prompt_tokens += response.prompt_eval_count ?? 0;
        completion.usage.completion_tokens += response.eval_count ?? 0;
      }
      return completion;
    }
    return {
      type: "text",
      content: response.message.content,
      toolCalls: toolCallInfo,
      ...opts?.usage ? { usage: {
        prompt_tokens: response.prompt_eval_count,
        completion_tokens: response.eval_count
      } } : {}
    };
  }
  async stream(model, thread, opts) {
    model = this.selectModel(model, thread, opts);
    const context = {
      model,
      thread: this.buildPayload(model, thread, opts),
      opts: opts || {},
      toolCalls: [],
      usage: { prompt_tokens: 0, completion_tokens: 0 },
      thinking: false
    };
    return {
      stream: await this.doStream(context),
      context
    };
  }
  async doStream(context) {
    context.toolCalls = [];
    context.thinking = false;
    logger_default.log(`[ollama] prompting model ${context.model.id}`);
    const stream = this.client.chat({
      ...this.buildChatOptions({
        model: context.model.id,
        messages: context.thread,
        opts: context.opts
      }),
      ...await this.getToolOpts(context.model, context.opts || {}),
      stream: true
    });
    return stream;
  }
  buildChatOptions({ model, messages, opts }) {
    const chatOptions = {
      model,
      // @ts-expect-error typing
      messages,
      options: {}
    };
    if (opts?.contextWindowSize) {
      chatOptions.options.num_ctx = opts.contextWindowSize;
    }
    if (opts?.maxTokens) {
      chatOptions.options.num_predict = opts.maxTokens;
    }
    if (opts?.temperature) {
      chatOptions.options.temperature = opts.temperature;
    }
    if (opts?.top_k) {
      chatOptions.options.top_k = opts.top_k;
    }
    if (opts?.top_p) {
      chatOptions.options.top_p = opts.top_p;
    }
    if (opts?.structuredOutput) {
      chatOptions.format = zodToJsonSchema(opts.structuredOutput.structure, { name: opts.structuredOutput.name });
    }
    if (Object.keys(opts || {}).length === 0) {
      delete chatOptions.options;
    }
    return chatOptions;
  }
  async getToolOpts(model, opts) {
    if (opts?.tools === false || !model.capabilities.tools) {
      return {};
    }
    const tools = await this.getAvailableTools();
    return tools.length ? {
      tools
      //tool_choice: 'auto',
    } : {};
  }
  async stop() {
    await this.client.abort();
  }
  async *nativeChunkToLlmChunk(chunk, context) {
    if (chunk.done && (chunk.eval_count || chunk.prompt_eval_count)) {
      context.usage.prompt_tokens += chunk.prompt_eval_count ?? 0;
      context.usage.completion_tokens += chunk.eval_count ?? 0;
    }
    if (chunk.message.tool_calls?.length) {
      for (const tool of chunk.message.tool_calls) {
        const toolCall = {
          id: `${context.toolCalls.length}`,
          message: tool,
          function: tool.function.name,
          args: JSON.stringify(tool.function.arguments || "")
        };
        context.toolCalls.push(toolCall);
        yield {
          type: "tool",
          id: toolCall.id,
          name: toolCall.function,
          status: this.getToolPreparationDescription(toolCall.function),
          done: false
        };
        logger_default.log(`[ollama] tool call ${toolCall.function} with ${tool}`);
        const args = JSON.parse(toolCall.args);
        yield {
          type: "tool",
          id: toolCall.id,
          name: toolCall.function,
          status: this.getToolRunningDescription(toolCall.function, args),
          call: {
            params: args,
            result: void 0
          },
          done: false
        };
        let content = void 0;
        for await (const update of this.callTool({ model: context.model.id }, toolCall.function, args)) {
          if (update.type === "status") {
            yield {
              type: "tool",
              id: toolCall.id,
              name: toolCall.function,
              status: update.status,
              call: {
                params: args,
                result: void 0
              },
              done: false
            };
          } else if (update.type === "result") {
            content = update.result;
          }
        }
        logger_default.log(`[ollama] tool call ${toolCall.function} => ${JSON.stringify(content).substring(0, 128)}`);
        context.thread.push(chunk.message);
        context.thread.push({
          role: "tool",
          content: JSON.stringify(content)
        });
        yield {
          type: "tool",
          id: toolCall.id,
          name: toolCall.function,
          status: this.getToolCompletedDescription(toolCall.function, args, content),
          done: true,
          call: {
            params: args,
            result: content
          }
        };
      }
      if (context.opts.toolChoice?.type === "tool") {
        delete context.opts.toolChoice;
      }
      yield {
        type: "stream",
        stream: await this.doStream(context)
      };
      return;
    }
    if (chunk.message.content === "<think>") {
      context.thinking = true;
      return;
    } else if (chunk.message.content === "</think>") {
      context.thinking = false;
      return;
    }
    yield {
      type: context.thinking ? "reasoning" : "content",
      text: chunk.message.content || "",
      done: chunk.done
    };
    if (context.opts.usage && context.usage && chunk.done) {
      yield {
        type: "usage",
        usage: context.usage
      };
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  requiresFlatTextPayload(msg) {
    return true;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  addImageToPayload(attachment, payload, opts) {
    if (!payload.images) payload.images = [];
    payload.images.push(attachment.content);
  }
};
var openrouter_default = class extends openai_default {
  constructor(config) {
    super(config, {
      apiKey: config.apiKey,
      baseURL: "https://openrouter.ai/api/v1"
    });
  }
  getId() {
    return "openrouter";
  }
  async getModels() {
    return await super.getModels();
  }
  getModelCapabilities(model) {
    let input_modalities = model.architecture?.input_modalities;
    if (!input_modalities && model.architecture?.modality) {
      input_modalities = model.architecture.modality.split("->")[0].split("+");
    }
    return {
      tools: model.supported_parameters?.includes("tools") ?? false,
      vision: input_modalities?.includes("image") ?? false,
      reasoning: model.supported_parameters?.includes("reasoning") ?? false,
      caching: false
    };
  }
  modelSupportsStructuredOutput(model) {
    const meta = model.meta;
    return meta?.supported_parameters?.includes("response_format") ?? false;
  }
  get systemRole() {
    return "system";
  }
  setBaseURL() {
  }
  requiresFlatTextPayload(msg) {
    return super.defaultRequiresFlatTextPayload(msg);
  }
};
var xAIBaseURL = "https://api.x.ai/v1";
var xai_default = class extends openai_default {
  constructor(config) {
    super(config, {
      apiKey: config.apiKey,
      baseURL: xAIBaseURL
    });
  }
  getId() {
    return "xai";
  }
  getModelCapabilities(model) {
    const vision = model.id.includes("vision");
    const reasoning = model.id.includes("grok-3-mini");
    return {
      tools: !vision,
      vision,
      reasoning,
      caching: false
    };
  }
  get systemRole() {
    return "system";
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  doesNotSendToolCallFinishReason(model) {
    return true;
  }
  async getModels() {
    if (!this.client.apiKey) {
      return [];
    }
    return await super.getModels();
  }
  setBaseURL() {
  }
  requiresFlatTextPayload(msg) {
    return super.defaultRequiresFlatTextPayload(msg);
  }
};
var igniteEngine = (engine, config) => {
  if (engine === "azure") return new azure_default(config);
  if (engine === "anthropic") return new anthropic_default(config);
  if (engine === "cerebras") return new cerebras_default(config);
  if (engine === "deepseek") return new deepseek_default(config);
  if (engine === "google") return new google_default(config);
  if (engine === "groq") return new groq_default(config);
  if (engine === "lmstudio") return new lmstudio_default(config);
  if (engine === "meta") return new meta_default(config);
  if (engine === "mistralai") return new mistralai_default(config);
  if (engine === "ollama") return new ollama_default(config);
  if (engine === "openai") return new openai_default(config);
  if (engine === "openrouter") return new openrouter_default(config);
  if (engine === "xai") return new xai_default(config);
  throw new Error("Unknown engine: " + engine);
};
var loadModels = async (engine, config) => {
  if (engine === "azure") return await loadAzureModels(config);
  if (engine === "anthropic") return await loadAnthropicModels(config);
  if (engine === "cerebras") return await loadCerebrasModels(config);
  if (engine === "deepseek") return await loadDeepSeekModels(config);
  if (engine === "google") return await loadGoogleModels(config);
  if (engine === "groq") return await loadGroqModels(config);
  if (engine === "lmstudio") return await loadLMStudioModels(config);
  if (engine === "meta") return await loadMetaModels(config);
  if (engine === "mistralai") return await loadMistralAIModels(config);
  if (engine === "ollama") return await loadOllamaModels(config);
  if (engine === "openai") return await loadOpenAIModels(config);
  if (engine === "openrouter") return await loadOpenRouterModels(config);
  if (engine === "xai") return await loadXAIModels(config);
  throw new Error("Unknown engine: " + engine);
};
var loadAnthropicModels = async (engineConfig, computerInfo = null) => {
  const anthropic = new anthropic_default(engineConfig, computerInfo);
  let metas = [];
  try {
    metas = await anthropic.getModels();
  } catch (error) {
    console.error("Error listing Anthropic models:", error);
  }
  if (!metas) {
    return null;
  }
  const models = metas.map((m2) => ({
    id: m2.id,
    name: m2.display_name,
    capabilities: anthropic.getModelCapabilities(m2),
    meta: m2
  })).sort((a2, b2) => b2.meta.created_at.localeCompare(a2.meta.created_at));
  return {
    chat: models,
    //.sort((a, b) => a.name.localeCompare(b.name)),
    image: [],
    embedding: []
  };
};
var loadAzureModels = async (engineConfig) => {
  const azure = new azure_default(engineConfig);
  let metas = [];
  try {
    metas = await azure.getModels();
  } catch (error) {
    console.error("Error listing Azure models:", error);
  }
  if (!metas) {
    return null;
  }
  const models = metas.map((m2) => ({
    id: m2.id,
    name: m2.id,
    capabilities: azure.getModelCapabilities(m2),
    meta: m2
  })).sort((a2, b2) => a2.name.localeCompare(b2.name));
  return {
    chat: models,
    image: []
  };
};
var loadCerebrasModels = async (engineConfig) => {
  const cerebras = new cerebras_default(engineConfig);
  let metas = [];
  try {
    metas = await cerebras.getModels();
  } catch (error) {
    console.error("Error listing Cerebras models:", error);
  }
  if (!metas) {
    return null;
  }
  const models = metas.map((m2) => ({
    id: m2.id,
    name: m2.id.split("-").map((s2) => s2.charAt(0).toUpperCase() + s2.slice(1)).join(" "),
    capabilities: cerebras.getModelCapabilities(m2),
    meta: m2
  })).sort((a2, b2) => b2.meta.created - a2.meta.created);
  return {
    chat: models,
    //.sort((a, b) => a.name.localeCompare(b.name))
    image: [],
    embedding: []
  };
};
var loadDeepSeekModels = async (engineConfig) => {
  const deepseek = new deepseek_default(engineConfig);
  let metas = [];
  try {
    metas = await deepseek.getModels();
  } catch (error) {
    console.error("Error listing DeepSeek models:", error);
  }
  if (!metas) {
    return null;
  }
  const models = metas.map((m2) => ({
    id: m2.id,
    name: m2.id.split("-").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ").replace("Deepseek", "DeepSeek"),
    capabilities: deepseek.getModelCapabilities(m2),
    meta: m2
  }));
  return {
    chat: models,
    //.sort((a, b) => a.name.localeCompare(b.name))
    image: [],
    embedding: []
  };
};
var loadGoogleModels = async (engineConfig) => {
  const google = new google_default(engineConfig);
  let metas = [];
  try {
    metas = await google.getModels();
  } catch (error) {
    console.error("Error listing Google models:", error);
  }
  if (!metas) {
    return null;
  }
  const uniques = [];
  const versions = /* @__PURE__ */ new Set();
  for (const model of metas) {
    if (!model.version) {
      uniques.push(model);
      continue;
    }
    if (versions.has(model.version)) {
      continue;
    }
    uniques.push(model);
    versions.add(model.version);
  }
  const models = uniques.map((m2) => ({
    id: m2.name.replace("models/", ""),
    name: m2.displayName ?? m2.name,
    capabilities: google.getModelCapabilities(m2),
    meta: m2
  })).filter((m2) => !m2.id.includes("generation"));
  const realtimeModels = models.filter((model) => model.id.includes("dialog"));
  const imageModels = models.filter((m2) => m2.meta.supportedActions?.includes("predict"));
  const videoModels = models.filter((m2) => m2.meta.supportedActions?.includes("predictLongRunning"));
  const embeddingModels = models.filter((m2) => m2.meta.supportedActions?.includes("embedContent"));
  const ttsModels = models.filter((model) => model.id.endsWith("tts"));
  const chatModels = models.filter((m2) => m2.meta.supportedActions?.includes("generateContent")).filter((m2) => !m2.meta.supportedActions?.includes("bidiGenerateContent")).filter(
    (model) => !imageModels.includes(model) && !videoModels.includes(model) && !embeddingModels.includes(model) && !realtimeModels.includes(model) && !ttsModels.includes(model)
  ).sort((a2, b2) => {
    if (a2.id.includes("gemini") && !b2.id.includes("gemini")) {
      return -1;
    }
    return b2.name.localeCompare(a2.name);
  });
  return {
    chat: chatModels,
    image: imageModels,
    video: videoModels,
    embedding: embeddingModels,
    realtime: realtimeModels,
    tts: ttsModels
  };
};
var loadGroqModels = async (engineConfig) => {
  const groq = new groq_default(engineConfig);
  let metas = [];
  try {
    metas = await groq.getModels();
  } catch (error) {
    console.error("Error listing Groq models:", error);
  }
  if (!metas) {
    return null;
  }
  const models = metas.map((m2) => ({
    id: m2.id,
    name: m2.id.split("-").map((s2) => s2.charAt(0).toUpperCase() + s2.slice(1)).join(" "),
    capabilities: groq.getModelCapabilities(m2),
    meta: m2
  })).sort((a2, b2) => b2.meta.created - a2.meta.created);
  const ttsModels = models.filter((model) => model.id.includes("tts"));
  const chatModels = models.filter(
    (model) => !ttsModels.includes(model)
  );
  return {
    chat: chatModels,
    //.sort((a, b) => a.name.localeCompare(b.name))
    image: [],
    embedding: [],
    realtime: [],
    computer: [],
    stt: [],
    tts: ttsModels
  };
};
var loadLMStudioModels = async (engineConfig) => {
  const lmStudio = new lmstudio_default(engineConfig);
  let metas = [];
  try {
    metas = await lmStudio.getModels();
  } catch (error) {
    console.error("Error listing LMStudio models:", error);
  }
  if (!metas) {
    return null;
  }
  const models = metas.map((m2) => ({
    id: m2.id,
    name: m2.id.split("-").map((s2) => s2.charAt(0).toUpperCase() + s2.slice(1)).join(" "),
    capabilities: lmStudio.getModelCapabilities(m2),
    meta: m2
  }));
  return {
    chat: models,
    image: [],
    embedding: []
  };
};
var loadMetaModels = async (engineConfig) => {
  const meta = new meta_default(engineConfig);
  let metas = [];
  try {
    metas = await meta.getModels();
  } catch (error) {
    console.error("Error listing Meta models:", error);
  }
  if (!metas) {
    return null;
  }
  const models = metas.map((m2) => ({
    id: m2.id,
    name: m2.id.split("-").join(" "),
    capabilities: meta.getModelCapabilities(m2),
    meta: m2
  })).sort((a2, b2) => b2.meta.created - a2.meta.created);
  return {
    chat: models,
    image: [],
    embedding: []
  };
};
var loadMistralAIModels = async (engineConfig) => {
  const mistralai = new mistralai_default(engineConfig);
  let metas = [];
  try {
    metas = await mistralai.getModels();
  } catch (error) {
    console.error("Error listing MistralAI models:", error);
  }
  if (!metas.length) {
    return null;
  }
  const uniques = [];
  const aliases = /* @__PURE__ */ new Set();
  for (const model of metas) {
    if (aliases.has(model.id)) {
      continue;
    }
    const latest = model.aliases?.filter((alias) => alias.endsWith("-latest"));
    if (latest?.length === 1) {
      model.id = latest[0];
      model.name = model.id;
    }
    uniques.push(model);
    model.aliases?.forEach((alias) => aliases.add(alias));
  }
  const models = uniques.map((m2) => ({
    id: m2.id,
    name: (m2.name || m2.id).split("-").map((s2) => s2.charAt(0).toUpperCase() + s2.slice(1)).join(" "),
    capabilities: mistralai.getModelCapabilities(m2),
    meta: m2
  })).sort((a2, b2) => {
    if (a2.meta?.created && b2.meta?.created && a2.meta.created !== b2.meta.created) {
      return b2.meta.created - a2.meta.created;
    } else {
      return a2.name.localeCompare(b2.name);
    }
  });
  return {
    chat: models.filter((m2) => m2.meta.capabilities?.completionChat),
    image: [],
    embedding: []
  };
};
var loadOllamaModels = async (engineConfig) => {
  const ollama = new ollama_default(engineConfig);
  let metas = [];
  try {
    metas = await ollama.getModels();
  } catch (error) {
    console.error("Error listing Ollama models:", error);
  }
  if (!metas.length) {
    return null;
  }
  const models = metas.map((m2) => ({
    id: m2.model,
    name: m2.name,
    capabilities: ollama.getModelCapabilities(m2),
    meta: m2
  }));
  const chatModels = [];
  const embeddingModels = [];
  for (const model of models) {
    try {
      const info = await ollama.getModelInfo(model.id);
      if (!info) {
        chatModels.push(model.id);
        continue;
      }
      let isEmbedding = info.details.family.includes("bert");
      if (info && "capabilities" in info) {
        const capabilities = info.capabilities || [];
        if (capabilities.includes("embedding")) {
          isEmbedding = true;
        }
        if (capabilities.includes("tools")) {
          model.capabilities.tools = true;
        }
        if (capabilities.includes("vision")) {
          model.capabilities.vision = true;
        }
      }
      if (isEmbedding) {
        embeddingModels.push(model.id);
      } else {
        chatModels.push(model.id);
      }
    } catch (e2) {
      console.error(`Error getting info for model ${model.id}:`, e2);
    }
  }
  return {
    chat: models.filter((model) => chatModels.includes(model.id)).sort((a2, b2) => a2.name.localeCompare(b2.name)),
    image: [],
    embedding: models.filter((model) => embeddingModels.includes(model.id)).sort((a2, b2) => a2.name.localeCompare(b2.name))
  };
};
var loadOpenAIModels = async (engineConfig) => {
  const openAI = new openai_default(engineConfig);
  let metas = [];
  try {
    metas = await openAI.getModels();
  } catch (error) {
    console.error("Error listing OpenAI models:", error);
  }
  if (!metas) {
    return null;
  }
  let models = metas.map((m2) => ({
    id: m2.id,
    name: m2.id,
    capabilities: openAI.getModelCapabilities(m2),
    meta: m2
  })).sort((a2, b2) => b2.meta.created - a2.meta.created);
  if (!engineConfig.baseURL || engineConfig.baseURL.includes("api.openai.com")) {
    models = models.filter(
      (model) => !model.id.includes("davinci") && !model.id.includes("babbage") && !model.id.includes("moderation") && !model.id.includes("audio") && !model.id.includes("search")
    );
    const imageModels = models.filter((model) => model.id.startsWith("dall-e-") || model.id.includes("image-"));
    const embeddingModels = models.filter((model) => model.id.startsWith("text-embedding-"));
    const realtimeModels = models.filter((model) => model.id.includes("realtime"));
    const computerModels = models.filter((model) => model.id.includes("computer-use"));
    const sttModels = models.filter((model) => model.id.includes("whisper") || model.id.includes("transcribe"));
    const ttsModels = models.filter((model) => model.id.includes("tts"));
    if (!imageModels.map((m2) => m2.id).includes("gpt-image-1")) {
      imageModels.unshift({ id: "gpt-image-1", name: "GPT Image", meta: {
        id: "gpt-image-1",
        object: "model",
        created: 0,
        owned_by: "system"
      }, capabilities: { tools: false, vision: false, reasoning: false, caching: false } });
    }
    const chatModels = models.filter(
      (model) => !imageModels.includes(model) && !embeddingModels.includes(model) && !realtimeModels.includes(model) && !computerModels.includes(model) && !sttModels.includes(model) && !ttsModels.includes(model)
    );
    return {
      chat: chatModels,
      image: imageModels,
      embedding: embeddingModels,
      realtime: realtimeModels,
      computer: computerModels,
      stt: sttModels,
      tts: ttsModels
    };
  } else if (engineConfig.baseURL.includes("api.together.xyz")) {
    return {
      chat: models.filter((model) => ["language", "chat", "code"].includes(model.meta?.type)),
      image: models.filter((model) => model.meta?.type === "image"),
      embedding: models.filter((model) => model.meta?.type === "embedding")
    };
  } else {
    return {
      chat: models,
      image: [],
      embedding: []
    };
  }
};
var loadOpenRouterModels = async (engineConfig) => {
  const openrouter = new openrouter_default(engineConfig);
  let metas = [];
  try {
    metas = await openrouter.getModels();
  } catch (error) {
    console.error("Error listing OpenRouter models:", error);
  }
  if (!metas) {
    return null;
  }
  const models = metas.map((m2) => ({
    id: m2.id,
    name: m2.name,
    capabilities: openrouter.getModelCapabilities(m2),
    meta: m2
  }));
  return {
    chat: models.filter((m2) => m2.meta?.architecture?.modality?.split(">")?.pop()?.includes("text")).sort((a2, b2) => a2.name.localeCompare(b2.name)),
    image: models.filter((m2) => m2.meta?.architecture?.modality?.split(">")?.pop()?.includes("image")).sort((a2, b2) => a2.name.localeCompare(b2.name)),
    embedding: []
  };
};
var loadXAIModels = async (engineConfig) => {
  const xai = new xai_default(engineConfig);
  let metas = [];
  try {
    metas = await xai.getModels();
  } catch (error) {
    console.error("Error listing xAI models:", error);
  }
  if (!metas) {
    return null;
  }
  const models = metas.map((m2) => ({
    id: m2.id,
    name: m2.id.split("-").map((s2) => s2.charAt(0).toUpperCase() + s2.slice(1)).join(" "),
    capabilities: xai.getModelCapabilities(m2),
    meta: m2
  })).sort((a2, b2) => b2.meta.created - a2.meta.created);
  return {
    chat: models.filter((m2) => !m2.id.includes("image")),
    image: models.filter((m2) => m2.id.includes("image")),
    embedding: []
  };
};
var logger = {
  disable: logger_default.disableLogger,
  set: logger_default.setLogger
};

// src/prompt/impl/QiCorePromptManager.ts
var llmError = (code, message, category, context = {}) => create4(code, message, category, context);
var QiCorePromptManager = class {
  engines = /* @__PURE__ */ new Map();
  config = null;
  async loadConfig(configPath, schemaPath) {
    return fromAsyncTryCatch4(
      async () => {
        const builderResult = await ConfigBuilder.fromYamlFile(configPath);
        const config = match5(
          (builder) => match5(
            (validatedConfig) => validatedConfig,
            (error) => {
              throw new Error(`Config validation failed: ${error.message}`);
            },
            builder.validateWithSchemaFile(schemaPath).build()
          ),
          (error) => {
            throw new Error(`Config loading failed: ${error.message}`);
          },
          builderResult
        );
        const llmSection = match5(
          (section) => section,
          (error) => {
            throw new Error(`LLM config not found: ${error.message}`);
          },
          config.get("llm")
        );
        const llmConfig = { llm: llmSection };
        this.config = llmConfig;
        return llmConfig;
      },
      (error) => validationError(
        `Config loading failed: ${error instanceof Error ? error.message : "Unknown error"}`
      )
    );
  }
  async initializeProviders(config) {
    this.config = config;
    this.engines.clear();
    const initResults = [];
    for (const [providerId, provider] of Object.entries(config.llm.providers)) {
      if (!provider.enabled) {
        continue;
      }
      const initResult = await this.initializeProvider(providerId, provider);
      initResults.push(initResult);
      match5(
        (engine) => {
          this.engines.set(providerId, engine);
        },
        () => {
        },
        initResult
      );
    }
    if (this.engines.size === 0) {
      return Err(
        llmError("NO_PROVIDERS_INITIALIZED", "No LLM providers could be initialized", "SYSTEM", {
          operation: "initialize"
        })
      );
    }
    return Ok(void 0);
  }
  async executePrompt(prompt, options) {
    if (!this.config) {
      return Err(
        llmError("NOT_INITIALIZED", "PromptManager not initialized", "SYSTEM", {
          operation: "executePrompt"
        })
      );
    }
    const validationResult = this.validatePrompt(prompt);
    return match5(
      async (validatedPrompt) => await this.tryProvider(options.providerId, validatedPrompt, options),
      async (error) => Err(error),
      validationResult
    );
  }
  getProviderStatus() {
    const status = {};
    for (const [id, engine] of this.engines) {
      status[id] = {
        available: true,
        models: engine.models.length,
        name: engine.name
      };
    }
    return Ok(status);
  }
  isProviderAvailable(providerId) {
    return Ok(this.engines.has(providerId));
  }
  // Private methods (extracted from working demo)
  validatePrompt(prompt) {
    if (!prompt || prompt.trim().length === 0) {
      return Err(
        llmError("INVALID_PROMPT", "Prompt cannot be empty", "VALIDATION", {
          operation: "validatePrompt"
        })
      );
    }
    if (prompt.length > 1e4) {
      return Err(
        llmError(
          "PROMPT_TOO_LONG",
          "Prompt exceeds maximum length of 10,000 characters",
          "VALIDATION",
          { operation: "validatePrompt" }
        )
      );
    }
    return Ok(prompt.trim());
  }
  async tryProvider(providerId, prompt, options) {
    const engine = this.engines.get(providerId);
    if (!engine) {
      return Err(
        llmError("PROVIDER_NOT_FOUND", `Provider ${providerId} not available`, "SYSTEM", {
          provider: providerId,
          operation: "tryProvider"
        })
      );
    }
    const model = this.selectModel(engine, options.model);
    if (!model) {
      return Err(
        llmError(
          "NO_MODEL_AVAILABLE",
          `No suitable model found for provider ${providerId}`,
          "SYSTEM",
          { provider: providerId, operation: "selectModel" }
        )
      );
    }
    return fromAsyncTryCatch4(
      async () => {
        const messages = [new Message("user", prompt)];
        const response = await engine.engine.complete(model, messages);
        if (typeof response === "string") {
          return response;
        }
        if (response && typeof response === "object" && "content" in response) {
          return response.content;
        }
        return JSON.stringify(response);
      },
      (error) => llmError(
        "COMPLETION_FAILED",
        `Provider ${providerId} completion failed: ${error instanceof Error ? error.message : "Unknown error"}`,
        "NETWORK",
        {
          provider: providerId,
          model: model.id || "unknown",
          operation: "complete",
          error: String(error)
        }
      )
    );
  }
  async initializeProvider(providerId, provider) {
    return fromAsyncTryCatch4(
      async () => {
        const engineConfig = {
          baseURL: provider.baseURL
        };
        if (provider.apiKey && provider.type === "api") {
          const apiKey = provider.apiKey.startsWith("${") && provider.apiKey.endsWith("}") ? process.env[provider.apiKey.slice(2, -1)] : provider.apiKey;
          if (!apiKey) {
            throw new Error(`No API key found for provider ${provider.name}`);
          }
          engineConfig.apiKey = apiKey;
        }
        const engineType = this.mapProviderToEngine(providerId);
        const engine = igniteEngine(engineType, engineConfig);
        const modelData = await loadModels(engineType, engineConfig);
        const models = modelData?.chat || [];
        return {
          id: providerId,
          name: provider.name,
          engine,
          models
        };
      },
      (error) => llmError(
        "PROVIDER_INIT_FAILED",
        `Failed to initialize provider ${provider.name}: ${error instanceof Error ? error.message : "Unknown error"}`,
        "SYSTEM",
        {
          provider: providerId,
          operation: "initializeProvider",
          error: String(error)
        }
      )
    );
  }
  selectModel(engine, preferredModel) {
    if (engine.models.length === 0) {
      return { id: "default" };
    }
    if (preferredModel) {
      const model = engine.models.find((m2) => m2.id === preferredModel);
      if (model) return model;
    }
    return engine.models[0];
  }
  mapProviderToEngine(providerId) {
    const mapping = {
      ollama: "ollama",
      openrouter: "openai",
      // OpenRouter uses OpenAI-compatible API
      groq: "groq",
      huggingface: "huggingface",
      together: "together"
    };
    return mapping[providerId] || providerId;
  }
};

// src/prompt/index.ts
function createPromptHandler() {
  const manager = new QiCorePromptManager();
  return new DefaultPromptHandler(manager);
}

// src/state/impl/StateManager.ts
import { randomUUID as randomUUID2 } from "crypto";
import { join } from "path";
import { fromAsyncTryCatch as fromAsyncTryCatch5, match as match6, validationError as validationError2 } from "@qi/base";
import { ConfigBuilder as ConfigBuilder2 } from "@qi/core";
var DEFAULT_CONFIG = {
  version: "0.2.7",
  defaultModel: "ollama",
  availableModels: ["ollama", "groq", "openai"],
  enableDebugMode: false,
  maxHistorySize: 100,
  sessionTimeout: 30 * 60 * 1e3,
  // 30 minutes
  preferences: /* @__PURE__ */ new Map()
};
var DEFAULT_MODELS = [
  {
    id: "ollama",
    name: "Ollama (qwen2.5:7b)",
    provider: "ollama",
    available: true,
    description: "Local Ollama model"
  },
  {
    id: "groq",
    name: "Groq (llama-3.1-70b)",
    provider: "groq",
    available: false,
    description: "Fast inference via Groq"
  },
  {
    id: "openai",
    name: "OpenAI (gpt-4)",
    provider: "openai",
    available: false,
    description: "OpenAI GPT-4"
  }
];
var StateManager = class {
  config;
  currentModel;
  currentMode;
  context;
  session;
  models;
  listeners = /* @__PURE__ */ new Set();
  // LLM configuration
  llmConfig = null;
  classifierConfig = null;
  promptConfig = null;
  constructor() {
    this.config = { ...DEFAULT_CONFIG };
    this.currentModel = DEFAULT_CONFIG.defaultModel;
    this.currentMode = "ready";
    this.models = /* @__PURE__ */ new Map();
    for (const model of DEFAULT_MODELS) {
      this.models.set(model.id, model);
    }
    this.context = {
      sessionId: randomUUID2(),
      currentDirectory: process.cwd(),
      environment: new Map(
        Object.entries(process.env).filter(([_2, v2]) => v2 !== void 0)
      ),
      metadata: /* @__PURE__ */ new Map()
    };
    this.session = this.createSession();
  }
  // Configuration management
  getConfig() {
    return { ...this.config };
  }
  updateConfig(updates) {
    const oldConfig = { ...this.config };
    this.config = { ...this.config, ...updates };
    this.notifyChange({
      type: "config",
      field: "config",
      oldValue: oldConfig,
      newValue: this.config,
      timestamp: /* @__PURE__ */ new Date()
    });
  }
  resetConfig() {
    const oldConfig = { ...this.config };
    this.config = { ...DEFAULT_CONFIG };
    this.notifyChange({
      type: "config",
      field: "config",
      oldValue: oldConfig,
      newValue: this.config,
      timestamp: /* @__PURE__ */ new Date()
    });
  }
  // LLM configuration management (qicore internal, simple interface for agent)
  async loadLLMConfig(configPath) {
    const result = await fromAsyncTryCatch5(
      async () => {
        const configFilePath = join(configPath, "llm-providers.yaml");
        const schemaFilePath = join(configPath, "llm-providers.schema.json");
        const builderResult = await ConfigBuilder2.fromYamlFile(configFilePath);
        const config = match6(
          (builder) => match6(
            (validatedConfig) => validatedConfig,
            (error) => {
              throw new Error(`Config validation failed: ${error.message}`);
            },
            builder.validateWithSchemaFile(schemaFilePath).build()
          ),
          (error) => {
            throw new Error(`Config loading failed: ${error.message}`);
          },
          builderResult
        );
        const llmSection = match6(
          (section) => section,
          (error) => {
            throw new Error(`LLM config not found: ${error.message}`);
          },
          config.get("llm")
        );
        this.llmConfig = { llm: llmSection };
        if (this.llmConfig.llm?.classifier) {
          this.classifierConfig = {
            provider: this.llmConfig.llm.classifier.provider,
            model: this.llmConfig.llm.classifier.model,
            temperature: this.llmConfig.llm.classifier.temperature,
            maxTokens: this.llmConfig.llm.classifier.maxTokens
          };
        }
        if (this.llmConfig.llm?.prompt) {
          this.promptConfig = {
            provider: this.llmConfig.llm.prompt.defaultProvider || this.llmConfig.llm.defaultProvider,
            model: this.llmConfig.llm.prompt.currentModel,
            temperature: this.llmConfig.llm.providers?.[this.llmConfig.llm.prompt.defaultProvider || this.llmConfig.llm.defaultProvider]?.models?.[0]?.defaultParameters?.temperature,
            maxTokens: this.llmConfig.llm.providers?.[this.llmConfig.llm.prompt.defaultProvider || this.llmConfig.llm.defaultProvider]?.models?.[0]?.defaultParameters?.max_tokens
          };
        }
        this.updateConfig({ configPath });
        this.notifyChange({
          type: "config",
          field: "llmConfig",
          oldValue: null,
          newValue: this.llmConfig,
          timestamp: /* @__PURE__ */ new Date()
        });
        return void 0;
      },
      (error) => validationError2(
        `LLM config loading failed: ${error instanceof Error ? error.message : "Unknown error"}`
      )
    );
    return match6(
      () => Promise.resolve(),
      (error) => Promise.reject(new Error(error.message)),
      result
    );
  }
  getClassifierConfig() {
    return this.classifierConfig ? { ...this.classifierConfig } : null;
  }
  getPromptConfig() {
    return this.promptConfig ? { ...this.promptConfig } : null;
  }
  updatePromptModel(model) {
    if (!this.promptConfig) {
      throw new Error("Prompt configuration not loaded");
    }
    const availableModels = this.getAvailablePromptModels();
    if (!availableModels.includes(model)) {
      throw new Error(`Model '${model}' not available for prompts`);
    }
    const oldConfig = { ...this.promptConfig };
    this.promptConfig = { ...this.promptConfig, model };
    const _oldCurrentModel = this.currentModel;
    this.currentModel = model;
    if (this.llmConfig?.llm?.prompt) {
      this.llmConfig.llm.prompt.currentModel = model;
    }
    this.notifyChange({
      type: "config",
      field: "promptModel",
      oldValue: oldConfig,
      newValue: this.promptConfig,
      timestamp: /* @__PURE__ */ new Date()
    });
  }
  updatePromptMaxTokens(maxTokens) {
    if (!this.promptConfig) {
      throw new Error("Prompt configuration not loaded");
    }
    if (maxTokens < 1 || maxTokens > 32768) {
      throw new Error("Max tokens must be between 1 and 32768");
    }
    const oldConfig = { ...this.promptConfig };
    this.promptConfig = { ...this.promptConfig, maxTokens };
    if (this.llmConfig?.llm?.providers?.[this.promptConfig.provider]?.models) {
      const models = this.llmConfig.llm.providers[this.promptConfig.provider].models;
      const currentModel = models.find((m2) => m2.name === this.promptConfig?.model);
      if (currentModel?.defaultParameters) {
        currentModel.defaultParameters.max_tokens = maxTokens;
      }
    }
    this.notifyChange({
      type: "config",
      field: "promptMaxTokens",
      oldValue: oldConfig,
      newValue: this.promptConfig,
      timestamp: /* @__PURE__ */ new Date()
    });
  }
  getAvailablePromptModels() {
    if (!this.llmConfig?.llm?.providers || !this.promptConfig?.provider) {
      return [];
    }
    const currentProvider = this.promptConfig.provider;
    const providerConfig = this.llmConfig.llm.providers[currentProvider];
    if (!providerConfig?.models) {
      return [];
    }
    return providerConfig.models.map((model) => model.name);
  }
  updatePromptProvider(provider) {
    if (!this.promptConfig) {
      throw new Error("Prompt configuration not loaded");
    }
    const availableProviders = this.getAvailablePromptProviders();
    if (!availableProviders.includes(provider)) {
      throw new Error(`Provider '${provider}' not available for prompts`);
    }
    const oldConfig = { ...this.promptConfig };
    const providerConfig = this.llmConfig?.llm?.providers?.[provider];
    const availableModels = providerConfig?.models?.map((model) => model.name) || [];
    const newModel = availableModels.length > 0 ? availableModels[0] : this.promptConfig.model;
    this.promptConfig = {
      ...this.promptConfig,
      provider,
      model: newModel
    };
    this.currentModel = newModel;
    if (this.llmConfig?.llm?.prompt) {
      this.llmConfig.llm.prompt.currentModel = newModel;
    }
    this.notifyChange({
      type: "config",
      field: "promptProvider",
      oldValue: oldConfig,
      newValue: this.promptConfig,
      timestamp: /* @__PURE__ */ new Date()
    });
  }
  getAvailablePromptProviders() {
    if (!this.llmConfig?.llm?.providers) {
      return [];
    }
    return Object.keys(this.llmConfig.llm.providers).filter(
      (providerId) => this.llmConfig?.llm?.providers?.[providerId]?.enabled === true
    );
  }
  /**
   * Extract LLMConfig structure that the prompt module expects
   * This removes our classifier/prompt sections and returns the traditional structure
   */
  getLLMConfigForPromptModule() {
    if (!this.llmConfig?.llm) {
      return null;
    }
    const { classifier, prompt, ...llmCore } = this.llmConfig.llm;
    return {
      llm: llmCore
    };
  }
  // Model management
  getCurrentModel() {
    return this.currentModel;
  }
  setCurrentModel(modelId) {
    if (!this.models.has(modelId)) {
      throw new Error(`Model '${modelId}' not found`);
    }
    const oldModel = this.currentModel;
    this.currentModel = modelId;
    this.notifyChange({
      type: "model",
      field: "currentModel",
      oldValue: oldModel,
      newValue: modelId,
      timestamp: /* @__PURE__ */ new Date()
    });
  }
  getAvailableModels() {
    return Array.from(this.models.values());
  }
  getModelInfo(modelId) {
    return this.models.get(modelId) || null;
  }
  addModel(model) {
    this.models.set(model.id, model);
    this.notifyChange({
      type: "model",
      field: "models",
      oldValue: null,
      newValue: model,
      timestamp: /* @__PURE__ */ new Date()
    });
  }
  removeModel(modelId) {
    const model = this.models.get(modelId);
    if (model) {
      this.models.delete(modelId);
      if (this.currentModel === modelId) {
        this.setCurrentModel(this.config.defaultModel);
      }
      this.notifyChange({
        type: "model",
        field: "models",
        oldValue: model,
        newValue: null,
        timestamp: /* @__PURE__ */ new Date()
      });
    }
  }
  // Mode management
  getCurrentMode() {
    return this.currentMode;
  }
  setCurrentMode(mode) {
    const oldMode = this.currentMode;
    this.currentMode = mode;
    this.notifyChange({
      type: "mode",
      field: "currentMode",
      oldValue: oldMode,
      newValue: mode,
      timestamp: /* @__PURE__ */ new Date()
    });
  }
  // Context management
  getContext() {
    return { ...this.context };
  }
  updateContext(updates) {
    const oldContext = { ...this.context };
    this.context = { ...this.context, ...updates };
    this.notifyChange({
      type: "context",
      field: "context",
      oldValue: oldContext,
      newValue: this.context,
      timestamp: /* @__PURE__ */ new Date()
    });
  }
  resetContext() {
    const oldContext = { ...this.context };
    this.context = {
      sessionId: randomUUID2(),
      currentDirectory: process.cwd(),
      environment: new Map(
        Object.entries(process.env).filter(([_2, v2]) => v2 !== void 0)
      ),
      metadata: /* @__PURE__ */ new Map()
    };
    this.notifyChange({
      type: "context",
      field: "context",
      oldValue: oldContext,
      newValue: this.context,
      timestamp: /* @__PURE__ */ new Date()
    });
  }
  // Session management
  getCurrentSession() {
    return { ...this.session };
  }
  createSession(userId) {
    const now = /* @__PURE__ */ new Date();
    const newSession = {
      id: randomUUID2(),
      userId,
      createdAt: now,
      lastActiveAt: now,
      conversationHistory: [],
      context: this.getContext(),
      metadata: /* @__PURE__ */ new Map()
    };
    this.session = newSession;
    this.notifyChange({
      type: "session",
      field: "session",
      oldValue: null,
      newValue: newSession,
      timestamp: /* @__PURE__ */ new Date()
    });
    return { ...newSession };
  }
  loadSession(_sessionId) {
    return null;
  }
  saveSession() {
    this.session = {
      ...this.session,
      lastActiveAt: /* @__PURE__ */ new Date()
    };
  }
  addConversationEntry(entry) {
    const newEntry = {
      id: randomUUID2(),
      timestamp: /* @__PURE__ */ new Date(),
      ...entry
    };
    const updatedHistory = [...this.session.conversationHistory, newEntry];
    if (updatedHistory.length > this.config.maxHistorySize) {
      updatedHistory.splice(0, updatedHistory.length - this.config.maxHistorySize);
    }
    this.session = {
      ...this.session,
      conversationHistory: updatedHistory,
      lastActiveAt: /* @__PURE__ */ new Date()
    };
    this.notifyChange({
      type: "session",
      field: "conversationHistory",
      oldValue: null,
      newValue: newEntry,
      timestamp: /* @__PURE__ */ new Date()
    });
  }
  clearConversationHistory() {
    const oldHistory = this.session.conversationHistory;
    this.session = {
      ...this.session,
      conversationHistory: [],
      lastActiveAt: /* @__PURE__ */ new Date()
    };
    this.notifyChange({
      type: "session",
      field: "conversationHistory",
      oldValue: oldHistory,
      newValue: [],
      timestamp: /* @__PURE__ */ new Date()
    });
  }
  // State persistence
  async save() {
  }
  async load() {
  }
  // State change notifications
  subscribe(listener) {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }
  notifyChange(change) {
    for (const listener of this.listeners) {
      try {
        listener(change);
      } catch (error) {
        console.error("State change listener error:", error);
      }
    }
  }
  // Utility methods
  getState() {
    return {
      config: this.getConfig(),
      currentModel: this.getCurrentModel(),
      currentMode: this.getCurrentMode(),
      context: this.getContext(),
      session: this.getCurrentSession()
    };
  }
  reset() {
    this.config = { ...DEFAULT_CONFIG };
    this.currentModel = DEFAULT_CONFIG.defaultModel;
    this.currentMode = "ready";
    this.resetContext();
    this.session = this.createSession();
    this.models.clear();
    for (const model of DEFAULT_MODELS) {
      this.models.set(model.id, model);
    }
    this.notifyChange({
      type: "config",
      field: "reset",
      oldValue: null,
      newValue: null,
      timestamp: /* @__PURE__ */ new Date()
    });
  }
};

// src/state/index.ts
function createStateManager() {
  return new StateManager();
}

// src/workflow/impl/QiWorkflowExtractor.ts
import { create as create5 } from "@qi/base";
export {
  ClassificationSchemas,
  ContextManager,
  DefaultPromptHandler,
  IntentSchema,
  QiCorePromptManager,
  SecurityBoundaryManager,
  SentimentSchema,
  ThreeTypeSchema,
  TopicSchema,
  createAccurateClassifier,
  createAgent,
  createBasicClassifier,
  createClassifier,
  createCommandHandler,
  createCompleteClassifier,
  createContextManager,
  createDefaultAppContext,
  createFastClassifier,
  createInputClassifier,
  createPromptApp,
  createPromptHandler,
  createRuleBasedClassifier,
  createStateManager as createStateManagerFactory,
  getClassificationSchema,
  globalSchemaRegistry,
  parseInput,
  selectOptimalClassificationSchema
};
/*! Bundled license information:

web-streams-polyfill/dist/ponyfill.mjs:
  (**
   * @license
   * web-streams-polyfill v4.0.0-beta.3
   * Copyright 2021 Mattias Buelens, Diwank Singh Tomer and other contributors.
   * This code is released under the MIT license.
   * SPDX-License-Identifier: MIT
   *)

formdata-node/lib/esm/blobHelpers.js:
formdata-node/lib/esm/Blob.js:
  (*! Based on fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> & David Frank *)

humanize-ms/index.js:
  (*!
   * humanize-ms - index.js
   * Copyright(c) 2014 dead_horse <dead_horse@qq.com>
   * MIT Licensed
   *)

node-domexception/index.js:
  (*! node-domexception. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@google/genai/dist/node/index.mjs:
@google/genai/dist/node/index.mjs:
@google/genai/dist/node/index.mjs:
@google/genai/dist/node/index.mjs:
@google/genai/dist/node/index.mjs:
  (**
   * @license
   * Copyright 2025 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=index.js.map