/**
 * File Operations Sub-Agent
 *
 * Specializes in file system operations using Read, Write, Edit, MultiEdit, Glob, and LS tools.
 * Handles tasks like file manipulation, content processing, and directory navigation.
 * Uses QiCore Result<T, QiError> patterns for consistent error handling.
 */

import type { Result } from '@qi/base';
import { failure, match, success } from '@qi/base';
import type { QiError } from '@qi/core';
import { BaseSubAgent } from '../core/BaseSubAgent.js';
import type {
  SubAgentCapability,
  SubAgentConfig,
  SubAgentProgress,
  SubAgentResult,
  SubAgentTask,
} from '../core/types.js';

/**
 * File operations specific task types
 */
export type FileOpsTaskType =
  | 'file_read'
  | 'file_write'
  | 'file_edit'
  | 'file_search'
  | 'directory_list'
  | 'file_batch_edit'
  | 'file_analysis'
  | 'content_processing';

/**
 * File operations task context
 */
export interface FileOpsTaskContext {
  filePath?: string;
  directoryPath?: string;
  searchPattern?: string;
  encoding?: string;
  backup?: boolean;
  recursive?: boolean;
  filters?: string[];
}

/**
 * File Operations Sub-Agent
 * Handles all file system operations with advanced content processing capabilities
 */
export class FileOpsSubAgent extends BaseSubAgent {
  protected requiredTools = ['Read', 'Write', 'Edit', 'MultiEdit', 'Glob', 'LS'];

  constructor() {
    super('file-ops-agent', 'File Operations Agent', '1.0.0');
  }

  /**
   * Define capabilities for file operations
   */
  public get capabilities(): SubAgentCapability[] {
    return [
      {
        type: 'file_read',
        name: 'file_read',
        description: 'Read file contents with optional range support',
        confidence: 0.95,
        domains: ['filesystem', 'content', 'data'],
        workflowPatterns: ['sequential', 'parallel'],
        toolRequirements: ['Read'],
        estimatedDuration: 500,
      },
      {
        type: 'file_write',
        name: 'file_write',
        description: 'Write new files or overwrite existing content',
        confidence: 0.95,
        domains: ['filesystem', 'content', 'generation'],
        workflowPatterns: ['sequential'],
        toolRequirements: ['Write'],
        estimatedDuration: 800,
      },
      {
        type: 'file_edit',
        name: 'file_edit',
        description: 'Edit existing files with precise string replacement',
        confidence: 0.9,
        domains: ['filesystem', 'content', 'modification'],
        workflowPatterns: ['sequential'],
        toolRequirements: ['Edit', 'Read'],
        estimatedDuration: 1000,
      },
      {
        type: 'file_batch_edit',
        name: 'file_batch_edit',
        description: 'Perform multiple edits on a single file efficiently',
        confidence: 0.85,
        domains: ['filesystem', 'content', 'batch'],
        workflowPatterns: ['sequential'],
        toolRequirements: ['MultiEdit', 'Read'],
        estimatedDuration: 1500,
      },
      {
        type: 'file_search',
        name: 'file_search',
        description: 'Search for files using glob patterns',
        confidence: 0.9,
        domains: ['filesystem', 'search', 'discovery'],
        workflowPatterns: ['parallel'],
        toolRequirements: ['Glob'],
        estimatedDuration: 700,
      },
      {
        type: 'directory_list',
        name: 'directory_list',
        description: 'List directory contents with filtering',
        confidence: 0.95,
        domains: ['filesystem', 'navigation'],
        workflowPatterns: ['sequential', 'parallel'],
        toolRequirements: ['LS'],
        estimatedDuration: 400,
      },
    ];
  }

  /**
   * Check if this agent can handle the given task
   */
  async canHandle(task: SubAgentTask): Promise<Result<boolean, QiError>> {
    try {
      // Check if task type matches our capabilities
      const isFileOpsTask = this.capabilities.some(cap => cap.type === task.type);
      if (!isFileOpsTask) {
        return success(false);
      }

      // Validate required tools are available
      const capability = this.capabilities.find(cap => cap.type === task.type);
      if (!capability) {
        return success(false);
      }

      const toolCheckResult = await this.validateToolAccess(capability.toolRequirements);
      return match(
        () => success(true),
        () => success(false),
        toolCheckResult
      );
    } catch (error) {
      return failure(
        this.createSubAgentError('FILE_OPS_CAN_HANDLE_ERROR', 'Error checking task compatibility', {
          taskId: task.id,
          taskType: task.type,
          error: error instanceof Error ? error.message : String(error),
        })
      );
    }
  }

  /**
   * Execute file operations task
   */
  async *execute(task: SubAgentTask): AsyncGenerator<SubAgentProgress, SubAgentResult> {
    const startTime = Date.now();
    this.emit('taskStarted', { taskId: task.id, agentId: this.id });

    try {
      // Initialize execution context
      yield {
        taskId: task.id,
        agentId: this.id,
        status: 'running',
        progress: 0.1,
        message: `Starting ${task.type} operation`,
        timestamp: new Date(),
        details: { phase: 'initialization', operation: task.type },
      };

      // Route to specific operation handler
      const result = await this.routeFileOperation(task);
      
      const executionTime = Date.now() - startTime;
      
      return match(
        (data) => {
          this.emit('taskCompleted', { taskId: task.id, agentId: this.id, executionTime });
          return {
            taskId: task.id,
            agentId: this.id,
            status: 'completed' as const,
            result: { success: true, data },
            executionTime,
            timestamp: new Date(),
          };
        },
        (error) => {
          this.emit('taskFailed', { taskId: task.id, agentId: this.id, error, executionTime });
          return {
            taskId: task.id,
            agentId: this.id,
            status: 'failed' as const,
            result: { success: false, error },
            executionTime,
            timestamp: new Date(),
          };
        },
        result
      );
    } catch (error) {
      const executionTime = Date.now() - startTime;
      const qiError = this.createError(
        'FILE_OPS_EXECUTION_ERROR',
        'File operation execution failed',
        {
          taskId: task.id,
          taskType: task.type,
          error: error instanceof Error ? error.message : String(error),
        }
      );

      this.emit('taskFailed', { taskId: task.id, agentId: this.id, error: qiError, executionTime });
      return {
        taskId: task.id,
        agentId: this.id,
        status: 'failed',
        result: { success: false, error: qiError },
        executionTime,
        timestamp: new Date(),
      };
    }
  }

  /**
   * Route to appropriate file operation handler
   */
  private async routeFileOperation(task: SubAgentTask): Promise<Result<unknown, QiError>> {
    const context = task.context as FileOpsTaskContext;

    switch (task.type) {
      case 'file_read':
        return this.handleFileRead(task, context);
      case 'file_write':
        return this.handleFileWrite(task, context);
      case 'file_edit':
        return this.handleFileEdit(task, context);
      case 'file_batch_edit':
        return this.handleFileBatchEdit(task, context);
      case 'file_search':
        return this.handleFileSearch(task, context);
      case 'directory_list':
        return this.handleDirectoryList(task, context);
      default:
        return failure(
          this.createError('FILE_OPS_UNSUPPORTED_OPERATION', 'Unsupported file operation', {
            taskType: task.type,
            supportedTypes: this.capabilities.map(cap => cap.type),
          })
        );
    }
  }

  /**
   * Handle file read operations
   */
  private async handleFileRead(
    task: SubAgentTask,
    context: FileOpsTaskContext
  ): Promise<Result<unknown, QiError>> {
    try {
      if (!context.filePath) {
        return failure(
          this.createError('FILE_OPS_MISSING_PATH', 'File path required for read operation', {
            taskId: task.id,
          })
        );
      }

      const readTool = this.toolProvider.getTool('Read');
      if (!readTool) {
        return failure(
          this.createError('FILE_OPS_TOOL_NOT_AVAILABLE', 'Read tool not available', {
            taskId: task.id,
          })
        );
      }

      // Execute read operation
      const readResult = await readTool.execute({
        file_path: context.filePath,
        ...(task.context.limit && { limit: task.context.limit }),
        ...(task.context.offset && { offset: task.context.offset }),
      });

      return success({
        operation: 'file_read',
        filePath: context.filePath,
        content: readResult,
        timestamp: new Date(),
      });
    } catch (error) {
      return failure(
        this.createError('FILE_OPS_READ_FAILED', 'File read operation failed', {
          taskId: task.id,
          filePath: context.filePath,
          error: error instanceof Error ? error.message : String(error),
        })
      );
    }
  }

  /**
   * Handle file write operations
   */
  private async handleFileWrite(
    task: SubAgentTask,
    context: FileOpsTaskContext
  ): Promise<Result<unknown, QiError>> {
    try {
      if (!context.filePath || !task.context.content) {
        return failure(
          this.createError('FILE_OPS_MISSING_PARAMETERS', 'File path and content required', {
            taskId: task.id,
            hasPath: !!context.filePath,
            hasContent: !!task.context.content,
          })
        );
      }

      const writeTool = this.toolProvider.getTool('Write');
      if (!writeTool) {
        return failure(
          this.createError('FILE_OPS_TOOL_NOT_AVAILABLE', 'Write tool not available', {
            taskId: task.id,
          })
        );
      }

      // Execute write operation
      const writeResult = await writeTool.execute({
        file_path: context.filePath,
        content: task.context.content,
      });

      return success({
        operation: 'file_write',
        filePath: context.filePath,
        result: writeResult,
        timestamp: new Date(),
      });
    } catch (error) {
      return failure(
        this.createError('FILE_OPS_WRITE_FAILED', 'File write operation failed', {
          taskId: task.id,
          filePath: context.filePath,
          error: error instanceof Error ? error.message : String(error),
        })
      );
    }
  }

  /**
   * Handle file edit operations
   */
  private async handleFileEdit(
    task: SubAgentTask,
    context: FileOpsTaskContext
  ): Promise<Result<unknown, QiError>> {
    try {
      if (!context.filePath || !task.context.oldString || !task.context.newString) {
        return failure(
          this.createError('FILE_OPS_MISSING_EDIT_PARAMETERS', 'Edit parameters required', {
            taskId: task.id,
            hasPath: !!context.filePath,
            hasOldString: !!task.context.oldString,
            hasNewString: !!task.context.newString,
          })
        );
      }

      const editTool = this.toolProvider.getTool('Edit');
      if (!editTool) {
        return failure(
          this.createError('FILE_OPS_TOOL_NOT_AVAILABLE', 'Edit tool not available', {
            taskId: task.id,
          })
        );
      }

      // Execute edit operation
      const editResult = await editTool.execute({
        file_path: context.filePath,
        old_string: task.context.oldString,
        new_string: task.context.newString,
        ...(task.context.replaceAll && { replace_all: task.context.replaceAll }),
      });

      return success({
        operation: 'file_edit',
        filePath: context.filePath,
        result: editResult,
        timestamp: new Date(),
      });
    } catch (error) {
      return failure(
        this.createError('FILE_OPS_EDIT_FAILED', 'File edit operation failed', {
          taskId: task.id,
          filePath: context.filePath,
          error: error instanceof Error ? error.message : String(error),
        })
      );
    }
  }

  /**
   * Handle file batch edit operations
   */
  private async handleFileBatchEdit(
    task: SubAgentTask,
    context: FileOpsTaskContext
  ): Promise<Result<unknown, QiError>> {
    try {
      if (!context.filePath || !task.context.edits) {
        return failure(
          this.createError('FILE_OPS_MISSING_BATCH_PARAMETERS', 'Batch edit parameters required', {
            taskId: task.id,
            hasPath: !!context.filePath,
            hasEdits: !!task.context.edits,
          })
        );
      }

      const multiEditTool = this.toolProvider.getTool('MultiEdit');
      if (!multiEditTool) {
        return failure(
          this.createError('FILE_OPS_TOOL_NOT_AVAILABLE', 'MultiEdit tool not available', {
            taskId: task.id,
          })
        );
      }

      // Execute batch edit operation
      const batchEditResult = await multiEditTool.execute({
        file_path: context.filePath,
        edits: task.context.edits,
      });

      return success({
        operation: 'file_batch_edit',
        filePath: context.filePath,
        editCount: task.context.edits.length,
        result: batchEditResult,
        timestamp: new Date(),
      });
    } catch (error) {
      return failure(
        this.createError('FILE_OPS_BATCH_EDIT_FAILED', 'Batch edit operation failed', {
          taskId: task.id,
          filePath: context.filePath,
          editCount: task.context.edits?.length || 0,
          error: error instanceof Error ? error.message : String(error),
        })
      );
    }
  }

  /**
   * Handle file search operations
   */
  private async handleFileSearch(
    task: SubAgentTask,
    context: FileOpsTaskContext
  ): Promise<Result<unknown, QiError>> {
    try {
      if (!context.searchPattern) {
        return failure(
          this.createError('FILE_OPS_MISSING_PATTERN', 'Search pattern required', {
            taskId: task.id,
          })
        );
      }

      const globTool = this.toolProvider.getTool('Glob');
      if (!globTool) {
        return failure(
          this.createError('FILE_OPS_TOOL_NOT_AVAILABLE', 'Glob tool not available', {
            taskId: task.id,
          })
        );
      }

      // Execute file search operation
      const searchResult = await globTool.execute({
        pattern: context.searchPattern,
        ...(context.directoryPath && { path: context.directoryPath }),
      });

      return success({
        operation: 'file_search',
        searchPattern: context.searchPattern,
        searchPath: context.directoryPath,
        matchedFiles: Array.isArray(searchResult) ? searchResult : [searchResult],
        timestamp: new Date(),
      });
    } catch (error) {
      return failure(
        this.createError('FILE_OPS_SEARCH_FAILED', 'File search operation failed', {
          taskId: task.id,
          searchPattern: context.searchPattern,
          error: error instanceof Error ? error.message : String(error),
        })
      );
    }
  }

  /**
   * Handle directory listing operations
   */
  private async handleDirectoryList(
    task: SubAgentTask,
    context: FileOpsTaskContext
  ): Promise<Result<unknown, QiError>> {
    try {
      if (!context.directoryPath) {
        return failure(
          this.createError('FILE_OPS_MISSING_DIRECTORY', 'Directory path required', {
            taskId: task.id,
          })
        );
      }

      const lsTool = this.toolProvider.getTool('LS');
      if (!lsTool) {
        return failure(
          this.createError('FILE_OPS_TOOL_NOT_AVAILABLE', 'LS tool not available', {
            taskId: task.id,
          })
        );
      }

      // Execute directory listing operation
      const listResult = await lsTool.execute({
        path: context.directoryPath,
        ...(context.filters && { ignore: context.filters }),
      });

      return success({
        operation: 'directory_list',
        directoryPath: context.directoryPath,
        contents: listResult,
        filters: context.filters,
        timestamp: new Date(),
      });
    } catch (error) {
      return failure(
        this.createError('FILE_OPS_LIST_FAILED', 'Directory listing failed', {
          taskId: task.id,
          directoryPath: context.directoryPath,
          error: error instanceof Error ? error.message : String(error),
        })
      );
    }
  }

  /**
   * Get specialized insights for file operations
   */
  async getSpecializedInsights(): Promise<Result<Record<string, unknown>, QiError>> {
    try {
      const fileSystemStats = await this.gatherFileSystemStats();
      
      return success({
        fileSystemHealth: fileSystemStats,
        operationHistory: this.getRecentOperations(),
        toolUtilization: this.getToolUsageStats(),
        recommendedOptimizations: this.getOptimizationRecommendations(),
      });
    } catch (error) {
      return failure(
        this.createError('FILE_OPS_INSIGHTS_ERROR', 'Failed to gather specialized insights', {
          error: error instanceof Error ? error.message : String(error),
        })
      );
    }
  }

  // Helper methods for insights
  private async gatherFileSystemStats(): Promise<Record<string, unknown>> {
    return {
      recentOperations: this.metrics.completedTasks,
      averageExecutionTime: this.metrics.averageExecutionTime,
      successRate: this.metrics.successRate,
      commonFileTypes: ['ts', 'js', 'json', 'md'],
    };
  }

  private getRecentOperations(): Record<string, unknown>[] {
    // Return recent operations from metrics
    return [];
  }

  private getToolUsageStats(): Record<string, number> {
    return {
      Read: 0,
      Write: 0,
      Edit: 0,
      MultiEdit: 0,
      Glob: 0,
      LS: 0,
    };
  }

  private getOptimizationRecommendations(): string[] {
    const recommendations: string[] = [];
    
    if (this.metrics.averageExecutionTime > 2000) {
      recommendations.push('Consider using batch operations for multiple file edits');
    }
    
    if (this.metrics.successRate < 0.9) {
      recommendations.push('Review file path validation and error handling');
    }
    
    return recommendations;
  }

  /**
   * Abstract method implementations required by BaseSubAgent
   */
  protected async executeTask(task: SubAgentTask): AsyncGenerator<SubAgentProgress> {
    yield* this.execute(task);
  }

  protected async onInitialize(_config: SubAgentConfig): Promise<Result<void, QiError>> {
    return success(undefined);
  }

  protected async onCleanup(): Promise<Result<void, QiError>> {
    return success(undefined);
  }

  protected async canHandleCustom(_task: SubAgentTask): Promise<Result<boolean, QiError>> {
    return success(false);
  }

  protected createSubAgentError(code: string, message: string, context?: Record<string, unknown>): QiError {
    return {
      code,
      message,
      category: 'SYSTEM',
      context: context || {},
    } as QiError;
  }
}