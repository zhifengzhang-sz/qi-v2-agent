/**
 * Search Operations Sub-Agent
 *
 * Specializes in search operations using Grep and advanced search patterns.
 * Handles tasks like content search, pattern matching, and code analysis.
 * Uses QiCore Result<T, QiError> patterns for consistent error handling.
 */

import type { Result } from '@qi/base';
import { failure, match, success } from '@qi/base';
import type { QiError } from '@qi/core';
import { BaseSubAgent } from '../core/BaseSubAgent.js';
import type {
  SubAgentCapability,
  SubAgentConfig,
  SubAgentProgress,
  SubAgentResult,
  SubAgentTask,
} from '../core/types.js';

/**
 * Search operations specific task types
 */
export type SearchTaskType =
  | 'content_search'
  | 'pattern_match'
  | 'code_search'
  | 'multi_file_search'
  | 'regex_search'
  | 'context_search'
  | 'reference_search';

/**
 * Search operations task context
 */
export interface SearchTaskContext {
  pattern?: string;
  filePath?: string;
  directoryPath?: string;
  fileGlob?: string;
  fileType?: string;
  caseSensitive?: boolean;
  contextLines?: number;
  multiline?: boolean;
  maxResults?: number;
  excludePatterns?: string[];
}

/**
 * Search Operations Sub-Agent
 * Handles all search operations with advanced pattern matching capabilities
 */
export class SearchSubAgent extends BaseSubAgent {
  public readonly name = 'Search Operations Agent';
  public readonly version = '1.0.0';
  protected requiredTools = ['Grep'];

  /**
   * Define capabilities for search operations
   */
  public get capabilities(): SubAgentCapability[] {
    return [
      {
        type: 'content_search',
        description: 'Search for text content within files using basic patterns',
        confidence: 0.95,
        domains: ['search', 'content', 'text'],
        workflowPatterns: ['parallel', 'sequential'],
        requiredTools: ['Grep'],
        estimatedDuration: 800,
      },
      {
        type: 'pattern_match',
        description: 'Advanced pattern matching with regex support',
        confidence: 0.9,
        domains: ['search', 'regex', 'patterns'],
        workflowPatterns: ['parallel'],
        requiredTools: ['Grep'],
        estimatedDuration: 1000,
      },
      {
        type: 'code_search',
        description: 'Search for code patterns, functions, and symbols',
        confidence: 0.85,
        domains: ['search', 'code', 'development'],
        workflowPatterns: ['parallel', 'hierarchical'],
        requiredTools: ['Grep'],
        estimatedDuration: 1200,
      },
      {
        type: 'multi_file_search',
        description: 'Search across multiple files with filtering',
        confidence: 0.9,
        domains: ['search', 'bulk', 'filtering'],
        workflowPatterns: ['parallel'],
        requiredTools: ['Grep'],
        estimatedDuration: 1500,
      },
      {
        type: 'regex_search',
        description: 'Complex regex-based search operations',
        confidence: 0.8,
        domains: ['search', 'regex', 'advanced'],
        workflowPatterns: ['sequential'],
        requiredTools: ['Grep'],
        estimatedDuration: 1100,
      },
      {
        type: 'context_search',
        description: 'Search with context lines before and after matches',
        confidence: 0.9,
        domains: ['search', 'context', 'analysis'],
        workflowPatterns: ['sequential'],
        requiredTools: ['Grep'],
        estimatedDuration: 900,
      },
    ];
  }

  /**
   * Check if this agent can handle the given task
   */
  async canHandle(task: SubAgentTask): Promise<Result<boolean, QiError>> {
    try {
      // Check if task type matches our capabilities
      const isSearchTask = this.capabilities.some(cap => cap.type === task.type);
      if (!isSearchTask) {
        return success(false);
      }

      // Validate required tools are available
      const capability = this.capabilities.find(cap => cap.type === task.type);
      if (!capability) {
        return success(false);
      }

      const toolCheckResult = await this.validateToolAccess(capability.requiredTools);
      return match(
        () => success(true),
        () => success(false),
        toolCheckResult
      );
    } catch (error) {
      return failure(
        this.createError('SEARCH_CAN_HANDLE_ERROR', 'Error checking task compatibility', {
          taskId: task.id,
          taskType: task.type,
          error: error instanceof Error ? error.message : String(error),
        })
      );
    }
  }

  /**
   * Execute search operations task
   */
  async *execute(task: SubAgentTask): AsyncGenerator<SubAgentProgress, SubAgentResult> {
    const startTime = Date.now();
    this.emit('taskStarted', { taskId: task.id, agentId: this.id });

    try {
      // Initialize execution context
      yield {
        taskId: task.id,
        agentId: this.id,
        status: 'running',
        progress: 0.1,
        message: `Starting ${task.type} operation`,
        timestamp: new Date(),
        details: { phase: 'initialization', operation: task.type },
      };

      // Route to specific search operation handler
      const result = await this.routeSearchOperation(task);
      
      const executionTime = Date.now() - startTime;
      
      return match(
        (data) => {
          this.emit('taskCompleted', { taskId: task.id, agentId: this.id, executionTime });
          return {
            taskId: task.id,
            agentId: this.id,
            status: 'completed' as const,
            result: { success: true, data },
            executionTime,
            timestamp: new Date(),
          };
        },
        (error) => {
          this.emit('taskFailed', { taskId: task.id, agentId: this.id, error, executionTime });
          return {
            taskId: task.id,
            agentId: this.id,
            status: 'failed' as const,
            result: { success: false, error },
            executionTime,
            timestamp: new Date(),
          };
        },
        result
      );
    } catch (error) {
      const executionTime = Date.now() - startTime;
      const qiError = this.createError(
        'SEARCH_EXECUTION_ERROR',
        'Search operation execution failed',
        {
          taskId: task.id,
          taskType: task.type,
          error: error instanceof Error ? error.message : String(error),
        }
      );

      this.emit('taskFailed', { taskId: task.id, agentId: this.id, error: qiError, executionTime });
      return {
        taskId: task.id,
        agentId: this.id,
        status: 'failed',
        result: { success: false, error: qiError },
        executionTime,
        timestamp: new Date(),
      };
    }
  }

  /**
   * Route to appropriate search operation handler
   */
  private async routeSearchOperation(task: SubAgentTask): Promise<Result<unknown, QiError>> {
    const context = task.context as SearchTaskContext;

    switch (task.type) {
      case 'content_search':
        return this.handleContentSearch(task, context);
      case 'pattern_match':
        return this.handlePatternMatch(task, context);
      case 'code_search':
        return this.handleCodeSearch(task, context);
      case 'multi_file_search':
        return this.handleMultiFileSearch(task, context);
      case 'regex_search':
        return this.handleRegexSearch(task, context);
      case 'context_search':
        return this.handleContextSearch(task, context);
      default:
        return failure(
          this.createError('SEARCH_UNSUPPORTED_OPERATION', 'Unsupported search operation', {
            taskType: task.type,
            supportedTypes: this.capabilities.map(cap => cap.type),
          })
        );
    }
  }

  /**
   * Handle basic content search operations
   */
  private async handleContentSearch(
    task: SubAgentTask,
    context: SearchTaskContext
  ): Promise<Result<unknown, QiError>> {
    try {
      if (!context.pattern) {
        return failure(
          this.createError('SEARCH_MISSING_PATTERN', 'Search pattern required', {
            taskId: task.id,
          })
        );
      }

      const grepTool = this.toolProvider.getTool('Grep');
      if (!grepTool) {
        return failure(
          this.createError('SEARCH_TOOL_NOT_AVAILABLE', 'Grep tool not available', {
            taskId: task.id,
          })
        );
      }

      // Execute content search
      const searchResult = await grepTool.execute({
        pattern: context.pattern,
        ...(context.filePath && { path: context.filePath }),
        ...(context.fileGlob && { glob: context.fileGlob }),
        ...(context.fileType && { type: context.fileType }),
        ...(context.caseSensitive === false && { '-i': true }),
        output_mode: 'content',
        '-n': true, // Include line numbers
        ...(context.maxResults && { head_limit: context.maxResults }),
      });

      return success({
        operation: 'content_search',
        pattern: context.pattern,
        searchPath: context.filePath || context.directoryPath,
        results: searchResult,
        timestamp: new Date(),
      });
    } catch (error) {
      return failure(
        this.createError('SEARCH_CONTENT_FAILED', 'Content search operation failed', {
          taskId: task.id,
          pattern: context.pattern,
          error: error instanceof Error ? error.message : String(error),
        })
      );
    }
  }

  /**
   * Handle advanced pattern matching
   */
  private async handlePatternMatch(
    task: SubAgentTask,
    context: SearchTaskContext
  ): Promise<Result<unknown, QiError>> {
    try {
      if (!context.pattern) {
        return failure(
          this.createError('SEARCH_MISSING_PATTERN', 'Pattern required for pattern matching', {
            taskId: task.id,
          })
        );
      }

      const grepTool = this.toolProvider.getTool('Grep');
      if (!grepTool) {
        return failure(
          this.createError('SEARCH_TOOL_NOT_AVAILABLE', 'Grep tool not available', {
            taskId: task.id,
          })
        );
      }

      // Execute pattern matching with advanced options
      const searchResult = await grepTool.execute({
        pattern: context.pattern,
        ...(context.filePath && { path: context.filePath }),
        ...(context.fileGlob && { glob: context.fileGlob }),
        ...(context.fileType && { type: context.fileType }),
        ...(context.caseSensitive === false && { '-i': true }),
        ...(context.multiline && { multiline: true }),
        output_mode: 'content',
        '-n': true,
        ...(context.contextLines && { '-C': context.contextLines }),
        ...(context.maxResults && { head_limit: context.maxResults }),
      });

      return success({
        operation: 'pattern_match',
        pattern: context.pattern,
        searchPath: context.filePath || context.directoryPath,
        multiline: context.multiline,
        contextLines: context.contextLines,
        results: searchResult,
        timestamp: new Date(),
      });
    } catch (error) {
      return failure(
        this.createError('SEARCH_PATTERN_FAILED', 'Pattern matching operation failed', {
          taskId: task.id,
          pattern: context.pattern,
          error: error instanceof Error ? error.message : String(error),
        })
      );
    }
  }

  /**
   * Handle code search operations
   */
  private async handleCodeSearch(
    task: SubAgentTask,
    context: SearchTaskContext
  ): Promise<Result<unknown, QiError>> {
    try {
      if (!context.pattern) {
        return failure(
          this.createError('SEARCH_MISSING_PATTERN', 'Code pattern required', {
            taskId: task.id,
          })
        );
      }

      const grepTool = this.toolProvider.getTool('Grep');
      if (!grepTool) {
        return failure(
          this.createError('SEARCH_TOOL_NOT_AVAILABLE', 'Grep tool not available', {
            taskId: task.id,
          })
        );
      }

      // Common code file types if not specified
      const codeTypes = context.fileType || 'js,ts,tsx,py,java,cpp,c,h,go,rs,php';

      // Execute code search
      const searchResult = await grepTool.execute({
        pattern: context.pattern,
        ...(context.filePath && { path: context.filePath }),
        ...(context.fileGlob ? { glob: context.fileGlob } : { type: codeTypes }),
        output_mode: 'content',
        '-n': true,
        '-C': context.contextLines || 2, // Default context for code
        ...(context.maxResults && { head_limit: context.maxResults }),
      });

      return success({
        operation: 'code_search',
        pattern: context.pattern,
        searchPath: context.filePath || context.directoryPath,
        fileTypes: codeTypes,
        contextLines: context.contextLines || 2,
        results: searchResult,
        timestamp: new Date(),
      });
    } catch (error) {
      return failure(
        this.createError('SEARCH_CODE_FAILED', 'Code search operation failed', {
          taskId: task.id,
          pattern: context.pattern,
          error: error instanceof Error ? error.message : String(error),
        })
      );
    }
  }

  /**
   * Handle multi-file search operations
   */
  private async handleMultiFileSearch(
    task: SubAgentTask,
    context: SearchTaskContext
  ): Promise<Result<unknown, QiError>> {
    try {
      if (!context.pattern) {
        return failure(
          this.createError('SEARCH_MISSING_PATTERN', 'Pattern required for multi-file search', {
            taskId: task.id,
          })
        );
      }

      const grepTool = this.toolProvider.getTool('Grep');
      if (!grepTool) {
        return failure(
          this.createError('SEARCH_TOOL_NOT_AVAILABLE', 'Grep tool not available', {
            taskId: task.id,
          })
        );
      }

      // Execute multi-file search
      const searchResult = await grepTool.execute({
        pattern: context.pattern,
        ...(context.directoryPath && { path: context.directoryPath }),
        ...(context.fileGlob && { glob: context.fileGlob }),
        ...(context.fileType && { type: context.fileType }),
        ...(context.caseSensitive === false && { '-i': true }),
        output_mode: 'files_with_matches', // Get list of matching files
        ...(context.maxResults && { head_limit: context.maxResults }),
      });

      // Also get detailed results if needed
      let detailedResults = null;
      if (task.context.includeContent) {
        detailedResults = await grepTool.execute({
          pattern: context.pattern,
          ...(context.directoryPath && { path: context.directoryPath }),
          ...(context.fileGlob && { glob: context.fileGlob }),
          ...(context.fileType && { type: context.fileType }),
          ...(context.caseSensitive === false && { '-i': true }),
          output_mode: 'content',
          '-n': true,
          ...(context.contextLines && { '-C': context.contextLines }),
          head_limit: Math.min(context.maxResults || 50, 50), // Limit detailed results
        });
      }

      return success({
        operation: 'multi_file_search',
        pattern: context.pattern,
        searchPath: context.directoryPath,
        fileMatches: searchResult,
        detailedResults,
        includeContent: task.context.includeContent,
        timestamp: new Date(),
      });
    } catch (error) {
      return failure(
        this.createError('SEARCH_MULTI_FILE_FAILED', 'Multi-file search operation failed', {
          taskId: task.id,
          pattern: context.pattern,
          error: error instanceof Error ? error.message : String(error),
        })
      );
    }
  }

  /**
   * Handle regex search operations
   */
  private async handleRegexSearch(
    task: SubAgentTask,
    context: SearchTaskContext
  ): Promise<Result<unknown, QiError>> {
    try {
      if (!context.pattern) {
        return failure(
          this.createError('SEARCH_MISSING_PATTERN', 'Regex pattern required', {
            taskId: task.id,
          })
        );
      }

      const grepTool = this.toolProvider.getTool('Grep');
      if (!grepTool) {
        return failure(
          this.createError('SEARCH_TOOL_NOT_AVAILABLE', 'Grep tool not available', {
            taskId: task.id,
          })
        );
      }

      // Execute regex search with advanced regex support
      const searchResult = await grepTool.execute({
        pattern: context.pattern,
        ...(context.filePath && { path: context.filePath }),
        ...(context.fileGlob && { glob: context.fileGlob }),
        ...(context.fileType && { type: context.fileType }),
        ...(context.caseSensitive === false && { '-i': true }),
        ...(context.multiline && { multiline: true }),
        output_mode: 'content',
        '-n': true,
        ...(context.contextLines && { '-C': context.contextLines }),
        ...(context.maxResults && { head_limit: context.maxResults }),
      });

      return success({
        operation: 'regex_search',
        pattern: context.pattern,
        searchPath: context.filePath || context.directoryPath,
        multiline: context.multiline,
        results: searchResult,
        timestamp: new Date(),
      });
    } catch (error) {
      return failure(
        this.createError('SEARCH_REGEX_FAILED', 'Regex search operation failed', {
          taskId: task.id,
          pattern: context.pattern,
          error: error instanceof Error ? error.message : String(error),
        })
      );
    }
  }

  /**
   * Handle context search operations
   */
  private async handleContextSearch(
    task: SubAgentTask,
    context: SearchTaskContext
  ): Promise<Result<unknown, QiError>> {
    try {
      if (!context.pattern) {
        return failure(
          this.createError('SEARCH_MISSING_PATTERN', 'Pattern required for context search', {
            taskId: task.id,
          })
        );
      }

      const grepTool = this.toolProvider.getTool('Grep');
      if (!grepTool) {
        return failure(
          this.createError('SEARCH_TOOL_NOT_AVAILABLE', 'Grep tool not available', {
            taskId: task.id,
          })
        );
      }

      // Execute context search with before/after lines
      const contextLines = context.contextLines || 3;
      const searchResult = await grepTool.execute({
        pattern: context.pattern,
        ...(context.filePath && { path: context.filePath }),
        ...(context.fileGlob && { glob: context.fileGlob }),
        ...(context.fileType && { type: context.fileType }),
        ...(context.caseSensitive === false && { '-i': true }),
        output_mode: 'content',
        '-n': true,
        '-C': contextLines,
        ...(context.maxResults && { head_limit: context.maxResults }),
      });

      return success({
        operation: 'context_search',
        pattern: context.pattern,
        searchPath: context.filePath || context.directoryPath,
        contextLines,
        results: searchResult,
        timestamp: new Date(),
      });
    } catch (error) {
      return failure(
        this.createError('SEARCH_CONTEXT_FAILED', 'Context search operation failed', {
          taskId: task.id,
          pattern: context.pattern,
          error: error instanceof Error ? error.message : String(error),
        })
      );
    }
  }

  /**
   * Get specialized insights for search operations
   */
  async getSpecializedInsights(): Promise<Result<Record<string, unknown>, QiError>> {
    try {
      const searchStats = await this.gatherSearchStats();
      
      return success({
        searchPerformance: searchStats,
        commonPatterns: this.getCommonPatterns(),
        searchHistory: this.getRecentSearches(),
        optimizationTips: this.getSearchOptimizations(),
      });
    } catch (error) {
      return failure(
        this.createError('SEARCH_INSIGHTS_ERROR', 'Failed to gather specialized insights', {
          error: error instanceof Error ? error.message : String(error),
        })
      );
    }
  }

  // Helper methods for insights
  private async gatherSearchStats(): Promise<Record<string, unknown>> {
    return {
      recentSearches: this.metrics.completedTasks,
      averageSearchTime: this.metrics.averageExecutionTime,
      searchSuccessRate: this.metrics.successRate,
      mostUsedPatterns: this.getMostUsedPatterns(),
    };
  }

  private getCommonPatterns(): string[] {
    return [
      'function\\s+\\w+',
      'class\\s+\\w+',
      'import\\s+.*from',
      'export\\s+(default\\s+)?',
      'TODO|FIXME|HACK',
    ];
  }

  private getRecentSearches(): Record<string, unknown>[] {
    // Return recent searches from metrics
    return [];
  }

  private getMostUsedPatterns(): string[] {
    // Would track actual patterns used
    return [];
  }

  private getSearchOptimizations(): string[] {
    const optimizations: string[] = [];
    
    if (this.metrics.averageExecutionTime > 3000) {
      optimizations.push('Use more specific file type filters to reduce search scope');
    }
    
    if (this.metrics.successRate < 0.8) {
      optimizations.push('Review regex patterns for syntax errors');
    }
    
    return optimizations;
  }
}