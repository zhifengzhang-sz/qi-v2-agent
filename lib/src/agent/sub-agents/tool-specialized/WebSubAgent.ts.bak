/**
 * Web Operations Sub-Agent
 *
 * Specializes in web operations using WebFetch and WebSearch tools.
 * Handles tasks like web scraping, content retrieval, and web research.
 * Uses QiCore Result<T, QiError> patterns for consistent error handling.
 */

import type { Result } from '@qi/base';
import { failure, match, success } from '@qi/base';
import type { QiError } from '@qi/core';
import { BaseSubAgent } from '../core/BaseSubAgent.js';
import type {
  SubAgentCapability,
  SubAgentConfig,
  SubAgentProgress,
  SubAgentResult,
  SubAgentTask,
} from '../core/types.js';

/**
 * Web operations specific task types
 */
export type WebTaskType =
  | 'web_fetch'
  | 'web_search'
  | 'content_extraction'
  | 'web_research'
  | 'multi_source_fetch'
  | 'site_analysis'
  | 'api_interaction';

/**
 * Web operations task context
 */
export interface WebTaskContext {
  url?: string;
  urls?: string[];
  query?: string;
  maxResults?: number;
  extractionPrompt?: string;
  timeout?: number;
  retryCount?: number;
  userAgent?: string;
  headers?: Record<string, string>;
  followRedirects?: boolean;
  domains?: string[];
  excludeDomains?: string[];
}

/**
 * Web Operations Sub-Agent
 * Handles all web-related operations with intelligent content processing
 */
export class WebSubAgent extends BaseSubAgent {
  public readonly name = 'Web Operations Agent';
  public readonly version = '1.0.0';
  protected requiredTools = ['WebFetch', 'WebSearch'];

  /**
   * Define capabilities for web operations
   */
  public get capabilities(): SubAgentCapability[] {
    return [
      {
        type: 'web_fetch',
        description: 'Fetch and process content from web URLs',
        confidence: 0.9,
        domains: ['web', 'content', 'scraping'],
        workflowPatterns: ['sequential', 'parallel'],
        requiredTools: ['WebFetch'],
        estimatedDuration: 2000,
      },
      {
        type: 'web_search',
        description: 'Search the web for information and resources',
        confidence: 0.95,
        domains: ['web', 'search', 'research'],
        workflowPatterns: ['parallel'],
        requiredTools: ['WebSearch'],
        estimatedDuration: 1500,
      },
      {
        type: 'content_extraction',
        description: 'Extract specific content from web pages using prompts',
        confidence: 0.85,
        domains: ['web', 'extraction', 'analysis'],
        workflowPatterns: ['sequential'],
        requiredTools: ['WebFetch'],
        estimatedDuration: 2500,
      },
      {
        type: 'web_research',
        description: 'Conduct comprehensive web research on topics',
        confidence: 0.8,
        domains: ['web', 'research', 'analysis'],
        workflowPatterns: ['hierarchical', 'parallel'],
        requiredTools: ['WebSearch', 'WebFetch'],
        estimatedDuration: 4000,
      },
      {
        type: 'multi_source_fetch',
        description: 'Fetch and compare content from multiple sources',
        confidence: 0.85,
        domains: ['web', 'comparison', 'aggregation'],
        workflowPatterns: ['parallel'],
        requiredTools: ['WebFetch'],
        estimatedDuration: 3000,
      },
      {
        type: 'site_analysis',
        description: 'Analyze website structure and content',
        confidence: 0.75,
        domains: ['web', 'analysis', 'structure'],
        workflowPatterns: ['sequential'],
        requiredTools: ['WebFetch'],
        estimatedDuration: 3500,
      },
    ];
  }

  /**
   * Check if this agent can handle the given task
   */
  async canHandle(task: SubAgentTask): Promise<Result<boolean, QiError>> {
    try {
      // Check if task type matches our capabilities
      const isWebTask = this.capabilities.some(cap => cap.type === task.type);
      if (!isWebTask) {
        return success(false);
      }

      // Validate required tools are available
      const capability = this.capabilities.find(cap => cap.type === task.type);
      if (!capability) {
        return success(false);
      }

      const toolCheckResult = await this.validateToolAccess(capability.requiredTools);
      return match(
        () => success(true),
        () => success(false),
        toolCheckResult
      );
    } catch (error) {
      return failure(
        this.createError('WEB_CAN_HANDLE_ERROR', 'Error checking task compatibility', {
          taskId: task.id,
          taskType: task.type,
          error: error instanceof Error ? error.message : String(error),
        })
      );
    }
  }

  /**
   * Execute web operations task
   */
  async *execute(task: SubAgentTask): AsyncGenerator<SubAgentProgress, SubAgentResult> {
    const startTime = Date.now();
    this.emit('taskStarted', { taskId: task.id, agentId: this.id });

    try {
      // Initialize execution context
      yield {
        taskId: task.id,
        agentId: this.id,
        status: 'running',
        progress: 0.1,
        message: `Starting ${task.type} operation`,
        timestamp: new Date(),
        details: { phase: 'initialization', operation: task.type },
      };

      // Route to specific web operation handler
      const result = await this.routeWebOperation(task);
      
      const executionTime = Date.now() - startTime;
      
      return match(
        (data) => {
          this.emit('taskCompleted', { taskId: task.id, agentId: this.id, executionTime });
          return {
            taskId: task.id,
            agentId: this.id,
            status: 'completed' as const,
            result: { success: true, data },
            executionTime,
            timestamp: new Date(),
          };
        },
        (error) => {
          this.emit('taskFailed', { taskId: task.id, agentId: this.id, error, executionTime });
          return {
            taskId: task.id,
            agentId: this.id,
            status: 'failed' as const,
            result: { success: false, error },
            executionTime,
            timestamp: new Date(),
          };
        },
        result
      );
    } catch (error) {
      const executionTime = Date.now() - startTime;
      const qiError = this.createError(
        'WEB_EXECUTION_ERROR',
        'Web operation execution failed',
        {
          taskId: task.id,
          taskType: task.type,
          error: error instanceof Error ? error.message : String(error),
        }
      );

      this.emit('taskFailed', { taskId: task.id, agentId: this.id, error: qiError, executionTime });
      return {
        taskId: task.id,
        agentId: this.id,
        status: 'failed',
        result: { success: false, error: qiError },
        executionTime,
        timestamp: new Date(),
      };
    }
  }

  /**
   * Route to appropriate web operation handler
   */
  private async routeWebOperation(task: SubAgentTask): Promise<Result<unknown, QiError>> {
    const context = task.context as WebTaskContext;

    switch (task.type) {
      case 'web_fetch':
        return this.handleWebFetch(task, context);
      case 'web_search':
        return this.handleWebSearch(task, context);
      case 'content_extraction':
        return this.handleContentExtraction(task, context);
      case 'web_research':
        return this.handleWebResearch(task, context);
      case 'multi_source_fetch':
        return this.handleMultiSourceFetch(task, context);
      case 'site_analysis':
        return this.handleSiteAnalysis(task, context);
      default:
        return failure(
          this.createError('WEB_UNSUPPORTED_OPERATION', 'Unsupported web operation', {
            taskType: task.type,
            supportedTypes: this.capabilities.map(cap => cap.type),
          })
        );
    }
  }

  /**
   * Handle web fetch operations
   */
  private async handleWebFetch(
    task: SubAgentTask,
    context: WebTaskContext
  ): Promise<Result<unknown, QiError>> {
    try {
      if (!context.url) {
        return failure(
          this.createError('WEB_MISSING_URL', 'URL required for web fetch operation', {
            taskId: task.id,
          })
        );
      }

      const webFetchTool = this.toolProvider.getTool('WebFetch');
      if (!webFetchTool) {
        return failure(
          this.createError('WEB_TOOL_NOT_AVAILABLE', 'WebFetch tool not available', {
            taskId: task.id,
          })
        );
      }

      // Default prompt for content extraction
      const prompt = context.extractionPrompt || 'Extract the main content and key information from this page';

      // Execute web fetch operation
      const fetchResult = await webFetchTool.execute({
        url: context.url,
        prompt,
      });

      return success({
        operation: 'web_fetch',
        url: context.url,
        content: fetchResult,
        prompt: prompt,
        timestamp: new Date(),
      });
    } catch (error) {
      return failure(
        this.createError('WEB_FETCH_FAILED', 'Web fetch operation failed', {
          taskId: task.id,
          url: context.url,
          error: error instanceof Error ? error.message : String(error),
        })
      );
    }
  }

  /**
   * Handle web search operations
   */
  private async handleWebSearch(
    task: SubAgentTask,
    context: WebTaskContext
  ): Promise<Result<unknown, QiError>> {
    try {
      if (!context.query) {
        return failure(
          this.createError('WEB_MISSING_QUERY', 'Search query required', {
            taskId: task.id,
          })
        );
      }

      const webSearchTool = this.toolProvider.getTool('WebSearch');
      if (!webSearchTool) {
        return failure(
          this.createError('WEB_TOOL_NOT_AVAILABLE', 'WebSearch tool not available', {
            taskId: task.id,
          })
        );
      }

      // Execute web search operation
      const searchResult = await webSearchTool.execute({
        query: context.query,
        ...(context.domains && { allowed_domains: context.domains }),
        ...(context.excludeDomains && { blocked_domains: context.excludeDomains }),
      });

      return success({
        operation: 'web_search',
        query: context.query,
        domains: context.domains,
        excludeDomains: context.excludeDomains,
        results: searchResult,
        timestamp: new Date(),
      });
    } catch (error) {
      return failure(
        this.createError('WEB_SEARCH_FAILED', 'Web search operation failed', {
          taskId: task.id,
          query: context.query,
          error: error instanceof Error ? error.message : String(error),
        })
      );
    }
  }

  /**
   * Handle content extraction operations
   */
  private async handleContentExtraction(
    task: SubAgentTask,
    context: WebTaskContext
  ): Promise<Result<unknown, QiError>> {
    try {
      if (!context.url || !context.extractionPrompt) {
        return failure(
          this.createError('WEB_MISSING_EXTRACTION_PARAMS', 'URL and extraction prompt required', {
            taskId: task.id,
            hasUrl: !!context.url,
            hasPrompt: !!context.extractionPrompt,
          })
        );
      }

      const webFetchTool = this.toolProvider.getTool('WebFetch');
      if (!webFetchTool) {
        return failure(
          this.createError('WEB_TOOL_NOT_AVAILABLE', 'WebFetch tool not available', {
            taskId: task.id,
          })
        );
      }

      // Execute content extraction
      const extractionResult = await webFetchTool.execute({
        url: context.url,
        prompt: context.extractionPrompt,
      });

      return success({
        operation: 'content_extraction',
        url: context.url,
        extractionPrompt: context.extractionPrompt,
        extractedContent: extractionResult,
        timestamp: new Date(),
      });
    } catch (error) {
      return failure(
        this.createError('WEB_EXTRACTION_FAILED', 'Content extraction operation failed', {
          taskId: task.id,
          url: context.url,
          error: error instanceof Error ? error.message : String(error),
        })
      );
    }
  }

  /**
   * Handle web research operations
   */
  private async handleWebResearch(
    task: SubAgentTask,
    context: WebTaskContext
  ): Promise<Result<unknown, QiError>> {
    try {
      if (!context.query) {
        return failure(
          this.createError('WEB_MISSING_QUERY', 'Research query required', {
            taskId: task.id,
          })
        );
      }

      const webSearchTool = this.toolProvider.getTool('WebSearch');
      const webFetchTool = this.toolProvider.getTool('WebFetch');
      
      if (!webSearchTool || !webFetchTool) {
        return failure(
          this.createError('WEB_TOOLS_NOT_AVAILABLE', 'Required web tools not available', {
            taskId: task.id,
            hasSearch: !!webSearchTool,
            hasFetch: !!webFetchTool,
          })
        );
      }

      // Step 1: Search for relevant sources
      const searchResult = await webSearchTool.execute({
        query: context.query,
        ...(context.domains && { allowed_domains: context.domains }),
        ...(context.excludeDomains && { blocked_domains: context.excludeDomains }),
      });

      // Step 2: Extract URLs from search results
      const urls = this.extractUrlsFromSearchResults(searchResult);
      const topUrls = urls.slice(0, Math.min(context.maxResults || 3, 5)); // Limit sources

      // Step 3: Fetch content from top sources
      const researchPrompt = `Research the topic "${context.query}" from this source. Extract key facts, insights, and relevant information.`;
      const contentResults = [];

      for (const url of topUrls) {
        try {
          const content = await webFetchTool.execute({
            url,
            prompt: researchPrompt,
          });
          contentResults.push({ url, content, success: true });
        } catch (error) {
          contentResults.push({ 
            url, 
            content: null, 
            success: false, 
            error: error instanceof Error ? error.message : String(error) 
          });
        }
      }

      return success({
        operation: 'web_research',
        query: context.query,
        searchResults: searchResult,
        sourceUrls: topUrls,
        researchData: contentResults,
        successfulSources: contentResults.filter(r => r.success).length,
        timestamp: new Date(),
      });
    } catch (error) {
      return failure(
        this.createError('WEB_RESEARCH_FAILED', 'Web research operation failed', {
          taskId: task.id,
          query: context.query,
          error: error instanceof Error ? error.message : String(error),
        })
      );
    }
  }

  /**
   * Handle multi-source fetch operations
   */
  private async handleMultiSourceFetch(
    task: SubAgentTask,
    context: WebTaskContext
  ): Promise<Result<unknown, QiError>> {
    try {
      if (!context.urls || context.urls.length === 0) {
        return failure(
          this.createError('WEB_MISSING_URLS', 'URLs array required for multi-source fetch', {
            taskId: task.id,
          })
        );
      }

      const webFetchTool = this.toolProvider.getTool('WebFetch');
      if (!webFetchTool) {
        return failure(
          this.createError('WEB_TOOL_NOT_AVAILABLE', 'WebFetch tool not available', {
            taskId: task.id,
          })
        );
      }

      const prompt = context.extractionPrompt || 'Extract and summarize the main content from this source';
      const results = [];

      // Fetch content from all sources
      for (const url of context.urls) {
        try {
          const content = await webFetchTool.execute({ url, prompt });
          results.push({ url, content, success: true });
        } catch (error) {
          results.push({
            url,
            content: null,
            success: false,
            error: error instanceof Error ? error.message : String(error)
          });
        }
      }

      return success({
        operation: 'multi_source_fetch',
        urls: context.urls,
        prompt: prompt,
        results,
        successfulFetches: results.filter(r => r.success).length,
        failedFetches: results.filter(r => !r.success).length,
        timestamp: new Date(),
      });
    } catch (error) {
      return failure(
        this.createError('WEB_MULTI_FETCH_FAILED', 'Multi-source fetch operation failed', {
          taskId: task.id,
          urlCount: context.urls?.length || 0,
          error: error instanceof Error ? error.message : String(error),
        })
      );
    }
  }

  /**
   * Handle site analysis operations
   */
  private async handleSiteAnalysis(
    task: SubAgentTask,
    context: WebTaskContext
  ): Promise<Result<unknown, QiError>> {
    try {
      if (!context.url) {
        return failure(
          this.createError('WEB_MISSING_URL', 'URL required for site analysis', {
            taskId: task.id,
          })
        );
      }

      const webFetchTool = this.toolProvider.getTool('WebFetch');
      if (!webFetchTool) {
        return failure(
          this.createError('WEB_TOOL_NOT_AVAILABLE', 'WebFetch tool not available', {
            taskId: task.id,
          })
        );
      }

      // Comprehensive site analysis prompt
      const analysisPrompt = `Analyze this website and provide:
1. Site structure and navigation
2. Content themes and topics
3. Technical characteristics
4. Key features and functionality
5. Overall purpose and target audience`;

      const analysisResult = await webFetchTool.execute({
        url: context.url,
        prompt: analysisPrompt,
      });

      return success({
        operation: 'site_analysis',
        url: context.url,
        analysis: analysisResult,
        timestamp: new Date(),
      });
    } catch (error) {
      return failure(
        this.createError('WEB_SITE_ANALYSIS_FAILED', 'Site analysis operation failed', {
          taskId: task.id,
          url: context.url,
          error: error instanceof Error ? error.message : String(error),
        })
      );
    }
  }

  /**
   * Extract URLs from search results
   */
  private extractUrlsFromSearchResults(searchResults: unknown): string[] {
    // This would parse the actual search result structure
    // For now, return empty array as placeholder
    if (Array.isArray(searchResults)) {
      return searchResults
        .filter(result => result && typeof result === 'object' && 'url' in result)
        .map(result => (result as { url: string }).url)
        .filter(url => typeof url === 'string' && url.startsWith('http'));
    }
    return [];
  }

  /**
   * Get specialized insights for web operations
   */
  async getSpecializedInsights(): Promise<Result<Record<string, unknown>, QiError>> {
    try {
      const webStats = await this.gatherWebStats();
      
      return success({
        webPerformance: webStats,
        commonDomains: this.getCommonDomains(),
        searchHistory: this.getRecentSearches(),
        optimizationTips: this.getWebOptimizations(),
      });
    } catch (error) {
      return failure(
        this.createError('WEB_INSIGHTS_ERROR', 'Failed to gather specialized insights', {
          error: error instanceof Error ? error.message : String(error),
        })
      );
    }
  }

  // Helper methods for insights
  private async gatherWebStats(): Promise<Record<string, unknown>> {
    return {
      recentRequests: this.metrics.completedTasks,
      averageResponseTime: this.metrics.averageExecutionTime,
      webRequestSuccessRate: this.metrics.successRate,
      mostAccessedSites: this.getMostAccessedSites(),
    };
  }

  private getCommonDomains(): string[] {
    return [];
  }

  private getRecentSearches(): Record<string, unknown>[] {
    return [];
  }

  private getMostAccessedSites(): string[] {
    return [];
  }

  private getWebOptimizations(): string[] {
    const optimizations: string[] = [];
    
    if (this.metrics.averageExecutionTime > 5000) {
      optimizations.push('Consider using more specific extraction prompts for faster processing');
    }
    
    if (this.metrics.successRate < 0.85) {
      optimizations.push('Check URL validity and network connectivity');
    }
    
    return optimizations;
  }
}