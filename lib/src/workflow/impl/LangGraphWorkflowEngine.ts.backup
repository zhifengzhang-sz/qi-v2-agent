/**
 * @qi/workflow - LangGraph Workflow Engine Implementation
 *
 * Real LangGraph StateGraph integration for v-0.8.0
 * Replaces mock implementation with actual workflow orchestration
 */

import { StateGraph, Annotation, START, END, CompiledStateGraph } from '@langchain/langgraph';
import { MemorySaver } from '@langchain/langgraph';
import type {
  ExecutableWorkflow,
  IWorkflowEngine,
  IWorkflowEngineConfig,
  WorkflowCondition,
  WorkflowCustomization,
  WorkflowEdge,
  WorkflowNode,
  WorkflowNodeHandler,
  WorkflowNodeSpec,
  WorkflowResult,
  WorkflowSpec,
  WorkflowState,
  WorkflowStreamChunk,
} from '../interfaces/index.js';
import { createQiLogger, type SimpleLogger } from '../../utils/QiCoreLogger.js';
import { fromAsyncTryCatch, success, failure, match } from '@qi/base';

/**
 * LangGraph state type for workflow execution
 */
type LangGraphWorkflowState = {
  input: string;
  pattern: string;
  domain: string;
  context: Map<string, unknown>;
  toolResults: any[];
  reasoningOutput: string;
  output: string;
  metadata: {
    startTime: number;
    currentStage: string;
    processingSteps: string[];
    performance: Map<string, number>;
  };
};

/**
 * LangGraph state annotation for workflow execution
 */
const WorkflowStateAnnotation = Annotation.Root({
  input: Annotation<string>,
  pattern: Annotation<string>,
  domain: Annotation<string>,
  context: Annotation<Map<string, unknown>>,
  toolResults: Annotation<any[]>,
  reasoningOutput: Annotation<string>,
  output: Annotation<string>,
  metadata: Annotation<{
    startTime: number;
    currentStage: string;
    processingSteps: string[];
    performance: Map<string, number>;
  }>,
});

export class LangGraphWorkflowEngine implements IWorkflowEngine {
  private compiledWorkflows = new Map<string, CompiledStateGraph<LangGraphWorkflowState, any>>();
  private config: IWorkflowEngineConfig;
  private logger: SimpleLogger;
  private memorySaver: MemorySaver;

  constructor(config: IWorkflowEngineConfig = {}) {
    this.config = config;
    this.logger = createQiLogger({
      name: 'LangGraphWorkflowEngine',
      level: 'info',
    });
    this.memorySaver = new MemorySaver();
  }

  createWorkflow(pattern: string, customizations?: WorkflowCustomization[]): ExecutableWorkflow {
    this.logger.debug('Creating LangGraph workflow', undefined, {
      component: 'LangGraphWorkflowEngine',
      method: 'createWorkflow',
      pattern,
    });

    // Create LangGraph StateGraph
    const workflow = new StateGraph(WorkflowStateAnnotation);

    // Create base nodes for the pattern
    const nodes = this.createBaseNodes(pattern);
    const edges = this.createBaseEdges(pattern);

    // Add nodes to LangGraph
    for (const node of nodes) {
      workflow.addNode(node.id, this.createLangGraphNodeHandler(node));
    }

    // Add edges to LangGraph
    for (const edge of edges) {
      if (edge.condition) {
        workflow.addConditionalEdges(
          edge.from,
          this.createLangGraphCondition(edge.condition),
          { true: edge.to, false: END }
        );
      } else {
        workflow.addEdge(edge.from, edge.to);
      }
    }

    // Set entry point using START constant
    if (nodes.length > 0) {
      workflow.addEdge(START, nodes[0].id);
    }

    // Apply customizations if provided
    if (customizations) {
      for (const customization of customizations) {
        this.applyCustomization(workflow, customization);
      }
    }

    // Compile the workflow
    const compiledGraph = workflow.compile({
      checkpointer: this.memorySaver,
    });

    // Store compiled graph
    this.compiledWorkflows.set(pattern, compiledGraph);

    // Return ExecutableWorkflow interface
    const executable: ExecutableWorkflow = {
      id: `${pattern}-workflow-${Date.now()}`,
      pattern,
      nodes,
      edges,
    };

    return executable;
  }

  async execute(
    workflow: ExecutableWorkflow,
    initialState: WorkflowState
  ): Promise<WorkflowResult> {
    const startTime = Date.now();
    const executionPath: string[] = [];

    this.logger.info('Executing LangGraph workflow', undefined, {
      component: 'LangGraphWorkflowEngine',
      method: 'execute',
      workflowId: workflow.id,
      pattern: workflow.pattern,
    });

    try {
      // Get compiled graph
      const graph = this.compiledWorkflows.get(workflow.pattern);
      if (!graph) {
        throw new Error(`No compiled graph found for pattern: ${workflow.pattern}`);
      }

      // Convert WorkflowState to LangGraph state format
      const langGraphState = this.convertToLangGraphState(initialState);

      // Execute the graph
      const result = await graph.invoke(langGraphState, {
        configurable: {
          thread_id: `workflow-${workflow.id}`,
        },
      });

      // Convert back to WorkflowState
      const finalState = this.convertFromLangGraphState(result);

      const totalTime = Date.now() - startTime;

      this.logger.info('LangGraph workflow completed', undefined, {
        component: 'LangGraphWorkflowEngine',
        method: 'execute',
        workflowId: workflow.id,
        duration: totalTime,
      });

      return {
        finalState,
        executionPath: finalState.metadata.processingSteps,
        performance: {
          totalTime,
          nodeExecutionTimes: finalState.metadata.performance,
          toolExecutionTime: finalState.toolResults.reduce(
            (sum, result) => sum + (result.executionTime || 0),
            0
          ),
          reasoningTime: finalState.metadata.performance.get('reasoning') || 0,
        },
      };
    } catch (error) {
      const failureTime = Date.now() - startTime;
      
      this.logger.error('LangGraph workflow execution failed', undefined, {
        component: 'LangGraphWorkflowEngine',
        method: 'execute',
        workflowId: workflow.id,
        errorMessage: error instanceof Error ? error.message : String(error),
        duration: failureTime,
      });

      return {
        finalState: {
          ...initialState,
          output: `Workflow execution failed: ${error instanceof Error ? error.message : String(error)}`,
          reasoningOutput: 'Execution failed due to error',
          metadata: {
            ...initialState.metadata,
            processingSteps: [...initialState.metadata.processingSteps, 'error'],
          },
        },
        executionPath: executionPath,
        performance: {
          totalTime: failureTime,
          nodeExecutionTimes: new Map(),
          toolExecutionTime: 0,
          reasoningTime: 0,
        },
      };
    }
  }

  async *stream(
    workflow: ExecutableWorkflow,
    initialState: WorkflowState
  ): AsyncIterableIterator<WorkflowStreamChunk> {
    this.logger.debug('Starting LangGraph workflow stream', undefined, {
      component: 'LangGraphWorkflowEngine',
      method: 'stream',
      workflowId: workflow.id,
    });

    try {
      // Get compiled graph
      const graph = this.compiledWorkflows.get(workflow.pattern);
      if (!graph) {
        throw new Error(`No compiled graph found for pattern: ${workflow.pattern}`);
      }

      // Convert WorkflowState to LangGraph state format
      const langGraphState = this.convertToLangGraphState(initialState);

      // Stream the graph execution
      const stream = await graph.stream(langGraphState, {
        configurable: {
          thread_id: `workflow-stream-${workflow.id}`,
        },
      });

      for await (const chunk of stream) {
        // Extract node information from chunk
        const nodeIds = Object.keys(chunk);
        for (const nodeId of nodeIds) {
          const nodeState = chunk[nodeId];
          
          yield {
            nodeId,
            state: this.convertFromLangGraphState(nodeState),
            isComplete: false,
          };
        }
      }

      // Final completion chunk
      yield {
        nodeId: 'complete',
        state: this.convertFromLangGraphState(langGraphState),
        isComplete: true,
      };
    } catch (error) {
      this.logger.error('LangGraph workflow stream failed', undefined, {
        component: 'LangGraphWorkflowEngine',
        method: 'stream',
        workflowId: workflow.id,
        errorMessage: error instanceof Error ? error.message : String(error),
      });

      yield {
        nodeId: 'error',
        state: initialState,
        isComplete: true,
        error: {
          nodeId: 'unknown',
          error: error instanceof Error ? error : new Error(String(error)),
          retryable: false,
        },
      };
    }
  }

  async precompileWorkflows(patterns: readonly string[]): Promise<void> {
    this.logger.info('ðŸ”§ Starting LangGraph workflow precompilation', undefined, {
      component: 'LangGraphWorkflowEngine',
      method: 'precompileWorkflows',
      patternCount: patterns.length,
      patterns: patterns.slice(0, 5), // Log first 5 patterns to avoid spam
    });

    for (const pattern of patterns) {
      try {
        this.createWorkflow(pattern);
        this.logger.debug('âœ“ Compiled LangGraph workflow for pattern', undefined, {
          component: 'LangGraphWorkflowEngine',
          method: 'precompileWorkflows',
          pattern,
          operationType: 'workflow_compilation',
        });
      } catch (error) {
        this.logger.error('âœ— Failed to compile LangGraph workflow for pattern', undefined, {
          component: 'LangGraphWorkflowEngine',
          method: 'precompileWorkflows',
          pattern,
          errorMessage: error instanceof Error ? error.message : String(error),
          operationType: 'workflow_compilation_error',
        });
      }
    }

    this.logger.info('ðŸŽ¯ LangGraph workflow precompilation complete', undefined, {
      component: 'LangGraphWorkflowEngine',
      method: 'precompileWorkflows',
      compiledCount: this.compiledWorkflows.size,
      operationType: 'precompilation_complete',
    });
  }

  getCompiledWorkflow(patternName: string): ExecutableWorkflow | null {
    const graph = this.compiledWorkflows.get(patternName);
    if (!graph) {
      return null;
    }

    // Return a minimal ExecutableWorkflow representation
    // Note: This is simplified - in a full implementation, we'd store more metadata
    return {
      id: `${patternName}-compiled`,
      pattern: patternName,
      nodes: [], // Would need to be populated from stored metadata
      edges: [], // Would need to be populated from stored metadata
    };
  }

  async executeWorkflow(
    spec: WorkflowSpec,
    config: {
      sessionId: string;
      contextId: string;
      streamingEnabled?: boolean;
      checkpointingEnabled?: boolean;
      progressCallback?: (nodeId: string, progress: any) => void;
    }
  ): Promise<WorkflowResult> {
    this.logger.info('Executing workflow from specification', undefined, {
      component: 'LangGraphWorkflowEngine',
      method: 'executeWorkflow',
      workflowId: spec.id,
      sessionId: config.sessionId,
    });

    // Create executable workflow from spec
    const executable = this.createWorkflowFromSpec(spec);
    
    // Create initial state from spec parameters
    const initialState: WorkflowState = {
      input: (spec.parameters.get('input') as string) || '',
      pattern: spec.name,
      domain: (spec.parameters.get('domain') as string) || 'general',
      context: new Map(spec.parameters),
      toolResults: [],
      reasoningOutput: '',
      output: '',
      metadata: {
        startTime: Date.now(),
        currentStage: 'starting',
        processingSteps: [],
        performance: new Map(),
      },
    };

    // Execute the workflow
    return this.execute(executable, initialState);
  }

  // Private helper methods

  private createBaseNodes(pattern: string): WorkflowNode[] {
    return [
      {
        id: 'input',
        name: 'Input Processing',
        type: 'input',
        handler: this.createInputHandler(),
      },
      {
        id: 'reasoning',
        name: 'Reasoning',
        type: 'reasoning',
        handler: this.createReasoningHandler(pattern),
      },
      {
        id: 'output',
        name: 'Output Generation',
        type: 'output',
        handler: this.createOutputHandler(pattern),
      },
    ];
  }

  private createBaseEdges(pattern: string): WorkflowEdge[] {
    return [
      { from: 'input', to: 'reasoning' },
      { from: 'reasoning', to: 'output' },
    ];
  }

  private createInputHandler(): WorkflowNodeHandler {
    return async (state: WorkflowState): Promise<WorkflowState> => {
      return {
        ...state,
        input: state.input.trim(),
        metadata: {
          ...state.metadata,
          currentStage: 'input',
          processingSteps: [...state.metadata.processingSteps, 'input-processed'],
        },
      };
    };
  }

  private createReasoningHandler(pattern: string): WorkflowNodeHandler {
    return async (state: WorkflowState): Promise<WorkflowState> => {
      const reasoning = `LangGraph reasoning for ${pattern}: ${state.input}`;
      
      return {
        ...state,
        reasoningOutput: reasoning,
        metadata: {
          ...state.metadata,
          currentStage: 'reasoning',
          processingSteps: [...state.metadata.processingSteps, 'reasoning-complete'],
        },
      };
    };
  }

  private createOutputHandler(pattern: string): WorkflowNodeHandler {
    return async (state: WorkflowState): Promise<WorkflowState> => {
      const output = `${state.reasoningOutput}\n\nProcessed via LangGraph StateGraph`;
      
      return {
        ...state,
        output,
        metadata: {
          ...state.metadata,
          currentStage: 'output',
          processingSteps: [...state.metadata.processingSteps, 'output-generated'],
        },
      };
    };
  }

  private createLangGraphNodeHandler(node: WorkflowNode) {
    return async (state: any) => {
      const workflowState = this.convertFromLangGraphState(state);
      const updatedState = await node.handler(workflowState);
      return this.convertToLangGraphState(updatedState);
    };
  }

  private createLangGraphCondition(condition: WorkflowCondition) {
    return (state: any) => {
      const workflowState = this.convertFromLangGraphState(state);
      return condition(workflowState) ? 'true' : 'false';
    };
  }

  private applyCustomization(
    workflow: StateGraph<any>,
    customization: WorkflowCustomization
  ): void {
    switch (customization.type) {
      case 'add-node':
        if (customization.nodeDefinition) {
          workflow.addNode(
            customization.nodeDefinition.id,
            this.createLangGraphNodeHandler(customization.nodeDefinition)
          );
        }
        break;
      case 'add-edge':
        if (customization.edgeDefinition) {
          workflow.addEdge(
            customization.edgeDefinition.from,
            customization.edgeDefinition.to
          );
        }
        break;
    }
  }

  private convertToLangGraphState(workflowState: WorkflowState): any {
    return {
      input: workflowState.input,
      pattern: workflowState.pattern,
      domain: workflowState.domain,
      context: workflowState.context,
      toolResults: workflowState.toolResults,
      reasoningOutput: workflowState.reasoningOutput,
      output: workflowState.output,
      metadata: workflowState.metadata,
    };
  }

  private convertFromLangGraphState(langGraphState: any): WorkflowState {
    return {
      input: langGraphState.input || '',
      pattern: langGraphState.pattern || '',
      domain: langGraphState.domain || 'general',
      context: langGraphState.context || new Map(),
      toolResults: langGraphState.toolResults || [],
      reasoningOutput: langGraphState.reasoningOutput || '',
      output: langGraphState.output || '',
      metadata: langGraphState.metadata || {
        startTime: Date.now(),
        currentStage: 'unknown',
        processingSteps: [],
        performance: new Map(),
      },
    };
  }

  private createWorkflowFromSpec(spec: WorkflowSpec): ExecutableWorkflow {
    // This is a simplified conversion - in a full implementation,
    // we'd create the full workflow structure from the spec
    return {
      id: spec.id,
      pattern: spec.name,
      nodes: [], // Would be created from spec.nodes
      edges: [], // Would be created from spec.edges
    };
  }
}